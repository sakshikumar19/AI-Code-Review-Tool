Let's add a constant for "version 2"
Iffy formatting
don't return NULL, throw UnsupportedOperatedException instead
That is unusual, as the parser should be on START_TAG of the element. Why do you feel it is necessary to check for this condition?
Should this not prefer the token over the raw?
We cannot do this - this is a really bad practice. Please don't write code that resembles this either. We need symmetric encoding/decoding that's done for all databases, not targeted at MySQL/MariaDB.
I don't think this helps, because as long as the number of available threads is smaller the number of core threads, the executor will create new threads for each submitted task.
Can this be changed to createSubjectRoleAttribute?
Thanks for these cleanup items, too. Will you please put them in a separate commit (same PR)? That is, any code changes that aren't directly related to the new constructor, let's separate them into their own commit. This simplifies maintenance.
Please remove debug codes.
Is there a reason this isn't implemented?
nit: unnecessary generic type declaration
Out of interest why can you not do BuiltinAggregator.values()?
Need to catch IOException from getFilesToRetry as well as it may throw this exception for NN failures and need retry.
minor: you can use QuickMath.modPowerOfTwo(l, 8) == 0 instead of ((l >> 3) << 3) == l, to make it more readable. I misread this like ((l >> 3) << 3) == 1 initially (so 1 instead of small L) and didn't get what it means.
@snleee This is handled with the API refreshSegment()
check to make sure notificationUUID is not null
probably premature, but if in most usage validateLocksOnReads is going to be false, then flipping the arguments makes sense.
Does it make sense to continue here? Or just return false.
Here I would just say return true. Then fall through return false, instead of creating a variable.
It's better to use **isBlank** here
Here too we may use IanaLinkRelation.EDIT?
coudl be just ArrayList since now it is imported ^^ vv
I don't like IMavenProjectHolder. I think targetPart.getAdapter(MavenProject.class) is more appropriate here.
printStackTrace() must not be used. Use a logger instead.
this.redisTemplate
thread.isUnterupted not necessary?
I assume this was meant to be removed?
What do we do, if the result is null?
I think we always display view names capitalized to users.
CallNode are only present in sequence diagrams, so I would recommend eliminating the first (presumed defensive) clause aType == DiagramType.SEQUENCE because of the potential confusion if may cause.
I think it would be good to perform this logic in OutputEmitter.
I'd prefer that we call this something like DEFAULT_REQUEST_ID. It'll be easier to read and easier to change if we decide zero isn't the best number (which I suggest it isn't since it's probably the most likely number to be non-unique with other users of the API).
Why to use: try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) { return connection.createArrayOf(typeName, array); } catch(SQLException ex) { throw new RuntimeException(e); }
magic number
I would prefer that the exception were re-thrown as a different typed exception (e.g. PlatformServicesException) and handled by the caller rather than just eating the exception here.
Why does this need to be ordered by the synthetic primary key?
Is a null check for the passed in "date" required here for safety?
Since numberOfVotes can be null you should replace this with Objects.equals(numberOfVotes, other.numberOfVotes)
Could have been WordUtils.capitalize(Delivery.State.REJECTED) so the test is more stable (will cause compilation errors) if we at some point change the Delivery API.
any reason for disabling cache for descending order queries ?
maybe it's just me but that mixture of functional and non-functional programming doesn't look right, I know it works, but still
assertEquals and remove the expected value from message string
should be possible to provide one
Looks like a duplication to me. How about this.json().getString("name")?
Should we also validate that DataType != null.
I think we need to close this InputStream at some point
do you clean up these files on exit? or the root level dir is deleted on exit ?
in range yet you're not providing a range; perhaps "'count' must be at most %s"? Also, shouldn't that be %d?
hear i think we could handle this error gracefully by if (toast != null) check and not send the traceback to crashylytics using Zlog.logException(e)
Should this support a null address? Same with the other one, which make support a null or empty address.
this is followup of above, it should not be required.
Please make sure this is properly formatted. "else" should be on the same line as the }.
you don't take any resourcees from player when buying dev card
@Serranya The same here. See above.
Not sure if this description will be displayed anywhere. If it gets displayed, please change the name DataFlow to Spring Cloud Data Flow
String.matches can be expensive. If we're caching the list of pattern per Site, it would be best to cache compiled java.util.regex.Pattern objects.
There should be a space here between expected and school.roster()
We should put the URL fragments into static vars in a common file then select them based on version in one place rather than scatterred throughout code.
This should be in the if(v != null) check I am thinking
Check for illegal arg or are we happy with a ClassCastException here?
Maybe using a constant here for "://"
consider 'ternary if' here
Extra space
@Nadahar I just read that the one used by the PS3 are .**atrac**. Did you tried to stream this kind of file to the PS3 ? **P.S.** .omg (from the french Wikipedia) and .msa are seen as well.
SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
You could move this line to preSave. That way the topoliogy can be used both in effectively once as well as atleast/atmost once mode
Put the test in the same package (not directory) and you can at least use package private or protected
a very small impovement, but you can use the method notation when the mapper is on second place and params vararg is on 3rd place. That will allow to pass eventType without creation of array.
suggestion Objects.requireNonNull(filter, "filter cannot be null");
as the all() is used just internally I think we can rewrite it as: java public Collection<DataType> all() { return dataTypes.values(); }
nit: maybe we can save the result of getPartition(topicPartition)
I think these instance of are getting away from why we should have inheritance in the first place. Can we throw an UOE in other non table data source data sources?
Would be nice if this could be incorporated into the checkForAddRemoveListener method? Perhaps checkForAddRemoveListener(listener, checkForNull) ?
final
suggestion this.ignoreAbove = mw.ignoreAbove;
Wrapper#getX() : float Use float instead of double.
ImplUtils has a isNullOrEmpty method that should handle these checks.
Could you use Strings.repeat or something?
this can be reduced to protected.
We have a StringMarshal helper class that does all of this UTF8 logic for a string.
It's unclear to me what's going on here. This appears to check that the service *isn't* bound before calling unbindService(Context).
-1 for using Objects.hash(...) for hashcodes, as it will create an array and i think that it is important to make such thin places as cheaper as possible. If you define hashcode for LogMessage, then it is useful to use this message in collections or smth, and based on log message nature you will have to deal with tons of those messages. Checkout [this](<LINK_0> for generating cheaper hashcode.
isn't the topology always a LocalizedCacheTopology?
Copy-paste and you haven't changed the member name. Is it wise to have a WTextArea called wTextField?
Remove cast
What's the reason for this change? We want people to use setFields to change the fields, so it's good practice to return unmodifableSet here.
This commandContext seems unused.
consider replacing 96-97 with just one try block (see line 455)
So we are back to the same perf issue that you mentioned in my PR :) I would be curious to know how do you propose we solve this.
not good to add sth when calling getter
Isn't this dataset automatically executed?
add "balanced" ?
Need to remove this leftover debug output
Json -> "JSON" (do a search-n-replace)
why swallowing?
Why public?
replace the if ... else block with  return queryStateMap.remove(queryId) != null ? true : false;
nit: try to avoid string concatenation in the log.  logger.info("Setting Quota mode to {}", mode.name());
Can we make this method delegate to a package-private static boolean isPreJava8(String javaVersion) which we can invoke directly from the test? The reflective method is likely to cause failures if we refactor this code in the future, and setting the java.version system property may have other consequences which I'd prefer to avoid.
curly braces aren't required
To match the old format, do "Network parameters:\n " here.
These could be renamed to not use nonAscii.
I wonder if people running with locale GERMAN, CHINESE etc would get localized error messages from the JDK? You may need to just check the exception type, or maybe try to change the default locale and restore it back after the test.
@Irenyak1 why return false here?
Check for null and make a defensive copy java this.signature = requireNonNull(signature, "signature is null").clone();
The annotations are inherited, so you don't HAVE to repeat them. But it doesn't hurt I guess.
!Strings.isNullOrEmpty(name)
extract to assertClassAndMethodName(stackTraceElement, className, methodName)
@davidfestal formatting in if(. Probably it would be better to extract it to some method e.g. isHttp(String url) Could you please clarify what exactly is done in updateServer and why internal URL is updated only when it is http based ?
Just return the day value. Don't need to recomute MILLIS_PER_DAY.
Doesn't seem necessary to keep this function, the two lines below should suffice pauseSelfScanning(); mHandler.postDelayed(mScanRunnable, Math.round(1.5 * TeclaApp.persistence.getScanDelay()));
You can return this from here to expose kind of fluent API.
this.size for consistency
Do we still need to do all this reflective bullshit now that it's in a separate artifact?
If JDK 6/7 returned a double and JDK 8+ return Integer, can't we just simplify this whole block to java assertEquals(3, variable);  since we're expecting JDK8+ from now on?
After throws Exception is dropped from rollbackLocks, seems like this code should be : java CompletableFuture<Void> getFailureOp(CommitData cd) { return rollbackLocks(cd); }
this test fails  java assertThat(empty().leftPadTo(1, 1)).isEqualTo(of(1));  I believe <code>if (length <= 1)</code> should be removed
should be removed
can be static to avoid to avoid redundant object creation on startDownload
lowerCamelCase please, also enderPearl**s**. P.S. 0-1
(List<?>) (3 places)
What about using org.apache.commons.io.FileNameUtils to simplify the code? java String.format("%s%s%s", FilenameUtils.getBaseName(filename), count, FilenameUtils.getExtension(filename));
Use MethodType.GENERATIVE.getCode()
Add a line break before ||
It would be nice if this can be a tunable. Also please give it a meaningful name.
I would suggest using ObjectUtils to check for nulls here
For troubleshooting, should more specific information be output about the vendor generating the error, such as PMW vendor ID or KFS vendor ID?
why do we need this?
Same here, we should be relying on [DateFormatterProvider](<LINK_0>
Could use Long.BYTES and Float.BYTES
Given the problems we've had with other properties of StorageDomain with converstion of Integer to int and the NPEs resulting I think it's best that the return type will be int as we never return null either way, please fix and I'll merge
According to the Druid formatting rules, should break all or none arguments.
Not the right implementation, permissions other than the one at zeroth index would get ignored.
This is not a deep copy
Consider using System.currentTimeMillis instead, since it has better performance (not much, from Date().getTime() I reckon), but it will save on GC execution, by skipping the creation of a new object, that fills memory and then has to be cleaned up. Same on [StreamingServiceTransExecutor](<LINK_0>, but more relevant here, since this is called for each row.
1.65 looks like an interesting value (instead of 4).
Guava's Iterables.getOnlyElement might be more crisp.
@pjain1 and @gianm this means if only the first 5000 events are not properly formatted you won't see the log. i will use an exponential backoff strategy.
Removing datasource before restoring snapshot is not necessary IMO.
Can be put as single statement --> final ContainerInfo containerInfo = containerStateManager.allocateContainer(pipelineManager, type, replicationFactor, owner);
same question: it doesn't seem to be necessary?
throw new UnsupportedOperationException
Please, use fail(). <LINK_0>
suggestion return _addedFiltersNoDuplicates.add(filterToAdd.withId("AvoidDuplicateFiltersThatOnlyDifferInTheirId"));
I believe this will be flagged as a potential NPE by Android Studio. It makes sense that this will never happen so I recommend adding a readingList != null to the conditional, suppressing the warning, or throwing an IllegalStateException if null to show that the author was considering this case and only true warnings are flagged by Android Studio.
use StringUtils.isEmpty()
Any reason for this exact RNG function? Also, how about using this.rand provided in the World class
Take a look at Object executeScript(String script, Object... args) method in AppPage
Please format this code correctly. Enter and { after else.
configurationAdmin.getConfiguration(PID, "?")
No isDebugEnabled()
also check this
these assertions are checking the wrong thing, copy/paste err?
model needs to be set dirty. this was a bug in the original code, please fix it on the way
<LINK_0>
extract layerOnMap.getDefaultPolygonStyle() to intermediate variable?
Yep, this is correct. Would it be worth having some preconditions check on the exception (that it is an InterruptedException)? - in case someone later on tries to re-use this and passes in some random other exception type
other.hashCode() is only fast for immutable Tuples with cachedHash, not for VolatileTuples. If obj is volatile, we can jump straight to internalEquals() I believe. Though this should not matter a lot, I guess most comparisons will happen against other immutable Tuples anyway.
Shouldn't we keep a test to check that in this situation an array of object is returned? I remember that in past this was not the case.
What are some benefits of using retained fragment in this case?
is it the messageHandler's job to mark the message as handled successfully? would it make sense to put that responsibility in here, and then maybe on error we could know that we could return the message to the queue with a failure status and eventually it can get DLQ'd (otherwise it won't redrive until its visiblity timeout expires - maybe a longer backoff than we want)
I don't feel very good about this constructor. It seems counter-intuitive to have the fsContext as an argument here. There is already an fsContext embededed within the fs object. Is there a better way to access it?
As you are negating the result when using this function, it'd be better to avoid the double-negation by just returning the result here directly.
Usually we just put tests in TestBackgroundHiveSplitLoaderForBucketedTables.java into this TestBackgroundHiveSplitLoader.java class. In this specific case, I understand the tests and other helper methods in TestBackgroundHiveSplitLoaderForBucketedTables.java are very specific and may not suit for general purposed TestBackgroundHiveSplitLoader.java. But a preferred approach might just be refactoring these methods into a helper class like HvieSplitTestHelper (this name is just made up)
submit?
(current = toProcess.takeFirst()) != REPORTING_NONE) ?
You may not intend to change it.
please add new HelpTag and HashName (as in StorageListModel)
what if you just sort the process instances based on their id, and start aborting the highest ones first? a child process should have a higher id than its parent.
Is this notification ever removed? if not, will this have the potential to affect other tests?
This should call authorization(List<AuthInfo> authInfos). E.g.  return authorization(Lists.newArrayList(new AuthInfo(scheme, (auth != null) ? Arrays.copyOf(auth, auth.length) : null)));
Watch out the naming: timer/threshold, getIOs/getStreamMapping
Would you mind declaring two new constants DEFAULT_READ_TIMEOUT = 80*1000 and DEFAULT_CONNECTION_TIMEOUT = 30*1000 and using the named constants here?
The removal here of public breaks the NameGenerator module - generally the HeadlessEnvironment is available for other things to use, an IDE might just not think it is in-use if you lack whatever module or facade in your workspace.
if we removed the ambiguity, this can be reverted
Use OseeWebApplicationException
Please abstract index2chrom to a class, this is a bit odd
we can remove this
connection leak, needs to be closed. Instead use the non-static version TEST_UTIL.getZookeeperWatcher()... that is automatically closed with HTU teardown.
Do we need all of these extra constructors?
Only one uses intValue(). Let's remove it.
You do not use the return value here (which should be complained by our QA tools). And you instantiate a ByteArrayOutputStream each time this method is invoked. Better use an unsynchronized map implementation and synchronize all accesses via synchronized(..) to avoid both issues.
wouldn't you want the conditions check prior to assignments?
Nitpick: space
The "remove" method is not part of the interface, so the client will never be able to invoke it, so there is no need to prepare a nice response for the user. Just throw an exception: throw new UnsupportedOperationException();
3 is a magic number. I assume it is due to the following: <<< outputBuffer.putInt(systemMetadataRelativeOffset); outputBuffer.putInt(userMetadataRelativeOffset); outputBuffer.putInt(dataRelativeOffset); Ideally 3 is iether a method call or a constant.
new HashMap<String,Object>(0) or Collections.<String, Object>emptyMap() if immutable
Is that a good enough debug print? You're not really printing the VMs you have
rename to image
Likewise doesn't need the if check.
Please use TIME_FORMAT instead of "HH:mm:ss"
suggestion try { prRevision.validateMergeHash(repo); } catch (AbortException e) { fail("Validation should succeed, but: " + e.getMessage()) }  If the validation fails the way it is written it will be reported as an error instead of a failure
Loop can be replaced by passing the collection to CTOR: suggestion List<String> referencePoints = new ArrayList<>(idToReferencePointMapping.keySet());
This looks like it's fixing a bug in datasketches, is that right?
why don't you account for the size of hiveTypeName
No need to do this, just this.url is enough
Could be simplified by returning immediately if null - would save having to indent the whole block.
Same here with the lock and leaderListener.
static import
if the profile isn't set you'll have NPE here.
I don't think you actually need this flag - you are cancelling the job anyhow, so no further calls will be done.
You could simplify this using the ternary: this.clusterCriterias = StringUtils.isBlank(clusterCriterias) ? EMPTY_JSON_ARAY : clusterCriterias;
mExecutor.shutdown() ?
what happens if 2 aspects have the same name?
else is redundant.
adding an assert here might stop Codacy from complaining
How about :  if () { } else if (){ } else { } return null;
I assume you're scanning all supertypes because the model may implement different interfaces? what about if the model inherits from an ancestor that implements RealmModel or overrides RealmObject? this should not be allowed?
This is a bug, we need to pass requestOptions instead of options Since you are OOF, I will fix it in your branch and push it.
Im Console Log des Builds der Jenkins Instanz!  j.assertLogContains("ID checkstyle is already used by another action: io.jenkins.plugins.analysis.core.views.ResultAction for CheckStyle", build)
When can this happen in practice?
As we log the Metrics periodically, I think logging this message should be enough with FINE (or below) level.
typo: nonexistent ??
it's bad to use a common port as 8080...
deleting Donor(228l), and then testing by searching for Donor(000233)? Also, a lot of Donor Numbers and Ids are using characters [a-z] in them, but Donor Number and Donor Id formats are numeric: e.g. donor id: 167 e.g. donor number: 000189
Something wrong with indentation. Use 4 spaces.
rename to keyEvent or ignoredKeyKevent
This conditional is probably not necessary, even from a performance point of view. The meaning might be clearer with only the put() call and no conditional.
why are 38,39 lines the same?
What is the point of putting the application mode in the session? Anywhere we would read that information can't we simply read the configuration?
@fanifieiev Let's put this in a constant.
Should we swallow typo-case without even issue a warning? Delete email method above doesn't really matter, because if a mail doesn't exist, all is fine. Here someone rellies on this command to change something, yet when she spelled email wrong, it should fail, i think.
unless you want to allow <null> values, use the primitive boolean instead of the java.lang.Boolean object.
I think this method doesn't work properly, please follow steps below: - Log as UserA - Open Pricing loans table, append row / change some data - Keep the table opened with unsaved changes by UserA - Simultaneously in new private window log as UserB - Open the same Pricing loans table, it is locked by UserA, it is read only however the Columns tab is enabled
keep own check
Instead of setting the field to null and handling that case in all of the methods, it would be easier to just have a private class for the empty marker singleton.
Maybe suggestion List<Action> actions = new Vector<>(getPersistedActions());  for clarity.
@bgeVam just inline null
I believe you should return a 404 in this case. If you go to a private GitHub repo that you don't have permissions to, you get a 404, not an unauthorized error. The logic behind this is that you don't even want to indicate that it exists to an evil-doer. If they know it exists, that's the first step. Then they could then start trying to break into it. I'll let others opine on this.
Interesting: is there a reason we wrote this as opposed to just nanos.get();? The memory semantics are different (this does a volatile *write* as well), though I don't understand why we need it
Unneeded surrounding lines for line 206.
Shouldn't this be a field so we don't have to create one each time
On END_DATE, discount factor should be 1.
The queueNames must be wrapped to Arrays.asList(): ![array_in_sout](<LINK_0>
Code congruity with upstream libanki is important, so I'd prefer if you didn't do this. <LINK_0>
I don't see these changes in hot-fix branch. Can you provide context on why are we changing this to exception from throwable?
why not use harness#deployContrib directly ?
This if does not seem necessary. totalSessionsCompleted is not used to prevent new sessions when maxSessionsAllowed is reached in getNewSession
url is used only once, so I guess we could use it inline i.e. driver.getCurrentUrl().contains()
getUsage(...) expects a localization key.
not required if nothing is happening
And sessionIdCol
@pynicolas maybe the failing message could be added as a parameter to give more info about this condition ? WDYT ? Something like "Instanciating a SeparatedList with inconsistent number of elements (x) and separators (x)" ?
method access specifier plz.
Let's check the parameter for null and test this case via NullPointerTester.
withMillisOfSecond(0) could be done here.
All enableX and disableX in this class could return boolean for better understanding of the API and their respective invocations.
This might not work as well if MainActivity wasn't singleTask. I know the API isn't great but have you considered specifying the parentActivityName and updating onOptionsItemSelected()? <LINK_0> <LINK_1>
Shame the constructor can't throw exceptions direct. Catch only the exception's known to be raised, and don't convert RTEs or, especially, Errors.
It would be nice if you could also log the total elapsed time since the script started. That makes it easier to estimate how long the conversion will take.
is this the only type possible? what about reflection?
You could inline the variable isConnected.
I bet you love next(null) right? :P
max ? This could be bad if there are a lot of these endpoints. I wonder if we should really be blocking here; SmartLifecycle has stop with callback.
Do not squash here, propagate as IOException
Do we want to state No value initialized?
How about WikipediaApp.getInstance() instead?
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "user". [![rule](<LINK_0>](<LINK_2>
This should be R.attr.multi_select_background_color, to account for dark/black mode.
The way BackgroundLocationHelper is being used here really reminds me of the ["Delegate" pattern](<LINK_0> Would it be too nerdy to call it a BackgroundLocationDelegate instead? On that, it could be cool to have the BackgroundLocationManager depend on an interface rather than a concrete class. That might help make it clearer where the separation is.
new Duration(1, SECOND)
May be, I wrong, but on my first impression: if the parameter message is a RST for a original message, the soruce/destination is already exchanged. > EmptyMessage.newRST(message); would exchange source/destination again.
You should check that you are not yet in an entity.
DataConstants please.
Does maven build output contain warning that there is switch without default section?
Iterating refAndCountMap.entrieSet() is more efficient. RealmCacheType.values() allocates new array in every call, but refAndCountMap.entrieSet() caches returned object. and it can also avoid hash table lookup.
rename to container or sourceContainer
So these read/write methods for histories scare me a bit. Could there be multiple knoxshells reading/writing at once? Can we lock the file via the Java NIO methods? Should these methods be synchronized to prevent multiple usage at once from the same JVM. Is the directory ".knoxshell" assumed to exist already? This applies to reading as well.
One of the constructors calls init() directly, so this could still create a thread at construction. Or are we sure that one is never called from "fake traces"? I think it'd be safer with the lazy-init that was done in the previous version. getTimer() and dispose() could both be synchronized (so it synchronizes on "this"), it doesn't really have anything to do with fLock.
add connector to the message. Include catalog name?
Should this be returning a String? I would think it would be desirable for it return hudson.util.Secret like its internal type. @stephenc what are your thoughts?
Please stick to java convention for naming variables - first letter should be lower case. Also this is another case where local variable is not needed just return it directly.
This is constant and can be extracted, should help with the nutty indentation going on here.
Maybe it'd be better to use IOUtils.copy here as in <LINK_0> I forgot about it when I introduced this method.
Redundant variable name - just use "name"
Use new HashSet<>
What is the plan for usage this method? From my point of view it must be like that:  id = saveSubscription(subscriptionData)
Maybe a log statement slipped through?
SimpleReportEntry should _always_ use testIdentifier.getLegacyReportingName() as name and testPlan.flatMap(plan -> plan.getParent(testIdentifier)).map(TestIdentifier::getLegacyReportingName) .orElse("<unrooted>") as source.
It would be clearer IMO to have .anyMatch indent on the newline, preferably inline with .concat() - I initially read this as only performing the anyMatch on right, and was trying to figure out why
We've been following the format where the async APIs call the async overloads, and the max overload API calls the PL. Similarly, the sync APIs call the sync overloads, and the max overload sync API calls the async API.
Should this refer to a platform-relative constant?
Why not simply Objects.hashCode(logEntry)?
The original line 949 is correct. If path is null, FileSystem.access should throw IllegalArgumentException and that's what calling makeQualified(path) will do.
not needed
I think the typical case is that the metricsLabel is not empty. So, let's put that in the first part of the "if" block and let's handle the metricsMode.isEmpty() case with an "else" block. Also, are there situations in which the metricsLabel is null?
Include portletClass in the exception message
for consistency reason with the prev line please use "validateVm" (small "m")
Would prefer this to happen in serverAdded rather than the event listener.
Please change it to internally use task.getScheduleAsLong(). Otherwise you need to implement same supplementary methods as in Task object, including changes in serializer. Same goes for getStartTime and getEndTime().
What about using of "SeleniumWebDriverHelper#getAction()" method?
please simplify boolean expressions above. Here ignoredStatic and ignoredFinal contain isStatic and isFinal in their initialization.
Can you somehow also check that it actually hasn't tried to connect?
Would recommend checking if contract is an instance of ReactiveC and only warp of not
Include version in message.
String.format("KafkaIndexTaskClient-%s-%%d", dataSource) should work too, although changing is unnecessary
### Option B Change this from setting currentImage to the new image, just set the _texture_ to the new texture. If you wanted to get really fancy you could also use a binding, and bind the texture to images.get(index) via ReadOnlyBinding this would make the texture automatically update without you having to set it.
please return raw value, on end-user code you can wrap it simply with BooleanUtils null in return value means that there is no value. No value != false from req/rsp view point.
shouldn't it be after eventHandle() below?
Can this cause memory overflow? don't we need to limit buffer?
Can this be a more specific ActiveMQ Exception? Even if its just ActiveMQException
Ah yes, sure. "protected" then maybe. The public constructor together with the DEFAULT_INSTANCE constant made me stumble.
s/Resturning/Returning s/staring/starting ???
Better to have variable name in the message: handlerClass can not be null
don't use FileReader; it doesn't handle encodings properly
Isn't the test class that uses it in the same package?
do this AFTER setting the closed flag
I used my powers to push a rewritten version of this method :-)
We're not guaranteed that this is an authHeader, so maybe a better name is extraHeader or something similar
To start client grid startClientGrid() should be called.
@artemkuzmenko Extend from CustomEventRewardedVideo and override hasVideoAvailable() instead of isReady().
What would happen #clearTestUsers threw an exception? Will the LDAP port kept open? May be the #stopLdapService need to go to a finally block.
@erdemedeiros let's remove all the system outs
Use assertEquals here instead
Now there is missing space:)
streamEstimator should never be null right?
Extract to constant
IfExists => ifExists
This is where it gets tricky again. The client is not aware of the version of the cluster it is connected to. So it might happen that the function is serializable and static and is sent to the cluster but the cluster members fail to deserialise it. Unfortunately, this would mean there is no other option for the user but to not have a serializable function when calling from the client or to upgrade the member versions. I don't have a good idea how to tackle this. As a poor-man's solution (but, still better than an infinite loop which we have now), we can avoid this optimisation on the client and simply use computeIfPresentLocally in all cases. WDYT? cc @sancar
We should also preserve byte[] suggestion if (value instanceof Number || value instanceof byte[]) {
can we assume all JVM/OS nodes in the cluster are clock synced? are the nodes configured to sync system clock from a central server regularly?
Pass the visualizerId to the above method. Doing this will help avoid that method being moved to a place where the visualizerInstanceId is not set yet
validation?
You can extract value.name() to a local var.
Why shuffle these? If you need to shuffle them can we use a set random seed? TestUtil.RANDOM_SEED is a good option.
Note that File#toURI() produces an invalid URI. Convert to NIO Path first and then to URI.
can we have: private static final int VERTICAL_PADDING = 1 and private static final int HORIZONTAL_PADDING = 2 instead of having magic 1's and 2's everywhere?
Maybe it's just because I'm new to the *Handler code, but it's not clear to me why one would handle exceptions locally vs. handle them from this handleException method. I guess it's all hooks for operating within the confines of a Runnable off on a thread pool somewhere.
given/ execute/ assert
can we do this atomically?
what about creating a separate put method with no Environment parameter to avoid using null?
Why are you using the serializer that does the lexi encoding as the default here? The Simple type encoders should be faster and potentially smaller.
Why are you not using the Spring test framework here and just injecting all this stuff via annotation?
Probably better to use Long.BYTES.
tests should never do things like exit()
I think it's better to use try-with-resources here, it will also fix Sonar complaining about it. I mean it should be smth like: java try (Repository repo = EGitUtils.getRepository(project)) { if (repo == null) { return null; } return EGitUtils.getCurrentBranch(repo); }
include in the message that we're ignoring the passed config and using 1.
The truncation handle is not an HSID, you should use TxnEgo.txnIdToString() instead.
I suppose to avoid double get of volatile field which will be cached in most of the cases better to do  fileId = bonsayFileId.get(); if (fileId == 0) { fileId = resolveFileIdByName(name + INDEX_FILE_EXTENSION); bonsayFileId.set(fileId); }  that is minor so up to you
Does every put needs the offset initialization?
this should be checked at construction time. don't create the object with an inconsistent state.
this API looks much cleaner
(There is no action required; just thoughts when reading the code) I see. Previously, if it's not variable, then it's constant and can be simply ignored. Now, if it's not constant nor variable, it's a (coalesce) expression, and should return false for this method :)
instanceof Dataset is redundant -- why not just a single instanceof FilesystemDataset check?
Making methods public for test purposes is not a good idea, esp. for AzureBlobFileSystem class. Find alternative.
There should be a normalized() method you can call that avoids the lowercase string allocation.
Any reason for not calling super?
getWorld().getWorld()? Also, why not just pass in minTime to compare here?
why does the test constructor need to be public?
use IdentityExtractionFn when it is null that will reduce the amount of if/else IMHO
nit: it seems to me this should be just before the return at the end of the method.
Not required. Will be collected with the connector object.
can just chain it right? dfsCluster = new MiniDFSCluster.Builder(conf);
This only takes RTP into account, right? Is this intentional?
rename to sash
Traditionally we use "TYPE_RESOURCES" for logs related to app installs/updates/etc.
static import
The "else" seems unnecessary
Assert the instance of the parent instead o the class
checkit
style nit: no braces around single line blocks
I decided to strip the trailing slashes here. The caller here don't care if it is "dir" or "dir/", so we will get the "native git" behavior. I decided not to do this in PathMatcher, because it is more generic one and this would also have implications on ignore rules, which I can't overlook right now.
In this test method and the one below it, I would suggest including an assertion that also checks the formCode field.
throws Exception can be reduced to throws IOException.
Make the "super" dex field protected and remove this one? Or a protected getDexBuffer() method?
![Codacy](<LINK_0> Issue found: [A method/constructor shouldnt explicitly throw java.lang.Exception](<LINK_1>
Probably typo in serizalize ?
maybe add a es- prefix to these values or change LogIndexerProcessor.class to ElasticSearchIndexerProcessor.class ?
I don't see a SWT.Selection event when I click, except if there was a non-empty selection before, then clicking clears the selection.
If you do this, might the retryPeriodMs exceed the retryTimeoutMs? Is that ok?
drs should be dns ;-) or any other name, but drs doesn't fit at all
The reason it was named CB was so it'd be short when statically referenced. But, either way -- no biggie...
Is this necessary?
Please don't change it to static. It is usually a bad design decision. Static classes and methods complicate tests.
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
InterruptedException should never be handled this way because it eats the interrupted flag. Look for other catch InterruptedException's in the code on how to handle it properly.
Let's throw this error, so it'll be handled by the test runtime.
in = fs.open(filePath)
Just one minor thing - this can be simplified to  java return new Stream.Cons<>(head, tailSupplier);
You should probably look at how users were dealt with on line 239. I believe that additionally prints the email. Some users may have the same FullName, it helps disambiguate.
the widget should draw this
Not a huge fan of this method name. A bit obtuse :)
I don't know much about Robolectric testing really. Do you think this should: a) Generally match the targetSdkVersion? b) Generally match the minimumVersion? c) Just be consistent? Currently it's 21 and we're building for 22. I assume there's scenarios where you want to test a particular function and so you need a certain version
double ;
This is line-wrapping ugly. I'd prefer (assuming you change scanPath to return File): File gitExe = scanPath(...); if (gitExe != null) { gitExe = gitExe.getAbsoluteFile(); File bin = gitExe.getParentFile(); // discard "git.exe" return bin.getParentFile(); // discard "bin" }
you could extract this (and from method above) to a private method like getCuratorClients(manager)
I guess you should also check if an error is empty
I don't understand what this check is doing here. maybeMove is already taking check of checking rights.
I think we should have a null check here but I don't think we need a blank string check. Locale.forLanguageTag("").toLanguageTag() or Locale.forLanguageTag(" ").toLanguageTag() or similar will return "und" (undefined), which is a legitimate language tag. I don't think we need to worry too much about the edge case of browsers sending something that isn't a valid language tag (however, we do need to deal with JavaScript not being enabled and do the null check). Plus, if we do a null check rather than a blank string check, we can have cool code like this: java String language = Optional.ofNullable(templateData.getAuthCardDetails().getJsNavigatorLanguage()) .map(Locale::forLanguageTag).map(Locale::toLanguageTag).orElse("en-GB");
You can find out if it was manually aborted with the following pseudo code  java InterruptedBuildAction a = build.getAction(InterruptedBuildAction.class); for(CauseOfInterruption cause : a.getCauses()) { if (cause instanceof UserInterruption) { //User aborted the run, now do something } }
Don't see purpose of using a FocusPanel here.
rename to contribution
No reason to include an unused constructor.
This should be a function derived from RoutineCharacteristics.language. Actually is it better to expose language rather than implementation type?
Why Boolean instead of boolean?
Better error message please :) Something along the lines of "must be a relative path" reads better than a regular expression.
Since site is assigned by mSiteStore.getSiteByLocalId(getSelectedSite().getId()) just above this, can we pass it to getMySiteFragment().onSiteChanged() like getMySiteFragment().onSiteChanged(site) and avoid calling getSelectedSite() with refreshSelectedSiteDetails(getSelectedSite()) in MySiteFragment.onSiteChanged()? The MySiteFragment.getSelectedSite() method just calls WPMainActivity.getSelectedSite(), which would be the same as passing site with getMySiteFragment().onSiteChanged(site), right?
It seems to cause overflow when the difference of two table volumes are more than the range of integer value.
Why do we set these false? It seems that we should set them true.
You don't need this. buildUserAccount() has a null check.
nit: Processor: {} has executionEnvContainerId: {} to be consistent in other places. I remember Prateek made a whole clean up PR for this :)
ITEMS -> items
this is not needed - the finally clause closes it anyway.
Is the double wait needed?
why you are not verify updateAdapter(patientList) method ? You can check if it was called with the proper list
Are you sure this is the correct method!? From what I can see (from the code) that will show a popup to restore the file to the current version. Other editors use versionRecordManager.reloadVersions(path); in their "save success callbacks". You might also want to check the XLS Score Card Editor and the "Upload file" Editor for similar problems. I'll compile this PR and _see_ what it's doing; in case my code review is misguided.
This should return boolean (primitive, not reference). No need to complicate things with the return type suggesting the value could be null.
Same here - check env variable before returning true.
It's better to it in try catch finally
Let's use ViolationMessage for these test methods
I wonder about throwing everywhere, as most of the reportIssue message are calling the same on line 123/127.
*in*sufficient?
Cache manager is being leaked here. HR server won't stop cache manager... To avoid such leaks, it's better to extend existing classes, e.g. SingleHotRodServerTest
Is new Random().nextLong() really ok for sequence numbers? I would have expected them to be increasing - but guess this works for testing
Again, not sure why the constant renames, what do they have to do with FixT?
This will never be seen.
checkState(spillEnabled, "Revocable memory requested when spill to disk is not enabled");
I would suggest adding an error message to the response.
Method deprecated. Use clientBuilder.version() instead.
This should be private method.
static Strings or enum for list targets would be helpful
Why does this return a PagedFlux if it's only going to return a single (first) message?
Add a method getAndClearLogEntries(type), call it from the handled, deal with nonexistent types in that method not the handler. The handler should have no business logic preferably.
Some of these codec constructors are public and some are package-protected. Seems like they should all have the same access, unless there is some specific reason for it ?
Please use {} for blocks.
The rule manager is a mandatory reference, so it cannot be null if the component is active.
this shouldn't be present - super() the base class is Object which doesn't have a special constructor to call.
closeRepo should be set to true, otherwise the repo is not closed
Single statements don't need a transaction.
beware that not all queries _can_ have an order by clause. For instance a "SELECT COUNT(*) from table" cannot have an appended order by
Worth to use try with resources: java try (final InputStream inputStream = ioService.newInputStream(path, StandardOpenOption.READ)) { final String drl = DecisionTableFactory.loadFromInputStream(inputStream, null); return fillDrlIndexBuilder(path, drl); }
It's better if simpler/shorter branch goes first
This can be static.
We cannot move eObjects to another resource because this can have side effect to other tools (using the resourceSet).
This exposes mutable internal state. A copy is needed.
This should be configurable, no?
I am not super familiar with this but the usage pattern elsewhere seems to be 1) inject an executor 2) Call context.asynchronous() 3) Perform the work which may block in a Runnable 4) Call context context.complete() at the end of the Runnable i.e. the heavy work should happen in a different thread.
one line: ) throws ...
A test would be nice here. If the TextFormat had an interface and didn't have static methods it could be mocked
The compiler guarantees this is not null
use in try-with-resources to avoid leaking FS instances
These two parts can be extracted
Seems like the description setter could handle the null-checking logic so you don't have to do it here.
@davidmsantos90 Why not use a fixed Locale? getDefault() varies form computer to computer and that is not something that we want to test in this test.
checkArgument for negative numbers?
An IllegalArgumentException should be thrown.
Would a switch be easier to understand? The two cases that should be treated the same way can just fall through, as in:  switch(currentToken) { case START_ARRAY: case START_OBJECT: depth++; break; ... }
Should this be "boot/h2-1.4.196.jar" ?
This should return RowMapper<String, T>
/ is missing from the file name. As a result, your file is now in the root directory. :rofl:
Cut and paste error
Shouldn't this also 'put' to ensure that a re-used regex is treated as new in the list.
Usually, static variables accessed not by instance but by class.
I would tend to use decodeHex(char[]), not sure how charset sensitive this will be, however, given only <127 ASCII should be used.
This will not clear the MDC if it was initially empty. IOW keys and values set inside an executor's thread will not be cleared, if the outer context (when calling current() and apply()) was null or empty. Consider this: java MDC.clear(); TransferableMdc mdc = TransferableMdc.current(); executor.submit(() -> { try (@SuppressWarnings("unused") Mdc mdcTmp = mdc.apply()) { MDC.put("transferred", "value"); } logger.info("'{}' == value", MDC.get("transferred")); // logs 'value' == value, but should log " == value" });  I think in this case the MDC should also be cleared: it was empty before, so why should it be non-empty afterwards? Removing the if (context != null) check seems to fix this. Are there any side-effects to not checking context here? Maybe related: I'm not sure the conditional in apply() spans the correct statements. Shouldn't the backup always be set and the null-check only be performed around the foreach loop?
Provide the defaultLabel as argument of defaultIsLastCase, so you will just have to check if the last label equals() the default tree, and not check again for keyword matching.
Is this the end of the added? Can you mark it?
It looks like this change ended up being unnecessary
I did not understand why adding that. In general, adding API to AST or Framework is carefully discussed before. You can do that to go ahead in your experimentation, but there is no guarantee that will be merged at the end.
Would it be possible to cache the DatabaseDescriptor in the initialize() method similarly to what we do with the SchemaDescriptor, so that we don't have to throw StandardExceptions all over the place?
Typo *intput*
Can we remove the version variable since it's always equal to the constant?
Minor, you could use COUNT(id), in general it's faster
NPE if interface number is null
...and these two above...
Please provide more meaningful field names. Also consider prefixing field names with f and parameter fields with p
I guess the path should have been "JERSEY-2643" instead of "test3"
again, use a map
With the changes to the getters, this can be reverted, right?
use LambdaTestUtils.intercept(). Not only simpler, it will (correctly) fail if the rest operation didn't actually raise an exception
I don't know that we want to return generic server exceptions in the payload to the UI. This has the nasty habit of exposing pieces of the workings of a service to the world. Generally better to swallow unhandled exceptions and log them somewhere for developers/debugging.
safely()
No need to store the return value here - you could just write it as: java Assertions.assertDoesNotThrow(() -> { DynamodbStreamRecordTransformer.toStreamRecordV2(streamRecord); });
size is missing in the message
suggestion "logical slot %s for execution vertex (id %s) from the physical slot %s",
style nit: I would phrase this loop as: int qi = 0, ii = 0; for (Entry q = head; q != null; q = q.next) { if (++qi % 100 == 0) index[ii++] = q; } Its shorter by two lines because you can combine into the for loop. I know you have three "iterators" here, but I think its sane to use the for loop for the Entry pointer that is the main loop control variable. The other two "iterators" qi and ii aren't related to the number of iterations the loop makes so don't need to be in the for loop construct.
Replace 4 with VISIBILITY_VALUES_PER_BYTE
getFreshTimestamps(numTimestamps)
Same here, it seems that validateBeforeUndeploy is doing the exact same thing as the code below.
This and the below methods should be protected rather than public so that they can only be accessed by subclasses
I think this is wrong (there's also tool configurations). Better to retain the existing behavior and just adapt the Predicate as needed.
val
This should just set patientProgram without creating another instance
Why this format and Locale.ITALY is used? Maybe Locale.ROOT to make it more or less locale-agnostic? Is there some fixed date format in TSD like RFC822/2822/5322 one?
Why not use [TransactionStatus#canRollback()](<LINK_0> here?
It is not the responsibility of our callers to deal with our exceptions after we've hidden them. Do not propagate this, log it and fall back out of the catch to return null, or properly throw the CoreException so that the caller knows there's an error case, which in our code we'll simply log and recuperate from (use the other groups, which can be only the default one if all of our extensions failed to be instantiated).
checkstyle will complain here, missing {}.
Same here, what's the usage of this output?
This public has to be remove. See Travis report.
These (glowing methods) were added on day 1 of 1.9 builds, so no check is required here.
localName can now be inlined
Definitely agree. I might make this error very, very explanatory since I'm not sure what people would expect to happen here.
propose to populate queries in the constructor or init method
there's no evidence this must be non-null (though it might've been the original intent).
nit: parameterized logging
I wonder if this API is good enough, when you consider vertical zooming (Ctrl+PLUS and Ctrl+MINUS). Here we don't know which entry's font is being set, you can't rely on the height because it can vary due to vertical zooming. Perhaps all we need is a maximum font height for the whole time graph control (for tall entries and/or with large vertical zoom). Then this can be handled internally (as a bug fix/improvement) and doesn't need a new API. What would be a good maximum font height though, does it need to be configurable?
Do all the functions being passed here need to be instantiated each time? Or could we use a singleton for them?
Verifying the html won't be able to tell us whether the element is actually displayed or not. For that, we need to use the isElementVisible() method provided in AppPage.java (perhaps also extract it into a method isModerationHintVisible in FeedbackSubmitPage.java). In this case, we simply need 1 html verification to ensure that the html is correct, followed by 2 visibility checks to test that the button works as intended to show and hide the hint.
suggestion default @Nonnull Collection<View> getAllViews() {
This could be a pre-defined (static final) instance of a static class, rather than an instance class instantiated anew each time.
In the descriptor builder, we usually read the file immediately to fail fast. I think it would be better to move the reader code here for the same reason. It could also be reused more easily.
Move this validation to PluginProfileService.
You can remove this line, this is done in transactionalFeature.nextTransaction()
It's a very strange use of generics. Why configuration property is not defined as T ?
change exception
How about return expiresAtMs == Utils.Infinite_Time ? Utils.Infinite_Time : Math.max(0, TimeUnit.MILLISECONDS.toSeconds(expiresAtMs - creationTimeMs)); ?
Instead of making delete operation a special case, in case of delete we can just push a null value into the cache. So it will automatically return null.
Any methods that override should be annotated with @Override. Otherwise I can't quickly say if it is correct or not.
Revert this change please.
code not required? its taken care in the next addRepresentation call
nicely done! just one consideration: the ioobException contains the information on what went wrong (i.e. what the actual index was and the size of the list) and by catching it and then throwing a new one you lose this information. so please change it such that the stacktrace and message of the original exception are passed on:  } catch (IndexOutOfBoundsException ioobException) { comparingSet.remove(element); throw ioobException;
Tricky! validateAddAllowed currently checks if you have the WRITE_META permission on the entity. Acl gets created after the check. This breaks OneClickImporter
rename this url variable to location and then simply use the variable name url in the foreach loop below
In general we don't mark local variables as final in Presto source code.
Don't need to call setUp() here
no need to do +1 inside in the loop just do iteration from 1 till <= dimension
I wouldnt use regex matcher inside this in this way. Because if a label contains a special char... it would not be matched properly.
Is this the purpose of having this class?
can be cached
SinkSemantic or KafkaSinkSemantic? It maybe confusing that it also works for source.
this method name is unclear
Could we set this string to a pre-defined constant ? i've seen it being used everywhere. Easier to maintain if we can define all system properties used in test cases in a single place.
fix formatting here please
Yes this is syntactically correct but it would be nice for things to be consistent. Opening curly brace on function declaration, code, closing curly brace on a separate line.
I think this should be a copy, not a reference. We wouldn't want changes to one jdbi context changing the behavior of another.
word "check" is overkill
You don't have to check for id equality if the listener is defined on sign_in_button
The event description is wrong, the account is being deleted it may not even mention the users and simply say removing all users under the account.
How about byteContainments? Especially an "s" is missing.
I think a static import for common preconditions checks would be reasonable I believe?
Ditto. It appears you have a Room reference on Exam directly.
Please remove "public" (our mistake, because the other constructors in this class should be package-private, too).
I think you should separate _expectation_ section from _given_ and _action_ sections, this test case is not obvious
you should actually call super with false as a third parameter.
I think it's clearer to add else { return true; } here
This can be made simpler using the fact that remove returns null if the mapping doesn't exist, and we have putIfAbsent at our disposal. java final String tag = tags.remove(fromTag); if (tag != null) { resource.putIfAbsent(toResource, tag); }
why do you set the username here?
please do compile and save it in final field of class, to improve performance a bit.
We can replace the method call of(partialFunction) by providing a type hint <R>:  java return () -> Try.<R> of(partialFunction::apply).getOption();
Based on the work done in the Pay/Receive PR's, the CheckPinDialog will be replacing UnlockWalletDialogFragment
you already synchronized at line 261, do we still need this?
I am not sure that A needs here, I think renderAsSource will be better
Please, change as discussed.
As mentioned on previous patch, there is no guarantee that 2 objects with the same hash code will be identical. You would have to be very unlucky with a typically small number of descriptors to have to identical hash codes on different objects, but it's not impossible.
Why return AtomicInteger?
Also this should be probably split to two methods, one for TCP and one UDP, see usages, where you are using this method in context when you are actually want to check only TCP ones.
suggestion if (getDateOfDeath() == null) {
shouldn't this be error()?
rename
There are a bunch of places where getLinkedAddresses are iterated over, and the collection is not thread safe. We need to double check those are covered by an external sync such that we don't get concurrent mod exceptions.
Not sure about this; sure, this is a lot of exceptions in the method signature, but this encourages throwing whatever you want and not caring about what you catch.
Should fail if the list is empty
I think that GoMethodDeclaration is not appliable for gobench, so something like  type T int function (T) B<caret>enchmarkName() { }  shouldn't produce gobench run configuration, right? If so then it's better to replace with  GoFunctionDeclaration function = PsiTreeUtil.getNonStrictParentOfType(contextElement, GoFunctionDeclaration.class);
Please add ioe to the exception.
Look like this is not used anywhere. Also if we do need it it should not be public
Java 8 has UncheckedIOException which would be perfect FileException is going away so let's not even talk about him again... @swankjesse any thoughts?
Static string constants
Hm, why "RuleImpl" instead of "Rule"?
Another space after add
This means, if the number of partitions are set to more than one, then a threadpool with multiple threads will be created. I think we just need a single thread.
Style-nit: Use curly brackets and wrap the return to next line.
Remove this if statement
This method should just check if the maven-executable is present in ${karaf.data} (in the correct version)
Collectors.toSet()
Not sure if it matters, but to be on safe side, collect to a set that can preserve order?
This is currently pulling from the training date, not the date for the new training completion.
I think we can drop the enum and make this public abstract String getName();
should this be done internally by RetryPolicyExhaustedException? What other uses are there for it?
Do you want to switch this to the same jooq pattern as ClientDAO?
!isEmpty and throughout the CL
shouldn't here be a selectedNetworkElements.clear()
Weird argument names, inconsistent with usual naming expressions.
No need for a static import here.
Add not-null check here.
Minor nitpick! This duplicates code from getCanonicalUri. We should have a private method that generates the appropriate URI for any given domain, and have getCanonicalUri and getMobileUri call that.
why assume, not assert?
I think the MockWebServer can be removed since it doesn't look like it's needed for this test.
query builder not sure to be set here, needs check?
Please keep the TODO
Hmm... a tricky date format. This is usable right now, but anybody that wants to use it will have to convert it to something usable. Either in this PR or on a future one we have to implement a special data container IMO.
with n and p?
Use Closer
nonExistentLockService for consistency.
suggestion LOG.warn("could not remove referencePoint, no referencePoint is registered with ID: " + id);
find a unified way to report result, all by metrics or logs
This looks suspicious: both minStr and maxStr are initialized from values[1]
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
Please use Easybind.map(stateManager.activeDatabaseProperty(), ...) instead of createBooleanBinding. It's a bit more readable and shorter.
Avoid unwanted blank lines.
Three more lines of English.
RulesDao.getRules() already returns a list.
There is the potential for an uncaught IllegalStateException from the call to Case.getCurrentCase if there is no open case.
Nitpick: wouldn't step = -step be clearer? (and is this check even necessary?)
This variable is called twoHoursAgo, but in fact it could be any number of hours ago.
With the key-value set introduced I don't think each header element passing by will be a messagePriorityElement, so that name had better changed to something more general.
be positive: return vnicProfile.getNetworkQosId() == null || getNetworkQos() != null ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.NETWORK_QOS_NOT_EXISTS) ;
Remove the reversal here, and let the JDK 8 implementation return it in reverse, and the JDK 9 implementation *not* reversed.
In a try with resources statement the resource is implicitly final, so here you can remove the final modifier.
Let's either just say Jwt since that is the name of the class or JSON Web Token since that is what JWT stands for.
We shouldn't default to enrollment. mPower 2.0 configs are going to change anyway, so back-compat is a non-issue. Adding a special case for enrollment just adds complexity and confusion. If we absolutely need a default for some reason, that default should be activities_retrieved.
need only IOException
Collectors.toSet() is terser (and Set<> is a better return type than HashSet<>).
We should cleanup when the bundle is destroyed rather than using a shutdown hook.
This change makes it impossible to read tests from local folder
suggestion if (null != cookies) {
I'm wondering if we should use ValidClientsByTaskLoadQueue (with a (c,t)-> true predicate) instead of a plain PriorityQueue here, since our queue now nicely enforces uniqueness of elements.
should require permission on disk only, calling super will add requirement for vm as well
The rule is that hashCodes must be the same if equals returns true. It's not the case here if pageNumber is equal and some other field is different. The easiest fix here is to include just the first field that is checked in compareTo i.e. pageNumber. Please use HashCodeBuilder to generate the value.
builder is not the perfect name here. uniontype.
I'm not a huge fan - KeyedStream.of(historyQueries).mapKeys(...).map(...) gets you most of the way, although I'll confess that I'm not sure how to do the merging resolution in KeyedStream (although you can always collect to multimap).
Static imports (of e.g. Iterables.transform) or no static imports? Mixed bunch further down, e.g. EC2ListNodesStrategy **with** imports and plenty of other cases **without**.
Should be protected at most.
check for null here?
Maybe it is a good idea to log this (as WARN) ?
Should be BaseEdit
This looks like the same implementation from InstancedConfiguration, but maybe we can extract this into a function in FormatUtils or CommonUtils so we don't have the code in both places?
!isEmpty
please invert if condition
Remove before merging
I would set it private as this class ought to be externalized at one point.
One downside I see is that we have two constructors now with differing implementations. Perhaps debatable, but it can be easier to reason about a class when there is one constructor that has logic and all the other constructors invoke that constructor. If there is an update for example to how this class is initialized, we might forget to update both constructors. Or, when reading this class, there are two constructors that need to be taken into account when reasoning about the state of the class. Is there a way we can avoid the extra list but still have effectively one constructor?
I feel like my last feedback got ignored
This is problematic for the following situation. * Open RFile with config for MyBlockCacheManager * Open 2nd RFile with config for TinyLfuBlockCacheManager Seems like the 2nd RFile will use MyBlockCacheManager
Again, insufficient. FileWriter is also AutoCloseable.
Perhaps replace by: return chain[0].getIssuerX500Principal().getName().equals(chain[0].getSubjectX500Principal().getName()) (there's no need for the if/else)?
albeit not related to this patch - shouldn't be called explicitly, but via its getter.
just return "kudu" here
@slubwama Why uses patient.getUuid().toString() when the uuid is already a string
we can remove this.
Ditto here, no need to move the validation to DatadogHttpClient
Double ||?
usually this ) { is on the next line
Do you mean this to sort team1 before team2 if either of them are null? It seems like it should sort the null one to be first?
have a bytebuffer based impl?
Please shorten the exception message to method name: getSponsoredMembers, since this text is wrapped in sentence by exception constructor and passing own sentence would result in nonsense text. Thank you.
I didn't understand why you are traversing the InputStream but returning when the first element is retrieved.
call this variable accountService
This should be method.methodPrefix.equals(prfx) Test Scenario:  @Test public void getIsolationMethodTest() throws Exception { PhysicalNetwork.IsolationMethod method = new PhysicalNetwork.IsolationMethod("bla"); final PhysicalNetwork.IsolationMethod isolationMethod = PhysicalNetwork.IsolationMethod.getIsolationMethod("bla"); assertEquals(method, isolationMethod); }
I'm sorry I didn't notice/think of this on my first review, but I just realized that I was envisioning us sharing/sending the file itself, rather than sending the log contents as the body of a plain text message. In the event that the logs have gotten quite long, I think that would cleaner. Does that switch make sense to you as well, or was there another reason you decided to do it this way?
static imports
I guess it will be better to allocate ArrayList with fixed capacity (alternativeNames.size() +1) and then add all the names. This will prevent from potential reallocation.
As discussed in main issue, this should be in the check for the entire method. Maybe this should be moved to the isCheckedMethod method?
please fix 'packageNameWithSuffix' name
I don't think we need this check nor this method. simply call geoRepDao.getById(getParameters().getGeoRepSessionId()) when needed, if getParameters().getGeoRepSessionId() we will simply won't get any result
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "getPluginKeyAndResourcePath" a "static" method. [![rule](<LINK_2>](<LINK_0>
you also need to check it doesn't end with "/", which would indicate a folder
typo
is community using only one language? If so this text should be in some kind of FINAL in this class
Need to validate that action has GlusterServiceType parameter
I believe that is true instead of false
style-nit; we don't use braces for simple single stament constructs
Actually, I think initLineModel() should be no-op too; the semantics of it are what happens when a different key is picked, but in this case nothing should change when a different key is picked, right? Both value boxes (constrained value and free text) are hidden all along. So I would hide them originally, say by extending the createNewLineModel() method, and implement this as no-op.
I would replace those statements above with this(handledExceptions,failureWindow,halfOpenAfter,threshold,false).
Rather than hard-code "people" here, how about "person_id IN (SELECT person_id FROM " + PEOPLE_TABLE + "WHERE..."
Is there a reason this is a Set? Set seems suspicious to me (vs. List) for two reasons. - I think DruidCluster is meant to only have a single copy of each server anyway - ServerHolder equals includes a call to LoadQueuePeon.equals, which is based on reference equality, so it seems unreliable to use it to dedupe servers
logging should removed / disabled before merging
This could possibly break iterators that extend WrappingIterator and override getSource(). I don't think we should make this change. Maybe it would be better to deprecate WrappingIterator and introduce another version for users that more efficient. I don't think we have a lot of wiggle room to make this one more efficient without possibly breaking user iterators.
This constructor should have package visibility instead of public
this is only valid for a Standby, isn't it more intuitive if they see the status is ongoing? or do we aim to reflect the status of the replication from an active's point of view? In which case should we add a status that reflects that? cause it can be misleading, thinking that data is not consistent cause replication is stopped, when in reality the active is transferring data.
Does this mean that if I change the runtime config to something invalid (or invalid but of a different type), that the system will fall back to the default config? Can we log a very clear message and keep the previous version instead? Seems safer than potentially changing everything.
To make things refactoring-safe use something like SimpleTaskRepository.class.getName(), same for JdbcTaskExecutionDao.
I'd prefer that we handled it (the snapshot type) in a separate change.
This can be dropped.
ImmutableList.copyOf
I think would be good to rephrase this kind of messages to be something like "findNodes by multiple property names and values are not supported."
Bad, do not return null. Return is either one loader or other, there is nothing between. If you get here and have to return null you obviously didn't carry out appropriate checks or you do not trust your code
unsafe addition, can cause integer overflow. use long instead of integer
You probably don't want to have this return null, it should return an empty list worst case scenario.
You need to verify that the preference is about the email format, and not the alert one (a.ka. the notifications in the menu).
If we are changing this code, then relying on Optional could be a good move.
in tests, most of the time, we use incrementing numbers to make obvious the order in the tree. This confused me a little as 3 is the parent of 1 and 2. Maybe rework a little? long parentId = 1L; // by declaring a local, it is obvious that the parent is missing. It is more obvious because the traceId low is the same as the parent id. // then use (parentId, 2L) and (parentId, 3L)
It could just concatenate instead of going through the formatter.
this breaks the feature of changing log levels at runtime
Instead of passing null, is it possible to use the OIDs listed in the OpenJDK link I provided for the other algorithms? Thoughts?
break from for loop if annotation is found
Again, no need to use FileHandler... you should use PropertyConfigurationLayout: java config.getLayout().load(config, cleanUp(in));
We don't need this. See super-super-super class:  public EventObject(Object source) { if (source == null) throw new IllegalArgumentException("null source"); this.source = source; }
We always check for the positive case. For example isNotPrivate. Hence we should name this doesnotHaveTraceAnnotationAndReturnValue or sg like that.
Maybe just return path here? Can somehow url.toString() differ from path?
null or "null" ?
Please separate the two lines so that it's readable. boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration.isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; }
have acquireSerialDevice return the serial device, and get rid of the member variable.
why is this any more reliable in java versions lower or higher, even in java 1.8, System.gc() is just a hint.
nit: put args on a separate line
you could do this in a single line
It's not great to rely on this without knowing what it relies on. In particular, you replace it with failing test elsewhere, but it's not immediately obvious that this is running the "sample" test once I got to the bottom of the file.
what if there was a write setting this to null inbetween the check of null
I think it is clear enough even without the additional id variable same for below
Suggest debug message along the lines of log.debug("Closing [%s]", id);
Check if command is null.
As discussed, this code should never be executed for connections. Should be checked above in stack trace.
Why null is acceptable situation?
null != settings
Will this condition be ever met?
Initialise in constructor
This if block can also be replaced with ContextCompat.startForegroundService(context, intent).
Closing curly-bracket should be at the new line.
That way the parameters will be remembered and saved on MZmine exit
please make checks explicitely. onView(withId(R.id.dfghjkl)) will always work in espresso because it doesnt do anything. so it would be nicer if you would add an explicite statement that youre actually checking something here. onLegoSensorPortConfigDialog() .checkDialogVisible() or something like that
Shall we change the order of equals checking as well?
Just return azureBlob.containerExists("system"); also wrap it in a try/finally block to close the context.
This condition is little hard to read. I would prefer return isNormal && (substitution.isEmpty() || isGround()) ? this : (Term) this.accept(new SubstituteAndEvaluateTransformer(substitution, context));
suggestion if (!(obj instanceof IdToken)) {
We should watch out for ApplicationContext::getId returning null suggestion if (event instanceof ContextRefreshedEvent && ((ContextRefreshedEvent) event).getApplicationContext() == this.applicationContext) {
Possible to make it private?
Why is hashCode and equals implemented like this? Two UserResourceProfilePK instances with the same userId and gatewayID should be equal and should hash to the same value, right?
@Overrding public should be on the same line according to Ignite code style.
Should we be using a Secure CXF client here? @stustison
Needs JGitText entry, I think
Shouldn't this be anything active after CLAIMED?
It seems we should not filter nulls here.
if bad version is passed, there will be a ugly message like "File not found...etc" maybe it is make sense to prettify it somehow, wdyt?
use 'L'
Defensive copy here instead?
usually I do either  IOException|RuntimeException or if doing Throwable, use propagateIfFatal
or properties. Well. Looks like there are a few of these.
Maybe the common stuff could be moved into a utility class or something that avoids repeated code.
I'd prefer to return empty string rather than "null"
add expected offset to exception message
[Waves hand] This is not the validator you're looking for...
the .contains() should probably be in the synchronized block too
@weisebrazil all indentations should be 4 spaces, not 8.
ph -> pageHelper
user should be in constructor right ?
I think the flag should be true for it to be in prefix mode?
Use Strings.isNullOrEmpty?
There is no format specified for parsing. Isn't it better to do so?
Not so sure about this guard. If notifiers isn't empty shouldn't the destroy run even when not disabled? What if I do the bootstrap, disable the service and then get here, shouldn't we still destroy?
I don't see how this is going to work, readInbound is an object and b is a byte array, we want the method assertThat(byte[], byte[]) for correct comparison. I have vague recollections that the cast might even be required in later junits.
setting dateFormat is redundant
check formatting
We should also animate transitions.
Why not use [TransactionStatus#canRollback()](<LINK_0> here?
I believe this method should be getWorkerMetricConf()
This is useless since clear() below resets position to zero?
I am a bit concerned about the coding style here. Azkaban uses a different coding style than LinkedIn. If we are moving to LinkedIn standard, let's change the entire codebase and move to it. Else let's stick to Azkaban's default. Having both styles in the same codebase may not be the best idea
Shall we change this log to Service removal failed. Microservice class '" + service.getClass().getName() + "' doesn't contain a root Path.
query better to put the extra keys in class constants
java String testedPage = urlBuilder.getUrlForFandomPage(article); AdsFandomObject fandomPage = new AdsFandomObject(driver, testedPage); getJquery();  What do you think about creating one method in AdsFandomTestTemplate and be more DRY?
If you have made equals final then you also need to make hashCode and compareTo final
All the following methods should also do size checks like readByte does and throw EOFException. Otherwise we will get IndexOutOfBoundsException instead.
Might need a JUnit test for the case where translate is requested with a URL and no version, but the requested ConceptMap is not versioned in the repository.
This sounds like an error, too.
AsyncTask's toString is a tad large. Perhaps joining this list with a newline would make the log easier to read?
one of these should be host
Why don't we have rate metrics
Souldn't that hashmap be configured once at object allocation instead of recreating it each time getMeta() is invoked ?
this line can be pulled into setActionMessageParameters() method in the NetworkQoSCommandBase class since it repeats in any of the NetworkQoS commands.
This is silly nitpicking, but, I just had issues reading this code, so, could we use a rcvrClass local variable? Then we also avoid twice the .getSOMClass(). Not that it matter performance-wise, but I have to think of one indirection less.
s/Moved/Requested Move since we are expressly not checking if it worked.
resolve() can return null but Class<?> getReturnType(Method method) is expected to return non null values. Maybe we should use resolve(Class<?> fallback) variant or assert the returned class is not null before returning it if we are sure that will be the case here?
No need to check the value of StartupContext.getInjectionContainer() here before assigning it to this.injectionContainer.
The ids here should be a concat of appName + instanceId as their combination uniquely identifies.
Returning Java null here won't work - what you have to do is to send a channel state update UnDefType.NULL. Imho the best place to do the colorMode check would be [here](<LINK_0> - simply do the update with PercentType it colorMode!=CT and otherwise do an updateState(CHANNEL_COLORTEMPERATURE, UnDefType.NULL);. Makes sense?
Is it possible to keep return type of asc() as is (ie Collation) ? While it doesn't add functionality it hides all methods from user during IDE auto-complete (that was the point of empty interface).
The iterator contract is to throw NoSuchElementException if there is no next
Put the close() into a finally block so that an attempt is always made to close the session, even on commit failure. If closing the session fails, there's not really anything we can do -- log and move on.
Can you change limit.intValue() / 1000 to (int) (limit / 1000)
isMathematicalInteger and "pair +" commonality
Should be public.
if maxValue is near Long.MAX_VALUE (i.e. 2^63-1) and minValue is near Long.MIN_VALUE (i.e. -2^63), then maxValue - minValue is going to overflow
This should have a meaningful error message (i.e. a message added to the relevant logger), and should include the exception stack trace (like what you have done below).
for readability/consistency, consider invoking SearchableListModel -> forceRefresh() instead...
Please do not use System.out.println, log may better way
The whole purpose of FullListAdapter is to abstract the implementation details of querying the device list from the caller - so how about moving the changes that are done in VmDevicesMonitoring to FullListVDSCommand ?
The following code can be used to create this NhinTargetSystemType from NhinTargetCommunitiesType extracted from request. This would reduce 3 methods from this class. NhinTargetSystemType target = getMessageGeneratorUtils().convertFirstToNhinTargetSystemType(targets);
Move this line into the if statement. We don't need to execute it if groups is null or empty
@fanifieiev the same above.
why this function write the headInfo information by read this.thisReadSequence ?
should this throw an exception?
not synchronized?
empty partitions -> should we say empty topics ? Just to clarify that some partitions from _different_ topics are empty?
This doesn't seem right. I would have assumed this would be stream(), not streamByPage().
Same as above, this is deprecated and should no longer be used.
We look at ENUM_DEF and examine all children for comma and see if it has another trailing constant def. So we are manually doing our own looping here. Wouldn't this check be even simplier if we stopped on ENUM_CONSTANT_DEF and then only look at the next token or 2? Just check if the next token is a comma it must be followed by another ENUM_CONSTANT_DEF?
<LINK_0>
does not support an no? How about requires a instead?
Static import?
nitpicking: better to have error message with human readable text there otherwise it throws IllegalArgumentException without any explanation
This is hard to understand, because it's a field and a default value at the same time. It's an interesting idea, but I don't think we use this anywhere else in our Java code.
I think you could return a byte[] here to have cellularInfo final
Are this class and DatagramSocket designed for inheritance ? If so, programs that derive from this class will not be able to override these methods (they're hidden). Will that break such classes ? Is it the case these methods are used *only* by the corresponding NIO channels, and subclasses are safe because there's no way to build a channel out of those classes ?
The log seems to be a copy & paste error.
Why this magic value?
I think there is no need to cast driver to JS executor
Maybe specify what users should replace true with as well?
Should we trim this? suggestion this.dlqTopicName = connConfig.dlqTopicName().trim();
Is this just a formatting change? :) The PR is already big enough to add cosmetic changes into it :)
I prefer isEmpty() to size() == 0.
It's wrong, see drop in other blocks
so just use getIsWipeAfterDelete().setIsChangeable(!isVmAttachedToPool());
traceEvents.containsValue(field)?
The Fragment should obtain the host by calling FragmentUtil.getCallback(). I think if the Activity is ratained in a Fragment instance, it'll cause a memory leak.
multi-catch. Nice :)
When globalMinimumClock has value of greater than 0, parameter addedEval should be false. Handling this case by throwing RuntimeException will make sense.
Ah, thanks for pointing that out - I missed that. What is it that calls xaResource() method? Something in the spring config during boot? We need to make sure that the recovery helper is installed during boot? Is there a reason you don't do that in the xaResourceRecovery() method immediately below? My preference would be that there was some way we can force the DummyXAResourceRecovery to be set on the RecoveryManagerService during boot? For example can we call a setter on the RecoveryManagerService using spring wiring that passes DummyXAResourceRecovery in or pass the RecoveryManagerService to the DummyXAResourceRecovery so it can call add on it? This last one is probably the way to go if possible.
This is a duplicate of the above line
strange name for the variable, what does it mean?
Remove useless assert
This is likely to be called on interruption. What happens to the proc in this case? Is it handled by Jenkins, or we should do the cleanup ourselves?
I think checkState(wiki != null) is more appropriate to force a proper usage.
Good to have null checks on these helper methods.
Looks like you don't need to pass in the instance here since there's no formatting characters in the string.
stop() should be in a finally block, or you could use TestingUtil.withCacheManager().
Isn't .boxed().mapToDouble() equivalent to .map()?
Mind changing the type of this to Map<String, Object>?
Shouldn't you intersect with the original envelope first? Some unit tests for this class (and the feature equivalent) would not hurt.
Probably should crash if bad format string
Even if there is only 1 row in "for cyclus" i prefer using '{' and '}' for better reading.
my mistake, InterruptedException should be catched outside the while
Don't duplicate tokens, just re-call getRequiredTokens.
I think you can return Arrays.asList(...) directly, no need to create wrap that in ArrayList.
Wouldn't it be more readable to use TransactionSupport.executeInNewTransaction() instead of the code here which does the same?
I think this is an error: you should return an instance of ExceptionLogHandler, NOT of WarningErrorHandler
Is there a convention to use ++?
use install()
You can return on the same line or make it final
suggestion return mapper.orElseGet(ObjectMapper::new).convertValue(attributes, ValueAttributesInfo.class);
return StringUtils.defaultString(string);
Would it be useful to make this less generic? Something like Resource ingest has started for '{}'?
Can we put the Objects.requireNonNull(...) at the beginning of the method? This makes it easier to read.
not all listener
Is there some Path.join() thing you can use instead? Something more idiomatic.
Wouldn't this cause problems to actual consumers? If a user decides to build a listener that implements IClassListener and provides implementation only for onAfterClass() then they would be seeing exceptions for onBeforeClass. IMO we should not be throwing exceptions in our default methods. Can you please have this removed in this listener interface ?
by default.
change to BROWSER
Can simplify to one line, no? Or if you're going for readability, you can eliminate the local variable and just do "return ..." everywhere.
suggestion throw new IllegalArgumentException("Can not parse job ID: " + jobId, e);
The epoch is usually 1970, rather than 1980 - any particular reason for the change? Functionally equivalent, of course.
Code smell: clarify contract of repository regarding emptyness
Are consecutive reloads necessary or will be one reload at the end sufficient?
I first thought this would require a string resource but on second thought this case should never happen, right?
Why do we send content change messages from here now? What's actually changed on the content..?
Another reason to initialise when declaring the fields I guess, you don't have to repeat the initialisation code there.
return false
I know this is copied from Thrift, but still seems unnecessary to wrap an RTE with a new RTE.
whats significance of 47? maybe make it constant?
Don't need to wait for the tx completion responses before removing the local info here either, although since removing the local info is expensive you could still send the command first.
entry
might as well guard this with an if statement as well
why throw after some operations?
fallthrough to readFromNBT in line 47. Intended?
Default should be false
Do we need to keep  if (runtime != null) { runtime.shutdown(); }
Should get system bundle by location using the org.osgi.framework.Constants.SYSTEM_BUNDLE_LOCATION constant. This is to guarantee you always get non-null. Equinox regions could hide bundle ID 0 from you.
Same here, as dropTable: return new MetaDataMutationResult(MutationCode.TABLE_ALREADY_EXISTS, 0, null);
same here, missing return statement
What do you think of doing this instead?  java if(this.endUser.hasProperties() || this.endUser.getExternalId() || this.endUser.getPhoneNumber()) { sendUpdateEndUserRequest(); }  There's no validation in between so the presence should be enough
This assumes that the json helper parses the values as strings. Let's play it safe and use toString() instead of a cast?
possible NPE, since [replace](<LINK_0>,%20com.fasterxml.jackson.databind.JsonNode)) can return null
Never ever put conditional blocks into filterBy methods. Handle all these in the actual Request implementation instead. Not sure if these are actually needed. This way we cannot filter reference sets where the mapTargetComponentType is UNSPECIFIED. Null values are the only values that do NOT generate actual clauses in search requests. Please refactor.
Consider using the methods with a default value parameter from Helpers to avoid repeating the if-contains-key-else-return-default code.
Why moved here if you're not injecting?
I think the "force" variable should be passed to the vdsServer method as it is, instead of converting to string.
Should this return type be changed to avoid the list cast?
Can you use the directlyOn() version that returns an object instead, slightly better performance but also type safe?
Eclipse PDE put an error marker here because the plug-in is configured to use JRE 1.7. Changing to 1.8 makes the marker go away.
do you just want to getfirst here?
This should follow the normal exception handling path and let the caller handle the printing of the exception.
We should only create the inner filter once and re-use the same one. Accept is called for every file, so this will cause an unnecessary slowdown just to recreate the instance over and over. Please remove getXpathFilter and move all code to finishLocalSetup and assign it to a field.
timeo should be managed...
For consistency, let's try to move everything to Strings.isNullOrEmpty, which may also be faster, since it does not use .equals.
Replace (inline) previewTabViewModel by viewModel ?
space before ?
should this refer to a constant defined in Family?
Missing checkCallable(). We also should have a variant that takes Collection too.
Formatting issues. Please use appropriate spaces between string literals.
It would be clearer if "5" was replaced with EpdqStatusMapper.EPDQ_AUTHORISED
This can go away now...
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
I'm confused about what is being put in this Table. Whatever object this is needs to be Serializable right? Does this work properly?
Maybe the boss level should be the 2nd level so Maiko can test it more easily. < review
our old code didn't throw I think, rather returned null
Argument name
I don't believe we use this now, but to be future proof, should we do the same thing and clear caches for which the ancestor is the memory context?
remove, and see below
Debug statement?
maybe we should do some validation here, for example throw an exception if we are missing both imageId and imageUrl
This should be Optional.of()
What happens if it's null? Should we log an error or something?
There is no need to explicitly have a Runnable here or in the other uses:  txnRun( g, ()->assertTrue(g.contains(triple("S3 P3 O3"))) );  makes the tests shorter and clearer.
why eliminate count-- in the if branch
inline return statement here
Here it would be nice to use a static import, just for consistency
You need to assert something here? The ideal thing would be to test that whatever you write to the Buffer is also placed on the BINARY_QUEUE. As such, I'd place a random number of writes in the Buffer (see TestData.getScaleCount() for a random value)
Please add a java Objects.requireNonNull(computation, "computation is null");
Can the payload value be null? In that case, we'll get an NPE when executing toString
Use Map.of()
The tricky business here is that repositories are also CommandDispatchers and EventDispatchers. Let's make it impossible to use [add | remove | has ]...Dispatcher(...) and  API with the ...Repository-typed arguments.
can the exception type be made more specific?
redundant semicolon
suggestion this.connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
Since classes are objects, and methods perform something on those objects, this doesn't really make sense. Here, PantsGetAllTargets is a 'verb' implying a method, not an object. I'm not sure it is suited to be a class. Perhaps do some renaming to be more consistent with the object/method concepts, or reconsider this structure.
I'm not convinced this should be the default, and I'm not sure how we should be configuring it.
use new DefaultShell("Confirm Runtime Delete")
Nit: What is the benefit of having an explicit variable instead of just inlining the value in line 27 below?
might be more obvious while reading the code if it was: suggestion return executeLedgerOnlyStrategy();
The only place that uses this function is org.ovirt.engine.ui.webadmin.plugin.jsni.JsFunctionResultHelper.invokeAndGetResultAsBoolean(JsFunction, JsArray<?>, ErrorHandler, boolean) By tracking back the call stack to updateActionButtonCommand, it seems that if null is returned from getResultAsBoolean, you should return true and not false.
replace with this(true, true, true);
debug artefact?
some finals here and there.
The InjectionHelper may be a bit too heavy for this. You can just grab the config (only injected field) from the root context instead.
Why not implementing hashCode at abstract level since there is nothing specific here.
As you need to use the check in every case, why not using one assignment all the time instead of assign it twice sometimes: java String resourceName; if (name.startsWith("/")) { resourceName = name.substring(1); } else { resourceName = name; }
this isnt needed as the delegated method you have added messageChanged() to already, same for a number of methods.
METADATA_VIEW_ICON?
Why do we have this empty method? Don't you think user should be informed about the error, in some way?
nit: space missing
Visibility missing. Synchronized comes before static
getUrl method looks nicer if parameter consist only from one variable e.g. getUrl(URLsContent.filePage + fileName);
Can we merge initialize() step into the constructor itself ?
I think we should return here?
Should be true if not an exec. inter. and super.remove() was successful
I'm confused why this isn't (here and below):  getColumn(destColumn, destRow).replaceInt(value, destRow % TupleBatch.BATCH_SIZE);
Can we make 1 SmbConnection that takes a ProcessConnection?
This should say "OffsetDateTime".
no idea... this is not the common pattern in Papyrus
This changes the default behaviour and would lead to different results when a consumer updates mp3agic. We could do that in the future but should keep the decision to prefer id3v2 over id3v1 consistent in the whole library. This should go to another pull request and signed off by @mpatric before.
There is actually a TestParser or so in the project, which is meant to have the best possible configuration for tests.
I tried this on Mac OS X 10.6.8 with Language set to English but German date format. It seems the German date format set in Mac System Preferences isn't respected in Eclipse, I always get short EN_us date format in the History View when this change is used.
I would cast only once to ClassSymbol.
config is already initialized in BaseTestCase.java.
we are just logging here right. why not log this in else part and remove the return.
You probably meant private Closeables() right? There is no need to instantiate this class. TBH, I think we could even get rid of this constructor, the class has default access after all...
Instead of using Whitebox, can you make a test constructor which accepts a planner? Reflection makes it harder to find usages and do refactoring.
Could we please change this a bit? Stopping the timer is not nearly as important as actually closing the resource, and if stopping the timer throws any kind of exception it will not stop the resource. Could we do something more like.  try { super.close(); } finally { getMeasured().close(); }  This should guarantee that we close the resource always, and if an exception is thrown in both cases the resource exception takes precedent and in newer versions of java the other exception will show up as a Suppressed exception.
Minor typo in error message; should be "occurred" instead of "ocurred"
exchangePoint
This should not be removed, but rather displayed as redacted:  .add("password", "[credentials redacted]")
This whole message construction can be simplified since we have only one stage here always now, now reason to even have names variable, also now we always EXECUTING STAGE and never STAGES
This can be static.
Should this defensively copy, or instead just offer an add and remove interface?
move this assignment and check as first in the method to not change behaviour.
Why are you changing this? If the object is null, then of course there would be no fields to validate so i would expect no filed errors
do it
No need for parentheses
Why not just always call the update and have the update either apply the change if it is different or ignore it
rename 'selectionChangedListener'
If status is OK then omBucketCreateResponse must be non-null right?
But we have already clicked the button in the command before, haven't it?
you must draw shadow after last item too
Please extract a result variable.
Please add an assertion message to the asserEquals() call.
Redundant modifier. See Travis report And seems for me the whole class can be private.
I would prefer to create the DefaultAsProvider without using reflection
Same issues as the Region class.
Better set timeout ?
Can we make this static?
Please add TODO lines for incomplete methods.
Can you change the new asserts to org.testng.AssertJUnit.\* instead. Thanks.
S3 in message
can you make this a constant somewhere
I know it's awful and imperative and all, but does this look easier?  ImmutableList.Builder images = ImmutableList.builder(); for (StandardDrive drive : api.listStandardDriveInfo()) { if (drive.getMedia() == MediaType.DISK) { images.add(standardDriveToWellKnownImage.apply(drive)); } } return images.build();  ? In any case, use an ImmutableList?
I would rename the method to a more descriptive name here and wrap it into the skipRole condition. E.g. java if (! isSkipRole()) { addGroupSidsFromMsPac(token); }
Use macAddr.or("") and type.or("") (or another default), to have a better string representation?
Return on the next line.
Plase add {} to improve readability.
These look like they are for debugging. could we make them debug logs instead?
Wrong indent, and the previous line should be wrapped
Better use the same logic as on line 81: StringUtils.isNotBlank(prvdr)? prvdr : UNKNOWN_PROVIDER;
Use SystemReader.
Maybe "generateReadLink", and name the generated method "readLink", just to be consistent with the "readOne" and "readMany" methods.
is Set.union(scalarVariables, arrayVariables) = freeVariables ? If that is expected then I think we should add a check for that to be true to catch any potential bugs.
Cleaner if you do dataStores.stream().filter(ds -> ds != callingDataStore).forEach(ds -> ds.updateSessionAttributes(id, sessionAttribute)
@NisalaNiroshana , Provide more context to above debug log. Include username as well to the debug log.
You could return and test something here
I think this can be set by spring application.properties without creating bean explicitly.
Why we have extra log in here? Can it combine into 1
Ok, let's move this back to the methods, because we don't have any benefits of extracting here. Sorry :)
maybe I am missing something, but won't this fail if we're removing an internal snapshot?
this is 3.3 feature, not 3.2
synchronized is unnecessary because Context is (must be) instanciated for each thread. The purpose of Context class is making invokeTemplate single-threaded.
this sentence ("In case of large.... ) is too long and not clear. Please reformulate it using 2 sentences.
Optional<Region> instead of null please
Calling a protected method in the constructor of the base class is not a good idea ;)
It's beeter to used int type.
Might as well make it  java for (ISessionEventListener target : v) { ... }
![MINOR](<LINK_2> 'Severity: MINOR') Catch a list of specific exception subtypes instead. [![rule](<LINK_1>](<LINK_0>
Looks like these 2 lines can be before try-catch block, wdyt?
must be protected against concurrent accesses
same question as above
remove the unused 'e's
(args[0], args)?
Need to implement
Same here, just remove by dn without fetching entity.
Remove rounding... 3rd strike ;)
The correct way to get the type from an object is to use EntityDictionary.getType. Look at how it works with DynamicType.
Would nice to have a sanity check that the cohort doesn't contain an active membership for the patient before
It won't be safe to use null/not-null here to signify anything. After the first threadlocal is initialized by a timeout, it will be non-null forever thereafter.
try with resources
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Return FORBIDDEN too. No need to play nice if the user doesn't have rights to call this.
groups cannot be null.
Why jschSession.sendKeepAliveMsg() doesn't work for us?
Why not using the @Inject annotation?
I feel like logPutCountsPeriodically() depends on put method. That is, if put method, for some reason, is not invoked then logPutCountsPeriodically() won't be called. I am thinking if a background thread to periodically log put counts would be an option. What do you think?
Please, use text "Project name" (Name was fixed after sending this pool request) thank you.
Missing Final
This looks backwards. This would attempt to create BasicAWSCredentials when neither awsSecretKey nor awsAccessKey is provided.
Not part of this commit but could change "updateVideoButton" message to be consistent with method name "clickCloseButton" :)
Unsafe cast. I would recommend to check the class and to default the field to something if it is not <code> StaplerRequest</code>
The null check should be unnecessary.
This should be ROLE_ANONYMOUS. However given the defaults in AnonymousSpec you should just delete it
why this intermediate step, couldn't we transform into a BiConsumer which accepts an entity and a StringBuilder or even BiConsumer<PrefixSearchableEntity, Consumer<String>> and then invoke with (entity, this::addContentString) or the like
Why do we need to open project in setUp()? It's better to do it in the appropriate tests to avoid skipping of all tests execution in case of error, and to prevent duplication of code. Or expand full project tree at once.
Can we create a constuctor for ComponentParameter?
did you intend to leave the printStackTrace() here?
I think that this one is used only here. Can you consider changing it to private?
Please add @Nullable for the param.
I don't think the loadClientsInternal method should exist. Use getClients.
Can you put some dummy object into the expectedResult? Otherwise, this is just a check for any empty list.
What should happen if the network is not connected to any host? Two notifications?
The isMaskValid parameter is irrelevant here. This test only checks that the input is in valid prefix format.
You could have this method (optionally) take an Exception and add a button to show the Exception's toString.
extra lines
add sanity check?
I think the call to getLocalTableBlogIdForRemoteBlogId(remoteBlogId) should be changed here, since getLocalTableBlogIdForRemoteBlogId doesn't ensure the dotcomFlag=1. Maybe it's a really edge case, but on self hosted network installations of WP, the blog_id field could be a high value number, that matches the values we see on wpcom. We should add a new method getLocalTableBlogIdForWpComRemoteBlogId thar does something like int localBlogID = SqlUtils.intForQuery(db, "SELECT id FROM accounts WHERE blogId=? AND dotcomFlag=1", new String[]{Integer.toString(remoteBlogId)});
TLDR; I would return null here. I can see a two ways we're handling "issue with the file" .... here, we're returning empty string in case the filename does NOT end with .jar or .kjar. If it does end with the suffixes, but the file is corrupt or error during reading happens, we return null from loadFileTextFromJar method. Empty string should be IMO returned only when the file exists, is a jar/kjar has a corresponding zipentry and the entry is an empty file.
Lets rename this to removePipelineMetrics
nit. make this string literal a top-level constant
The else is not necessary (the if returns).
You don't need to do a == true check, a simple check works if (getContentValuesPopulator().populate(contentValues, data)) { .... }
Please add check for exception cause type and message, we must be sure that it's really expected exception.
Rename -> CosmosDbFactory to CosmosFactory
Can be on one line and doesn't need to throw IOException.
Per above, can you change this to "if (containedDataDefinitions == null) { containedDataDefinitions = new HashMap... }; return containedDataDefinitions;
@PawasChhokra Looks like this metric counts the number of times a processor has become the leader. The metric name "leader-election" can be easily misinterpreted as the number of times the processor participated in leader election. Can you please rename this metric?
nit. unnecessary 'final'
.equals() instead of ==
should this be modified as well ?
Nit: it would be more clear if udp and udp1 had more descriptive names.
not sure why we need activate... after you load all resources you can "activate" your-self.
It would be more efficient to assign the result of get() to a local variable. i.e. One less node lookup. suggestion Statement statement = statementMap.get(sql); return statement != null && !statement.getConnection().isClosed();
I think we should avoid a dependency to the given uberfire module due to the Pair class. I think we should use standard java map entry. For example on this line we can use  Map.Entry<String, String> attrs = new AbstractMap.SimpleEntry<>("", "");  What do you think?
Just call getCodec().decodeLong() in both cases here.
Given that the constant string level:// appears so often in this PR, it ought to be a string constant somewhere.
This change is unnecessary I think, but OK.
I would recommend a suitable localized message here in the precondition.
How about inlining the concrete logic into visitColumnCheckConstraint and visitTableCheckConstraint instead of having a nullable columnName and make a distinction again in visitCheckConstraint. Seems like a unnecessary generalization.
I don't see any advantage of using requireNonNull()
You don't need to rely on a list, you have a findElementById. You could even use findElementWithoutWaiting(By) there with a By.id since the button is supposed to be displayed.
Checks -> Check
nit: If we wrap one, then we wrap all.
So if there is a network or other valid error, this method will return 0? Seems strange.
isn't it missing "ACTIVE"?
I think "valid times" should be changed to "setup time" or even just "setup"
should we log what the result code here so we know what other junk we're getting in response?
It would be cleaner to replace this line with: fKind = kind; fSuffix = getSuffix(kind, value, CharArrayUtils.EMPTY); fLiteral = getLiteral(value, fSuffix); There is no need to call resetLazyFields in constructor.
on and off equalling true and false are only applicable to HTML forms, so this should not be generalized here.
Use Preconditions.* for consistency with null-checks unless a caller above expects a SamzaException to be treated differently.
Please add a static import for this method.
This attribute is not required, so it probably needs a default or something like that
You must update this to GDB_7_12_VERSION
copy paste bug: must be childWorkflows != null
It would be great if this map could use generics so we know what it contains.
Need to update this to use safe URI generation.
Maybe add a log statement here so it's easier to trace if things to not do what we expect.
Again this is displayed to the user "Android recycle" would be better.
iiuc "propietary" is a string and enum that you have added is PmProxyType, so you should be adding it to <pm_proxy> and validating it here.
I'd like to see some tests using a different timezone.
Seems me a  listeners.forEach(listener -> layerDeleted(layerName));  would have been at the same time more compact, readable, and faster (streams are very slow)
Check for equality of error code
You can remove NoSuchAlgorithmException now.
As already mentioned, this should be checkNotNull(statistic, "statistic"), this will throw a NullPointerException, therefore you will know it can't be null.
This is unnecessary
Not sure if we should create thread, DotConcurrentFactory is your friend
Not a must fix, I just want to suggest you try lamda. It would be very convenient and simple here.
I suppose we do not need this now after using serializer
Should be SELECT v.entry or v.entry.id?
since this happens in every test as the first thing, this probably should be in setUp(). at least the SharedPreferences call should be moved there. and i rather have the code duplication of having the two espresso clicks in each test, than this. before looking up what the method really does i suspected anything, but two clicks on "next" in it when reading the tests above.
why can't we do this by dc level? i don't think that we should have different behaviour between the host in the same pool - much harder to debug it later IMO please add a log so that we will be able to know what was called without checking the vdsm log atleast.
throws Throwable?
why was this added?
do we still want this? or do we want to start all over again? this means 1 large column chunk will trigger always having more mem overhead right? even if it's only 1 out of many small ones.
do we still need the if null check?
Should we check sessionReady to prevent multiple invocations of the delegate's methods (especially double delivery of init events)? I know the driver won't do this, but application code might.
I think one case is missing here, when esIndexReplicas=autowire
BTW, I agree with @coverbeck on this, parallelStream is probably more complex than needed here. So which to a normal stream when templating this with the V2 version, thanks!
Maybe, a better solution wrt to visibility would be to move the LanguageMetricsProvider out of ApexHandler, and into this package. ApexMetrics will probably not change for 7.0 (apart from this method), while LanguageMetricsProvider is still experimental and we can remove the new API freely in 7.0
Not sure we need nor want his condition : !(context instanceof AnalyzerMessageReporter), as soon as we introduce the concept. Pretty sure it's code you can't cover as well in your tests. As far as I see it, It's a hidden feature from the analyzer. So we should just feel comfortable casting the context directly to AnalyzerMessageReporter. (and we definitely want everything to explode if we change that behavior further on)
As above, the item with an id equal to the total number of records might not be the last record if some objects were deleted from the database. It'd be nice to actually capture both of these failing cases in your tests, and solve them in your implementations of first and last. If you need help writing those test cases, let me know and I'll throw in a commit!
Yea agreed should go in start.
isEmpty() please
rename to namespace
Data Constants.
Also, shouldn't this sceneOpaque connected to the WriteOnlyGBuffer?
I would add Assert.fail()
maybe use switch()
why not use the MessageLevel type?
Hi Sharad, I saw you already changed the code a bit regarding getDiskImageDao - care to refactor and replace DbFacade.getInstance().getDiskImageDao() with a "getDiskImageDao()" call?
It makes sense to use assertEquals here and below, to see the actual value in the failing case
I think it's possible for a user to type <span id="img_container">, which would be removed by this regex. How about we make it a little more precise with <progress.*?><\/progress>|<span id="img_container.*? class="img_container" contenteditable="false">?
Maybe use a ternary expression? Up to you
A modal dialog is unacceptable during perfrom stage of refactoring.
It should return ReadOnlyArray not ReadOnlyArrayInterface. Also IIRC, ReadOnlyArrayInterface is internal for Java.
@prondzyn this will return an int which is enough as bytes.length is an int such that you can avoid casting it as a long
Java if (lookupBoundClass(entityClass) == null) { bindEntity(entityClass); }  Might be simpler or more straight forward?
Consider removing magic numbers and using just source to get the the right div you want.
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
cut at &&
Why pass in parameter? It's already a field in the class..
See if you could write this more concisely, perhaps,  return StringHelper.isWhiteSpace(visibilityString) ? "GIVER" : "GIVER, " + visibilityString;
Do we need the entered check here and the boolean variant below?
Wrong formatting in whole method. Please fix it.
When one runnable raises a runtime exception nothing will be executed afterwards. Is this intended ?
Why not reuse existing constructors? public PermissionsOperationsParameters(Permission permission, Guid targetId) { this(permission); this.targetId = targetId; }
Why not just List<String>? This construction forces code that would like to use this method to explicit use ArrayList which is often considered as a code smell.
Just Downloadable
@ivandalbosco Minor: another possibility would have been to move these tests up to visitSuper.
Do base class really need to know about SSL? I suggest making 2 protected methods: clusterCustomProperties and connectionString that can be overridden and implemented in SSL test.
Make sure to use {this} in place of the name
Could be replaced with  headers.forEach(comparisonMetricFile::addHeader);
seems like the log file name should be pulled out as a constant, or alternatively, a member variable so you could override it if you wanted.
a matter of taste - types can be avoided for the sake of return statements from the if-else block.
Use Long.valueOf(1)
please add newly updatable fields expectation & verification
Is that variable used?
We could avoid creating the two Date objects by returning false immediately if !shouldPublishImmediatelyOptionBeAvailable(postModel)
Revert to WARN.
Do we ever use the returned value? Even the put in the cluster registry should use IGNORE_RETURN_VALUES.
1. create method clearCSS() with ace.edit('cssEditorContainer').setValue('') 2. add .ace_text-input element to UI mapping - this is cursor, 3. in sendCssText use sendKeys method to type using cursor.
line length + the ones below
Here too - once you change the API to use ints, you won't need all the Integer mess here.
We can remove else block replacing in just with return. (No added advantage with it for runtime, just for clean code)
ps this is a logic change. It saves size to not log 2xx range responses. <LINK_0>
Should use assertThat
typo above, should be: return this.rpmRevision;
Nullcheck missing.
This one shouldn't be public.
Not sure why you need Builder for two args. I'd have a factory method.
Plays the current, not the previous.
Nice PR. Maybe SystemUtils.JAVA_SPECIFICATION_VERSION + ": instead. Do you like static imports?
@antonini it's a one-time variable: <LINK_2>
Why do you need this? Are you planning to add the column to SubTabNetworkHostView?
avaialable -> available. ( Its might be my mistake, same typo may be there in Original class as well :-) )
IDE says that exception is never thrown by ClasspathContentRetriever constructor, so we should remove the throws clause there and remove try-catch block here.
Could be simplified to assertNull.
if you use lamda expressions then diamond operators should also be available)
All these are the same. It's fine if they have the same message.
What is the contract for the return of this method? If we are already at the state that we are trying to move to, it could be said that the moveToState is successful (i.e. true).
huh?
May we simplify that a bit? It should be possible to fit it in a single 1-line operator.
This is not needed - you can use getCluster() from base class?
Since init() is only called once, could we move it to start() so that start() and stop() become symmetrical?
LOG.trace
Add this to the string resource file
groupIdExisting -> existingGroupId?
Even though it was like this before, do we have reasons to keep it as iterator instead of using for-loop?
How about  java Iterable<TYPE> resultIterable = first(1); return resultIterable.hasNext() ? Optional.of(resultIterable.next()) : Optional.empty();  We don't need to copy it into list.
pls use querydsl instead (already in master)
- [x] I think, these three cases are no difference in the appearance of the result screen. So, it should take page source for evidence. --- OK by btkatoutmj
How do you tell that the cause of this exception is the request being invalid?
Remove word "URI"
Let's keep this?
Let's not printStackTrace in production code
intellij is continuously recommending to simplify this code this way, but i think it is very hard to understand this way
Is this debug? Otherwise, probably best to give more descriptive errors.
nit: static import anyLong() for consistency?
Can just use Map.of( ) here
The same: can it be package-private?
This should be done in a @Before method using githubBeforeAfter connection. <LINK_0>
why does the session being unavailable mean that it's a demo user? Shouldn't we not be here at all if a SessionUnavailableException is thrown?
Is this really needed with the global suppression on class-level?
SQL.sanitizeCondition also?
you should implement this
Might wanna use the API version constant her for v28.0, so we don't have to keep switching this up.
the payload may not be json
Needs to read the script name and parameters from the session.
better to use enum comparison if availabe rather than string comparison... Also im not sure this business logic should be placed here, it seems a bit obscure
Can you move this check of whether or not we enable doAs above to selectively call withRemoteUserExtractor, please?
Why are these methods here instead of in backdoor? (just like verifyPresentInDatastore for example)
Shouldn't we set the cachedProfile here before we return.
You'll keep in mind you should remove the "DslConverter" parameter from here?
Hmm... getActiveInstance() is deprecated in modern versions of Jenkins (as is getInstance()) - Jenkins.get() is favored these days (ever since Jenkins version 2.98). Rather than update this code with an already-outdated call, it may be a better idea to bump the minimum version of Jenkins required to 2.98 (we already require Java 8, so we can't _actually_ use Jenkins 1.642.3 anymore) and then call Jenkins.get() everywhere instead. @olivergondza WDYT?
// Do nothing.
Default access is probably good enough and is consistent with PartialDefaultRecord.
This one can be static.
this could be made final
casting to a byte isn't going to work
Adding this to a field is good manner.
do we need mutable List here? If not, can we use Collections.emptyList() ?
Should probably surround with a try catch and throw an ObjectMappingException with the provided exception.
there is no point in case sensitive check for an empty string. Also, just use StringUtils.isEmpty(connection.getId())
could java streams make it more readable/smaller ?
Could you correct the formatting?
Why make PartyContact depend on PhoneUtil? It's a very strange dependency. The PartyContact class should not have to know anything about PhoneUtil.
Why not simply call?  return build(Stage.PRODUCTION);
Well, no, we cannot have a System.out here. A log should replace it instead.
maybe extract this if sentence to a conditional method so that the code would be easier to read e.g. private boolean roleHerarchyNotSetForValidContext(){ ! roleHierarchySet && context != null }
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE);
there is another class named IndexingServiceFirehoseModule, wondering if we can just delete that class and use FireshoseModule in indexing service also.
This is not consistent with how we do the comparison in the DateTimeValue code. There, we are comparing the underlying Java values, i.e. using the compareTo method of Java's ChronoZonedDateTime.java which after the instant looks at the local time before comparing zoneIDs (the chronology you don't have to care about because that is always the same in our case). Also I wonder if you have thought through the case when one of the values has a zoneId >= 0 and the other has not? In general I think we need more test coverage for such cases, we don't cover it in our comparability PR either...
@dmmiller612, I've removed this conversion and the tests are still passing, not sure what is it for ... If this version is ok for you, I can merge
not sure all these metrics are useful. How do you envision their usage?
@vilchik-elena Charset.defaultCharset()
this call should be on the level above (in the doPush methods), otherwise in case of requested==rows.size() the end() won't be invoked.
Let's keep this method unchanged since it is better we modify the interface Catalog. Instead let's add null checks when this method is being used.
When catching InterrptedException, always reset the state via:  java Thread.currentThread().interrupt();
literalEncoder.toExpression() already returns the Expression if the value is an instanceof Expression, and a NullLiteral if it equals null. I would get rid of the if statements and always return literalEncoder.toExpression(value,BOOLEAN). And add a visitNullLiteral to FilterExpressionStatsCalculatingVisitor.
same again. please throw original exception.
Perhaps invert this if so it becomes a guard clause when location != MENU_LOCATION.TOOLS
Return the result of sha256 instead of using the local variable.
this mapping should happen via public enum and not via mapping backend enum to string
Thanks for the fix @quxiucheng, i think this patch can be promoted a little, we can move this logic to the parent class SqlDialect, you can get the SqlConformance from the dialect and decide if we should generates the ROW keyword based on method SqlConformance#allowExplicitRowValueConstructor . [1] <LINK_0>
this is very sketchy. Hash codes aren't unique
Add "this" qualifier
I would just log the warn.. no need for special logger.
dito - looks like you used search/replaceAll ;)
Should be able to just do: ApplicationInfo info = pm.getApplicationInfo(packageName, 0); return pm.getApplicationLabel(info);
this is my major concern. It is true that we are not changing the very high level API, as ClientCnxn is an internal class and applications should not use it directly. But it is probable that frameworks like Curator (ping @Randgalt ) do tricks over this stuff. This change is a big refactor and touches the very internals of the client so we should handle it with care. Don't get my wrong, I think this work is awesome and I hope we can make it land it to master someday. That's only my opinion, let's see if any other reviewer wants to sponsor this change
startCapture() calls System.setOut() and System.setErr() so our tests should at least reset those after each test run. Can you try using org.apache.maven.surefire.booter.ProviderFactory.invoke() instead of calling our invoke() implementation directly?
should be a new line after the closing curly brace ;)
This is where you should be checking if there is just one specified license, not in the getLicenseName() method below. The validation should always occur on set, not on get (because that's already too late).
suggestion assertKeyPair(file, null);
Why make this protected? You can override it even if it is public.
The @Override should be on this line.
In this case isShortwill have a default value of false - I assume that is OK? Also a common pattern for multiple constructors is to call the the "full" one passing in defaults for the missing values:  PostMessageField(String title, String value) { self(title, value, false) }
Is this method called when partition is removed from assignment? If not, may need changes in partitionRevoked method too?
Such general initialization should go along with the field declaration, otherwise it gets lost when adding another constructor.
I suggest you use org.apache.commons.lang.StringEscapeUtils.escapeCSV() here.
rename to contribution
Just pass thiz with type Object instead of thiz.toString() here, the JBoss logger should call toString() automatically, and if for some reason thiz is null, it will not throw an NPE like this code.
I would do a reverse().removeFirst(predicate) instead of findFirst in order to not process elements 2 times, e.g.  java final Stream<T> removed = reverse().removeFirst(predicate); return removed.length() == length() ? this : removed.reverse();
Maybe String.format( "Server[%s]", serverName )?
There is a logger-like syntax for this that is more efficient during valid state: Preconditions.checkState(false, "Cannot cast from %s to %s", castFrom, castTo); That said, if it's always invalid state why not just throw an IllegalStateException directly?
The MaterialConfig interface has a getFolder() method. Why is this needed? The condition check, I mean.
Do we really need this init() method? The _LoaderHelper_ class itself is in the hibernate-search-orm module, which depends on both JPA and Hibernate ORM, so it's module should be configured to be able to load the ObjectNotFoundException/EntityNotFoundException. I think this should work fine using  ClassLoaderHelper.classForName( "org.hibernate.ObjectNotFoundException", LoaderHelper.class )  hence not needing the init nor the volatiles.
Interrupts should be re-raised.
Not sure if this method should return anything as in fact in the Mvc endpoint the return value is used for logging purpose only
Maybe you can add the type of alien to the logfile.
Can you stick with the existing coding style and omit the Assert. prefix here.
Perhaps just chain here? return getAlerts(Collections.singleton(tenantId), criteria, pager);
can be replaced with ConfigValue / local constant
I think you'd like to print the content of 'input' here and pass the 'e' (exception) as a second argument of the RuntimeExeption c'tor call.
Consider iterating over systemProperties.entrySet() instead. This will eliminate the need for key lookups in each iteration.
Should 25 be configurable by the user?
This is not the correct way to test the proxy that is set. We need to make sure that the worker is getting the proxy that we expect it to use.
Is there any risk this will grow to a size it becomes a problem? If not, using a guava cache is overkill, if there is a risk then yes, we would need to
I think setting cancelable to false can result in an infinite dialog since the OnPlansFetched event may get lost during a configuration change. I think this isn't handled in many places in the app, but I just wanted to mention it. We may want to consider either allowing the user to cancel the dialog or setting @Subscribe(sticky=true,..) and handle it appropriately. Wdyt?
Does it need to be final?
And what about pseudo scopes? E.g. javax.inject.Singleton.
It seems like these two deadline-related methods could be static.
I believe we already instrument the TimelockService below (line 497), so not sure how the metrics will handle two TimelockService interfaces. @schlosna is this ok?
we should have a wrapper for the annoying Backend.getInstance().runInternalCommand thing of a jig
Before synchronized
Maybe move the parsing / construction into another class? Maybe even an inner class? I think the benefit would be keeping the SearchEngine class short, so it's easy to see what fields / method are available within the UI.
Fix up these as well so you don't specify PollResponse.
nit: s/android/Android/
Breaks encapsulation. Consider return Collections.unmodifiableSet(myAppliesToProfiles). Same goes for other collection accessors.
scim-schema? I think ist must be osiam now.
this should probably be a try with resources
This is wrong create a template interface <LINK_0> Line 129 And use the sb.append() function.
Does this need to be writable?
Revert this.
Exception is super generic and is usually an anti-pattern. Any reason for this change?
nit: this is not necessary, false is the default.
Please add backticks for the code related parts of the message and the period at the end of the sentence.
Maybe I'm being dumb - but wouldn't it be better to continue at this point rather than abort - abort means you want to be retried again next duty cycle in the expectation of success - eg a message send failed due to back pressure.
You can avoid this null check through initialization in the field declaration. Besides that LGTM.
This casting is not necessary, d.longValue() could be used instead.
This reveals the same problem as StandaloneLeaderElectionService does.
needs 3 _arguments_, plural
Need to do a stricter check then that. What if there is a layer or store named "script" for some reason? Then doing a GET for that layer may use this converter.
The code in this and above method does the same thing, just on different link element. Have you considered extracting it so you can just call: getLinkRedirectTitle(externalLinks.get(index)) getLinkRedirectTitle(internalLinks.get(index))
Redundant generic. At least my IDEA requests to remove it.
How about replacing this with _ like we do with version? It might be surprising to use a different replacement character I think. We also still might want to replace a few other things, like any whitespace that might creep into error codes. AFAIK there isn't a well-defined set of valid characters in error codes, so I did like that you were being relatively cautious before.
What do you think about using String.format?
braces please
I think you should create a new List<Throwable> and pass it to the validator. With what you have here, a validator could remove errors. Alternatively, the validation methods could return a List<Throwable>. I personally prefer this option, especially if AnnotationValidator is changed to be a concrete class (the base class implementation could return empty lists)
So this will be logged every time imageIncoming() is called? Since that's the condition to break out of the do/while loop. If that's the case, then we probably shouldn't be logging at all.
make all uncapitalized. that is LIST => list, DUMP => dump, etc..
use StringPool.EMPTY instead
I think it would be too spammy here, but I think it would be a good idea to log that throttling is enabled when building a session
I'm not sure- why do you need this method?
not empty?
Missing braces.
Inline the rel(sql).
why not a ConfigKey<Integer>?
Do we return doubles for both integers and double params?
Code style: Always use curly brackets, and space after if.
This needs to be changed to TestUtills.runRepairability("JKali", "/repairability_test_files/JKali/"); The first argument is the name of the tool.
Nit: Could double evaluate if a callback throws while executing -- maybe wrap in a try catch and/or remove the callback before executing?
Hope this won't introduce flaky test.
I would've been OK with a 0 here, it's the == that matters -- but no problem
Why this change?
Better not to use long dash lines in logs including test cases.
Create a new method like PDataType.fromSqlElementTypeName(typeName), since you know you're creating an ARRAY. In that method, first look up the primitive type using the typeName. Then from the primitive type name, get the typeId. Then just add this typeID to the sqlTypeID of an ARRAY (which is 1000). Then you can use this to lookup the PDataType for that type of array using PDataType.fromSqlType (which we may want to rename to PDataType.fromTypeId()).
Change to: return mode; ?
Why 800? what's the unit? A self-decriptive constant would probably be more appropriate
often -> times
Use ImmutableSet.Builder instead - no need for the intermediate hashset
Removing this line breaks the plugin interface.
You can use Function here. and this function can be static value
Add stop to CatalogReplicaShiipper?
this may not be 100% accurate for a local deployment where multiple processes share the same host name but different ports.
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "evt". [![rule](<LINK_2>](<LINK_0>
I would just return the boolean expression here. Also, do you want to use StringUtills.isNotEmpty? Similar thoughts for the other "exists" functions below
In that case getDateTime(JsonObject object, String memberName) should use this method. Also you should check that formatter != null.
I think adding a field that can be specified at construction time that gives this a name would be useful. Usually the people creating the input streams will have some named source, it's just not easy to convert it to a Path, but the name is still useful for error messages.
For all these assertions: the other way around? TestNG is assertEquals(actual, expected)?
it seems to me you don't need map here
Is there no InsertAll or Merge in Java?
Let's fix SqlViewExporterSpi instead of excluding it (looks like a bug in its implementation)
Collections.singletonMap
Better to add nonNull precondition guard for leaseBlobManager here.
Likewise..
What is this stupid iteration? Why don't you use map.values() ?|?|?|?
Change to state == ReplicaState.STANDBY
This loses any existing bounds and annotations. I think you'll want to combine just like annotated does.
I reckon extracting this 3 lines to a private method would save some space in the test.
What's this for? Shouldn't new CategoryPage().open(categoryName) make sure that the page is ready to be tested? Also, we query the DOM before waiting, what happens during these 1500 ms?
Again, the static import makes this harder to read.
use Objects.hashCode() ?
this method can be replaced by FeatureSupported.hotPlug(Version) which performs exactly the same.
not NPE safe (order has changed) should be value.equals(buttonValue) with precondition check, or StringUtils.equals(value, btnVal) if commons-lang3 available in classpath
You don't need to change it for this PR, but for the future, baos is typically used as a name for a ByteArrayOutputStream, not a byte[]
Perhaps keep this as before for easier debugging, ie have it match the method name?
Not quite, to go the NPE route, you should use a liner with Objects.requireNonNull().
hard-coded wait can cause tests to be slow. Is it possible to use waitForPassCondition(() -> <Condition>) instead? (See my snippets below). In general, you would wait for page to load, then wait for condition. That could reduce test speeds down to ~200ms.
why do you call getSelectedValue() in other places, but here you have the code instead
unnecesssary change
Java return CharMatcher.inRange('A', 'Z') .or(CharMatcher.inRange('a', 'z')) .or(CharMatcher.inRange('0', '9')) .negate() .trimAndCollapseFrom(s, '-');  This will convert .Something.*.Blah_$$$_whatever_ to Something-Blah-whatever
It is better to use the logger here.
Minor: since locateMemberTests has been renamed to locateTestsArtifact, maybe downloadMemberTests should be renamed, too?
I am trying to get rid of these checks where they don't save a large amount of work. No need to check whether logging is enabled here, there's no work inside the function.
I think the ThreadLocal itself should never be set to null (and I would instantiate it eagerly in the constructor), only its thread-specific value should be. Otherwise a thread could see a null reference when another thread has executed a batch.
logger.error("some message", event.getException()); instead
This can be read easier by others by splitting the check using "guards style": <LINK_0> if (getMapGenerator.requiresInternetConnection()) { return false; } if (Settings.getMapFile() == null) { return false; } return true; And if you now want to ask: But isn't my original code much more compact and optimized? No, it is not. The compiler will create basically the same binary code for both versions. Besides that, even if there are differences in the binary, they don't matter. Code should always be optimized for readability and understandability, as that is the most severe problem in software development.
prices.length == 0 || prices.length == 1 <==> prices.length < 2
It seems it will break Alphanumeric sorting, e.g natural comparator sorts these in wrong order "NUM10071", "NUM9999"
update.getUpdatedObject().getValuesForAttribute(AttributeType.MNT_BY); is a bit cleaner?
@kdkeck looks like a copy/paste error here
What about making the method implementation be: return cmd.getRefName().startsWith(NEW_DRAFT_CHANGE); ?
@adyach shouldn't this be different from the remote url?
Use Flux.from and use the abbreviated subscribe
IllegalArgumentException
Maybe we can remove this "isErrorEnabled"
I think objects.remove() is going to throw exceptions rather than return null when the pool is empty
Use constants for string values occuring more then once.
Why is groupArtifact being set twice?
can be replaced with more simple one: return COMPILATION_MESSAGE.test(text) || LINKER_MESSAGE.test(text)
Looks like there are odd parentheses in the command: organizations.removeIf((o -> nonNull(o.getParent()))); \> organizations.removeIf(o -> nonNull(o.getParent()));
Let's not make this too hard on ourselves, let's put an IF statement here and let's generate: SetWireframeTask : enable wireframe / SetWireframeTask : disable wireframe in the log. We don't want to have to get to the opengl manual just to understand what is going on. =)
Strictly speaking this is unnecessary as start can be accessed from setAsCancelled directly.
Please remove this before committing
This call throws AssertionError so this won't work. You want:  try { expectException.evaluate(); } catch (AssertionError e) { assertThat(e.getMessage(), containsString("Expected exception: " + AssumptionViolatedException.class.getName())); return; } fail("ExpectException should throw when the given statement passes");
toString() is not implemented for DropwizardReporters.
this. is not needed. Also make the targetDomainName field volatile because it's checked and modified and invalidated from different threads.
suggestion thrown.expect(containsCause(new ValidationException("Unsupported value 'test' for timestamp-format.standard. Supported values are [SQL, ISO-8601].")));
Why doesn't computeIfAbsent() work for us here?
Just a doubt, here typeList contains only 1 value ("all"), so why join is being used, we can directly provide the string value
@mavrk one test should only be for one method and one combination of parameters. and the goal is that every public method in the service layer is tested. so you should write tests for the methods * getAllDrugs() * getAllDrugs(includeRetired) and for the latter you need one test passing true and one passing false. another case is also what if there are no drugs will it return an empty list? I know this is tedious but thats because when this was written [TDD|<LINK_0>] which would start with tests wasnt used.
Can you make all the "unsafe" methods you added have package-private (default) protection instead of public.
What's the benefit of storing this as a line w/ slope instead of an angle? It seems like "robot pose" is really just a line with the notion of a heading added on... that makes me think that there is a simpler way of doing this, but I don't really understand what this logic is doing.
I believe _RegisterBuiltin.register(factory);_ should also be executed, in order to have a provider factory that behaves the expected way. WDYT? (this applies to all similar code blocks in this PR)
What would you think of the following construct? java try { return DownloadType.valueOf(type); } catch (final IllegalArgumentException e) { return MAP; }  It's not the same as the current code (case-sensitive), but it might be a bit cleaner than having a lot of if-else cases chained
Returning qListhere should be enough, unless qList is null
@t-izbassar I think it's not clear, because default matcher in Hamcrest library usually is Matchers.equalTo(), so as a user of HmRqTextBody I'd expect that body is equal to constructor parameter string
can we add here more descriptive name instead of element? Maybe templateName, templateElement or template?
change to static import ?
You can run into a problem if you use basename; imagine that multiple map reduce tests are running in parallel. Also I would suggest pulling out the results lists into the setup method, so that the getList is done there. And where the list is needed, you can just access the results list directly.
So hasSubclasses is true only in the SINGLE_TABLE case? I don't understand how this commit is related to "table per class hierarchies" and fix anything for them. Could you explain it to me?
update this if statement to use identity.isValid()
Here also, let any exceptions be thrown, and handle it at the bottom of the call stack.
Obviously the second invocation should not have been replaced, since you are still checking for null. Given the presence in the init package I suspect that getInstanceOrNull is correct in both invocations.
If we want to add same object as key and value, why are we using ConcurrentHashMap instead of Sets.newConcurrentHashSet()?
The redis server is started at host:
Please use Map<?,?>
Why the \1 byte at the end here? Should be abd, no?
nit - just use new HashMap<>();
nit: maybe nice to gate this behind if (LOGGER.isVisible(Level.FINE)) { ... } so Throwable.fillInStackTrace isn't called unnecessarily.
This method could be supported. You could do it without too much work by doing new OrDimFilter(boundDimFilters).getDimensionRangeSet(dimension)
Why double storage of the events? You seem to have removed most of the workQueue usage already.
nit: this can be IFACES_ALL
Please sort this out.
Why does this need a super()?
Maybe remove the useless super()?
I find it strange that websocket is a member of connectionAttemptState, it should be simply a member of XmppWebsocketTransportModule instead.
Same as above for product, content doesn't have a toString method, so this makes sense. I can write a toString for content if you like, or you can.
This seems a little odd. Why would I need to register an AccessDecisionManager in order for the AuthorizedEvent to be fired? It would likely be a breaking change if applications upgraded and then events stopped firing.
You can just inline key and value IMO.
Instead maybe just use try-with-resources?
shouldn't this be assigned?
It is redundant check. value.getAllValidationResults() will never return null. I think developer should check for null only those values, which is not under his control (e.g. incoming parameters of public methods, but not private methods)
Same concern as above.
I think we should set the same for XML configuration. @mustafaiman ?
If the map is empty then the stream won't do anything.
Don't do string formatting yourself.  java log.debug("constructed {} of type {}", this, this.getClass().getName());
is this update required to fix stackoverflow ? if this is not related better to move to separate commit of the same PR.
It seems to be enough with TajoException rather than Throwable.
is it no longer possible for strategy to be null?
how about to simplify it a bit with: EnumSet.of(VMStatus.Suspended, VMStatus.SavingState, VMStatus.RestoringState).contains(vm.getStatus())
It's better to check for mMixpanelInEditMode here. show should show a view and it should not be it's responsibility to check whether there is a socket open or not, etc..
This should be protected so modders can subclass it with their own small changes.
Not a necessary change but these can probably be simplified to Assert.assertFalse(mantaClient.existsAndIsAccessible(childDir). Up to you if you want to make this change.
We could shorten the test slightly if we use assertj library see the code below, would you mind to incorporate? java @Test public void testLhsOrder() { // DROOLS-3080 final SpreadsheetCompiler converter = new SpreadsheetCompiler(); String drl = converter.compile("/data/LhsOrder.xls", InputType.XLS); Assertions.assertThat(drl.split("\n")) .as("Lhs order is wrong") .containsSequence("accumulate(Person(name == \"John\", $a : age); $max:max($a))", "$p:Person(name == \"John\", age == $max)"); }
Same as before: this change seems unrelated to the topic of this PR and just expresses a personal preference. While that preference might well be better than the existing code, it should not pollute this PR.
Shall we keep clenUp() without remove?
We repeat this calculation over and over again. Why don't create a utility method? E.g. getTimezoneZeconds().
should be instance of ServoControl not Servo.. :)
We should provide a default, in case of this header is missing. I guess you could do something like:  java String charset = Objects.firstNonNull(request.getHeader("Accept-Charset"), "UTF-8"); return charset.split(",")[0];
I would suggest using by if possible, by is an instance of [ByFactory](<LINK_0>, so if you need a new selector and simply use it via Selenium in your PO the new selector can not be reused, but if you add it to ByFactory it is available on all PO, also you can add some validation or error control logic easily without polluting your PO
fileExtesionStartIndex will never be -1 even when there is not an file extension.
Put setters at end of file
While we're at it, let's remove all the redundant this. as well.
Should we just return null here rather than propagate the exception? If we are sure we want to return null then the exception should be logged if we are swallowing it.
Also, this is getting a bit too long for a single line I think. It's probably better to restructure this: if (ore) { return true; } else if (1.16) { return [debris stuff] } else { return false; }
subtask != task therefore these two lines should be: SubMonitor.convert(monitor, /title/, 1); (other cases of same marked with ditto2)
use a singleton instance of DefaultVariableNameFunction
What is the rationale behind this check? Why not if (getRange().getEndTime() > fTimeRange.getEndTime()) { for instance?
This could be refactored to use contains method on List.
I recall, you should do setProperties on config from the endpoint. Perhaps either @oscerd or @davsclaus can confirm this.
Many of your instructor test cases (such as this) can be simplified by running the helper methods in BaseActionTest instead of doing all of these manually. It'll make it easier to understand and parse. You should utilize methods such as  verifyUnaccessibleForInstructorsOfOtherCourses(submissionParams); verifyAccessibleForInstructorsOfTheSameCourse(submissionParams); verifyAccessibleForAdminToMasqueradeAsInstructor(submissionParams);  instead of what you have now. Check your other test methods too. In the same vein, the same could be said for students:  verifyUnaccessibleForStudentsOfOtherCourses(submissionParams); verifyAccessibleForStudentsOfTheSameCourse(submissionParams); verifyAccessibleForAdminToMasqueradeAsStudent(submissionParams);  etc.
Doing this in a live test is a symptom of something that users will probably have to do themselves. better use the build-in Predicates2.retry construct to wait until the server is deleted and consider binding it to the guice context so it can be reused where needed.
setErrorMessage
can u extract a final constant with a readable name out of "<[ ]*%s[ ]*>" ?
This is currently not the case and I do not like to have everything rendered. It should use the configured probe level.
normAlized
This line is longer than 120 cols
this method states it check the button visibility. It doesn't mention checking the module visibility. Please make this diversion more precise
Return a Set<String> instead of HashSet<String>.
I love the readability improvement here. We might actually be able to improve it even further, by having the ConstraintDescriptor have an enforcesUniqueness() method (and an enforcesPropertyExistence() method) that delegates to the state of the type that it holds. In fact, if we make that change the ConstraintDescriptor.Type enum does not need a public enforcesUniqueness() or enforcesPropertyExistence() method, since all places that use these methods follows the pattern of having a ConstraintDescriptor and invoking the type() method of that in order to invoke the enforcesUniqueness() or enforcesPropertyExistence() method on the result. In fact the ConstraintDescriptor.Type wouldn't need the methods at all, since the ConstraintDescriptor can access the fields of its inner class directly.
nitpick: if the stream is null, isn't worth it to invoke a createStream to avoid double checking? the same logic could be applied to the else branch by passing the stream directly.
Add the @Inject annotation and remove the public modifier from the constructor to make it package private ([background](<LINK_0>
Similar to above for shadowing field idempotencyKey ->
Nits: please add annotation in separate line above. You may want to change for all such lines below and above.
this mapping should happen via public enum and not via mapping backend enum to string
this line is redundant now that you call endSuccessfully directly
REMOVE_CONTAINER_TIMEOUT = Integer.getInteger("org.apache.apex.nodemanager.kill.timeout", 30 * 1000);
Consider using constants for values like this, as you did in your other test class to increase readability.
pkgtypes.get(pkgType)...
In other pull requests, we had mechanisms that ensured that it was not necessary to recompute every weight for every selection. Should this use the same trick?
Is this about terminating, or sending a specific signal (there are both TERM and KILL signals)?
hide this and expose factory method
What happens if the command is null or empty? A null/empty check would be cool.
One suggestion s/unkown/unknown
Empty list instead of null
We don't need to set RowKind on keyRow, because we never to use it.
Done, added two new constructors, one with public key and one with password and public key
For consistency, should this be a LOG_MODEL_RUN_COMPLETE?
Unless I'm missing something, this method could be safely deleted and you could use the byte[] header and payload variant instead.
What does this buys us? There is no _expected_ failure path once we managed to writeLockAll() so we should simply move the segments.clear() after the finally block.
why this?
For all other calls of scheduleDirect, we use: suggestion Schedulers.io().scheduleDirect(new Runnable() {
Could use CompletableFutures.COMPLETED_NULL.thenComposeAsync(...) to avoid the double wrapping the result. Maybe it's worth adding a static method in CompletableFutures.
nit: as mentioned elsewhere, I don't think we need to add all of these exceptions to the method. They are all runtime exceptions, so it's still up to the user to read the docs.
Developer tag should be a prefix.
Unfortunately here we can have a situation when some events can be lost. I meant that eventsToFire map can have at the moment of call of method more elements than were processed in the loop because eventsToFire is backed by events map.
Could throw new UnsupportedOperationException if not empty. We should deprecate it in AbstractMemento.setCustomFields. It is deprecated in all sub-types.
add assert that leaderSessionID and leaderAddress is not null. Otherwise this method will allow us to break isEmpty.
Should compile once? This might be called many times.
MISO convention for RequestManager has an initial check for if xStore is null (add to this and three methods below)
Why not case ShowToCEvent.ACTION_TOGGLE? And throw exception for default
Just pass the set.
Is there a reason why this is RuntimeException not TribbleException?
duplicatePolicy -> dataLoadingPolicy
why not make this method public?
For consistency with the other infrastructure components, I'd suggest to do the builder.validate() call in the constructor.
I'm wondering how the no-op impl plays in here. Shouldn't there be a "real" implementation in case of Neo4j Embedded, just not based on JDBC but on the Neo4j TX API?
Do we really need the flush? We're dealing with the single stream anyway, so writes will be serialized somehow (and also we synchronize this anyway), and I don't really care about the order as long as the chunks are not interleaved, which should not be happening since we write the whole chunk at once inside synchronized.
If you want, you could change this to allowCors(response (like in "version", above) to allow Cross-Origin Resource Sharing. I'm sort of wondering what's returned if no API terms of use are set.
I think we shouldn't log PIDs (email) ? At present we are logging reference, amount, return_url. New fields (delayed_capture, language) seems fine.
This is the same as below, but I am fine if you want to keep as it is. java for (final Element element : children) { Position.setY(element, ++parentY); }
Can you define this property name in 'VoldemortBuildAndPushJob' together with other cdn related properties? It seem this one is very important to execute distcp job.
There are tools that auto-generate files but let you edit them (usually between markers) and your changes are not lost. As swt tools are not such better to be more exlicit. What about smth like: "Auto-generated file." "DO NOT EDIT - your changes will be erased!"
this isn't monotonic, shouldn't nanoTime() be used for measuring elapsed time?
Why initialize with default value? You could: 1. Save a boolean of "succeeded" 2. Save a null and check for it later. I think option 1 would be better, then the method just return false in the end, and if the vdsm command didn't throw error just return the getSucceeded()
how about also printing vdsId? it might be useful in the future
This error message isn't particularly helpful. Maybe this instead:  ArgChecker.isTrue( fixedLeg.getCurrency().equals(floatingLeg.getCurrency()), Messages.format( "Swap leg conventions must have same currency but found {} and {}, conventions {} and {}", fixedLeg.getCurrency(), floatingLeg.getCurrency(), fixedLeg, floatingLeg));
call notFound instead of returning null
Synthetic access.
Use Tree.Kind instead, to remove the import.
Seems like this appender could also be scoped to the class that logs the message we want to capture, right?
That's probably not what we want, right? Maybe some logging at least? Why shouldn't we fail in such a case?
Note that in Oxygen this bundle has not updated to java 8 yet.
Use Objects.requireNonNull
how about "url cannot be null"? that would be a completed sentence
Do we need super(), if the class is not inheriting from a super class?
Collections.singletonList would be fractionally more efficient.
This method should be static to avoid a warning if such warnings are enabled.
could replace this if and the above get with : java CachedConnections ccl = getCache().computeIfAbsent(cacheKey, ck -> new CachedConnections);  Also a concurrent map will handle this correctly for multiple threads.
add brackets to make this expression more easy to understand
Is it our common rule? I mean invertring boolean condition? Maybe it's not so smart question :). I mean, maybe is little more readable? if ( propertyEntries.isEmpty() ) {   return null;  }  return first( propertyEntries) ; }
I don't think that this is the right place for incrementing of receiving keys. Let's call this outside the updateGroupMetrics since this is a method-candidate to remove.
Not an exception
Could potentially use: <LINK_0>
This check is redundant. Just call taskKeyToTaskIdMap.remove(taskKey), and check if it returns null or not
Why not just have a default on the switch?
Do we really need to specify the version here? Afaik, it should grab the version from the pom.
The same as above: returning the previous MessageBufferInput
this method should be changed to private
while you're rebasing, please rename to originType
should we be resetting this static object repeatedly? Why not just have a static initialization?
I think getting a live stream was there for a reason. Perhaps we should evaluate if that is a good idea, and if so, still keep it, as opposed to having a dataFile. Once it is a data-file, it is the same as any other provider (not necessarily meetup).
when would this be of use except for in init which is always false. I mean in line 442 of GlusterVolumeSnapshotListModel you are doing snapshotModel#getDisableCliSchedule#setEntity but that doesn't come here right?
why endAction of RunVm will not be called automatically ?
Replace with this(in, null)
listeners are not notified?
probably safer to have a current != null
that's wrong, should be: return message;
this can lead to an NPE, if firstStoredEntryForBookie is null.
Put it inside the if.
Sorry one more thing, please make this guard >= 3.20.0 as the warnings will happen on 3.20 as well.
same again: reuse method
why?
@ekondrashev Same here, let's declare Exception being thrown.
If ProtobufMetadataManagerImpl needs the cache to be running, then it should start it in its own @Start method. cacheManagerStarted is too late: if a cache manager is created with start=false and 2 threads call getCache(X) and getCache(Y), only one of them (say the one starting cache X) will wait for cacheManagerStarted to run. The other thread will start cache Y without waiting for the protobuf metadata cache to start first.
Character should be "char" <LINK_0> This is returning a char (primitive type) and that is why the "=="test works I think, if it was returning Character (object wrapper for char) we would need to use ".equals"
are you planning to add an isInitialized() method on TransactionManager?
I'd rather avoid using continue and just do: if (vm != null) { vms.add(vm); }
use getIdentifier() insteand (applies to all changed Enums)
If this is intended for human consumption, {>=, >, <=, <} would be preferred to {gte, gt, lte, lt}.
Use curlies on split-line ifs
Just in case, I would first check with instanceOf
I think we should not cast here, but parametrize cache directly: verifierNode.<String, Integer>cache(CACHE_NAME).get(entry.getKey())
You might should take into account the LoginStartupPage#priority field to order the results here.
You could just inline it here.
Remove this line. Doesn't make sense for a primitive value. What's happening here is that the primitive boolean is being auto-boxed into a Boolean.
Since this method is not used, logging 'Configuration reloaded' is misleading.
What about calling this class TCPSurefireForkChannel ? it is really bound to "tcp://127.0.0.1"....
I strongly recommend to use 16-bit dense array! The problem is, that on world generation, every block will be set to some value, so all memory gets allocated anyway. After a chunk has been generated by the world generators it will be deflated and the array will be switched to the sparse implementation. Currently, deflation does not happen if it is already a sparse array!
These have to be public? They are in same package as comparator and Cell types.
please add the constant
Since it would get converted into a MaxSizeSplitHintSpec in createSplit, could this create a MaxSizeSplitHintSpec directly? (Does this also mean SegmentsSplitHintSpec is deprecated?)
public?
Maybe use Optional here instead of returning null
change to:  return new RuleMemberValidator(this);  (see Effective Java, 2nd edition)
It might not be clear which value was the offending value, does it make sense to print out the 'pre-split' value?
Does this one have to be public? As an extender of such annotation, I don't think this is something I would need to invoke directly and I'd expect the underlying framework to do the necssary optimizations.
I guess it depends on what you are doing with the image. If you are doing center crop, yes. If you are doing center inside, no.
The groupId rule used to replace - by .. This change has a new rule that replaces dashes by empty space. Isn't that breaking what we used to do for groupId?
same, double de-ref
The thread was interrupted, I don't think we should be continuing on like nothing happened.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
This doesn't include all fields. Use the parent class's hashCode as a basis and then incorporate this class's fields into the mix.
You'll want to replace this with a call to getPrimaryStorageSize() to ensure that your updated logic is applied in both places.
Be careful of nullable fields!
We also need to clear the cache when user switching occurs.
I do not like this defaulting logic. It does make sense if this is a LSH parsed by the LS backend from the query hints provided by the engine. But it makes no sense if this LSH is used as a builder by an end user wanting to customize the hints of a query. Even if a specific hint value is not set in the customization, we cannot be sure that the engine will use the static default, which could be overridden by engine-specific options or the query specification. I suggest removing the defaulting logic from the getters. Perhaps the defaulting logic in the backend can be achieved by extracting some of the logic of ViatraQueryEngineImpl.overrideKnownHints() into a public static method, which the LS backend can use to combine the parsed LSH with LSH.getDefault().
I don't think there is a use case for this, but let me know if you disagree.
I think keeping this method is not a right design because setScrollTargetCallback is preferred to call in onCreate and should not be change in other states of Activity / Fragment lifecycle which mean calling this method is redundant. With the update yesterday, whenever mScrollTargetCallback is set, it will prioritize the result from this method first. So that, it's more flexible now.  return mScrollTargetCallback != null ? mScrollTargetCallback.callback(target) : getSupportedScrollTarget(target);  I prefer not to keep setBehaviorScrollTargetCallback method and rollback some changes in Behavior class. The rest looks good to merge.
Having an if/else block here would make this better readable
this may be confusing to people. why are params with the same name considered "equal"? what about the value? if some part of the code wants to treat these Params as "equal" as long as they have equal names, it is better to keep this comparison logic close to that area, maybe with a local Comparator class or something, but not inside the data object itself. this would allow reusability for this class in the future.
change method name to clickPreview
I get a warning at this cast from Object
what is acc ? please use full name.
I would keep the condition on != null as the list can be set to null...
I would keep this pattern as it was, it's easier to see what's part of the assertion and what's not. If there are other cases please revert them too.
Locale class doesn't have "zh_hans", so I guess this check is correct.
timeout is ignored here
do we need to make a copy of groupByColumns?
Given consumerProperties is always non-null in this class, may be we can do !consumerProperties.isEmpty() here.
please rename to script
All the subqueries will become never-lazy now. Does not look like a correct fix.
The dialog is a big short in height after you switch to Remote. Since we don't create the Remote composite by default, we don't use its height hint at the initial layout. You could set a heightHint on the dialog composite's grid data to compensate.
The logic you want is rather "Crashlytics on devices, not-Crashlytics on the emulator, DEBUG-vs-RELEASE is not a factor". Also, this needs to be done at all entry points to the program; the services as well. Check AndroidManifest.xml for inspiration, basically all onCreate() implementations should set up Crashlytics. Feel free to copy code from / copy the entire files from here and relicense it for Bankdroid if you want: <LINK_1> <LINK_0>
Add null-check for inputStream.
It's late and I'm tired so I could be totally off on this but I feel like this could be done in a single pass and save all the conversions and checks. Maybe just iterate through the array and write each item into a resultant array until you encounter the double dash and then return the result array?
You don't need to override this since you're already enforcing the 'altered' default in the getLimit(String) method.
@JonathanGiles Do we have a guideline about when to return an empty collection and when to return null? I noticed this also in: <LINK_0> and a few other places. I personally prefer returning an empty collection, because you'd know that there are no items, whereas, you'd have to do a null check, then check for empty if we return null.
The idea here is that we expect the source of overloading is a few bad actors hammering, so this will effectively throttle them?
Can the instantiation of the objects in the equals method be broken out of the if condition? There's a lot going on for a simple equality check that would be easier to follow if the impls are instantiated earlier IMO
More generally, maybe a test with an expected error would be good, to show that the expected type is inferred.
Column indexes are 1-based - otherwise this is a definite improvement!
Here, publishedFullRegistry.readLock needs to be taken.
Could be "return this.getRuntimeInfo(engine, connectorTopology, GoogleDriveConnectionDefinition.SOURCE_CLASS)" to avoid code redundance. (ok it's only two lines...)
Since this is just for Jackson, you can make it private and then get rid of the @Deprecated if you want
Forgotten or left intentionally?
I would consider wrapping completing the future in a finally block to ensure it's always set, imagine close of role is refactored and then throws an exception..
I think I'd rather see the PROPERTIES written out here than defined as constants at the top of the class. The UUIDs make sense as constants at the top of the class since they're standardized and unreadable values.
If the request failed, is this.reponse also null? Is the warning then still appropriate?
Can we pre-compute this value instead? The tokens are immutable and set in the constructor.
this function should only be called if metrics are enabled.
move this closer to other filters.
This should probably use connectorId.getCatalogName() for the message. @dain should take a look since he recently changed all the connector ID handling.
What does this 1 represent? Is there an enum holding this value you could reference instead?
No need for getInstance(), the container can be passed
Should just be checkNotNull(globalNames, ...
just use return Iterables.filter(getMembers(), MongoDBRouter.class);
@vilchik-elena That works only if the default charset is StandardCharsets.UTF_8. Why not make highlightXML accept a java.io.Reader and use a java.io.StringReader here?
Default should be false.
I don't think this will help. The 'timesToRun' number requires ALL of the running to pass. If any one of the running failed then the test will fail. Increasing timesToRun will make the test slower but does not help with retrying intermittent failure. I have a PR to fix this issue at <LINK_0> Sorry for the trouble from the intermittent failure.
If you add the new JSON they won't be published until we deal with the front-end of this project, which seems more reasonable to me.
Formatting here is weird too
We would never do multiple actions at once. So make this an enum that selects the operation mode, e.g.: enum Operation { BEGIN, CONTINUE, SKIP, ABORT; } and have the individual set methods assign the enum field accordingly.
Please add a TODO here. We may need to do something smarter here by using a different kind of loader. Destroying the cached data is not something we want. What we should aim for is invalidating the data if the underlying data changes. What is the use case in which this returns the stale data?
Is uri.getPath() not sufficient?
This either needs to be protected or Exception needs to be public.
shortcut for this is, context.getCurrentAddressValue();
You can remove the unused variable accesResultCode. That also fixes the typo in its name ;-)
Make this string a constant
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
Should these test be really removed ? Are they moved somewhere else ? Should there be some replacement ? E.g. now there is no need to check the functionality (integration: something is generated and so on). But you may check that some methods of classes that are in the lookup are called: e.g. factory is called. And also objects produced by the factory are called somehow (doesn't matter what they do but they are called).
Move all Strings uses more then once to a constant.
I'm not sure these labels are necessarily better than ones that reflect "onOrAfter", "onOrBefore", and "onDate".
Why did the whitespace change.
suggestion Set<ConstraintViolation<RemoteDataSetDef>> violations = validator.validate(dataSetDef,
Why doing this ?
if (getVm().getVmPoolId() != null) ?
please use NotImplementedException()
For example in this case I think you would say suggestion contains(ExtensionList.lookupSingleton(NoNavigatorSomeFactoryInstalledDescriptor.class)));
Please put the creation of TimeStressorCompletion to else branch (you can omit the variable and return new instance right away).
entires.putAll(map)?
Please, write it in one line: @Override public Any reason to copy-paste implementation from mapKeyToPrimaryAndBackupsList?
It actually is equivalent to kill. There is no waiting for undeploy etc.
What is this method meant for? What is the "Intramurals" username?
Variable name unclear, using the singular "order" to refer to a list of orders.
Whatever you did here don't commit this change
A more proper abstraction would not expose the Map interface.  public String getNameByEmail() { // .... }
asJsonObject() ;)
Are you so sure that no Jenkins component is logging secrets at FINE or below?
Perhaps make id optional for MockSCMSourceBuilder too.
I think the docs are wrong here  they say fragment queries match if "any part of a dimension value contains any of the values specified" but the code matches only if all values are found.
I missed bounded type parameters already :-) I don't know if it would be better to create separate versions of createPoint methods? Like this?  protected Points.Point createPoint(Long timestamp, Rollup value); protected Points.Point createPoint(Long timestamp, String value); protected Points.Point createPoint(Long timestamp, Object value);
Iterators.transform ?
What's the reasons for that initializations here? Shouldn't all that ones not be done implicit already?
Don't need to have this in a separate function if it's just a oneliner, IMO.
variable can be removed
checkNotNull constructor params Ditto for other constructors
![MAJOR](<LINK_0> Unknown method [![rule](<LINK_1>](<LINK_2>
Used only once, do we need it at all? Why such simple actions can't be inlined?
we only need to load the capture queue once. could this line go before the for loop?
This adds the attribute transformers to the subsystem resource, which isn't where they should be - they are on the xa-datasource=* child resources. So: I'd do:  parentBuilder.createBuilder(.....) .addChildResource(PathElement.pathElement("xa-datasource")) .getAttributeBuilder()  This will add them in the right place
What if it's not the right instance? Shouldn't we throw an UnsupportedOperationException? Or, is there a way to just create it from the factory, so we know it's always the right instance type? Since this happens very rarely, I don't think we'll need to worry about getting it from the cache for efficiency.
What is the purpose of this method?
new LinkedHashMap<>();
So a fun thing I learned last week is that the toString() on TypeElement is not standard between compiler implementations. In Eclipse it will give you a string like "class org.acme.Foo" instead of just the name. The portable way to do this is to call e.asType().getQualifiedName().toString().
Does this work, it looks like you're asking the serviceDAO for workflows when it seems like workflowDAO is what I would have expected. Tests are passing though ... which might mean that this needs tests?
There is a FluxUtil method to handle pulling a response value out, I believe it is called toMono. Should use that in all the places update.
You need to make sure the EhcacheActiveEntity.destroy method triggers this as well.
I've been putting some thought into this method, and I've got a question for you. While the SAML spec allows multiple AttributeValues for a single Attribute, it also encourages that it be one-to-one. Because of that, I imagine that most applications will want to do: java String email = principal.getAttribute("email");  instead of: java List<String> emails = principal.getAttribute("email"); String email = emails == null || emails.isEmpty() ? null : emails.get(0);  What would be your expectation? If you'd expect to do the first option, we might want to change this method to: java List<A> values = getAttributes().get(name); return (A) CollectionUtils.firstElement(values);  and possibly rename it to getFirstAttribute. If you'd expect the second option, the signature should probably change to <A> List<A> getAttribute(String)
Please log debugging data here.
why new line? you can leave it on the previous line, like:  new Runnable() { } .run();
this seems a bit large, 512 would be better
String.valueof(String).toString();? why not just return the string, it's final.
Why a null check here, but not in previous test classes? Can this one be null more than others?
namespace is wrong here.
Please use static imports. The compiler should be able to tell assertThat(Optional) from assertThat(Comparable).
I don't understand why this parser is needed. isn't taskName simple String?
ioStatisticsStore.toString() does that too; what you get through the logging API is resilience to failures
Can use @Test(expected = ...), see above.
Please conform to one naming standard i.e. using singular or plurar form for classes and methods.
Should those hashcodes be hardcoded ? They depend on HashCodeBuilder.toHashCode() implementation.
do we use p after this? Maybe we can remove eventBinlogPosition as well?
might be better to go with msg=get-all-last-seen-insights-fail-insight-missing rather than repeat debug. It just so happens that for error it makes sense to have the error=xxxxx key.
Shouldn't this be a getAndSet(false)?
Use Closer here to make sure both resources had a chance to be closed.
Personally I would prefer to create a real RateLimiterKey rather than use a mock here given it's simple to do, but not a big deal
Please prepare for the internationalization with Messages.properties. Example: - <LINK_0> - <LINK_1>
shouldn't 50 be a constant?
externalize
Same, as above... Use dataset.xml instead
Can we split this as follows:  final StoreQueryParameters parameters = (StoreQueryParameters.fromNameAndType(keyValueStore, QueryableStoreTypes.keyValueStore()).withPartition(numStateStorePartitions + 1); final InvalidStateStoreException exception = asserThrows( InvalidStateStoreException.class, () -> storeProvider.getStore(parameters) ); assertThat(exception.message(), equalTo("..."));  And remove the (excpected = ...) annotation. (1) We should always limit the code that might throw the exception (eg, if withPartition would throw an InvalidStateStoreException the test should fail, but would pass in it's current setup) (2) We should always verify the exception cause -- getStore() could throw an InvalidStateStoreException or multiple reasons and we should make sure it's throwing for the reason under test. Same below for the windowed case
filedType::toMap
Better to explicitly check DEFAULT_STATE_MODEL_DEF here. For the other cases, shall throw an exception the earlier to better.
the transform should never ever return null. if something changed we need to unchange it. #getRule(...) should throw a NotFoundException if the ruleId isn't present in the database. The transform.appToRest should throw any errors that prevent the method from returning a valid rule.
Retain the original class name. I see no need to change it.
In fact, I would return all profiles. Something like: CommonHelper.toString(this.getClass(), "profiles", getPRofiles());
return Status.BACKUP_FAILED.equals(status) || Status.RESTORE_FAILED.equals(status);
suggestion checkArgument(key.length == 32, "key length should be 32 bytes, but is " + key.length + " bytes");
I don't think that addresses my concern about having a good error message if an unexpected exception is thrown. I think being explicit provides a cleaner, more obvious and easier to use API.
in other classes we throw UnsupportedOperation
Don't need to access iterator, just: for (Long long1: queryFactory.tupleQuery().getTuple2E1ListRaw(CoreTupleTypes.ViewApplicability, branch, applId.getId()) { ... }
Relying on the enum ordering seems scary. Could we instead java double toPerFrom = unitTo.convert(1, unitFrom) if (toPerFrom == 0) { toPerFrom = 1 / unitFrom.convert(1, unitTo) } return valueFrom * multiplicativeFactor final double result = valueFrom * toPerFrom  or something semantically equivalent?
use ShellIsAvailable
here, it could be simply return queue.peek(); (avoiding the redundant isEmpty check).
We should be able to use the writeUnsignedInt method from UnsignedNumeric class.
I would prefer a warning and going with the default value then - which means that the runtime can easily recover from the invalid config value.
![MAJOR](<LINK_0> Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_1>
typo. should be modify to adjusted.
OPAQUE
I'm confused by this, we removed the StreamsConfig.METRICS_LATEST config, but we've replaced it with a literal string value of the same thing. EDIT: NM re-reading the PR I think I get it now
Not needed anymore, they seems to have fixed the bug with "localhost" within ga.js
Intermediate ArrayList is unnecessary.
Why is this needed?
Probably can remove the print()
Why are we not checking the received msg count being > 0 here like other places ?
This is missing the assert that the .asc file was actually PUT?
Can't we just set without compare?
suggestion "Namespace is longer than "+MAX_NAMESPACE_LEN+" characters");
why do you need to print during a test?
In both the old and new situation this line seems duplicated
Is there any reason why exactRef() is not directly called on Repository here? It is called on Repository in all other places that have been changed. I suggest to call it more consistently troughout the whole file. Current occurencs of getRefDatabase() - lines [539](<LINK_3>, [731](<LINK_0>, [770](<LINK_1>, [1758](<LINK_2> Line [1758](<LINK_2> is additionally a candidate for using getRefsByPrefix() instead of getRefs().
This can also be simplified (assuming Java 1.8 is used)  public int getExtraData(int index, Vector3i pos, int value) { extendExtraDataTo(index); return extraData.get(index).getOrDefault(new Vector3i(x, y, z), 0); }
As we're anyway touching these lines, let's reformat and add space around = and !=.
We should be comparing using Object.equals(actionParam.getNames(), this.getName()) - To account for nulls - == Checks for reference equality not logical equality
suggestion timer = getMetrics().timer("key-validate");
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
would be nice if you pass in here the vdsManager and the cached numa nodes. Then the VmAnalyzerFactory is stateless and can be normally injected in VmsMonitoring.
$runDir doesn't look right.
!isEmpty() instead of size() > 0 ?
you should move "Creating snapshot..." to localization
If you only iterate over watched cubes here, non-watched cubes will never get unloaded, which defeats the purpose of chunk GC.
Doesn't this make equals assymetrical, if this is a subclass of o then this.equals(o) may be true while o.equals(this) would be false.
Same for all the changes in this file, just use OffsetDateTime.now() directly.
oops
Could UnsupportedOperationException be more convenient? Also, same for **Row**: 111
Previously we checked if we had more than 1 alleles that pass the TLOD and NLOD thresholds, not just the number of alleles. Just checking the number of alleles may make the filter too strict.
This breaks the humidity implementation of the habitat former because the humidity should only be controlled through the fluids and this allows to lower the humidity by consuming water which makes no sense. There already is a setAllowBackwards() in TileHabitatFormer#updateTemperature for the regulation of the temperature.
Should use ValidateUtils.notEmpty(files)
as I recently learn, function names are apparently case insensitive in PHP (<LINK_0>, so I would convert it in lowerCase before testing if contained in set.
Please do not use magic number here - actually, you can use http error codes for this or at least a constant.
Should the constructor be public?
Please add an assertion message to the asserEquals() call.
This winds up allocating two (2) StringBuilder instances -- use append instead of the concatenation.
this(this.delegate = newSimpleAggregatedMemoryContext());
Looking at this in variables view I think better we just name it "Lambda", because the details of the object are showing lambda name etc.
Remove these lines as they are superfluous now, but the original method was truly bizarre. Don? Ryan?
required?
More compact but less clear.
shouldn't we make sure there is no alive debug sessions for every session? not just the first one?
Won't this break horribly and cause dupe bugs as k is never subtracted from the resource?
It looks like this is the same for most (all?) subclasses. If you make USAGE_SUMMARY and OUTPUT_EXTENSIONS either constructor arguments or abstract methods then the duplicate code can be removed.
This is a static non-instantiable class, I'd rather change the constructor visibility to private.
Not sure if you notice, a method reference can be used here:  this.original = Optional.ofNullable( (ServletRequestAttributes) RequestContextHolder.getRequestAttributes()) .map(ServletRequestAttributes::getRequest);
why not just bubble the exception? It's used in test setup so I guess it's okay to just throw them
Also <LINK_0> . @dwnusbaum has added a utility method for that recently, so you could replace dir.toPath() byt fileToPath(dir)
The hashmap seems unnecessary. You could just iterate over ProjectType.values() and get the plugin from the ProjectType. Also, our coding style says there should be a space after keywords like for and if (but not after method names).
BTW java.util.Objects would make this a bit simpler.
Just a small note. There is no need to declare FileNotFoundException as it is a subclass of IOException
basepath.endWith(Files.separator)
can you check if other counts are 0 also?
Perhaps rename shard to conservativeShard and shard2 to thoroughShard.
This implementation could be restructured as below: int getClientWidth () { if (handle == 0 || (state & ZERO_WIDTH) != 0) return 0; GtkAllocation allocation = new GtkAllocation (); gtk_widget_get_allocation (handle, allocation); return allocation.width; }
requireNonNull
what do you expect this to do on windows :-)
This line is untested. Can this ever happen? Looks like this could result in a stack overflow since it calls itself with the same parameters.
you can remove this and the return in the catch block, and just return Optional.fromNullable(mqttUri) on line 83.
In order to able events we need to have both flags set to true.
Is there a reason not to clean this up in a finally block sooner?
Safer to check if get() returns null and then just call set method.
Wouldn't it be nicer to have a constructor that directly takes an int?
Do we need to invalidate the previous scan at all (e.g. isLoaded = false).
don't think this need to be public so far
This should be Double.isInfinite(turnWeight) instead (?)
Putting only a message from the original exception may lead to losing stacktrace - and the root cause. Could you rather incorporate the cause into the MojoFailureException, please?
line-lenght ok?
Issue says we are just checking extends and implements. Don't these 2 lines do more than that? I see the content of your issue went with Class name too, but the issue title doesn't agree too. @romani Should IllegalType really extend to defined class names too?
We should guard against this in the builder so it can never be null here.
despite its name elasticSleep is not elastic and this will pause all tests for 3 seconds. Better to use waitFor(... 3) which will wait 3 seconds for the log to contain the matcher that you want, but in the fast case will return as soon as the data is written.
RuntimeException? Not AssertionError?
this is perfectly correct, but looks suspicious. can you change it so that it shows like this? suggestion assertEquals("For the given page size, there are 1 page(s), so the correct page range is from 0 to 0 (both included).", response.getBody());
add curly braces even for oneliners
Break this one up
Is null the right thing to do here as the default or should we do something like throw new UnsuportedOperationException()?
I think it's a good idea to just throw the exception if the s3Client cannot be initialised successfully, and just have the caller handle it. This approach will create an NPE that'll be a bit more effort to debug (to check how come the client was null when ensureClient was called, exposing the abstraction).
Do we need a try...catch here?
suggestion assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
Got 0?
@pynicolas Analyzer for "php.ini" files? (IMHO it's better to have name starting from capital letter)
This can be boolean now. Being Boolean can imply it might be null.
This should check whether the id is already registered and the id must be lowercased.
this does not need to be public either.
>  > [](start = 5, length = 4) >  trailing space
Need to check for null.
rename to signature
Shouldn't we use Optional<Long> here instead of long, as with repliedMessageId below?
Please declare the message in Strings.xml and use the xml resource here. This will help in translation process whenever it is done!
Maybe an assertion that transaction events is empty before updating status?
Add Constructor with parameters.
Inlining smartpay would make it simpler
is it possible to make the '1000' a configurable param, or at least a varibale in the class?
Minor: can just return this, don't need local var.
the close should be in finally as the previous operations might throw exception
This paragraph could be replaced by super.syncSearch(), which basically performs the same thing. There's only need to override it when something special is performed, not when the backend result is just used for setItems().
Do we need this?
I should say something about lambdas again, after all lostSegments() already uses an enhanced for loop :)
I'm not sure why you need to have both Classes and Methods here Why not only registering to CLASS, and iterate over its members (Trees)? You will then have only 2 cases to handle: * It's a VariableTree, so it's necessarily a field, you already have the declaration... And in such cases you absolutely don't need to rely on the isField() method. * It's a MethodTree, so it's a method... and you have everything you need to check the parameters already. * It's something else (inner class for instance), do nothing
you refer to spmMap with and without "this". Please be consistent.
no need for 'this'.
whoops, why are we removing this again? :-)
I'm wondering why there is a double copy of the list. First when iterating over this.rawNode.instructions those instructions will be "copied" into list. Afterwards list will be copied into new ArraList<>(list) . I don't think the second copy is necessary. We should use ArrayList from the beginning. Is the size/number of instructions known? Would make sense to initialize the ArrayList with the number of items before copying from instructions.
Why not just:  RegExp pattern = RegExp.compile( "[\\x00-\\x1F\\x7F]" ); return pattern.test( path );
why 1 elem?
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
Please add a check Objects.requireNonNull(supplier, "supplier is null");
please change to usageEventDao. no reason in modern days to use these prefixes.
For all of these that use version, if version is null, this will roll up to to just "operation.entity" which means technically we lose the ability to distinguish between default version searches and other versions. How about if version is null, using the string "default" instead? (for example would look like "find.user.default" as a peer to "find.user.1.0.0" etc).
nit: can you reverse the null check? rhsQualifedName != null
You don't use parameters prefix and suffix - may be makes sense to remove them.
If you didn't use a thread you wouldn't need this. just use the scheduled executor to send pings to the client please. Cancel the executor from a future.
Since ""en-GB" is a constant, we already know what the result of Locale.forLanguageTag("en-GB").toLanguageTag() will be (it will be "en-GB") so we can just use "en-GB" here.
Why not use the constant FINGERID_VERSION instead of calling a private method fingerIdVersion()?
The exception thrown by the ANTLR parser is unintuitive for most Jdbi users. Let's continue wrapping any parse exception in a Jdbi exception so parsing exceptions are easier to recognize.
why not return failCanDoAction?
Remove
shouldn't we use !EnvironmentContext.getCurrent().getSubject().equals(Subject.ANONYMOUS) instead of != ? (I agree that it's testing for now the memory pointer but it may have side effect in future as I don't see tests)
div.getStyle().setHeight(4, Unit.EM);
Here also making stream is unnecessary
suggestion return () -> "1";
Should the core swap be inside the optimizeEnabled block? Seems like the core should be swapped regardless if optimize is enabled.
No need to return anything different than DefaultFileOperations.INSTANCE here
Hmmm .... maybe check for something more specific?
This is basically like a load of a String in CSV format. Take a look at CSVLoader for how we use au.com.bytecode.opencsv.CSVReader (an open source CSV reader). This isn't crucial, though, so how about if we just TODO it for now?
Move this open check into a helper method, like void checkOpen()
why 0?
suggestion if (s==null) throw new IOException("Reader side has already been abandoned", allocatedAt);
Integer.toString() instead of + " "?
Would it work to use OutputStreamWriter? That is, could the body of this method consist of: write(in, new OutputStreamWriter(out));
close() has no parameters ...
Keep them in the order of the definition in BenchmarkSuiteConfig
Lets add public/private accessor. It should be private right. as we have wrappers for each metadata type.
Not necessary here. Its handled within parseAny.
Throw the proper exception if something is not supported: - NullPointerException if command == null. - IllegalArgumentException if frameID < 0 or if frameID > 255.
Same as above for otherNonCodedConceptUuid
Don't just catch and ignore - will mask problems. Better to at least do a log.error. Or perhaps even in the try-catch collect all the exceptions and at the very end of the method throw a CompoundRuntimeException so that the test fails.
This can be changed to a single line: return IdentityProviderSyncMode.INHERIT.equals(mapperSyncMode) ? syncMode : mapperSyncMode
=> OptaPlanner or optaplanner
MemStore is used for tests, so we need to implement this function.
Is it valid formatting?
same here as well, no need to call .getValue() here.
If we declare fileRoot as Optional, we can initialize it with one-liner: java Optional.ofNullable(options.get("fileRoot")).map(File::new)
Same suggestion.
this change is not needed
@benzonico spaces around +?:)
deltaInValidDataSize is good enough. Same in line 138
The default was by database before?
I would rather not generate a copy of the path right here just to test the length of it. We should expose a method on the TreeWalk that exports the path length.
This should not be registered on an HC.
catch any exceptions on vn.shutdown() to ensure ReverseDNSCache.m_es.shutdown() is invoked.
suggestion } else if (isInvincible == true) {
1. This should call the next method with the DEFAULT_TIMEOUT_MILLISECONDS as the extra param 2. Line 85/86 should call this method with the null as the extra parameter. I know the second one as like that, but we should only have command, true, Optional.of(ByteStreams.nullOutputStream()), Optional.of(ByteStreams.nullOutputStream()) once in the file, and we now have it 3 times.
Missing StringUtils.isNotNullOrEmpty() check
nit: why final?
We should have an isNullOrEmpty type check on the provided list.
This isn't reactive to have to create a new Mono operation everytime a message come in. How about a combination of Flux.swithOnNext(publisher).takeUntil(notCancelled) where a new item is emitted from the publisher if there is a next message? And for each item emitted, delay at an interval. So if the item is emitted, then cancel the emitter.
This needs to be implemented?
. I had always though is was equivelant to == rather than just an alias of is(equalTo()). Will use in future!
better return "", then it seems also we do not need to pass to safeName() ?
Minor thing, I suggest to have: private final LexoNumericComparator lexoNumeric = new LexoNumericComparator(); and in compare() method: return lexoNumeric.compare(map1.get(key), map2.get(key)); (I tend to prefer avoiding instance creation, although in this case, it's not that big of a deal, though.)
Please use Collections.emptyMap().
Partition -> Destination Partition ?
This process is not referenced or used in this test class
Hmm, our caller should be invoking us with a full AccountSshKey object in hand. They should pass down the last used time from the database column to initialize this field, rather than always assume it is null.
There should be an @Override annotation here. Most IDEs will be busy freaking out at you, and some java versions won't compile the code.
I would suggest to keep references of these client in Context, and verify they are started. Then we won't need this type conversion and exposing the getters with the @VisibleForTesting annotations.
Looks like we have missed here transactional() option for convenience.
@ should be replaced by the constant UNIQUE_ID_PROJECT_NAME_DELIMITER
unfortunately we can't use this text since it's a copyright infringement
@eg04lt3r the logic here doesn't seem correct - my understanding of the issue is that there has to be some active monitoring of each call to accept. To me this means a new thread created inside BkTimeable that will be looping and waking up every once in a while to check a list of threads that have called accept and stopping them if their time is up.
why this change ?
The brackets around the left hand of the -> operator are redundant (and frankly, a bit confusing). Please remove them.
Why not for (Action action : failedActions.values())?
Is there a way to use the className instead of the beanName here?
maybe an extra log could help us later here
If it is possible that the editor control is disposed here, it might also be possible that it is null. So I would add getEditorControl() != null && ... And please make every && condition on a new line for better readability. Not your fault, just for better readability.
Minor: this. for these as well.
Isn't that would be better to wrap the line on the .isEqualTo() instead of splitting string?
o
Not only non-null, but also not empty
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Don't forget to update this
We do not use Glick-style annotations. If the method returns @NonNull then the @NonNull shall be on the line preceding the access modifiers not between the access modifiers and the return type
please remove newlines at begin of functions
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "someService" 8 times. [![rule](<LINK_2>](<LINK_1>
throw new IllegalStateException("Trying to acquire partition lock twice. Please report.")
Why is this doing log.warn and returning null instead of a code 403? Code 403 would make more sense to me. If it's because you just don't have anything you can return to do that, then you could try either, - switch the return type to Response - or, define a ForbiddenException and an ExceptionMapper<ForbiddenException> in the manner of CustomExceptionMapper; and throw the ForbiddenException.
Both messages say "later than" - one of them must be wrong.
Same here, StringClass does not deal with wiki content, only TeatArea does. The only thing to do here is to escape any html this **plain text** value contains.
Several points not respecting our coding conventions here (space in if condition, else not in the same line as the if closing brace)
you initialized map already at line 24, why again?
I would personally prefer if the methods that are the "external API" be public. Yes, the outer class can call private methods directly, but most IDEs show public methods differently, let you filter out non-public methods when browsing, etc.
This would AFAIK lead to the creation of a PostgreSQLContainer when postgis is used in the JDBC url
Unnecessary braces?
I'd add a checkNotNull here and make the builder field a Boolean. This will make sure someone sets the field instead of it defaulting to false.
would addAll() work here ?
Why do you think that this behaviour is right?
Just to double check: We do not want this to be the default behavior in BufferWritingResultPartition, because this would finish the partial buffers for streaming/pipelined cases as well, which we don't want. I think this logic may be confusing for future developers. What we could do is the following: - BufferWritingResultPartition leaves the void flush(int) and flushAll() methods abstract. - Instead it offers protected void flushSubpartition(int partition, boolean finishProducers) and protected void flushAllSubpartitions(boolean finishProducers). That makes it clear that there is a producer that may or may not be finished, so the caller has to be aware of this behavior. - The BoundedBlockingResultPartition then implements flushAll() { flushAllSubpartitions(true); } and the PipelinedResultPartition implements flushAll() { flushAllSubpartitions(false); }
Please assert the Charset is the ISO-8859-1 charset.
s/ram/local-heap/
Why does this need to start with File.pathSeparator?
This test fails when running ce537ac0417ebb159a4589f028a024814e03d03f.
I prefer to have the variable on the line before for debugging.
responseTypes.stream().anyMatch(s -> ResponseType.fromString(s, "").contains(TOKEN))
It reads a bit strange to fall through to lookupCoordinator if we know the request doesn't need the coordinator. Maybe clearer with a slight restructure: java transactionManager.retry(nextRequestHandler); if (nextRequestHandler.needsCoordinator()) { transactionManager.lookupCoordinator(nextRequestHandler); } else { // For non-coordinator requests, sleep here to prevent a tight loop when no node is available time.sleep(retryBackoffMs); metadata.requestUpdate(); }
+static
Why are you returning 0 instead of value from inDefault like in other methods?
why new ArrayList<>(asList( ?
We should probably implement this equality checking in the equals() method of DiscussionThread. That should also take care of performing null checks (as a sanity check).
I think it's not an error, it can be logged with "debug" level
Remove extra parentheses
availableEmptyExpressions Some interpreter do not only provide a prefix but also a suffix.
static import utf8Slice
mb it would be better to create instance of UserManager in method annotated with @BeforeMethod
Are the left over agencies: agencies with reports to agency that has not been sorted? would it make sense to update the method name to be more descriptive?
This should be an UnsupportedOperationException, not an IllegalStateException
Error or warn.
again with I think this was intended to be an update.
Please rename superOnClose() (line 313) to superDoClose() as its what it does and it's confusing here to see java public void onClose() { superOnClose(); ... super.onClose(); }
I guess I'd use String::matches here instead of the whole Pattern ceremony. This is not important though - change it or keep it, I don't mind either way.
No check of the missing resource
Is it a good idea to output errors in a toString. It may have sensitive data.
loads of findbugs for potential NPE with this style as getInstance() may return null
reloading all filters seems a bit unnecessary, should just update the icon maybe?
This method name has a typo (final 'y').
Similar to the CsvSchema, could we let users override the default? as in:  CsvMapper csvMapper = getCsvMapper()!=null ? CsvMapper() : configureCsvMapper(); ObjectReader objectReader = csvMapper.readerFor(JsonNode.class);
fetch the raw value
s/ignored/expected
Maybe we can do if(!mService.isControlEnabled()) { setSystemAudioMode(false); }
The main difference i see between the two PRs is that this PR leverages the use of getChannel() which only returns a channel object. Just a few lines later the same function uses the channel object directly. From a readability standpoint this is pretty confusing as a reader might misinterpret that getChannel() does something different behind the scenes which in actual fact it doesn't.
Having a potentially null field seems unnecessary. How about initializing it with BinaryAuthenticationValidator.INSTANCE?
onFileCreate can fail, when there is an exception, in that case, the file will be in the processedFiles list and we would not retry setting up pipe ?
This line will have to move into the analyze function in order for the skipFrames builder function to take effect
mpPushSpy.getBitmapFromUrl(VALID_URL) will never be called because you're sending an empty string to mp_imgurl. I don't think you need to mock this method because it shouldn't actually be called at all.
What about we do not have any options for OVER , there would then has no reference for underlying inputs.
We can remove this line, so that we always use the latest codec, right?
Hi, since existing object ids start with 1 and you define voId/groupId=0 by default, then you can safely use something like: session.isVoAdmin(voId) || session.isGroupAdmin(groupId) in the first IF.
hmmm... the if branches do the same thing... or am I missing something?
This should be an || instead of a &&
It would be nice to know that our connection is against the prod endpoint.
besides container.shutdown, should we do jobcoordinator stop as well?
This could just be made synchronized... then we can just call "clear" etc.
This causes a "score trap" (see docs). Edit: not really, because 2 aassignments, will yield -1, 3 will yield -2 and 4 will yield -3. So it's not a 100% score trap. Still, I find that the penalities below work better: If 2 assignments conflict, the penality should be -1hard (AB) If 3 assignements conflict, the penality should be -3hard (AB, BC, AC) If 4 conflict, -6hard (AB, AC, AD, BC, BD, CD)
please make this more readable... Sure its compact but its really hard to read.
Maybe "Configure 'Verified' label"?
Sorry just one more minor thing. Do you think it makes sense to have the exception plus stack trace here as well? Otherwise it might be hard to debug if this case is hit unexpectedly.
v4.0.0.equals( nodeVersion ) would suffice without diff verbosity. It seems there are some spacing changes here.
@mdinino Could you use more descriptive variable names?
Needs to be replaced by interface
There is also a constructor that explicitly disables stracktraces, and given we are dealing with licensing code, I would suggest using that one.
Please bring the braces back.
no need for the wait, DefaultShell already has the wait inside
Another place where we could note that the boolean is unused.
This is the unexpected result, will have a look.
do we need return or print logs here
Sets.newHashSet
I guess you don't want to show the internal fields (e.g all) in the dialog
challenge service returns a challengetemplate
I'm wondering if we want to add any more logging here. It'd be great to try and get as much detail as possible when this happens.
== and != in Scala is .equals (with proper null handling), have we made sure that we haven't switched from .equals to reference equality?
@cfieber I'm thinking maybe pass a property from build.gradle in and use maven local resolver here?
i.e., java if (Boolean.TRUE.equals(request.getAttribute(BasicHeaderApiTokenAuthenticator.class.getName())) {
I know it's been around forever, but does this make you nervous? Our intent is for it to return "zh" but I don't think that's guaranteed. It's implemented as a stub in the source which leaves things open to funny stuff. Maybe this should return AppLanguageLookupTable.CHINESE_LANGUAGE_CODE instead?
If the dedicated java.time methods from TimestampUtils are used this should no longer be necessary.
This should use the TestSuiteEnvironment.getServerPort() instead of the hard-coded port.
Should use CREATE.getDisplayName() here I guess.
I think there's a newline missing here. It fails this test:  @Test public void shouldCheckoutIfSvnRepositoryChangesToAParentRepo() throws IOException { String initialRepo = testRepo.projectRepositoryUrl(); runBuild(buildCommand("3", initialRepo), JobResult.Passed); assertThat(console.output(), containsString("Checked out revision 3")); String changedRepo = FileUtil.toFileURI(testRepo.projectRepositoryRoot()); runBuild(buildCommand("4", changedRepo), JobResult.Passed); assertThat(console.output(), containsString("Checked out revision 4")); assertThat(getWorkingDirInfo(workingCopy).getUrl() + "/", is(changedRepo)); }  If that is right, you should probably take a look at removing that + "/" in the test.
I still think starting with a lowercase looks better in the status report that git prints.
In [this check](<LINK_0>, we did something similar and we used ExpressionsHelper.getConstantValueAsString. We may want to use it to be consistent. It would also avoid to trim the quotes at line 74.
formatting
Why don't you have different playSound effect functions in your adio controller wich in turn fetch from the options menu? this structure is the beginning of god behaviour.
The common refrain, why not use a try-with-resources to autoclose this thing?
@Bertram25 We're only using this variable once, better to inline it.
why is Object returned instead of a specific type?
Remove 'Assert.' ?
nit: prefer static import. Also normally it's useful to include a hasMessageContaining to make sure it's the exception you expect
nit: you can merge both lines above as checkNotNull will return the given argument
Using Optional.of() here will fail since it throws an exception when meta is null. Can you make sure there is a test that checks this?
I think this should return whatever the channel this service represents (so pass in the channel name as a constructor argument). That way subscribeChannel will work normally.
'pd' no longer makes sense as a variable name, here and many other places
Wrap with a meaningful message or just let it bubble up.
!Objects.equals(
this variable could use better english :wink:
I think we should update getFirstAnnotation() as well, for this scenario java @Exclude class Foo { } @Include class Bar extends Foo {} class Baz extends Bar {}  I think getFirstAnnotation(Baz.class, Exclude.class, Include.class) would return Exclude.class?
@Suseika please remove assert, we don't use them
We still need to check isDebug enabled as this does not use marker
I don't think it improves performance that much, but you could stream the result from allItems() and collect it into a list, avoiding the for loop.
Could we move this to a util class that's clearly marked as non-public api?
think I'd invert this:  if (A && B) { return positive; } else { return negative; }
Suggestion: There seems to be a potentially surprising different in behavior between setSteps and withSteps if you call them when there are already some steps in the builder. The former will replace the existing steps, while the latter will append to them. Maybe it would be better to make both of them replace. If you think there's a need for a method to append a list of steps, maybe use withAdditionalSteps or something? But TBH I think that may just be overkill; in practice people will probably either use a series of withStep calls, or a single withSteps call.
Maybe we could change them to VED here and throw the error early if it's not a valid VE?
Could we use Objects.equals in whole class please?
static import
Likewise this. Using the ImmutableDataCachingUtil please.
How about setting a KubernetesProperty NAMESPACE instead of using PowerMockito here? And the same for the other test.
I had trouble understanding createKey and createLimiter because they return respectively a value and a function that returns a value: suggestion String limiterKey = getIpAddress(jp); RateLimiter limiter = limiters.computeIfAbsent(limiterKey, getLimiterFactory(limit));
use list in place of newArrayList, it does the same thing but is a bit lighter to read.
is the synchronization around trying to prevent people from simultaneously using the database connection? if so, I think there's a case where you call get() on two persistences simultaneously and it'll use it at the same time. if that's the goal then synchronizing on conn seems safer.
don't use hard-coded 92
static import?
why call copy 2nd time?
Should we consider giving it empty list instead of null?
Code is inconsistent in spacing/braces. To make it consistent I would add { } here and remove the extra spaces, on this line and the other lines that duplicate this, e.g. 300 and 331. suggestion if (bases.length <= 1) {
As we discussed elsewhere, maybe the strategy should be: * If the regex does not match => Optional.empty() * If the regex matches, but some extracted field on wrong format => runtimeexception And in this case, maybe the best thing is to let it be uncaught so it hits the user, i.e. we do not need the NotThrowingParser. Do you agree?
why isn't this onCompletion(null, gse)?
It would be simpler if MalformedURLException would be converted to a RuntimeException in getJob method so that no throws is required.
view isn't being used here.
I think it should be the original one or "is not _a_ primitive type".
Please don't abbreviate variable names. It might make the code shorter, but also harder to understand. Especially this method would benefit from much more descriptive variable names.
Looks like the opposite?
Do you mean - (1 + meanBiasInCR)?
It looks like GlueClientFactory is only used here, and is effectively a static method. Let's move it to be a static helper method in this class.
I don't think that it is safe to use ordinal() for encoding and decoding. as it means that two implicit decision (the order of the enum definition, and the way java converts an enum class into ordinals) affects how the cigar is encoded and decoded. I think that it is much preferable to have it written explicitly. @tfenne @lbergelson opinions?
Logging using standard output
please apply java conventions (spaces before and after +) and total amount of characters per line
Why not just 'return !isAnInprogressSubmission(context, item);'?
Why not include the MalformedURLException as cause?
this check seems to be important to be backward compatible, I guess. Any chance for calling ConnectionWrapper.wrapConnection() (as you do in production code) and checking the instanceof on returned object?
Why can't we use id.equalIgnoreCase check instead of the other way around? This option is more flexible than hard code English locale
return itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class).
maybe we should works this method for using of multiple arguments:  CodenvyEditor#waitTextIntoAutocompleteContainer(String ... expectedText);  It helps to reach more compact syntax:  editor.waitTextIntoAutocompleteContainer("Print", "Println", "Printf");  what do you think about this?
use assertNotNull
I believe the content of the HttpMockRule should be tested here as well, not only the existence.
We should be careful about the meaning of this method. Before it meant that a user had a confirmed booking. Are we defining reserved as definitely confirmed now?
is it ok to return null if the property does not exists or should it throw an exception? pls check spec
Nit: could name this variable binder
Add the thread group name
You likely need to rebase to add TRuntime Exception
-1 can be used to represent NO_OFFSET, will that cause a problem here?
static import
log.debug ?
Call setSecretWithResponse(name, value, Context.NONE).value()
Can we send null instead?
Typo is here as well, Iteration
can multiplying by -1 ever cause an issue?
List#isEmpty()
Should this be getAllEStructuralFeatures?
This is out of the scope of this pull request, but I don't see why we're using this custom widget instead of the standard Spinner implementation provided by the framework? This seems to be just a combination of TextView and AlertDialog, and I don't see that it provides anything that's not already possible with the existing widget. I guess it's fine for now, but if we're ever redesigning the sign-up screen, then we should consider refactoring this as well.
Hi @handreyrc can you appply KIE style formatting?
Here you have a mismatch with names given in the annotations - here is upper case
Given that there is always a ResistanceCalculator, this shouldn't be optional.
Will this always override the database value? Even if it is another date? Remove this and make sure the defaults from the database are used.
can be this(new ArrayList<Integer>(other.pattern));
I thought we were going to place it in the SDK folder? $SDKS/gradle/m2repository ? If it's there we can find it without the installer's help, right?
Using the Thread(String name) constructor should be the safest, least confusing option here.
1- I said before that getStateTable() didn't need to be cached before it was called once or twice, now it's called for every event... 2- The status is not the index in the state Table. So the heights are not OK. It's too bad that you need to do this, because I think the rest of the patch is much cleaner now, and it makes sense to put the height factor in the style, but if that means doing this here... while you already had to look up the style in getStateTableIndex(), it's seems redundant. Maybe the time graph control should save styles (pairs of RGB and heights) instead of just an array of rgbs?
I would avoid the negation here. I understand that cond?null:something is a pattern but that's usually used to avoid the negation in "x != null ? ..."
I think we must give user ability to use intention if GoInspectionUtil.getExpressionResultCount(e) != 1 It does't broke code and we just move error to another place @zolotov What do you think?
you're adding a risky semantic check here for no reason.. just do what the previous version was doing please?
Is there any strong reason we must deprecate this interface ? If we add an interface SqlFunction#getStrongPolicy, the only exception is the SqlKind.OTHER_FUNCTION, when we encounter that, a SqlFunction instance should be passed in. For the other SqlKind and policy mapping, it is great if we can make the mapping configurable and pluggable, just like what we do to SqlTypeMappingRule
Please also verify succeeded message
Just for consistency, please use final boolean actual
we put try into try so you can try and catch everything
Not sure I follow the logic of this test... We want to show that it doesn't block, but then we just assert that the call doesn't take longer than 30 seconds. It seems like this test is sensitive to timing, which is not ideal. I guess that what we really wanted to test is that the close method never calls Thread.sleep()/Thread.join() or maybe just never calls a specific list of blocking methods on the clients. Now that we have all the mocks above, it seems like we can make this assertion directly.
This is problematic. Imagine that I create a canvas using this builder, then build it. You return the backing canvas here. Now I change something using this builder - that's going to change the already built canvas. **The builder and provided object should have no relationship after the object is built**. The canvas currently has various paint methods, they really should be here on this builder, then a deep copy of the final data should be placed onto the canvas. The provided canvas should be immutable. Please separate the canvas and the builder, only creating an immutable cavas when you build.
topicFilter initialization can be done in the constructor of the class.
Set the table size to 5. We expect ~4 entries. 5 is a good default size.
this can be private i guess
This is a buggy as flags can include final modifier for instance. Please fix it.
Should check if value>0 before incrementing to avoid negative values for counters.
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Can you get rid of this IF? Otherwise the field ops are not in the same basic block and you cannot use CHECK.
suggestion writtenAndUnread.computeIfAbsent(variableName, k -> new HashMap<>()).put(key, statementTree); namesToSymbols.put(variableName, variableSymbol);
Can you set 2 and 3 to constants so that they're not magic numbers?
Why the valueof? Id is already a String
The constant should be moved to TmfFilterTreeNode. The others should be removed/deprecated.
Please implement toString() to provide debugging state information for debugging purposes.
why is this not symmetric with getSslConfiguration?
I'd just use a lambda here: (rowExpression, level, session) -> rowExpression
This doesn't feel right to me -- don't people tend to handle the way test results map to build results in vastly different ways, generally?
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
Nit: can replace (builder, input) -> builder.append(input) with ExpressionBuilder::append.
nit: consider testing empty shape
@lorobode In this scenario there are two options: 1) Use primative boolean type. -> Have only getter and setter 2) If using Boolean type: -> Getter (#getNewUser) returns Boolean... and therefore possibly null -> Additional helper method #isNewUser would return boolean... would be return newUser != null && newUser;
Formatting.
Does this lose the parent Config?
Changing the value of the setting seems like an unexpected side effect of repeatUntil. Please ensure the toggle is set back to its previous setting after the 'repeat' I actually believe a user that would want to use the repeat feature probably set the 'do not throw' setting before the first call (before the initial call that is repeated by calling one of the 'repeat' methods). So toggling here in code can probably be removed altogether.
This potentially breaking change will have no impact on the plugins from the ecosystem. You can find the analysis report in <LINK_0>, done with two different tools (GitHub search and "grep" search) by two different persons. Nothing was found that is not expected.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
log
Hm.. this is strange. Why not new RtContent(this.request, "README.md")?
put this in else clause
new ArrayList<String>(parents.size())
i18n
All comparisons involving NaN (except !=) return false, so even Float.NaN == Float.NaN returns false. This should be Float.isNaN(num) instead. There's also a Float.isInfinite(num) method which might be better to use for the next check.
I don't think that this will make a difference, but maybe we should use an instance of Shogun2JsonObjectMapper here? <LINK_0>
Maybe extract questionMetaData.getValue() into a variable as it is used thrice in this method
Would it be possible to avoid this state management by just deferring whatever code needs to be run until the next event loop (e.g. Scheduler.get().scheduleDeferred())? (Only suggesting this if it might make management here a bit tidier)
The original behaviour would skip writing to the memory cache as well, this one should probably be kept the same.  java return memoryPolicy(NO_CACHE, NO_STORE);
Let's just go ahead and pass unknown to the four args method, I think it will be a tad simpler.
Why?
You do not need bindAnnotated, since there's only one implementation of RpcDispatchHooks. bindAnnotated was used to bind an interface for the RPC and REST dispatchers to different implementations
Why not using here StringBuilder as well ???
Here too for message - remove if we can get away with it.
you forgot a parameter in the logging here: "setting name by nameString {}"
you may want to fix the typo while you are around... :)
This will result in a ClassCastException when e.g. a QueryMessage is delivered. If a certain message type not supported, we should throw an explicit exception stating that.
But why not check explicitly for zero? This is opaque, it seems like you're trying to optimize away a division.
What's a deep stub and why do I need one?
Why does Element and Type have references to the CHelper?
Can you add apublic void error (String msg, Throwable e) and change the public void warn(String s, Exception e) to public void warn(String s, Throwable e)
Including the !eos() in this check seems like a very odd way to write this code. Why not simply:  java if eos() { return; } if (isProfilingMode()) { ... } eos = true; };
isn't it better to "capture" lh.getLedgerMetadata() once ? maybe it is guaranteed somewhere else that calling getLedgerMetadata twice will return exactly the same object because we are using safeOrderedExecutor, but it is not very clear just by reading this code
Integer.highestOneBit(value) << 1 ? But it could be overflowed.
declare throws please
nit: UnsupportedOperationException, since NotImplementedException is reflection-specific
It looks like instead of using Pair it's better to create specific ScoreEntity POJO with two primitive fields: entity/value and score; so uses can understand directly understand what first and the second value represents.
nit: getTypeName is a new one, should be fine though e.getClass().getName() or e.getClass().getCanonicalName() might be simpler
What exactly IndexNotApplicableKernelException mean here? shouldn't we report that something went wrong instead of assuming that we do not have matches?
no need to change at here, because it is only for Date type
@Nullable annotation implies that the argument could be null. Correct fix is to keep the @Nullable annotation and do the following: return arg0 != null ? arg0.getSqlName() : null;
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
I wonder if instead of updating runLeaf() we should update methodBlock() to return a Statement that calls Thread.interrupted() at the end of the statement chain.
this doesn't need to be public right?
Don't you need to specify the enum class instead of null?
Likewise doesn't need the else clause.
Save the log level by calling RealmLog.getLevel() and restore to that.
You can remove the null check java if (APPLICATION_JSON.equals(response.getHeader(CONTENT_TYPE))) ...
Ternary operator if you're feeling fancy.
Why get it again? You already have a reference to it.
@manuelplazaspalacio unit test should execute in miliseconds, we have find a way for not wait 20 or 30 seconds for test. for example, can we pass interval as parameter?
<String, String> is redundant
return getCodecA() != null && ("dts".contains(getCodecA()) || "dca".contains(getCodecA()));
can be inlined
Also, the message was probably intended to say "This websocket uses ws instead of wss. No SSLSession available."
The MaterializedViewSubstitutionVisitor seems should not be used directly.
shouldn't this be doseUnits? :)
Thinking about this some more, rather than propagate the NoCurrentCaseException from the constructors, lets catch and log it and cal setEnabled(false) on the action so it would be grayed out, but not omitted from the node context menu.
Thank you for considering tests. Shouldn't these have some asserts in them?
We have full control of the expected data, right? Does that not mean that we can self-sanitize (I wonder if such term exists?) the data in expected?
Please, unify the naming format of the classes: ConfigurationSysPropResolver ClasspathConfigurationPlaceholderResolver
So why do we register in updateScores? A bit weird no? Also maybe MessagingService should store a list of WeakReferences so we don't need to unregister? Or we should unregister.
I wouldn't print anything like this in a unit test.
We could have a method to return bloop directory and then this and bloopJarsPath could just resolve single child. Or even better, to resolve the bsp path, so it can also be used for librariesFile
Reduce noise with !hasTrackedStartup.
It might be worth considering ellipisizing this? I'm not sure what behavior is consistent among the other SDKs ?
Better to return null here and let callers deal with null however they want. This will default to STRING in _all_ cases of deserializing ValueType, even unforeseen ones where that might not be ideal behavior.
How about having methods for creating these lambdas? The NodeImporter one is not so bad, but the RelationshipImporter involves a lot of fields.
ResourceUtils.closeOrLog(istream) ?
Inconsistent log level. Use only one. Stick to trace level for now in this method.
For consistency across the project, please remove the final keyword here.
suggestion .until(() -> j.jenkins.getQueue().isBlockedByShutdown(task));
We need to check the level here don't we? kotlin if (level == ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) { lifecycleListener.onAppGoesToBackground() }
this is a leftover I assume?
I would actually suggest making another method named "createExclusiveRelationship", since other methods may need to support repeating relationships, and the other createRelationship method does not replace existing relations.
brrr... maybe a current time would be better?
This function is no longer useful, use send_resourcepack(). This is send_resourcepack().
do init tokenizer in japanese2Romaji
what's the reasoning behind overriding the storable variable retrieved from the DB with the value in cache?
Thats no StoredObject, right?
This seems like the correct case. Do we not have any code that actually sets an offset so we never noticed the bug? It seems like there needs to be an additional constrain here which is value + offset >= 0
I'd leave this as calling the deprecated method on getPortForwarderAsync(), rather than doing the Optional.absent() here. Otherwise we're duplicating the handling of the deprecated case both here and in the async code.
I believed Codacy flagged this. I think this could be replaced with this.successfullyParsed &&= toAdd.isSuccessfullyParsed().
For reasons discussed in #661 this number of iterations might be wrong if we specify half-headway.
I think the SharedPreferences will be shared across tokens, so if someone is using multiple tokens, this will overwrite the first token. And then you'll be writing device ids to the wrong project. Please check this.
There should also be a method called Arrays.stream(array...)
You can make and use a putInt function in FirebaseEvent class instead of using the putLong.
this is not correct (and also not the one above) as you will cause a ClassCastException later on if the ChannelHandlerContext does not wrap an ChannelOutboundHandler.
Despite the looks K9.DEBUG is not constant and tied to the "debug logging" setting. Please use BuildConfig.DEBUG.
I think this should be !useHyphens
As far as I can tell, ISO-14882 allows both cv-qualifiers to be on the right side. This check would also mark int const volatile foo{}; for rewriting. Should we catch that case, or rewrite nonetheless?
To prevent reallocation of the underlaying array, we should give a size hint if possible (principals.size()).
Please use "something <operator> null" convention
This is not a nice way of having it fail. If the data dir is not set it throws a NullPointerException. I propose we catch that case and throw an exception with a proper description.
please remove or decrease log level to TRACE
querySet is null
Does that mean all JavaFile.writeTo methods would now throw AssertionErrors instead of IOExceptions? Sounds bad.
If we are on time i18n is usually required from QE
stopped
Please follow existing code style regarding spaces.
No check needed since we throw an IllegalArgumentException()
I think "resolve" fits better with the other strategy names we have.
since you have threadName same for both config classes, consider to change this name to ExchangeThreadPoolTaskScheduler so that we can debug in server log if needed.
classname vs. className is tricky. I would prefer a more distinct naming, e.g. rename member className to injectedClassName.
Is escape still needed here?
Can you add context here?
This does not throw
If the description is sanitized on the constructor, I don't think this is needed anymore. Just a simple return questionDescription will do.
I don't know if you are aware, but assertions are only "turned on" for testing. In production this will be a no-op. If you consider this check to be mucho importante then you need to do a real throw. Right now I have a hard time deciding what would be the "right thing". What do you think?
is there more clean way to do it?
suggestion: ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources();
Division by zero if mass is zero. Might want to put a constraint + log in the component
or Math.max
Any reason not to do getBlobInfo(blobId, null) directly? completeOperation() handles null callbacks anyway. Similar question for similar functions.
Removing all blocks associated with this pack isn't a bad idea. When the system calls remove(DsfPackFile) we have a pretty good notion the pack file is no longer part of the repository, so the memory its sitting on is now useless. I just didn't bother with this "optimization", because the cache eviction algorithm should eventually kill those blocks anyway, as they are not being accessed. If there is no pressure on the cache to evict (because its at/under target size), then there is no pressure to spend CPU time to evict this dead pack's blocks. The cache has "up to" its target size of memory promised to it, and the rest of the system should be hands off that part of the heap.
Double code, you should make index + height, segment.getUnifiedEnd() a variable outside the condition scope.
don't you think messages would help here? "Total connections don't match", "Total available connections don't match"?
you can probably check what is executed in the callback as well.
Don't you need to check whether priority-1 is between 0 and NICE_VALUES.length - 1?
Is this method just public for internal testing, or what?
why not support string "true" and "false" conversion?
can you please explain this null? It looks very strange to put value under null key in map and I'm afraid it would bite us later.
Please use username as the object for the method invocation.
Assign values to constant variable
Remove this?
Here is an alternative: CommonMetrics constructor takes an instance of MetricRegistry. In the production code, it is constructed using Guice. In test code, simply new the instances you need without using Guice.
Unchecked cast
This method is used from the UdpInboundChannelAdapterParser as well. Therefore outbound word here isn't correct. The change should be reverted.
This test doesn't pass. Maybe with just don't have any partition to migrate? Sorry, I'm not familiar with the subject...
Hello, this will restrict only enums to be appended from a collection, a list of other types (e.g. Collection of Integers or Strings) will be ignored. This filter should be removed to allow all types of collections (or we should allow buffer.append(col1) at last line of method to run for other types, either way)
Why don't you push this down to LogData::getPayload ? (since that's when deserialize is actually invoked)
s/repo/repo.getDirectory()/
I think more checks are needed indeed, because RB.isCompatibleWith0() uses this check as a short cut to determine compatibility. Alternatively, interface checks would need to be added to RB.isCompatibleWith0() just like for the interface case.
RuntimeException?
This should have a check that there does not exist a pin reset request yet (see remark about test). Otherwise it is stil possible to bruteforce the code the other way around.
I think teamcity is complaining about the Exception which is never thrown.
You're using .json all over the place can you pull it out into a constant
this is already done by super. Afaik you then also don't need the change in StreamSink.
While I realize this code isn't new in this PR, can we take this opportunity to improve the log statement here? I think this should say something like: log.error("Error looking up authorization rights of current user", ex);
Can we delegate the check to the RecentHistory class instead? I mean the history can answer on the question: "Did we have events that were originated with this command?" If yes, then the guard would fire the exception.
Why do we need to make this method final but not the rest?
Max 2 returns in a method
Can we use logger ?
I know Sonar will flag this for not having the {} around the block. This can be tricky to read the logic coming back at a later date.
@neykov tests pass for me too. Is your stack trace from the client or server side?
The || !storeExists part is covered by the needsRebuild = !storeExists; further up, is it not?
These values are always tough to predict, why not make it configurable? Also, is 10 secs meant to ensure we don't time out? If so, how close do we usually come to expiring before finishing?
return new FormulaShifter(... is fine. No need to store the returned value in instance.
is there a reason you changed the units? the values are the same so not sure if there is a reason.
suggestion return "<LINK_1>";
can be static
no need to check evidence type any more
Is this even possible? if it is not set we will use the default, right? Or maybe don't touch defaults here, just set the value in the optionsBuilder if it is set in the configuration, if it is not set don't do anything and let optionsBuilder pick the default.
this synchronization seems unnecessary?
Are you sure that the ordering will be correct? I think it will order wrongly for the following schemas: "1.0.2" "2.10.3" "10.0.0"
can you keep this method and also create a method "active" as alias which uses this method?
suggestion bean.setSourceSet(new HashSet<>());
Looks like MutableTupleBuffer needs replaceInt() etc., analogous to putInt() etc.
If I'm not wrong there is a race condition here, where multiple concurrently committing threads can hit this at the same time. If so, we can underestimate the last written timestamp, so technically it's possible for this to say 0 in a non-0 case (worst case you have a bunch of concurrent writes that dump loads of data in at timestamps T1 ... Tn, T1 wins the write here, and the immutable/unreadable timestamp gets stuck between T1 and T2 for some reason). A simple fix could be to use an AtomicLong (you want to accumulate with max). This is non-blocking though.
class doesn't exist
double ;;
Can we put this in a place where we have defines?
this.
Static import
you have isSetX() on all jaxb generated properties (which is equal to action.isForce() != null )
nit: this.cacheValidationEnabled = requireNonNull(cacheConfig, "cacheConfig is null").isValidationEnabled();
Isn't it text/plain?
It might be good to have a small delay in here, I've had similar assertions fail in CI because of timing issues (see 82d0d280078cb10ec043c544c9cd7e3d8dea6b02).
you should create EngineError (and use high value > 5000) for each exception you want to throw in a command, and throw EngineException with this key this way it would be possible to translate the erros and use the commands error handling 'infra'
at the beginning of the class: String tabSelector = "a[rel=%tabName%Tab']"; in the selectTab method: WebElement tab = waitForElementByCss(tabSelector.replace("%tabName%", tabName.toString()));
Same here. You get the idea! There are a couple more occurrences after that.
nit: this could be also event()
OZONE_SCM_DATANODE_ID_PATH_DEFAULT is now a constant as it is not configurable. We should move it to OzoneConsts.
It is preferable to use DOI.parse(value) since it adds a bit of cleanup and you don't need to catch the IlegalArgumentException. <LINK_0>
It might make sense to modify the usage of this cache. Transactors that have timed out should only "not exist" for all transactions before the startTime of the timeout. For any newer transactions, the timeout needs to occur again before the timeout cache is updated with a newer time. This will prevent rollbacks from continuing to occur on transactors that were slow but started to function correctly again.
Would the error be easier to understand if it said something like "Can only call set and get methods for call state when using a single CallContext" At present, it sounds like all methods are off limits.
Oops, I meant only the accessors in the abstract chat message class to indicate that they should not be overridden. Could you undo all of these except for the ones in the abstract class?
can't we do something a bit better here?
If it shouldn't be possible to store an Application without a slug then this abstract implementation should have control over it and not rely on an implementation calling this method.
I'd collapse this logic into the span namer.. ex.  java if (this.name != null) return this.name; return spanNamer.name(this.delegate, "async"); // last param is the fallback on default;
Optional: remove "debug" in print statement.
I think we want to make sure that the line numbers are copied over correctly.
You can just put getAbridgedConfigPath here, and then call the field "title" in createConfigGui. Same thing with modid really. Example: <LINK_0>
I would prefer this to become ScriptConsole.getActive().addActiveConsoleObserver(). This would allow observers to be per console and not some shared data.
Should this be done partition-wise?
This class is public, you need to make the change backwards-compatible.
Does this delete necessary?
This can be reverted back to being private
then consider to leave old constructor and add new one below
Shouldn't we also be doing executorService.shutdown() here as well?
why it was not needed and now you copy it over and over again?
maybe you like this code better to create Config instance:  import static io.digdag.client.DigdagClient.objectMapper; Config static newConfig() { return new ConfigFactory(objectMapper()).create() } ... import static XyzUtils.newConfig; return newConfig() .set("host", "foobar1.org"). .set("port", 6543). .set("user", "user1");
essageQueue.RegisterBankAccount_PushMessage
Couldn't we just get the prototype directly from this? javascript () => Object.getPrototypeOf(this).m;
Do we need to throw and log? Can we have this message include the message above?
@jdotcms please instead of a debug let's change it to error, if we are trying to register something with OSGI and we can not do it we want to be noisy about it and know the reason.
This uses the platform default character encoding. It's good to be explicit, so please use publicCertificate.getBytes(StandardCharsets.UTF_8) instead.
@carlspring would say indentation :P
nit: Move the left brace to the next line, otherwise the check style will complain :)
suggestion private void persistAndRunJob(JobGraph jobGraph) throws Exception {
What if Throwable or Exception are catch. java try { Connection conn = DriverManager.getConnection("jdbc:mysql://prod.company.com/production"); } catch(Exception e) { e.printStackTrace(out); }  I would added parent Exception classes. This will introduce some additional false positive but I think this is needed because catching Exception is very popular.
When we have a .get with no isPresent check, I think that's a good idea to explain why the value will always be present and do something like this: java private DMNShape findShapeByDMNI(org.kie.dmn.model.api.dmndi.DMNDiagram root, String id) { return root.getDMNDiagramElement() .stream() .filter(DMNShape.class::isInstance) .map(DMNShape.class::cast) .filter(shape -> shape.getDmnElementRef().getLocalPart().equals(id)) .findFirst() .orElseThrow(() -> new UnsupportedOperationException("the explanation here")); }
Wrap this with try-catch and return Mono.error() if there are any exceptions. For reference, see other async clients.
I think you meant shouldShowWidgetPromo()?
probalby Objects.equals can be more safe to apply in case reassingmentsInfo is null at some point
checkNotNull should be the first line of the method
Why don't you check this in the setTestState method, so that is done only in one place? Anyway this should not be possible, because once you get a timeout, you need to get exclusive access to the data structure where you keep running information and cleanup everything before other code gets executed.
Is Object needed here? Seems like its using a long everywhere (and could presumably be converted if not)
I am not so happy for opening this class so much.
I noticed that there are some-times non-ascii characters embedded into the docs, could you look for these at this point and fail if this happens so that we do not have to rely on reviewers to catch this?
nit: same here suggestion log.error("User [%s] had role [%s], but role object was not found.", user.getName(), roleName);
This is strange IMHO because it forces the caller to keep track of who might have called this method before it. KubernetesDeployments is used in quite a couple of places. Maybe a better alternative would be to provide the handler in the constructor and only have watchLogs() (or ensureLogsWatched() or somesuch). That way it would be clear who is responsible for setting up the logging and who starts it.
Same as above about the unnecessary storing of the local variable convertedStreamRecord
suggestion LOGGER.error("Updating remote repository failed",e);
0?
Wrap whole method to Mono.defer?
Why are we throwing an UnsupportedOperationException if the hashtag is not set and not another type of exception?
we should used: StringUtils.containsIgnoreCase(url, "_format=json")
Does assume work here, so it is not duplicated across all the tests?
This worries me. I think item 5 is a **bit** ambigious, since ArrayList **is** a List, though I think your interpretation is more plausible. But, since StringParameterInjector.extractValues() returns a HashSet, > @GET >public Response singleValuedQueryParam(@QueryParam("date") HashSet dates) { >... >} should work, right? So we're excluding behavior that used to work. That's not good.
is it necessary to null out dbExecutor? Won't it be garbage collected when the enclosing ImageGalleryController is garbage collected?
Why not just use fixture?
Should be isValidRepoId
you could move the if before ctx.onReturn() and avoid invoking ctx.continueInvocation()
Add codec to toString()?
Why have you only added it to the container part of the or?
It looks like we need to remember the result in entityConstructor.
As index is guaranteed non-null, index.equals(indexInterpolated) is sufficient
style-nit; we don't use braces for simple single stament constructs
Again, I don't understand why this is needed? Isn't it the same thing that happens in AbstractNetworkPopupPresenterWidget?
No, it should use TempIdTableExporter
Did you check this prints messages with decent grammar? Not sure, but did you mean "cluster name ... service name ..."
Should this be poller = new AdminPollerServiceBean(null, null);?
I don't have the code now but if the contract od sselection is to return null on getFirstElement() if sselection is empty, the code can be changed to simply return the first element, without the if.
you could inline this
When does this make sense ? If the repository is bare the returned path is non-existing and there are no Eclipse resources mapping to the path since there's also no project which could be imported. Or do I miss something ?
nit, _listener = listener That is our code convention.
I'd rather see more specific error messages here, as there's a few different scenarios here we should be aware of: * A permanent group's name can *never* be patched. But, its description can be updated. * Same with a Community/Collection group's name (not editable) & description (editable), unless it's detached. In which case it can be patched. So, at a minimum, it seems like we need different errors & checks here. Permanent groups can *never* have name updates, but can have description updates. Community/Collection groups can be updated if the Community/Collection is deleted, but are otherwise considered "permanent".
follow singleton pattern. add private to prevent others to call new AdapterPatientDiscoveryProxyWebServiceHelper()
final
Currently we have two widget providers (mostly for backwards compatibility). Please ensure to update both.
@ikhvostenkov this variable can be inlined
same here, or call this(,,)
Would you please fix here too?
The listBuckets() operation will kill the cluster in production as it needs to go trough all the keys. Maybe there is a better way to check for health?
Flip
This could be changed to use a constant from the Const class instead of keeping the old magic string.
Can we split this stream to multiple lambdas?
Let's make it _protected_ to allow users to override if they want
this call is not efficient cause you will map all N clusters in list() while only one can (potentially) answer your cluster.getId().equals(guid.toString()) condition (or even none), instead please implement public method in parent only doing VdcQueryType.GetVdsGroupsByStoragePoolId and reuse it in both parent and this class
setJournalNo?
Isn't this rather warning/error than info? My thoughts were all channels in kogito should have an envelope. Have just some of them the envelope? Or is it that small subparts/panels/components of editor can have registered different shortcuts so it will be quite common that no envelope is present?
always use curly braces, even for one-line statements.
You can optimize this so that if the first time you send SIZE, you get back the same value for both, you never need to call the remote command again. Once a file goes non-active...it will never go active again.
lets return an unmodifiableMap
* Should relative path be resolved as well?  Path absF = fixRelativePart(path); * Should Increment Read Statistics as well.  statistics.incrementReadOps(1);
Minor typo in variable name.
You could perhaps use the elytron resource to be homogenous with the other testcase.
Note: Writes to the sweep queue are only done when comitting a transaction, so non-transactional table writes (including internal tables like sweep-progress) shouldn't ever be enqueued. Agree that we should fail gracefully if we're unable to hydrate. This may be contentious, but I'd propose CONSERVATIVE rather than NOTHING - bad case of conservative is _usually_ that it does unnecessary work
Since we are using Histogram everywhere, replace AbstractHistogram::reset with just Histogram::reset.
I would suggest to use an enum for this. You can insert the enum if the text can be parsed by the static valueOf method. Therefore the strings should be uppercase, but as they are special, this seems to be more conventional as well. _Edit_ The method then becomes:  java @POST @Path("{id}/vote/{vote}") @Transactional public RoomModel voteSong(@PathParam("id") final int roomId, @PathParam("vote") final Vote vote) { final RoomInstance roomInstance = this.backend.getRoomInstance(roomId);
this will break as soon as we allow parts of subapps to be mapped. Then it can be that we get wrong opposites here. That was the reason that I added the orignal null check for the subappnetwork
the only one i know is cron parse from Trigger.class
why are we using clone and a cast here?
Why don't we have an equivalent value generator for Past?
This can be deleted.
this(new WithTextMatcher(title) and then removing title attribute
I would extract candidateBundle.getId() and candidateBundle.getVersion() outside the cycle
Please also pass the original exception as parameter. Just in case
This method could take in a boolean. This would allow the tests to be executed in any order, instead of encryption staying on once it was enabled.
minor: I would not call organizationFlags.isEnabled before checkOrganizationKeyConsistency, if the check fails, we uselessly made a call to DB
should this be a WARN instead of a debug?
suggestion ") returns null.");  the memberAccessor isn't null, it returns null.
Also not required if we use a new implementation of BulkCommand
One last nit for you. Can we change the class to AssetReport?
Should use Boolean.toString(true)
should be "declarative pipeline with podTemplate" ?
Why false again?
Make one Logger instance?
verifying that messageEt is not null before attempting to clear will prevent the NPE.
Should remove, and use similar functionality in MockServiceTicket
Thoughts on keeping the non-negative enforcement?
Can't these configuration classes be extracted and reused? They look quite similar to the existing ones.
This is throwing an exception on lowercase input such as in ContentDigestHistoryTest.testBasics().
In the current flows, a check is made to insure the model is not null. But it might be prudent to check again here, in case it's eventually called from elsewhere.
Why this empty line? :)
this is really dangerous and will most likely introduce a context leak. Try to avoid binding context strongly, or at least do this.context = context.getApplicationContext()
can it be cast to List?
Well, that the Exception occurred is easily visible from the delivered exception. I'm not even sure if I like the stack trace here, but I definitely would prefer a better log message, What do you think of "Tried to add client with id %id twice"?
This is redundant.
This file reader gets never closed. Also no enclude gets specified which is bad as it is then platform specific. Should be UTF-8
Can you please replace ==> with something unobstrusive like a colon :. Thanks.
For the above, use Context.getService(IdentifierSourceService.class).getProviderByUuid(getUuidProperty());
Is this necessary?
Isn't that if reset is called we know we reached end of the probe?
Maybe rewrite to java project.getGroups().stream().map(Group::getName).forEach(tags::add);  ? Hopefully I wrote it correctly (no IDE suggestions :D ).
Would it be better to set it to Const.ActionURIs.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED + "?key=" + regkey first and then append the rest if institute != null?
This should still be a Binary, just a reused one backed by a byte array.
this::performLoadBalancing?
I don't think this check was there before, was it intentional? If so then the this.link = link; below could be moved inside the if block?
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: java.io.IOException, java.util.concurrent.TimeoutException [![rule](<LINK_2>](<LINK_0>
use import static method for remove Assert.
just remove the log altogether, as this was clearly added for debugging purposes. I think it is just bad practice to use log for debugging instead of Android Studio's debugger. breakpoints ftw! :smile:
//TODO? Can we do this now by seeing if it's of type Item and if not throwing? Or is it more complex than that?
the column should be homepage_parameter
Add message
I would rather have separate method in PartitionedLookupSourceFactory which would return future denoting that set LookupSource is no longer needed. Maybe getSuppliedLookupSourceNoLongerNeededFuture?
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCIDENT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);
Alternatively, AssertJ has that method right now. JUnit 5 is not out yet.
remove sout
you could also use influxdb.ping() to make sure a connection is established
@puneethps can you try to move this before if (!Files.exists(path)) check?
Use P.lazy(F<Unit, A>) to construct the P1.
This is a mapping operation, so you can .stream().map() over collaborators to get the new list.
Why not just calling this method from subscribe in presenter ?
We probably want to check if there is a timed event for the given name and return 0 in that case
For existing users already implementing this method, this exception doesn't matter. For new users, this will only happen if they don't override either create. If the idea is to prevent that, maybe remove ", or at least ..." from the message?
Remove all the \n please and maybe also add the source: <LINK_0>
We should only log this if runnables is not empty.
Can we reconcile the 2 Contexts used in these lines? I mean, there is one passed as a parameter and one got via getContext() so, can we instead use only one or the other? Thanks!
You can use mapToLong here and then sum()
Magic
I don't think this getter is needed.
remove this
Another instance of the same hard-coded strings... they are repeated throughout this class :)
> Map [](start = 4, length = 3) Can you give the type here? #Closed
debug leftover?
Move after line 51.
suggestion assertFalse(c.namespaceOperations().exists(namespace));
Hmmm...in hind sight we probably should move this to debug to be sure that sensitive data isn't automatically logged.
public
Might want to use a LinkedList here, I think the ArrayList constructor allocates an array with initial size 10.
extra space
sssspppaaaacccciiiing :/
rename this to endpointStates
The base class has a "guid" field that contains the "id" converted to "Guid", so here you can use just "guid".
empty debug message
shouldn't this filter go in the constructor?
I'd be all for it if it were as simple as Seq(urlValidator, usernameValidator, passwordValidator, usernameAndPasswordValidator).forall(_.isValid)
This should only add a membership if no active one exists for the same patient and if the patient is not voided
I'm not sure I can allow a break for sugaring in this case.
Don't use explicit this if unnecessary.
We should still return the extension point marker sets if the editable marker config file does not exist.
you have to check that getParameters().getInterface() and getVm() are not null, because this method is called before canDoAction
The priorities should be reversed: get the creds from the properties first and fall back to the env.
Misc.free() does null check already
My IDE is warning me about a bunch of exceptions that are declared but never thrown in these methods.
could you reverse the ordering of this expression? Most of the time, fEnableWhenDebugging should be true.
please catch more specific/explicit exceptions. In this case the original exception is not passed through or embedded so it is totally lost.
why trim()? if we use <p> Hello\nthere </p>, wouldn't I want everything inside <p> that is not an html node?
add command?
Any reason why you've changed this to long? Now it won't match the starter implementation
This could probably be an assert since it is invalid and shouldn't get passed. The Encapsulate Field dialog doesn't allow an empty string and shows an error (though the message is not properly referenced and shows the id instead of the message).
There is no need for the super
log an error possibly? Thoughts?
How about moving this into the constructor?
Should this use the Java-7 typed collection syntax: > new ArrayList<>() instead of the earlier syntax: > new ArrayList()?
Similarly.
Perhaps we should seize the opportunity to rename this method. It is confusing as it is the same name as the current method but its purpose is really to provide a hook for clustered event bus to propagate the registration.
Variable names should start in lower case.
This can be replaced by method reference, i.e. pipelineFactory = Channels::pipeline
Do we really need session variable anymore?
After you regenerate the codec with correct since version. You will see an extra field parameters.isTriggerMapLoaderExists this should if the client is aware of the new field or not. if isTriggerMapLoaderExists is true then your field has two options as you did. But if it is false then, you should fall back to the old behavior and pass a true value into the triggerMapLoader parameter of the operation.
You don't need call to super method
'bootable' would be nicer, IMO
Let's throw an exception
You're not making a defensive copy of the Set.
Just a _style_ change. This could be rewritten as:  java for (String displayName: displayNameQuestionIds) { // do something }  So you don't need to keep track of indices etc. We had the same conversation with @ichinaski and this loop is doing "too much". On each loop we verify if we're last element. IMHO, It's "simpler" to just remove to trailing - at the end after building the string.
Looks like this should be COL_SUMMARY.
is this going to affect all the other tests that are run from the same JVM?
@riyafa can you also call channel.finish() and assert the return value ?
Since this method is good only under certain assumptions (that is: that toString() produces good SQL literal), it should be private
Maybe use the prefix announcement from config.yml
maybe you can rename period to periodInMinutes
Typo: "Will not able" -> "Will not be able"
How come there needs to be a substring for this?
rename startTime to startTimeNs
Missing braces {}.
Technically the method doesn't return a 'range', which should have an upper and lower boundary. Does this method return the startting sequence number of the block covering the gap? And what does it return if 'canCover' was returned false? Maybe merge the 2 methods? e.g. seqNo = getStartingSequenceNumberCoveringGap(gapStart). If returned 0, does not cover?
This is confusing. The users will think it has to do with RabbitMQ channels. Please use "Connection has reached EOF" or simply "I/O thread: reached EOF".
nit: can probably be condensed to one line.
May be we can change text "add" to "Add".
What about making getMapper generic and move the cast into it ?
I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. Just check if dimension is not null and get the proper value
please avoid breaking changes on public APIs
You can use ImmutableList.builder().
Let's use  CacheConfiguration<?, ?> oldCfg = cacheCfg; if (oldCfg != null) { CacheConfiguration<?, ?> newCfg = new CacheConfiguration<>(oldCfg);  to remove compiler warnings.
The var name could be changed.
This usually shouldn't happen, but should we be silently swallowing the exception here if it does?
per offline discussion, just delete it would still be dangerous since some worker (after failure) might still try to write to the old directory. We should just fail for now :) . In that case, you might want to revert the change to testCreateBucketedTemporaryTable that tries to write twice :)
Why is it Nullable? You only call it to obtain a not-null value. Move your assertion here, make the method not null. Also, make use of ObjectUtils.tryCast - it will improve readability. And move this method below it's usages - now it sort of interrupts a reading flow.
since quarks in the state system are used as "int" directly, shouldn't this class take care of the boxing/unboxing? ie, return a int here, and taking a int parameter in the method below (and in the constructors).
remove static so that we can access non-static variables
Probably best to move this to an instance or even static member than method-local.
In this case let's be specific and let's check that it is due in 1 day instead of just using > 0.
i thought we will compare the vm.runOnVds with getVdsId() this way you take into consideration all cases and not only the specific migration flow
Can we create a static constant (even in this class to start with) for this - "RSA-OAEP-256" - so that it is easier to change or track it in future ?
nit: standard practice is static import
Add codec != newCodec assertion and checks for DefaultStatefulStreamCodec?
literal initializers, not types. We emit types but when we collect them they are just initializers.
Why convulotions between list and array ?
We disable HealthIndicator by default. Please set false the default value.
Do you really intend to warn on each and every sampler execution? This looks awfully broken.
pls do this in an NPE safe way
If you're not familiar with travis-ci.org, I'd be happy to help work out the build issues for you.
use Long.valueOf() instead of new Long() - always for performance reasons
Could you please create truly random uuids e.g. using <LINK_0> They differ only a few chars from ListOfDiagnosis and ListOfProviders...
Not sure about this being so tied to authorisation (BaseAuthoriseResponse, authoriseClient etc.). In theory this could be used for querying a payment in any status.
Maybe clear the other system property as well that is set in setup method
just return false here.
Clear properties in tearDown method @After public void tearDown() throws Exception { }
should read 'stream' here
nit: 2 spaces needed here.
could we change to List<PropertyParameter> or is this API fixed?
why catch all exception?
Trying to understand this test case: so it tests if value is coerced and the way to check it is doing not in. For example. 4 not in ('1', '2', '3'). 4 should be coerced to varchar then it is not in ('1', '2', '3'). Then, I guess what is missing are negative cases. Because seems to me that even 4 is not coerced, it will still not in ('1', '2', '3'). So for each positive case here, there could be a negative case. For example, 3 not in ('1', '2', '3') which returns false.
I think you meant getFileName(), this doesn't compile.
Why did you change the order of super.close() vs cache.close() ?
sourceUrl -> invalidSourceUrl
Look at this variable name: 1) "erlangBuilder" is the name of your class - no value 2) "DirtyFiles" - yes, these indeed are dirty files, but these are not just files - these are modules 3) "Info" - no value at all
Try not to use failed in error messages as it makes failed tests harder to find in the ci build logs.
Couldn't you change this to something like: this.queryableGridDialect = as(QueryableGridDialect.class, gridDialect); This way we don't need to create a new method every time we add a new interface. This reminds me of ShrinkWrap Assignable interface, we could have something like gridDialect.as(BatchableGridDIalect.class) Not sure if it make sense in our case ...
have made the close method and called it in the finally block of write method. As once that is executed or even there if there is an exception, finally block should take care of closing the writer.
QueryTypeDescriptorImpl -> GridQueryTypeDescriptor?
this is already set below and should probably be final
Usage of ? : is confusing in logging statements. This problem also occurs many times.
this cause potential NPE when handleRenamedFiles is null, doesn't it?
Do we need an unmodifiableSet here? The return result doesn't belong to the state of this object.
Why Collections.unmodifiableList would not work like in PyStatementListTreeImpl ?
ret name doesn't make sense to me, can you set something meaningful?
I think you mean "Liquid Glass"
typo?
I expect that in 99% of the cases, a VM will be defined with SPICE once and restarted many times. so please move #899 into the 'if' block to reduce the number of queries from the database
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Definitely SDK-internal. Package access please.
Hi @rezita, isLightModeCahnged should be renamed to isLightModeChanged
Why are you removing this? Does the test fail if you don't?
There are two code smells regarding errorElements and parseAs not being static
Can do.
unnecessary parentheses around value
Would not it better to bind TracerProvider here as well?
should be statisticsOverwriteValue
getter/setters should be plain, not these tricks. Instead when creating the endpoint in the component, then set the security provider on the endpoint correctly
I'd prefer something like "Context: " + getId()
java Pager.builder().withPageSize(1).orderBy(Order.unspecified)).build()  can be replaced by:  java Pager.single()
job.getName() can be extracted as variable for more readability
This seems not needed.
This isn't entirely true. They need to run an earlier version of gerrit to init forward to this schema version.
Please either remove this or write something user -friendly. No one user will understand current message.
Actually should be getName(), because getCanonicalName() can return null for an anonymous class.
Let's do a try-catch here, catching ContainerException.
Since we do not need to keep track of the count, this should be foreach.
ok good for me.
again, @Nullable
FixturesTool.GLUSTER_CLUSTER_ID
computeIfAbsent?
1. Better to replace hard-coded string(cleanup.policy) with TopicConfig.RETENTION_MS_CONFIG . 2. Better to replace hard-coded string: compact with TopicConfig.CLEANUP_POLICY_COMPACT . 3. Better to replace segment.policy with TopicConfig. SEGMENT_BYTES_CONFIG
Wouldn't getMinimum() be more appropriate here than 0.
Let's use endpointStats?
Would be better to move this logic to the strategy to avoid splitting it between components.
Might want to combine these statements and add more context to the message
It might be useful to include the DB name in the metric, not just the table name
use Pojomatics
I would add a CommonHelper.assertNotNull for the customParams.
Output should say "inType"
Let's remove this behavior. setDebugging will only affect the indicators.
This will not support all formats like JGit's Config class does. For example 2GiB, 3KiB, etc... Same applies for other methods that perform conversion from string. Why not wrap a Config instance and delegate to it? Then we can use all supported formats for the values of plugin config parameters.
why do we want system default charset and not UTF-8 for example always?
Isn't it easier to have the serializationService as a field on this test? Are there any serializationServices created with different settings? Having it as field instead of local variable, will simplify the test methods.
Putting super.open() at the end of this method? Although it doesn't affect the correctness, it makes the code more readable.
please use our map util function.
Does this work nicely. I tried this but had no significant project to really see if it works.
System.setProperty(FirefoxDriver.SystemProperty.BROWSER_LOGFILE, System.getProperty(FirefoxDriver.SystemProperty.BROWSER_LOGFILE, "/dev/null"))  maybe ?
Can you please change the log level to debug?
Seems odd to even have a public constructor, but no other way to access it. Maybe access through getters instead of access private fields?
Simply awesome, Alex!
Use applyTo() rather than create()
In Trace Compass we haven't implemented the context-sensitive help. So remove this line. Once we implement it then we can bring it back.
We shouldn't embed headers if encoding natively.
getLength()
Do not expose the internal structure directly. There is actually an ImmutableBiMap, you can use that!
Can visibility remain package-private ?
extract method
@fabriciofx cactoo's LengthOf(Input) makes these calculations for us
So, if this is not set, the value should be -1? If there is a constant to compare with would be nice.
Remove getDefaultMongoCollection from the NSPrefs interface. It is an implementation detail.
When you're here, if address is null, you already know this.address is not null (it will always equate to true), due to the preceding check.
We should use a logging framework here
the exception should be handled better than that. Program should inform that the wanted image wasn't found.
Should be i==0 not i==2
Can we correct the hashCode method in Slice instead?
wasn't this renamed to ValidatingOutputFormat?
Should this method return an error if the worker is configured to not enable the active topic feature?
This is fixed in #2300. Since it's just tests, we probably shouldn't fix it here.
does this work if you create a session outside of the Control View (command-line)?
Could we remove this duplication, please? <img width="2476" alt="Screen Shot 2019-06-30 at 11 02 01 AM" src="<LINK_1>">  /** * Returns a synthetic Cursor instance with the provided values. */ public static AggregateCursor of(OffsetDateTime lastUpdate, String lastReturnedValue) { String cursorXml = getCursorXml(lastUpdate, lastReturnedValue); return new AggregateCursor(cursorXml, Optional.of(lastUpdate), Optional.of(lastReturnedValue)); } /** * Returns a synthetic Cursor instance with the provided values. */ public static AggregateCursor of(LocalDate date) { OffsetDateTime lastUpdate = date.atStartOfDay().atOffset(ZoneOffset.UTC); String cursorXml = getCursorXml(lastUpdate, ""); return new AggregateCursor(cursorXml, Optional.of(lastUpdate), Optional.empty()); } private static String getCursorXml(OffsetDateTime lastUpdate, String lastReturnedValue) { return String.format("<cursor xmlns=\"<LINK_0>\">" + "<attributeName>_LAST_UPDATE_DATE</attributeName>" + "<attributeValue>%s</attributeValue>" + "<uriLastReturnedValue>%s</uriLastReturnedValue>" + "<isForwardCursor>true</isForwardCursor>" + "</cursor>", lastUpdate.format(ISO_OFFSET_DATE_TIME), lastReturnedValue); }
Please refactor "f" string literal to a constant. Could you please do it with other string literals in this test class?
Consider using i18n for "Export Wizard".
extreme nit: move this after the below check.
nit: NullPointerException?
suggestion int errorId = exception instanceof YoutubeStreamExtractor.DecryptException ? R.string.youtube_signature_decryption_error : exception instanceof ParsingException ? R.string.parsing_error : R.string.general_error; onUnrecoverableError(exception, UserAction.REQUESTED_STREAM, NewPipe.getNameOfService(serviceId), url, errorId);
Can you extract this value into static variable to visually understand with what we try to compare?
No. The name looks like it measure calc offsets + send time. Now I understand intent of "MessageSend" in metric name though. "CaculateOffsetsTimeMs" seems clear enough since calc offset only done in send. Otherwise, "CalculateOffsetsDuringSendTimeMs" is clearer but more verbose.
Nit: I find assertEquals clearer for basic equality assertions like this
You can probably do a similar simplification to the one I suggested above here.
Why do you pass the invocation and not the invocation.getInstance() here?
I would return super.isDirty() || (fDirty.get() != 0); but that's me.
How about just typing yourself into the add user box?
Should we call updateSelected(rows) here as well? According to getMaxSize() method, selected array should be able to hold the max number of rows.
We should not modify the unparse logic of SqlRowOperator, instead in SqlDialect, match the ROW call and unparse it specifically.
You could put this line between 98 and 99
Can please you get rid of this init() method? Add 'open()' method to SpecialThemeDesignerPageObject and rename it to SpecialThemeDesignerPage. Use Lombok getters for infobox and builder
the assertEquals param order is expected, actual, so this (and all other assertions) should be written as  java assertEquals("Max Mustermann", info.name);
This might be an issue in EventCreationDialog, but when the dialog pops up its not confined to the bounds of the main window. In the particular case of my setup the dialog pops up on my other screen, far away from the main window. This also means that I can put the main window on top of the popup dialog thus hiding the the popup causing the main window to appear "stuck".
Update the BeanValidationProvider according to CDI20 requirments, please.
inline requireNonNull with this.
return visitor.checkIfType(DescriptorType.NUMERICAL);
throw AssertionError if checkboxVisibility is false
You shouldn't _need_ to check for null here, since the merge function will only be called if there is an existing value (which should always be non-null).
Formatting change? I'd rather keep this.
HashMap --> LinkedHashMap. Always.
Parsing previous files from < WF 10 isn't allowed? I'm referring here to that fact that ParsingOptions are not passed through.
Adapter.
Use "Ketch Stage"
I guess this is the WIP part...
Variable allocation not needed.
Suggestion: another way of handling the last GPW is with the scanner close method as well or when trying to commit the GPW. With that approach, you won't need to explicitly add this boolean here.
why is this part needed? there will be no additional cycle of VmsMonitoring until the 'perform' method of the previous cycle ends, no?
private static void warningMessage(String message, String[] args, boolean strict) {
n < 0 if you got an integer overflow or what? ETOOMANYROWS =)
please log also the command id (of the RemoveSnapshotSingleDiskLiveCommand command)
Is there any chance at all this could be expensive? (wondering if we should avoid calling it if the device pixel ratio hasn't changed in the last 1s)
With the SnapshotManager there are now 3 entities that need their data persisted (Config, Uninstaller, Snapshot). The only thing that differs is the persisted data type. All 3 use roughly the same logic to persist data. I should make a PersistedData (subclassed by PersistedList, PersistedSet and PersistedMap) that automatically persist themselves in a given directory. Then everybody else just uses these as their state and don't have to write their own persistence code. Watdcha say?
Should be final.
suggestion this.currentBranch.getName());
So basically, requestId is the current count of already masked expired rows? Can you please rename the variable to indicate that and the log line as well?
interesting, this setting will enforce checking all the entries, no? @govind-menon can you confirm what is the purpose of this?
If band is null the constructor will throw an IllegalArgumentExceptionwhich just as well could be a NullPointerException. In other words, I think just band.defaultSystem without the null check is okay.
Instead of using an anonymous class, can we define this as a separate Thread and name it for easier debugging?
try to use currentSelectedElement.isEqualNode(elementToSelect)
Would it be possible to verify the order of calls too? Like that onClose() was really executed before destroy was called? Not a hard req, just thinking that it could give better coverage.
I'm confused - I see that you didn't change the 'IBM POWER 8E' and that you don't convert 'IBM POWER v1.0' that was changed.. don't we need to convert the POWER 8E in the config and convert the v1.0 here for backward compatibility as well?
Why public?
whitespace
Would it be better/easier to just have the Text be created/added in the constructor then just set/get from there? Could you try that?
Here we are expecting a header Schema, however I couldn't find some information how do we set it up, do we expect the user to add it?
This could be useful for other HttpStatus' too. Would it be possible to extract the withHeader().withBody() out into another method to allow for fluent composition with other error codes? For example unauthorized().withJsonBody() / badRequest().withJsonBody()
Please simply use the argument name like "map" or whatever the faulty argument name is.
If the newDefaultVersion is null, do we really want to return true?
@lautarobock let's declare throws Exception, as per the [recommendations here](<LINK_0>
Do you think there would be an opportunity here to avoid the removeAll and to create only menus for new entries/remove too old entries? Maybe instead of a queue of ICommonFilterDescriptor, you could directory store and manipulate a queue of related ToggleFilterAction ?
I thought we weren't going to do this
Wrong class name in the error message.
if its from active, we can choose to not even create this object
This needs to be conditional. This should only be enabled on devices with both NV and RUIM. Otherwise the system should just default to the appropriate type.
It would be a tiiny bit safer/nicer if you put the config -> servers conversion inside the load method.
double semi-colon
It will be nice to have this method and the supercategory values accessible to reuse this map. For example, if I create a new program group for a tool I can add it to the tools supercategory and like that reuse this class to also include the others without copying the code in this method and re-define the supercat constants.... I would like to have this also in GATK to re-use super-categories and read groups...
Please always use braces around code blocks even in this case not needed. Also, the variable is not mAdapter but eventListAdapter
FWIW, we typically do these using ToStringBuilder. Intellij will actually do all the work for you if you want. [Here's a random example](<LINK_0>
What if there are multiple such related nodes at same level? Wouldn't they get same variable name (e.g. x1 at first level)? Thinking about same might actually happen when labels start with same letter (e.g. Person, Place ...) - maybe create separate issue?
Interesting, what's the rationale for not using array.length?
Can be boolean here too.
can we iterate over the keySet() here instead? The naming helps it tend to be more descriptive than using entry.getKey() and entry.getValue(). Same for below.
Can replace this with return ArrayUtils.contains(parts, "multipart/form-data");
Can you please log this exception.
rly?
What if the page was not loaded yet?
@ascend1 Can you check further why we pick cross join over broadcast join? With equality join condition, we should pick pick broadcast join instead of cross join. Thanks!
Something to keep in mind: We encourage users to turn on "TRACE" logging to see the actual moves that optaplanner is taking. Therefore, even the trace log must be _readable_ and contain only useful information for the (advanced?) user. One trick that often works well, is to ident trace logging with 2 spaces, so it's easier to see "solving started" and "step ended" log lines etc. If these trace loggings are purely here for our debugging purposes, I recommend to use "debugger log messages" instead. I think it would be useful to see which drools constraints are build from the CS, in trace logging, at the end of creating a constraint. I am not sure it's useful to see both "start" and "end" messages - I am not sure if those are worth their weight.
Now that this is a standalone function. You can just do return InetAdress.get... here, and remove the temporary variable.
Check this right after lookupSourceProviderFuture.isDone()... or better yet, don't check it here at all, check in tryFetchLookupSourceProvider
Please add 2-length names like "fo" to original and expected arrays.
Since there are no compareAndSet(), do you think it is better to use a volatile Exception (Since there is no AtomicException)? Also, is this function required? Looks to me like you can just make the set() call and this is not really improving code readability, reducing repeated code or making things modular.
I think this is not needed...
This doesn't actually work in all cases. Since the processing of the stream occurs later, the connection backing the CPQ can close and it'll trigger an exception instead of returning the result. For now, just return the CandlepinQuery object as normal, and set the container type to "Iterable" in the yaml.
I'm consistently getting this failure at the logout step of this test (running the tests on a Pixel, API 26): android.support.test.espresso.NoMatchingViewException: No views in hierarchy found matching: with id: android:id/button1 The test seems to think it has successfully tapped on the logout button and fails because the confirmation doesn't appear, but watching the test run I don't think it successfully taps on the logout button. However, when I replace wpLogout() with the Me page logout() it passes consistently:  new MePage() .go() .verifyUsername(E2E_DEFAULT_USER_USERNAME) .logout();
Now that we no longer leak usage count on purpose and the usage count is now ignored anyway, I think we can get rid of this.
The following check may not needed, since this is done in the constructor. if (instance == null) {
@vbradnitski you can use the projectPermissions variable instead of recall the getPermissionsFromForm( form ) method.
I don't really understand why the context was used actually, does not make much sense. All you have to do to know the extending macro name is to call MacroDescriptor#getName().
I prefer to not have this here and instead let the InboundBuffer code handle logging like you did for NetSocket
should be based on guid only
use name() instead. toString() can be overridden
Dont catch generic exceptions. Narrow it down to something specific.
rename stopAt to stopAtNs
Line 147 and 148 are redundant.
Because there's nothing else in this method other than the synchronized block, we don't really need the local variable, you can just replace the assignments of listeners with return statements.
I'd put this if outside the other. but :+1: anyway... no need for locks, since the temp dir won't change (or shouldn't, anyway)
If you get line 145 to return then you won't need this line.
You can not be sure that the value is present in the local storage (see the storeVncData). Please wrap the ...valueOf(...) by try-catch
O(n) for changing the type (which should be static in a statically typed language) IS EVIL.
I'd prefer the condition to check lookup.getCount() but that's not a big deal.
The same here. I think this line is not needed.
Since we decided to remove LostApiClient#numberOfListeners() can this also be removed? I see its currently used in tests only. Can we switch back to using the ShadowLocationManager in those tests?
Safer to check if the stateType exists or not.
It's a personal taste, but I prefer:  java if (m_count >= m_objects.length) { throw new NoSuchElementException(); } return m_objects[m_count++];
The member variables in this class are scoped to this unnecessarily. Not sure if that is a style preference, just pointing it out. Looks like the same is true for a couple other classes in this PR as well.
You need to terminate the recursion on isSpecialWildProject(), and handle projects that have no parent (as their parent is All Projects). I would replace the method with: if (!localOwners.isEmpty() || isSpecialWildProject() || project.getParent() == null) { return localOwners; } ProjectState parent = projectCache.get(project.getParent()); if (parent != null) { return parent.getOwners(); } return Collections.emptySet();
Static import of Reflection2.getInvokableParameters?
Please use constants in airlift SizeOf.
Is there any risk of this being called where checkBoxes_ is empty, so checkBoxes_.size() - 1 would be negative and (I think) end up throwing an exception? Might be worth a check for this if any chance of it happening.
You should not need to instantiate your own executor here. executeScript is available for all subclasses of AppPage.
Constants.CONNECTOR
this.query = requireNonNull(query);
Can we test the task definitions repo to see if the task definition was created?
I think we need an attribute here. Otherwise there will be no differences anyway?
yeah no uniqueness constraint?
nit: keep args on line? Also valid for various methods in this package.
The bit is either set or not, so != 0 is a faster test here.
I would rather check for a null treeWithCondition here and return false rather than passing it into the condition method as a nullable.
Iterables.transform ?
Why, btw ORIENTEER_APP_HOME, but not just ORIENTEER_HOME?
Invert this so it returns early
Again, use IOUtils.
Let's just drop to DEBUG
Logger::info would also work here
better use List<Object> and ArrayList<>
Add rights checks at this point and only call saveXWikiDocCollection on docFormCommand if the rights are given. We need the rights-checks here because it is a call comming from scripts. In an other situation we can have a direct call out of a java process (even without a request, but only a value/key map) where we do not want to additionally check for access rights.
If disabledMetricTypes is an EnumSet, we could use EnumSet.noneOf.
Use computeIfAbsent instead.
Why we need to change this class at all ? I can not find a reason.
This honestly feels like we can static builder the individualized texts like all other builders instead of using a factory
Why are there 2 ErrorReportRequest classes?
Hmm, can you call this ctor with null flags at all (besides using reflection)? If you don't specify any, it gets new Flag[0], if you set null as last param, it will just get null flag...
I might be wrong, but it seems that mDeviceOnly is missing here. Minor: Wondering why there is this method to refresh/set Fragment parameters. Is there a way to switch the picker mode after its creation? I see it's used by the main activity in onCreate, when the fragment is already available.
This should be handled in item.getLabel()
You don't want to do get return ChecksymType.nameToType(conf.get(HConstants.CHECKSUM_TYPE_NAME, DEFAULT_WHATEVER_IT_IS)); Is this a candidate for StoreContext? (Perhaps if called frequently). Perhaps StoreContext is not available where this is used?
ok good, butr if at some point the org.uberfire.java.nio.file.FileAlreadyExistsException gets refactored, this code will be broken.. so probably results more safe for future updates just using the instanceof operator or just using the Class object instead, as: String fileAlreadyExistsExceptionClassName = FileAlreadyExistsException.class.getName();
Can this be taken from atsApi.getQueryService().getArtifactOrSentinel(), then checked for validity instead of null?
ShowAction? Not simply Config or even HideAction?
So if this **is** a single provider flow then we'll have both the big text and the footer? If that's not the case (maybe the previous method has some internal switching) let's make that clearer here by doing if / else so only one of the PrivacyDisclosureUtils classes runs.
Replacing using regular expressions is a pretty heavy operation. I think we should have some global flag to tell server to consider environment variables. Otherwise just use config. Also, it would be nice to add underscore between words in camel-case parameters. For example database.ignoreUnknown should be converted to DATABASE_IGNORE_UNKNOWN.
do we want to return a mutable version of the list here?
Why not support add and offer?
I would also check if the file is readable as well as existing.
major == 5 && minor >= 4?
We should catch the exception and return a RuntimeException instead, this shouldn't really happen anyways since we checked the URL is valid when building the client
why is this split into two lines?
I think it is better to exclude "from" and "to" objects from resulting list
Get /wiki/ from URLsContent class (WIKI_DIR) or it would be better to put a const to urlbuilder
do we need a boxed primitive here?
similar approach should be taken here, but the condition is simpler: try { endWithFailure(); } finally { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } }
Sometimes reusing PageBuilder is valuable (because it can predict allocations' size better?) Can we safely assume this isn't a case here?
A constant for this would be good also
some nullchecks and asserts maybe?
This pattern can actually generate a _lot_ of garbage. The add() to the List will result in binary growth of the underlying array and then in the end **_another**_ array is created to copy stuff into it. While it won't hurt anything here, this is a fairly bad code pattern to follow in general. Either way, in this case, I think the faster and less-wasteful code is even clearer:  AggregatorFactory[] aggs = config.getSchema().getDataSchema().getAggregators(); combiningAggs = new AggregatorFactory[aggs.length]; for (int i = 0; i < aggs.length; ++i) { combiningAggs[i] = aggs[i].getCombiningFactory(); }
It's using constants from auth instead of session.
This is not a particular good criterion to decide for/against Cursors. Views can have very fast Cursors, for example if you do a few transformations on an ArrayImg that concatenate to identity, you will get a ArrayImg Cursor (although your input image is a IntervalView or something like that). It would be better to look at the Cursor types.
I'm probably wrong but I thought since we don't sample client spans, calls from the span reporter thread wouldn't be sampled anyways, they originate from the flush thread not server requests. Why is this check necessary?
should be .debug().
I don't think that HelixClusterManager needs to be passed in a HelixPropertyStore instance. Also, the property store path in HelixPropertyStoreConfig on the frontend will refer to the wrong path since that config is also used by HelixAccountService.
This doesn't check if the event is cancelled. The flying field should only be updated after the event is fired, and only if the event wasn't cancelled.
fancy, but we should test that we are not going to sync with ourselves here.. o/w we would end up with some nasty infinite loops.
you could use find here too
Okay, I misread that. I see it's a parameter now. In that case, throwing an exception about an invalid timeout value seems more reasonable to me than silently ignoring it with a substituted default value.
use DateUtil.now()
I'm not sure about this assert here. Do we want asserts in the code?
this field could be retrieved from results.size() rather than stored in private field.
I would imagine that you have a new contains method that takes in patient object that internally delegates to the old one so you wouldn't need these changes
insert exists for such an operation.
Could we change the header name to "X-Client-Id" instead?
can be rewritten as return (dataBytes == null || dataBytes.length == 0) ? null : new String(dataBytes, charset);
Please add a message instead of empty string
the test checks nothing, because iterate() method always return nonNull object. It's worth to use forks.iterate("newest").next() and check for some attribute
static
Does it matter if you rotate the screen? Would this trigger update checks more than wanted?
I think this test is always green, because the assertion has no _check_ called. Let's check the concrete value, i.e. java assertThat(oneToOne).isEqualTo(Option.some("One"));
This line should be moved out of the assertThrows as only the provider.getService() call should throw.
null != containerEditpart is already checked in the outer if
Kill the third parameter to closeConnection(), we cannot skip calling close(). The "penalty" in the rare case where an exception _is_ thrown by close() is merely an additional log (at debug level!).
The comparator here is invalid due to the 1.... maybe replace with one that throws UnsupportedOperationException
move the null check as first action in the method to ensure we also throw if watcherThread == null and unit is null
This should _describe_ the credential. If no credential is needed, just say something like "not used" or so, but don't leave this null.
Why peer class loading?
Needs same MIN_RECEIVE_THREAD_KEEP_ALIVE_TIME guard as in the constructor
Prefer:  java int N = mHighlightDrawables.length; for (int i = 0; i < N; i++) { ... }  It performs better on Android (_sigh_)
could be generic and do the cast as well with:  @SuppressWarning("unchecked") <T> T borrow(GenericObjectPool pool) { ... return (T) ... ... }
Please add this to LunDiskRowMapper
For these timeouts, can you make it be 60 minutes instead of 1 hour and make the timeout configurable with a setter (with 60 mins being the default). I'm thinking we'll make this configurable in Smile CDR config (and of course HAPI FHIR users can adjust this setting in Spring Config)
please factor out this hardcoded path segment
I think is is a rename refactoring that went a bit wrong :)
I wouldn't implement this (just return null). A long has a fixed size, and we can use putLong() in HTInterval to write them to the file. This method was more for string, structs, etc. that we want to serialize.
splited is not a word.
UnsupportedOperationException seems reasonable here.
Maybe use Lists2.map() instead?
I think we should use binaryMessageConstructionInterceptor.supportsMessageType() here to have one source of truth for the decision, whether the interceptor could handle the message type.
Can't you do this in the constructor, and make the field fTopNode final?
@ILikeToNguyen Why the change to FINEST here?
Better to have this baked instead of doing it each tick...
Why is this error? Should we make this an info log? And "updating {} {}" is not detailed enough. Say something like "Successfully added metadata store realm {} to namespace {}!"... and put it after the call so we know it succeeded.
why not return here?
I suggest using InternationalizationKt.getRootLocalizer().formatText(key) instead. It returns the key if there's no translation.
change Location to Version
We can remove the print() to clean up our logs during testing.
Since this JSON string is copyrighted, should we use it in a public test case in our code? It might be better to avoid copyright issues and mock up a JSON string instead...
This is wrong. It's always returning an empty target.
The task cannot be created in a 'done' state.
Should this be containsExactly(1, 1)?
It looks like resultBatch is reused here. I don't think it's causing any problem for now, but I'm wondering if it could be better to create a new instance instead for better readability and code maintenance. Like, I had to look at a couple of classes to make sure that the values queue in ResultBatch is always fully consumed before adding new elements and there is no chance to increase its capacity. Or is there a good reason to reuse the same queue?
What about experiment names, override names, etc. as well?
![MAJOR](<LINK_1> Make this line start at column 7. [![rule](<LINK_2>](<LINK_0>
0, looks like magic number. Any possibility to give a non-zero value, matching closer to the expected value ? Also, please add error message - assertThat("error message", stats.getLast(), greaterThan(0));
This class is actually where this constant should be and instead the test class should refer to it. Or maybe not in the state provider, but in the analysis itself
why timestamp is not taken from the row instead. above is only meaningful for message-time rejection policy in this case.
catch should be on previous line. Also, is there a more specific exception type that can be used here, e.g. IOException?
I'd prefer we stored actual UUID objects, not Strings representing them
Should this test also confirm that the exception message contains something about the value being out of range?
shouldn't this be key?
are spaces OK in namespace strings?
I think this needs to be a getLongVolatile.
rename 'selection'
naming: consider renaming this and line 849 to elapsedMillis? Up to you.
What will happen here if the string cannot be converted? Looks like some error handling and protective code is missing
Why here an explicit typecasting is required ?
does this need an instanceof check or Assert.isInstanceOf?
Inline this variable.
Please use description() instead of descricao() on the method name.
If sourceProcessingDetails is initialized to new HashSet<>() instead of null then we don't have to check here.
No need to cast here.
Do these calls want to go away? (I.e. you're not drawing the box anymore?)
Shouldn't this line be in StyledText.isVariableHeight() instead of current impl ?
This throws an exception in case the queue is full. We maybe don't want to cause change of control flow for the operation that logs the event. Isn't is better to replace the oldest entry instead? We do this in MC so it seams the most fitting solution here as well.
we probably should change "Ace" to something else, since AceFuture is not the only thing using this.
Same as above (indicate trying different node)
Remove final. We dont' usually use final in a body.
explicit real ref?
Is there any reason to wait until the whole source will be prefetched before we start emitting rows?
Why do we call this variable request? We can also create commands as a reaction on other commands (e.g. in CommandRouter), can't we? In this case, this may not be a request, but just a unit of internal communication of the system.
Currently, only TestParquetFileWriter uses this method. If it is not really required to be public I would suggest having it package protected.
This equals implementation should include attributes from the Command super class.
Just for clarity, I'd make this a method (getUrlForBase)
This line isn't necessary.
We also need to synchronise the System.currentTimeMillis()
This will evaluate incorrectly
Why aren't we checking for mSyncthingService being null here?
I don't think that we need offline access (Calendar export is a quick one-off operation) and thus don't need to store credentials. I think you can just remove these two lines and DATA_STORE_FACTORY' as well.
- no need to force user pass "origin" (unless i'm missing something), we can define it here as only custom events are being added. - really? 'description' is mandatory?
why do you use deprecated constructor here?
Does 'schema' need to put back to cachedById cache?
please apply java conventions (spaces before and after +) and total amount of characters per line
translateable stings should be externalized
Missing @ since.
I think it is better to return an empty collection with Collections.emptyList() to be more null-safe.
I don't think this check is needed.
Maybe have the variable renamed to isFrozen as well? It's more grammatically correct anyway :wink:
Let's change to !isAnalyticsActive()
negative logic
Shouldn't the blocks move into the parent container (or the wrapper's parent)?
Since the logic switch, this should be true (former behavior).
Curious what does 9_000L mean? it doesn't look like a number.
do we need this anylonger?
Not sure reusing TimeStepActionTypeSwitch here is very clear? I can live with it if you defend it but I was expecting these type switch classes to only be implemented inline.
the called method initializeMetricStore declaration proceeds the calling method
boundedElastic
CopyOnWriteArrayList list may offer a better performance for read operations, which are dominant here
do we know since when openstack metadata is supported? I'm concerned of a scenario where customers have old templates installed with version of cloud init that doesn't support it
Will it be better to cache yarnClient on the YarnAppHandleImpl instead of creating it every time? In ApexCli the yarnClient is cached.
I think, we should use the "cycloVersion" here, too.
return cardTypes.stream().anyMatch(CardTypeEntity::isRequires3ds);
Also this consumer could be simplified by lambda but leaving decision to you. selectedKieSession -> onSelectionChange()
Are these changes to TypeInference part of the fix for default methods? If not, can we pull all changes to TypeInference into a separate PR, to keep things clean?
Likewise..
extract a constant out of the string literal?
Style-nit: Remove the added final keyword.
any reason why not to put the authz name in separate field instead of parsing and re-parsing?
Just curious on this change. Is it necessary?
Should remove system.outs...
Change this to INFO
I didn't understand why this is required. Let's discuss tomorrow.
Consider having the formatting parameter on a new line, which would allow to keep the string one piece.
Is there a need to shutdown the existing client, if present?
You have to start a new server if this test has @GerritConfig or @GerritConfigs.
Can you use return permits.computeIfAbsent(name, n -> new MemberCapacityPermit(n, config.getCapacity())); instead?
Use the aggregateFactory.getAggregateType()'s class loader instead
use NullStatsLogger.INSTANCE rather than plain null Also I think this constructor use this other constructor  this(conf, NullStatsLogger.INSTANCE, registrationManager, new LedgerDirsManager(...));
you can static import these functions.
how do you now in doAssertHasMethods that the error message is about declared methods and not methods ?
The same as above conf.containsAll(keys) seems more robust.
is this used in some other class? Can't be private?
The Exception is never thrown.
suggestion static boolean sanityCheckArenaBlockSize( long writeBufferSize, long arenaBlockSizeConfigured, long writeBufferManagerCapacity) throws IllegalStateException {  Line wrapping improvement
Would Observable.empty() instead and removing the filter part work as well?
throw new IllegalStateException(e)? instead ?
Since forEach doesn't use these values, maybe we can avoid sending them back to the caller by simply returning null.
It would be good to have another test with isHeader()=false, which checks that STATIC_ID does not trigger in a non-header file.
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
Same issue as above.
This means that the callback is now a dynamic reference for the service, i.e. it can (or cannot) come at any time during runtime, while before it was guaranteed to be be at least called immediately after being injected into the registry. Also note that this call was previously done in a safeCaller and now directly.
Does this exclude duplicates?
This is awkward, can't we avoid it by having the proper method in TestableTimelockCluster? If it's too much changing around, I guess it's fine, but we are reimplementing the functionality here...
maybe we should create a common utility function to build EventLoopGroups and do not duplicate this kind of code
Please, make this as diamond and there are a couple patterns.toArray(new String[patterns.size()]) in this class. I guess they are smells on Sonar, so would be great to fix them as well since we are already in this class. Thanks
This seems incorrect. Imagine a fault detector from one cluster trying to seal a node from another cluster. Since a seal message is marked as ignore epoch, the second check won't be executed and thus allowing fault detectors from different cluster to reconfigure each other's nodes.
How do we know which ClassLoader to use? I noticed sometimes the ClassLoader of the this object is used, sometimes the ClassLoader of another class is used (like in SamzaSqlApplicationConfig) and sometimes a custom ClassLoader is used (like ArrayListOnlyClassLoader).
sounds to me that if the anchor parameter is null you keep returning false here.
Should we check for endpoint could be null and throw NPE ?
I would log this one since it means we have corrupted data in our db.
Please no :-)
as I know there is no need to escape single quote inside double quotes
public static LocalDate deserializeLocalDate(String dateTimeString) throws IOException { return DATE_FORMATTER.parse(dateTimeString, LocalDate::from); }
Not a good idea -- this sets a thread local so could interfere with other tests. Also I suspect DynamicTasks.queue(anotherTask) won't run anotherTask because the TaskQueueingContext t here is never submitted to an executor. (Another reason to let getMachineDetails fail gracefully if used from outwith a TQC or executionContext.)
Probably uneeded but I remember and old issue with counted loop causing long time to safe point pauses: maybe would be nice to check if the range is too big and use a long based loop in that case
I'm not convinced this is really needed to free file descriptors... you don't close ByteBuffers, they're only something in memory. Anyway, to be safe, we could keep it as it is. However, it's be more simple/representative to make the fBitBuffer null here.
not synchronized
This is perfect to me
the .bagit folder does not have to be hidden. .bagit is our incubating next version of the bagit spec; it solves a lot of problems from the originial spec.
If this event is fired after a delete operation what is the **isInodeIndexed** method validating?
localize please :)
AllocateWriteIdEvent should take writeIds as well to ensure idempotent behaviour in target when apply. Better to pass TxnToWriteId list. Also, shouldn't use the regular allocate writeid flow in target. For repl flow, need to check if the latest allocated writeid > requested writeid, then noop. If allocated writeid < requested writeid, then throw exception as it is invalid usage where they skipped some events.
can you also change the other getSystemAdmins() to use this new one with the label = ""
how about to combine the two methods above (pass null device from the second method and then change the db query according to this field)?
remove useless code
This works much better :  java String templateName = service.getLabels().getOrDefault("template", ""); return templateName.startsWith("eap");
How about TXBegin() calling TXBegin(TransactionType.OPTIMISTIC)? Maybe it is more intuitive that way to implement default parameters.
Create a constant.
Obviously an extreme edge case, but randomArticle will be null if there are 0 articles in the DB, right? I guess a 404 is appropriate then?
This seems to be a step backwards, actually. Why wrap it as a StreamsException only just to immediately unwrap it again?
Did you mean for this method to be static?
if the descriptor is null, I think you should just return this (ie keep the property so that it is not lost)
Any reason why you changed this from the default? If no, please revert.
Any reason for this Integer extraction from Score? You can compare scores directly, I couldn't think of a need for this.
why Customer? Consider com.google.common.io.Resources#getResource(java.lang.String) instead.
This should probably be in a different PR unless required for this one.
I think it is better for performance to get the member first, check if it is not null and perform deserialization. Also safer.
In this and the disable section, you need to add the second half of the text (jLabel1)
Shouldn't we pass false if no protobuf entity is indexed? I believe there is support for queries even in that case, throught "brute-force" scanning?
You don't need to mock this anymore you can set the string and return it.
The View should know nothing about the data
I don't think it's a good idea to change this behavior. Instead, for the use case where you consider a non-existent requestId to be equivalent to a completed one, you should surround the call in a try catch and ignore the exception.
It's not default in syncthing, 60s is default in syncthing. The suggested value when folder watcher is enabled is one hour, yet in our case it's always one hour regardless if the watcher is enabled or not.
Does waiting 1 millisecond to call setPublications() really help?
Unused parameter - maybe consistent but confusing.
Could this cause a performance issue with misbehaved code that calls beginTask frequently? To be safe, you could check if the current progressBar has the correct style and omit the recreation & requestLayout completely.
Why not use assertNull and assertNotNull?
empty string is better, if that works.
While I appreciate the explicit-ness, I'd rather this value just be inlined into the method call. If you want to be specific you can do:  java addPathParam(name, value, false /* do not URL encode */);
Prefix should be forgeImpl$, not sponge$
I'd suggest to make this line shorter, even if it requires many ugly line breaks and string concatenations: checkXmlRequest( "hosts/123/setupnetwors", 200, "<action>" + "<modified_bonds>" + ... );
instead of testing assertThat(d.toJavaList(), is(d.run().toJavaList())); (that only check that toJavaList() is an alias of run().toJavaList()) I think we better test something like assertThat(d.toJavaList(), is(List.range(0, 1000).toJavaList())); (same for below methods)
and again.
@daisuke-yoshimoto You can use @Before and @After annotations on setUp() and tearDown() public method to reduce boilerplate code in tests for cleanup. It should be enough to rename cleanUp() with tearDown() and annotate it with @After.
Can't getSelectableMilestones(allMilestones) be done once at the top?
there is a typo here: threashold should be threshold (and at other places)
Since we don't use the subs return value here, I would suggest to just call client.executeBlocking without storing the return value.
Seems to be this whole for is equivalent to footnoteMacro.getChildren().clear();
Two ';'
Should we not call CompletionStages.join once for a combined CompletionStage of the delete and notify operations.
should this say "Refer to" or possibly ", using hadoop config fs"?
Small typo in variable name
nit Map<String,String> params = new HashMap<>();
Should this be logged at an info level as this isn't performing the operation as expected?
You could make this a simple CREATE TABLE (...)
Please remove System.out
What happens, if the endDate is null?
This should be ENVIRONMENT_UUID, not ID. ID and UUID are different values
Unneeded tern (it's always a creeper if it's reading this line)
java if (!keyType.isInstance(requireNonNull(keyObject))) { ... }
Not sure how I feel about having this as a system property. On one hand, it does make some sense semantically, on the other those are typically "broker owned" properties that the service controls where sequence number is something the client controls. I'm open to suggestion here, though...
rather than doing a substring here would it make more sense to use Matcher.region() instead?
erroR
Core.METACARD_TAGS. Could also do filters.allOf(filterBuilder.attribute(Metacard.TAGS).is().text(WORKSPACE_TAG), filters.add(filterBuilder.attribute(QUERIES_ATTRIBUTE).like().text(queryId))); filterBuilder.attribute(QUERIES_ATTRIBUTE).is().text(queryId))
I wonder if this should be ~~ or contains ignore case etc
we don't need the 2nd param(name.length()) in subString.
jobName is required and should never be null. Would prefer to throw (option.get()) instead.
Extracting this new Action1<NetworkStatus.State> as a collaborating class will clearly highlight it's dependencies and improve the readability.  static class NetworkAction implements Action1<NetworkStatus.State> { private final NetworkStatusDisplayer networkStatusDisplayer; NetworkAction(NetworkStatusDisplayer networkStatusDisplayer) { this.networkStatusDisplayer = networkStatusDisplayer; } @Override public void call(NetworkStatus.State state) { if (NetworkStatus.State.AVAILABLE == state) { networkStatusDisplayer.displayConnected(); } else { networkStatusDisplayer.displayDisconnected(); } } }
should this return an unmodifiable copy?
This could be assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, "").isEmpty()); for better readability. This is valid for all further occurrences.
These are default for bool and int so no need to clarify. suggestion
why not leverage stop(SamzaAppStatus.FAILED) up top? I like some additional logs. so maybe modify the stop(...) to include this logs for better debuggability.
Would it make sense to call flush() here to force the updates to the persistent store?
Instead of ShellIsActive, use ShellIsAvailable - its safer.
Please chain the expression. We don't need to create a variable here.
This variable looks like a copy/paste thing leftover from the split developer job.
Hi @FernandaCG Did you check the length of the EditText so that the warning doesn't get shown when the activity is loaded? I tested this and that is the behavior I saw. Good job We can take this a bit further though and utilize the Boolean object wrapper so that the initial value can be null before the email validation is done because if you click next and it shows the warning and you rotate the screen the warning disappears and we don't want that to happen
What if groups is empty at this point ?
For consistency, we have never declared to throw IllegalStateException for null checking. I think we should remove it for consistency.
Properties seems to store data in memory in its own map, is there a benefit to the unitColors cache?
Add "creator" and "lastModifier" to the STANDARD_ALIASES list at the top of this class. These get added to all the criteria used in PaginatedDataSource
return !disks.stream().anyMatch(d -> d.getImageStatus() == ImageStatus.LOCKED)
Can remove this line.
ditto & throughout code
Include TRACE changes from 1.2 branch
why not use die() ?
We still need to call to activateParticipants()
This need to be fixed, I'll get to today. GitHubEvent.RepoIdentifier should really have a builder. There will be a new release today.
You can just return builder.build(). We have an opportunity to debug/inspect already.
How does all replicas being local mean it's a dummy list? Only the 2nd half of this predicate is dummy list related.
Define as a constant even if it's used once.
Maybe an off-topic, but using longer self-describing file names could be helpful
Offer may fail. Use ComponentUtils.offerUntilSuccess the locking has been removed in that method <LINK_0>
I think you should do the same thing as HiveTableProperties:  HiveStorageFormat.valueOf(((String) value).toUpperCase(ENGLISH)
This method could instead return class MobileElement. return new MobileElement(element, driver); Then all the elements returned by complexFind can be easily cast to MobileElement. Additionally, can we have all the methods in this class return MobileElement rather than WebElement. Since driver has to be an instance of AppiumDriver, might as well always return MobileElements
Hmmm wonder if there is a better way to do this.
deprecated, use this ITmfTreeDataModel model = ((TimeGraphEntry) entry).getEntryModel();
logger will never be null. Don't need the null check here.
Can this log statement contain a message, changed to DEBUG level, or be removed?
Instead of keeping track of readBytes you can use ByteStreams#limit
spacing
you don't need 'this' in waitForElementByElement method. We are not using it so please remove it to have consistency inside the repo if there is no specific reason for adding this
There isn't really a need for any unSet as each check against the clockBit (observed) should reset the clock bit.
Why are we throwing generic exceptions, shall we only throw relevant exceptions
errors should be properly logged, and not just printed to the system error.
This is totally out of topic because you just move this if block from CoapEndpoint to BaseCoapStack but I can not get the point of it.
Hi @sureshanaparti, could you please use CollectionUtils.isEmpty? It checks if the List is empty, returning true in case of null. (<LINK_0> Thanks.
Here, you can do the Charset.forName(encoding) trick.
nitpick: this class should have only one public method: upgradeStorageConfig
Please change the code to match how it is now replaced. I just wanted to be sure that there was no exception thrown here.
Empty lines...
make this synchronized, just in case
Optional: replace these System out with LOG statements
'needs 2 _arguments_', plural
As the next line is fInputHandler.save(...) and text and model are synchronized, is there really a need to save the textual editor as well?
Still using assert here
You can put ShutdownNow() to the finally block.
Euh ... do you test if "Harmonization Study ID cannot be null or empty" is null or empty ? Did you test your code ? ...
Add @Override. Same with afterExecute.
camel case variable names
this is incorrect place for command
Hmm, I honestly don't know if the "&" should be here or in the reviewed constant?
1. add the border size to log as above 2. also think about need of taking screenshot here and in the below methods
Instead of using contains("account location URL") here, the account constant could be used instead (i.e., contains(ACCOUNT)).
use checkNotNull or java requireNonNull
Could be return parents.stream() .map(doc -> doc.getAdapter(BundleGroup.class)) .filter(Objects::nonNull) .map(BundleGroup::getId) .collect(Collectors.toList());
Isn't this going to be slow on low end devices?
_id could be a combination of both attributes, to ensure consistency even when not enforced by the application layer.
This could be protected or package-private.
i think with this you can just use new Object() and synchronize on that object
hm... why two? where did you get this number?
mInterstitialContext should probably be cleared here.  if (mInterstitialContext != null) { mInterstitialContext.clear(); mInterstitialContext = null; }
This (and others using ScanTarget) could be just package visible to not expose ScanTarget, the methods with the ID of the scan should be enough.
similarly to the cases above - the review and bug pattern share error reporting
This is the case at startup, right? Maybe just == -1L instead?
Add 8 bytes for the key
You should use the defined constant here.
Why not just use AtomicBoolean.getAndSet()?
I would usually discourage doing any real work in a constructor. This often can cause bugs because when the constructor throws an exception a partially initialized class often will not be correctly cleaned up.
This can use ImmutableDataCachingUtil
No need for null check.
Optional.orElseThrow
Why getting through a test here? owner = excludee in both cases
What happens if its not a ConfigurableApplicationContext? probably better to take a class cast exception. It should never happen, but we don't want this to silently fail.
The method name is weird. this.isReadAllowed might be better.
I think this should be something like baf.setLength(baf.getLength() - lastLen)
What happens to an Iterator instance extant over a fail-over? I'd expect a "nice, clean" termination on the next next or hasNext call. I see that org.ehcache.clustered.IterationFailureBehaviorTest has a test that appears to cover this. Following the call path, it looks like this might wind up with an IlegalStateException wrapped in a StoreAccessException wrapped in a CacheIterationException.
I can see that this is taken from the way that WavelengthEditor works. In fact it pains me to admit I'm originally responsible for this SuggestibleString business and the fact that it is so mutable and nullish. I wouldn't do it this way these days though. At any rate, a slight improvement might be to add a copy method to Focus: java public static final class Focus extends SuggestibleString { public Focus(String value) { super(FocusSuggestion.class); setStringValue(value); } public Focus() { this(FocusSuggestion.DEFAULT.displayValue()); } public Focus copy() { return new Focus(getStringValue()); } }  and then java import edu.gemini.shared.util.immutable.*; public Object getValue() { return ImOption.apply((Focus) super.getValue()).map(f -> f.copy()).getOrNull(); }
Could we change this back to the ERROR_NOT_INTEGER constant? Geode Redis should return the same errors as Redis.
unnecessary throws (same for the constructor above).
If follows the top code, we can use pageViewCallback.getOnbardingPageView()
suggestion logger.debug("Connection[" + index + "] is lost. Reconnecting to resume...");
Not worth using the switch
remove
Shouldn't this go to the log, at DEBUG level?
Could task be null here?
We have a NullChannel implementation that does what you want here. Use that instead.
I believe it would be good to return boolean to signify the success of this method invocation.
Return value of the method is never used.
A single variant is not enough to convince readers that the use of (  "call", args) works correctly as varargs. I would expect to see closures with zero, one, and two or more parameters, as well as implicit it.
Good it is the way
It looks like we still need to cancel the pingTask in the receiver. Add Lifecycle ? What about closing the folder?
why not call onBind first (i.e. in line 83)? do we conflict with something?
(first).hasSize(3);
as the initialized list is an immutable list, this method should make save, that the provided list is made immutable too, in order to give a uniform behavior after replacing the original emptyList
Use try-with-resources so you don't need to manually close the session.
Why do we need to interrupt the current thread? Wouldn't throwing RunInterruptedException be enough?
StringUtils.substringAfter
suggestion + " characters should be renamed to conform to a "+MAX_NAMESPACE_LEN+" character limit. "
Missing <>, this is a raw type.
Why not use specific constructor instead of invoking setter later on existing object? GetFilteredAndSortedParameters params = new GetFilteredAndSortedParameters(max, QueryHelper.parsePageNum( QueryHelper.getConstraint(httpHeaders, uriInfo, "", modelType);));
why did you remove the lambda
Let's use a proper if/else statement here please.
More on code quality discussion: StudentFeedbackSubmissionEditQuestionsWithResponses/FeedbackSubmissionEditResponse  are something related to UI while the method actually should check whether the data exist or not. If u take a look at FeedbackSubmissionEditPageData. You will find that we add fake FeedbackSubmissionEditResponse and set isExisitingResponse to false to just make the UI correctly displayed. My suggestion is to check the bundle instead of the questionsWithResponses as questionsWithResponses is generated by bundle (Single point of truth). What do u think?
the context is not closed correctly in this method (it is done in the invoked saveRelations) better commit/complete here. A proper exception handling is required to avoid future connection leaks
this assumes annotations will be the first children among modifiers, but that may be false. public @Override static @PostConstruct void foo() { } is completely valid Java code.
s.a.
Aren't the \n and \r supposed to be doubly escaped like the \\s below? Shouldn't we be splitting based on the java platform line delimiter instead of assuming DOS/Windows?
assertThat(related).isEmpty();
line 61 on line 60 and align with parentheses in ArcBees's projects
Some HTML elements with other class?
Why do we need compensation data here?
Why the rethrow? Don't want IO leaking all over?
Assert that it actually contains the just created snapshot?
suggestion .stream() .map(UserRole::getName) .map(SimpleGrantedAuthority::new)
Possible npe ''' GerritServer server = getServer(serverName); if (server != null) return server.getConfig(); else { return null; } '''
More English. All three lines above.
This could be made into an ImmutableList
BUILD_TOOLS_VERSION?
add generic
You don't need to typecast if you change it to int.
Would the following also work? java if (driverPool.isEmpty()) { return new DriverSetup().instantiateDriver(); } return driverPool.remove();  It feels safer to limit the number of interactions with driverPool.
? We would have gotten a ClassCastException above.
Need to implement
looks like wrong fix
Lets remove these type of new lines.
Could the method use the countInputStream field instead of a local variable? As in:  countInputStream = new CountInputStream(csvSource);
Add Pagelogging
We should make this immutable to allow manipulation only via the CaffeineCache class.
Perhaps using getDimensionPixelSize would make it more obvious that pixels are returned. I remembered you rightfully complained about this method in Slack.
modelMapper and userRepository invocations are not verified
new MissingTabLayoutId**Exception**()
This is the kind of _set_ that you will not see coming should this not behave as expected and you start looking. I wonder if there is a better way where the config and the notifier interact a bit more obvious with each other.
Storing either the config or the defaultHistory period should be enough- doesn't look like there's a need to store both
Why not return a list of strings instead of a list of single-item maps that all have the same key?
Remove this line. ChangeDetailFactory seems not to be needed any more and can be deleted. The only using files seems to be PatchDetailServiceImpl.java, but there it is also not used and can be removed.
Formatting
Maybe we don't even need a passthrough filter, and just use null and do delegate == null ? chain.doFilter(request, response) : delegate.doFilter(request, response, chain) to avoid adding more delegation and stack levels.
I don't think this change should be made. This is the same as the host remove discussion we chatted about before I realized the host remove didn't require reload: 1) Deployment is deployed and is using various hosts. 2) User removes subsystem; we don't change runtime, we just report that reload is required. 3) User then triggers redeploy. But now there are no mappings so the deployment isn't available. Now, in reality, removing the subsystem is going to recursively remove the hosts too, so they are going to go away, not requiring reload, so this doesn't really matter. But having this here can be a cause of future bugs, and clearing in subsystem add is enough to deal with the reload case, so I think that is sufficient.
It would be good to have an info message here that the listener is stopping.
resetFlowCountAfterSave, the "s" is not needed.
These methods have associated commands in datadog-agent (stuff like datadog-agent jmxfetch list-matching) that is expected to print to stdout always, as it's a debugging command. These LOGGER.debug changes, unless I'm missing something, would make it subject to the log level, thus potentially breaking the agent commands. If we're going to keep this, it should probably be info or warning at the least - still maybe preferable to print to stdout....
Question: what scenario can lead to a null cacheAttribute?
why aren't we just getting this live each time? It doesn't feel like this is a super expensive call?
indices == null && indices.length != 1 is wrong, do you mean || ?
Just seen that this "key id formatting convention" is applied everywhere. Better create a static helper randomKey() to generate the key ids?
The SystemCommandTasklet allows the injection of a SystemProcessExitCodeMapper to map exit codes from system processes to an ExitStatus. Any reason not to allow that type of mapping here?
Style-nit: Spaces around operators like +.
Does this give a friendly error message when it fails?
I think this method is called not only upon downstream RPC, but also on task shutdown and other cases. If so, completely skipping of super.releaseAllResources can lead to resource leaks in those cases. WDYT?
It should be fine if this is done without checking for the dev environment too right?
This should be IllegalArgumentException since the argument is invalid. IllegalStateException means the class is in an incompatible state for the current method invocation.
Can we please out the parallelStream() call. It does not offer much benefit and causes a stream to possibly cross threads. Many server environments are sensitive to arbitrary code just running on ForkJoin.commonPool() In this case you are likely to have < 10 messages. There is no benefit given the possible problems
Better use method reference
here also - it should be take(length - this.length()), am I right?
This predicate here looks copied and pasted over and over again. Please split this out into a method in case we need to change this en masse (say we add a new role type). Your IDE probably has a refactoring tool that can help.
Because of the AIOOB exception above, this doesn't work. I wonder if we should not clear more broadly, can we tell the viewer to clear all its data without having to tell it what it was?
nit java this.client = requireNonNull(client, "client is null");
@lautarobock Here too, let's declare throws Exception.
Given these values are ignored, could we use then and thenMany?
Was there a reason to change this to info instead of trace?
Isnt this the same as Couldn't figure out the idle timeout from configuration. Will assume this to be the DEFAULT_IDLE_TIMEOUT ms
Need to handle this exception
In Context and Keys you use DRY_RUN_FORMAT_TYPE. Let's change this to be consistent.
Why not use the connection provider ?
just a thought about dropping this config in favor of neo4j+s scheme
nit: can we pull the createType call into a local. I really don't like the wrapping here.
we should change this message to reflect the actual stored credentials (cause that link wont hold true) so assuming String cacheDir = // the stuff on line 81 "Couldn't refresh the OAuth token. Are you using different client secrets? If so, you need to first clear the stored credentials by removing the file at " + userDir
Shouldn't storageDomain.getDiscardAfterDelete() be used?
log-messages-bytes-sent?
If you put a name, these wrappers will start appearing in the lists IIRC
Better to move this to finally block
Shouldn't an ExceptionDialog be thrown when it fails loading in the newick file?
should be int
Any chance you could add a constructor which takes just metadatsource and metadataTermCode?
Since this is a general toString(), we probably should handle manual assignment as well.
); should be on the next line
the list should contain right child's desired traitset.
Move this line after logging the error, so in any case the error get logged.
@fanifieiev the same above.
Can be simplified to : java boolean failOnMissingField = tableOptions.get(FAIL_ON_MISSING_FIELD); boolean ignoreParseErrors = tableOptions.get(IGNORE_PARSE_ERRORS);
Should be case UNDERSCORE. default should throw CucumberException
RuntimeException?
Perhaps we should print a warning if we disable the current?
not sure that catching Exception is a good idea. how should a user get to know and report back? Should at least log.
This should say "to an opponent"
IIUC, repo must be NotebookRepoSync, so it would always be NotebookRepoWithVersionControl
I think we should add a limit(...) of say 30 items here, at least unless paged fetcher are implemented.
excludedColumns.contains(Integer.valueOf(ind))
This method should be protected instead of public
I think this should catch the particular type of error. I guess it's ClassNotFoundException to be caught?
I hope there are no sensitive environment variables or system properties
I think that using a ConcurrentMap for statBuckets (and putIfAbsent() here) would allow to get rid of all explicit locking (and would also most likely have better performance as locking would be much more fine grained. It would require to add some locking to RollingHistogram (making its method synchronized should be sufficient).
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
outerIndex
Maybe we could have constants for InferredTypes.runtimeType("int") and other types to avoid reinstantiating them many times.
Remove a nesting level by inverting this if-statement.
the same check is done in verifyVirtIoScsi, why repeat it?
Move to setUp(). You can make mCameraId a local variable again.
Why protected? The default is package visibility which would make it accessible to the test class. Protected = package + subclasses.
remove double a valid from the test & original exception
Why wouldn't we want to swap the cursor when the main activity is searching?
These are all trivial lambdas, although it's not a high priority
Is this problem appear only for our sample app? Maybe we need to move it into skin
use .getUuid instead of getArtId, which will go away
Why do you use checked exceptions here?
remove the bracket.
Might be worth making it only work if it has free space in the inv. as this will just void the items once full I think?
the tracecontext here in currentSpan should be the same as what's above set in context.setAttribute right? as there's some cost to fetching it, I think we should remember or reuse the context value.
If there is a noexcept-expression, it needs to be evaluated. In the current AST formulation, that would be done using ValueFactory.create(IASTExpression), but once we start using evaluations it will be ICPPEvaluation.getValue(). This applies to several other places in this patch where currently we just check if the noexcept-expression is null.
no change from patch-set 3?
You don't need this, nobody was listening on the "Role" property changed event. Therefore the whole ObjectUtils.objectsEqual() check isn't necessary either, you may just set the member. (the case could have been different if this item wasn't always available in the form, see the different constructors of FormItem)
Please make it consistent with other places: <LINK_0> Possibly updating TK103 decoder would be even better.
@inverno remove this check and make getParent return JSTree
I would prefer to keep the "old" style, since this was a long time what the clients got. Honestly I would probably prefer to throw IllegalArgumentException, but I fear that this could be a breaking change. Let us try the compatible way first and add a TODO to check if we can safely change it to the "usual" way of handling illegal arguments?
-1 to this. but not a deal breaker. We do it in other places, just not very consistently. It stands out here since later in the file we just do configMap.containsKey...
What can be null here?
I think you mean FirebaseListAdapter.this here, (rather than FirebaseRecyclerAdapter.this)
Please delete this blank line. This isn't guarded by any permissions, which seems non-ideal. The only caller here should be the system process, so how about a check similar to verifyEncryptionPassword earlier in the file ?
Wouldn't it be simpler to call: <code>this(ThingTypeXmlResult.class, "thing-type");</code> So, we do not need to add the two new lines on both constructors.
Character.toTitleCase() because of [What is titlecase? How is it different from uppercase?](<LINK_0>
instanceof ?
Does this still need to be public?
Calls to get() may fail at runtime, getOrElse is recommended or we should return Option<Disperser>
This clock should be a constant like the other one (or the other one should be a local variable; I don't mind as long as it's consistent).
Why does this throw an Exception, and not just return false?
Is it possible for this to happen from the main server thread in the actual tick loop, or would flushing be too expensive there? How does Vanilla achieve this?
suggestion if (castTargetType.toLowerCase().indexOf(clobCompatibleCastTargetTypes[i]) == 0 && (castTargetType.length() == clobCompatibleCastTargetTypes[i].length() || castTargetType.charAt(clobCompatibleCastTargetTypes[i].length()) == ')')) {
a testcase for this maybe ?
Make this a constant at ApplicationConstants.
Would suggest using another MapID for 006 and 007 to break dependency from 001 and 002 to be successful
Guard by isDebug
Just checking...boot order _greater_ than zero means this is a boot device?
Since this is public class, I'd check for null here explicitly - just like we do in our public static methods.
For consistency, should this also be changed to SSLContext.getInstance("TLS")?
Please use guava Preconditions to check the arguments. The class fields should be final if they are supposed to be immutable (which seems to be the case), and they should be checked for consistency (not null and so on)
This is not accessed anywhere else. Please make this private.
the second sortChannels -> sortOrders
1ms=10^6ns
suggestion @Override public void onSaveInstanceState(@NonNull Bundle outState) {  Can we move the @Override annotation to a separate line than the method declaration for code style consistency?
Removed condition:  if (getTestIgniteInstanceIndex(igniteInstanceName) != 0) cfg.setClientMode(true);  means, that all nodes, except having index=0, should become client nodes, i.e. _one server and multiple clients_, but these lines:  startGrids(NODE_CNT - 1); startClientGrid(NODE_CNT - 1);  will start _multiple servers and one client._
This function has some bugs.  default> \d test table name: default.test table uri: hdfs://localhost:7020/tajo/warehouse/default/test store type: TEXT number of rows: 1 volume: 40 B Options: 'timezone'='Asia/Seoul' 'text.delimiter'='|' schema: t TIME ts TIMESTAMP d DATE default> \set TIMEZONE GMT-9 default> select ts from test; ts ------------------------------- 2015-04-30 21:01:23 2016-04-30 22:02:33 (2 rows, 0.016 sec, 0 B selected) default> select date_part('day', ts) from test; ?date_part ------------------------------- 1.0 1.0 (2 rows, 0.021 sec, 0 B selected) default> select date_part('hour', ts) from test; ?date_part ------------------------------- 15.0 16.0 (2 rows, 0.024 sec, 0 B selected)
use one of the supported types.
Question, is MetricCollector designed for Rebalancer metrics only? If not, here it is hardcoded.
why changed from static to non-static?
should return null if hasTimeEvents() is false
You can use Optional.ofNullable(...).ifPresent(...) or flatMap constructs here.
Please remove unnecessary brackets: return (RestartVdsReturnValue) super.getReturnValue();
![MAJOR](<LINK_0> Change this instance-reference to a static reference. [![rule](<LINK_2>](<LINK_1>
This can also be package private :)
This change is causing SegmentMetadataQueryTest.testSerde() to fail: <LINK_0> The query variable has a LegacyDataSource whereas the deserialized serialized version has a TableDataSource.
To follow convention, formatting here should be: java private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {
and this one
still mark nullable
I think it is cleaner to make it a method: getContext() in the Builder so we do the checks there.
Again with the platform encoding.
Not your change but having public constructors for test mocking seems a bit suspicious.
Error handling is incorrect, hiding request errors.
same here as well, null check for options
can this case be given? I mean having an entry for the given uuid but with no registrations?
can't this be defined as a List<DiskImage> ?
Spare semicolon ;
>byte[] [](start = 11, length = 6) KeyUnwrapResult with one property key
Why all this INFO level logging? I think that can be removed or use DEBUG.
This should probably be referenceBinding == other.referenceBinding (see ObjectVector.containsIdentical())
I don't think we should ever allow this condition to happen. We never returned null in 0.6, and this could be devastating for complex metrics that always assume some initial non-null value (e.g. HLL).
These debug statements don't add much, as jarFile.toString() is just getClass().getName() + "@" + Integer.toHexString(hashCode()) At most one per file should be sufficient.
suggest:  Param sensitivity = f.getAnnotation(Param.class); skip = (sensitivity != null && sensitivity.isSensitive());  extra changes are needed fro this on the response classes.
I don't think we need these two ifs as we shut down the executor afterwards.
There is this variant to simplify the code here: queryForList(String sql, Class<T> elementType, @Nullable Object... args)
Formatting.
@panchenko Looks good. Would you mind using TextUtils#isBlank here instead, please?
space after +
Push synchronization block into method.
I'd probably reverse the equals here to avoid a NPE, just to be on the safe side. Something like AlatirParams.Mode.LGS_P1.equals(_oe.blah blah blah).
@Nimfadora , here is a nuance. All checks have to clear all internal and non-property fields in beginTree method to make sure that no context is shared between two files validation. For all files we create only one instance of Check object, so on beginTree it has to reset all to initial state. To reproduce a problem, please launch Check on few files. Yes, we usually test Check on one file only in UT, but in real life one instance of Check is used for all files of execution. You need to make UT that executes Check on two files.
hardcoded value instead of argument? :)
It seems like the ctor does not check for null value but addValue does. We should either consistently do the null check.
suggestion return Arrays.toString(value);
Probably don't want to have a dependency on LambdaTest here?
LHS is wrong here
That second String.class should probably be Bitmap.class (also, check the generic type inference missing in CloudIconModelLoader).
Why not IStatistics<Long> ?
Nit-picky minor: other tests in this class use for-each loops.
remove system.out when debugging is done
Will it cleaner to call lock.shutdown in the server shutdown call?
Since this is a noop, we can remove this and the dependency on the result storage engine. For other storage engines like S3, there will likely be another mechanism to remove objects (like auto expiration).
Looks like you have changed your mind and decided to not use this setter in the ctor. I mean doesn't look like there is still a justification for a final...
Now that we have the constraintType , we need change this to something like this: suggestion if (!isEmpty(constraintValue) || constraintType != null) {  Otherwise, when the user selects the "Expression" type and leaves the expression blank, the _Expression component_ wont be loaded.
Good catch here, can we also update line 64 to reference datasets[1]?
Minor nit, but maybe have a final local variable for getAggregatorExpression() since we call it a number of times.
Why compare hashCode? Why not compare storeName or reference equality?
This should simply invoke the new method.
fix all string concatenation in this file
ok, value may be null!
From debug perspective it would be good to add some info about the host.
You need to call configureConsumer
What happened to the forwarding entry?
shouldn't this be filteredOptions = ListUtils.filter(filteredOptions, predicate);
Since the userAgent is set here now, [Line 195](<LINK_0> can removed. Since it is never initialized, it should be null there anyway.
return the object immediately. Sonar will complain. This counts for all the methods here below as well.
if I am right, when we are here, we already logged out the exception, if we had any. But we can also get here from the shutdown() function, when we close the socket just without catching any exceptions. What about instead of LOG.error("Unexpected exception... just print out a LOG.info about closing the socket, and also indicating in the logs if we will do it sync or async?
What if it the nested launcher is a delegating launcher as well? I would expect the method to continue the recursion then.
IMHO can you a no-argument C'tor.
You could make the connect method return a Future, which would allow you to await it in this test, which avoids this ugly sleep. Same for the other method a couple of lines below
ping ?
We can avoid the database lookup here and use the username cache that is within the byId cache: AccountState as = byId.getByUsername(userName); return as != null ? as.getAccount() : null;
Verify that the created deployment exists.
Why don't you add the extension directly?
Is it mandatory? The names should be already cached upon calling 'addAuditLogCustomValues', which is invoked on CommandBase's execute flow (execute -> logCommand).
Since you created the stored procedure just for your use case you can adjust the query to take a list of device types instead of firing the query two times
hash()
What's the benefit of using Optional instead of returning null? In what way would it make a caller's life easier? I suspect instead of simply checking for null a caller will end up doing Optional.isPresent checks (maybe hidden in an ifPresent with a lambda thrown in for additional complexity).
As the test method name suggest, we should probably leave readUnsignedShort call here.
line-wrap? this seems pretty long.
Qu: is it worth creating a variable for this since currentThread() is native ?
Should probably be at the end of the method.
Again would be nice for this to be a mock/fake rather than a spy.
seems, don't need map method
it's better to use FirebaseAnalytics.Param.VALUE as the parameter here as Firebase [auto-aggregrates over that](<LINK_0>
unmodifableSet(Sets.newHashSet..
No need to check view type above. table.getTableType() suffice.
Please consider using Objects::nonNull instead of lambda
consider make this private as it's not called elsewhere.
Why did you add here a null check but not in the other methods which access the given JsonObject in the same way? Maybe you can switch to Objects.nonNull call.
You need to preserve the escaping functionality of getUncapSimpleName(), that's the reason for the QPublic and QPrivate issues (public and private can't be used as variable names)
here too - can you explain?
Change loadBuildNumber(System.getenv(), properties); to loadBuildNumber(properties); once the BuildServerDataProvider also has a reference to env...
Is runQueue used anywhere?
Why this. here? You delete it elsewhere.
Should we use pushInlineDeployments here ?
This looks weird, what does it mean to watch null?
can extract string to item_id
Use the SEPARATOR constant here.
Do we really need a switch when this is really just overcomplicating an if...else or even a ternary expression? (Sorry if any of these have repeated... I thought I made a mistake.)
hashCode might look simpler like java @Override public int hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); }  But I'm OK with current way as well.
elvis notation?
Exceptions.launderedException is being removed, so avoid calling it here. Just wrap and throw RuntimeException.
can be replaced with 0L, similarly other casts can be ommitted.
I'm not sure if this is not breaking something. Looking at the source code of PGPUtil.getDecoderStream(InputStream) I can see that the provided InputStream is wrapped by a BufferedInputStream if the provided InputStream doesn't support marking, which is the case for the FileInputStream we provide. When the BufferedInputStream is closed it is ensured that all bytes from the buffer are written to the stream before it is closed. By the change above 'in' now only points to the FileInputStream, but not to the wrapping BufferedInputStream returned by PGPUtil.getDecoderStream. This means on in.close() the FileInputStream is closed, but the close() method on the wrapping BufferedinputStream is not invoked.
A cleaner way could be numPlayers = players.size()
Should we move the metrics code outside the exception type check? Seems like we should record the errors even if it was a non-transient exception.
For curiosity, will this method be called by multiple threads?
since we are talking about 128 bits, I'd use bits as the measurement, not bytes
You've managed to add the handler, why are you returning false?
style nit: missing braces
this distinction isn't necessary; new TimeoutException(timeoutMsg) will work in any case.
Please make this method return an URI. Stringifying can always be done later.
So here you do use ObjectUtils. Why not use it in the previous class I reviewed?
Again, seems like it would be easier to fix with an alignment property somewhere.
_verify
No need to check for empty
Please return filter(partialFunction::isDefinedAt).map(partialFunction::apply);. We try to omit if-branches if possible.
Wow!
Whoa been a while since i've seen bitshift code - fancy C stuff here!
Duplicated line (probably global replace)
It is outside the PR code, but I would like to share concern:  for (String pattern : this.patterns) { if (PatternMatchUtils.simpleMatch(pattern.toLowerCase(), header)) {  The pattern.toLowerCase() should be done only once during initialization, but not on each header.
This should return a URL
I'm not sure that the effective compatibility version is correct here as well, elsewhere we use 'getEffectiveCompatibilityVersion', better to use it I think
What message did we get before (just out of curiosity)?
Please Change to externalSearch
if space ( (...)
Where is the false coming from and why is it false? Consider moving it into a variable with an appropriate name to make it easier to understand the code.
return 'true'
@vilchik-elena What about expressions comparing a string and a non-string (e.g. a number)? Are they valid comparisons? Should we have separate rules for those cases?
nit: I guess it seem not very readable for message like .....releasing asyncCheckpointRunnable, 12. Maybe change to ......releasing asyncCheckpointRunnable for checkpoint 12? (Take checkpointId = 12 as example).
I'd suggest test them in alphabetic order, easier to read.
you can use url builder here.
My point is that this is probably just an Oracle-specific thing. Since Oracle is really the only database blurring the line between schema and user and therefore it probably doesn't belong in this general interface and should be kept to the Oracle-specific part.
Looks like we silently revert to totalTasks if the used entered an invalid value. Shouldn't we error instead?
Should this be package-access instead of public-access? Callers should use ArchiveRetrievalJobRequest.builder correct?
Could you refactor this out into a checkReadable method which raises?
this can be more simple as getGlusterVolume().getVolumeType().isReplicatedType() && getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount()
A TreeSet is a SortedSet. We can't check for equality here because insertion depends on the underlying Comparator. Please restore the previous version.
not related to this pr, but could we just do isDeleted = (dataStream.readByte() == 1); here?
dog.addChangeListener((RealmChangeListener) null);
Should inner loop be inside transaction?
typo: reasion
Can object be not null and hasAlternativeContent == false ? You could probably set object to null whenever you set hasAlternativeContent = true, that way you won't need the class to keep the state.
remove this method
You have many problems here, I prefer to create a ZipDataChecker object in class as a field.
i'm wondering about the "length >= offset" check, does that make sense? 'offset' is represented as a position in the array and 'length' is just a length...for example the offset could be '100' but length could be '20' (including the padding 0's), and should actually be, say, '18'...but we won't remove any zeroes because the 'length >= offset' check will fail immediately should it be (offset + length) >= offset ?
Can't we have a property on the matter and update it when setDeclaredName() is called? That's might be over-optimization, but still - curious what is your opinion :smile:
should we return true when an exception happens? We don't want to prevent people from accessing our app if something is wrong on our end. it's ok to have someone use more than what we'd like if something is wrong on our end.
Should work with static. In my imagination it results in one ExclusiveRule per command instance.
kid shouldn't be set from the input. That is assuming that you have the correct keys for the jws, which may not be the case. Further, this would prevent any support of rolling keys in the future.
Nice feature -- refresh all after .items file changed, right?
es gibt einen .andExpect(redirectedUrl("XXXXXXX")); matcher
We could iterate over this with prefScreen.getPreferenceCount -> prefScreen.getPReference(cout) and just hide anything that doesn't show up in the whitelisted keys, which would be a bit less verbose (and less error prone) than building both lists and diffing
Should specify the generic type to avoid warnings: AvroItemWriter< PlainOldUser >. We have a couple of them in this test class.
Please do not use an if-then-else to make the differentiation between 5 and 7 stars. Instead create a new method in the connector interface, and implement it to return 7 for your connector, and 5 for the AbstractConnector, where every other connector is derived from.
More concise version: options.overrideLoginPassword(passwordOptional.or(Passwords.generate())).
I would return ""
Are the tests assumed to be running on an arbitrary windows machine or do they operate in some sort of controlled environment (I.e. no need for the real windows installation in c:\windows). If the tests may be executed on a real machine, I think it's a bit too optimistic to assume that windows is always installed in C:\WINDOWS. You should probably be using %WinDir% and %SystemDrive% environment variables in order to figure out the actual location.
Shouldn't you handle the NumberFormatException?
Should the new getApiKeyActivityMetdata method be called here? And ActivityMetadata object be returned?
Please not here. This is not a standard SWT table.
unnecessary parens around dir != null
suggestion Unit(String symbol) {
@CTI777 same here.. the check is only on then User endpoints.. if you are admin you can execute the operation no matter what..
Adding this to a field is good manner.
@Inject
You may be able to avoid compiler warnings about raw types by phrasing as: return type instanceof Class<?> && ((Class<?>) type).isPrimitive(); You can use the straight-wildcard form of a generic type in instanceof and casts without issue.
i suggest you clean up the artifacts you created for this test once it's complete.
Consider using assertEquals on the html instead, here and below - since it makes tests much easier to maintain if they start failing. You might want to make this test class extend org.eclipse.mylyn.wikitext.tests.AbstractMarkupGenerationTest, since the toHtml and assertMarkup methods make it a lot easier.
I don't like this and I am not totally sure why. It smells like I could get a WFieldIndicator with a bogus selector and as long as I got a span this WebElement would be happy. This is most likely a reflection of the poor quality checking I put into the earlier WebElement extensions but I would prefer if new extensions were a little more strict. Please check HTML class for wc-fieldindicator as well.
I noticed this constructor is deprecated. Can we use the not deprecated one?
why we're not using contants from PlainJavaProjectConstants ?
This might not work with some caches since Resource isn't Serializable. I'd recommend something closer to suggestion String jwks = cache.get(url.toString(), () -> resourceRetreiver.retreiveResource(url).getContent()); return new Resource(jwks, "UTF-8");  return cache.get(url.toString(), () -> resourceRetriever.retrieveResource(url));
Why not Objects.hash(x, y)?
how are you going to compute the entity id without the source id? Also, please make "fileSystemPath" a constant.
I think it is better to move counter to handleWebSocketFrame method for BinaryWebSocketFrame
I think it would be better to have this call at the end of the ObjCClass.register() method. Just after the ObjCClass instance is created.
Can we replace "Error undoing deploying" with something more descriptive? Like what exactly are we trying to undo and why?
Could you check whether this one works alternatively:  super( new TranslatingGridTypeDescriptor( Character.class ), org.hibernate.type.YesNoType.INSTANCE.getJavaTypeDescriptor() );  Would save that new grid descriptor type. The whole type business is far from perfect btw., it's very high on our agenda to rework that. So many thanks for fighting through it :)
Is this the right place for this code? Shouldn't this be in the MainApplication class and guarded by the Config#areFirebasePushNotificationsEnabled check?
Code repeated. Get interactor from custom listener (if exists), else get it from template method. For both, attach, put and return
This should return a URL
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
constructors that exist only for codec / jackson should be either protected or private. That'll probably also handle the warning.
Git is just one implementation of version control, should be getRepo(0) instanceof NotebookRepoWithVersionControl
i think we might need to add a slightly longer wait. Using the exact timing may still cause failures on slower computers. Maybe +1 second to it?
WebDriver#findElement will throw NoSuchElementException if the element doesn't exist, so it will never be null here. You could use AbstractElement#findElementIfExists to get the element or null, but it makes more sense to remove the null check and allow NoSuchElementException to be thrown Same in clickCancel below
This kind of logic is indicative of awkward separation of list modes. I would prefer to use a Set<DirectoryListMode> and provide a simple factories to construct the sets a la filesOnly(), dirsOnly(), and all(). This way, this condition becomes modes.contains(DirectoryListMode.DIRS).
thrown a NotFoundException (if it is not declared, you should create it). This exception should be catch in the interceptor and to response with 404 not found!
Maybe we can use StringUtils.EMPTY.
If you use the some, how about removing the this.s.
You don't need this null check. If the factoryPid is null, then the next condition will return false since the ACCEPTED_ENTRY_FACTORY_PIDS doesn't have null as one of its items.
That's much better - but can be even better: no need to explicitly create the Callable. Just invoking entry.getValue().apply(store) should allow it to appear as a Callable.
PrimitiveType.stringifier() is for the API user. This one might be package protected.
Could we change the signature of ConstraintViolations.determineStatus from  java public static int determineStatus(Set<ConstraintViolation<?>> violations)  to  java public static <T> int determineStatus(Set<ConstraintViolation<T>> violations)  Doing so, we can avoid making a copy.
This check is not necessary. formatedTime is already doing it.
This looks incorrect - Record can be instantiated.
Why are you using CompletableFuture.runAsync here instead of executorService.execute(super::run)?
please extract this if-else to method getRegexCompileFlags.
Maybe use CamelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(...)
should this be <=, just check.
should be boolean
Since this method is designed to read $HOME/.td/td.conf, it is better to print the warning in case of file not found.
This change seems redundant with the other ones in the file: the constructors now handle the lowercase conversion.
Can we make the expring time a constant?
I know that TranscriptionGateway#stop() doesn't do anything right now, but I think we should call it here anyway.
1. It seems like this method's name is wrong (two "Account"s in it) 2. You don't need to qualify it since it's within this class, right?
The find method will throw an exception if not found, so the assertion below is redundant. Use tryFind if you want to be explicit or just remove the assertion.
This null check seems unrelated now that the data is set by the activity. FormEntryActivity.setBinaryWidgetData does that check anyway so I think it's clearer to remove it.
this will destroy the content in ALL languages that exist and cannot be undone
This check can be dropped.
ArrayList constructor can be called with initialCapacity.
@email2vimalraj Could you provide these checkings: java import static com.google.common.base.Preconditions.checkArgument; import static org.apache.commons.lang3.StringUtils.isBlank; ... public Activity(String appPackage, String appActivity) { checkArgument(!isBlank(appPackage), "App package should be defined as not empty or null string"); checkArgument(!isBlank(appActivity), "App activity should be defined as not empty or null string"); ... }
Maybe listing verified states as an enum and using the enum values as cases, instead of hard coded integers, will make things easier to read. For example, which state are we in when the value is '2'?
Since you removed throw new LauncherStartFailedException(); this method should not throw such an exception anymore. suggestion private Platform getPlatform() {
why expanded format?
This can be simplified as return (isInit && initException != null);
This is missing the translation of bb.putLong(eid-1);, and the allocation needs to be updated to match it.
IdDTO object is more readable
Add @since 5.1
We could just pass null to every parameter here, there is no need for mocking in this case.
I think this might be better with an Assert,checkNotNull check - in what situations could the supported protocols and cipher suites be null?
Again on future tense as above.
Can't you do this as a member variable? instead of creating it every time?
Missing closing )
use class loader of handlerType
static import
@darkled Here too, let's declare Exception being thrown, as suggested [here](<LINK_0>
brickDetails.getBrickProperties().getBrickId() could be null if the brick is not present in DB
I'm comfortable with throwing an IllegalArgumentException for this, which lets you use Utils.validateArg.
scheduledExecutorService.shutdown(); scheduledExecutorService.awaitTermination(..);
This try-catch can be moved to the @Test annotation as well.
Could use the constructor ExtensionAdaptor(String) with NAME as parameter (initialize() could be removed).
should pass address instead of null for the name
This method seems to be indented an extra level. The file also seems to use tabs not spaces. Running the gradle spotlessApply task should correctly format things.
parentheses around TIMESTAMP ... are not needed
isn't CONCURRENCY_LEVEL and LOCK_ACQUISITION_TIMEOUT missing?
bad formatting
I mentioned this in the review of the patch that adds this method, but this doesn't actually implement backoff for the full timeout. It just ensures you'll get another callback _within_ that timeout. This could result in retrying a lot more often if some partitions are healthy and receiving data. Maybe we should record the timestamp when the failure occurred and then decide whether to proceed into the execute() based on whether the desired amount of time has elapsed yet?
Did you verify this isn't going to break any existing test assumptions? We probably shouldn't modify this as we don't know what impact this is having on existing tests. It may invalidate a test that has different expectations of the scopes.
endswith -> contains to make it more robust
this can be package private
I'm not sure if in 100% the UI identifier should be same as model attributeName. See SMAP above. May be you should add methods with one more attribute identifier for cases when identifier is different from attributeName ... at least for the boolean value (SMAP).
Please use ParserException instead of the uncheckedioex.
if transports is private, there is not really need for a method that wraps list add.
public
Is this test not missing an assert ?
In that case, it's better to use FluentIterable.filter since Iterables.filter creates a FluentIterable anyway.
@droneboost here you can just call mPanMode.compareAndSet(current, update) to accomplish the intended functionality. You especially don't want to unregister the event receiver since it's filtering over events besides the drone gps updates.
what's the purpose of this? Is this to resume migrations that were not done (or service did not receive result) and crashed? If so that is too optimistic I'd say ... we cannot just assume that kie server didn't finish it while this service went down. So I'd say if we want this to be automatic then we should first check if migration has not finished successfully first.
closeQuietly again?
List objects of the values of map are shared between two maps. Same at getServerMetrics().
do we need to check the project == null here?
Why do we need a map? The list of NonCountableQutoaVmStatuses is of size 5!!! even if it will get to size 10 it is still redundant. you can just use List.contains(Object)....
these could be simplified further by importing import static uk.gov.pay.connector.common.model.domain.PaymentGatewayStateTransitions.isValidTransition;
even after getVmId() is checked, getVm() can return null here and cause to NPE.
Add an assertion here for the files being downloaded and extracted successfully?
same, why not set what is coming in here ?
avoid negation for readability?
Saying that a Sku is inactive means that it's not for sale whereas the InventoryUnavailableException is really used for when a Sku is active but it doesn't have inventory at this time. It's a subtle difference but if we're going to change the signature to return something that's not an IllegalArgumentException then I think we really should create a new Exception. IMO there's a reason we're throwing an IllegalArgumentException. It's because there's no other Exception in Broadleaf that makes sense therefore we should make one
Need to use parameterized logging instead of string concatenation. This should also be a warning, not an error.
JapaneseTokenizer t -> Tokenizer t = new JapaneseTokenizer
Protip, arraylist has a constructor that takes and array, also all lists have a addAll function.
This should be "principalDecoder", I guess.
I think you can just drop this parameter, and the MiB constant and that is the entire commit.
We should just pass preferredOrderingColumns to make it consistent
What about just doing String pwd = file.getProperty(id) here and then create an instance of KieServerInstanceAccount from it using return new KieServerInstanceAccount(id, pwd)? We don't need to iterate over the whole file all the time, do we?
You need first an assertion that the order type exists before purging it otherwise would be invalid if none matched id 3
No. Random ports will be a disaster. When it does eventually collide you won't know it and people will just rerun. My recommendation, and we did it in PCE, was using global increasing port numbers. I would recommend a test helper class that maintained this state and generated the JDBC urls (for example).
I don't think you should sanitize at this class. This will be an unexpected twist for other callers of this class that are not JSP.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
e.printStackTrace(); prints to stdout, not appropriate for production code. Use LOG.error("Failed to open {}: ", path, e) here so the stack trace will still be printed. with claiming private static final Logger LOG = LoggerFactory.getLogger(AbstractFuseFileSystem.class); in the beginning.
Maybe a more descriptive Exception like IllegalArgumentException or UnsupportedOperationException?
Intended change in functionality here? And wouldn't the default value null that's being passed here immediately cause an NPE?
don't need that check, snapshot are relevant only for image disks
just return this.count < this.values.count();
java return isSendComplete() ? 0 : channel.write(buffer);  if you want to make it more elegant.
Returning null from this method is likely to call an NPE in the caller code.
Please use StringBuilder
same here, should be a constant
nit: should it use Expr.ARG_JOINER?
Querying
Use constant
Why this change?
Sure, it would be faster to use long. It's a tradeoff between speed and maintainability. If a method returns to int's I find it easier to understand (and maintain) if this is explicitly expressed. My suggestion: I shortly measure it out what would be the difference in performance and memory consumption when diffing two 1mb texts. I'll let you know.
To reduce the number of methods that begin with the word remove, maybe we should call this handleLiteral.
Since it seems like pretty much every call to withContext needs to pass this constant, I think it'd be helpful if we defined something in storage.common that's like withTracingContext or something to automatically add this. Otherwise, I think us Storage folks are liable to forget and mess up tracing later :)
catch IOException in index(...)
Not sure but the use of handle_id here looks strange to me. I have also found this post on stackoverflow <LINK_0>
this might be obsolete if isValueValidis implemented...
I'm not sure about this optional  I believe you should just throw here (equivalent to Enum.valueOf)  actually the only use you have in this PR simply calls .get() on the optional and have it throw if called illegally
if certificate is null, line above will raise NPE
Maybe default arrival time to currentTimeMillis here?
rather than making the app crash, the sdk should handle this case and dismiss the notification
@Captain-P-Goldfish Can you please define this error message as a constant in ResponseCodeConstants class?
can be done in one line ??
Check buffer null.
instead using the Injector here, pls use the @Inject annotation, and when you intend to use GlusterStorageDomainDRSyncJob, declare it using @Inject or using Injector.get(GlusterStorageDomainDRSyncJob.class);
same, looks like this could blow up if you pass in an empty array
It could use the same method as the other statements.
close inputstream as well?
There's a good few methods here that have a higher wider access modifier than they need to. On the track here, we try to [adhere to best practise](<LINK_0> as noted in our POLICIES. This (and a few more) can be changed from public to package-private.
i should start at 1, as it's already processed by the preceding LOC.
Please call  super(statusCode);  and same thing for the 3 below.
What if both object have id==null? Then they are not equal?
Let's check that there is no cause
:pencil2: I think you could log e.getCause() instead since an ExecutionException just wraps the real exception that occurred. Also, if your value loader function throws an unchecked exception (and I can't tell if it does) then get() will throw an UncheckedExecutionException, which you may or may not want to handle differently.
Object o is never used. suggestion
sex language, it exists!
I thought prob = 1 will generates a matrix filled with ones, but the code will generate a matrix with zeros.
Honestly I'm thinking whether it would make more sense to literally inline the template text as static content here, although that would make the permgen size of this file really large. It makes me really uncomfortable that the code path for loading this is also static, as it introduces _huge_ unpredictable hits across the codebase for when a complex parse happens (And will/can mean it happens at weird and bad times), can we make the static init here happen lazily instead? (Is fine for the template parse itself to be static, I think), as long as it is stateless and threadsafe)
Rename logo to resourceUrl
Could have been this: return absoluteUris(PORTS, vxLanPortIds);
This seems to me as util method that could be used by **delegation** instead of **inheritance**. Is the inheritance used because of the testeability?
This is a bit weak, its better to use g.isVisible(), the same below. Also remember to detach the widget, so as we don't interfere with other tests
Objects.requireNonNull(buf)
additional loadTypeNameToCategoryMap not needed.
event1 -> event3
super() call is implicit. No harm, but not needed.
put this before try
It's probably a bad idea to be checking for exception messages in the first place.
rename to fragment
I think you should test that both MASTER and IDBROKER instance groups are available at the same time.
You could do (Properties) Objects.requireNonNull(properties, "Properties cannot be null").clone(); and be done with it.
logD? same for everywhere else.
Change this to 'else if'
suggestion throw new NativeException("Failed to stop watching. Reason: " + result.getMessage());
I don't get this. If progress has only one tick, then this consumes one too many now. And anyway, if there's only one operation using the monitor, why not simply pass it though: super.doRun(progress);
This could be just i == -1?
It would be good to make this consistent with registerClientInformation by making it re-register the cipher information if appropriate (and if the new information is different). Question for @rajinisivaram: can the SSL cipher of a connection change when an SSL handshake is done on an already established SSL connection?
This really shouldn't be public...
this refactor isn't related to the solved bug..please separate between this and the patch to solve the bug.
This formatting looks weird imo. @romani Whats your opinion?
I suppose that this is FP because Guava Optional is already imported. In that case a message should be sent to rules dogfood group.
Wasn't 300 recommended as the default parameterization in the SafePub paper?
If one host fails to update then it will stop updating other hosts well.
do you really want to make this public?
GitResourceVariantTreeSubscriber relay on data that are added into GitSynchronizeDateSet. Such data contains repository, destination and source rev's using with we can determinate differences in particular file. Passing empty GitSynchronizeDataSet will cause NPE in members() and getSyncInfo methods. In case of git it is quite tricky to obtain subscriber because we don't have one main repository. Of course we can consider that in this case we'll be always comparing HEAD against HEAD (or origin/HEAD or maybe origin/master (?)) I'm not sure what the default behavior should be here :|
Just a tiny detail, on upstream these were renamed to "Manual" using GuideGroup.ManualGroupDefaultName
This should use the InternalCacheRegistry approach instead.
you can add a static method: Config.builder() so that you don't have to do new Config.Builder()
Is this (ServerConnectionDetectedEvent) post really required? This basically repeats the above two lines and then finally calls finishServerConnectionDetection(). You can directly call the finishServerConnectionDetection() method instead of this.
Really ReviewFragmentStrategy is not a strategy for ReviewFragment is a strategy for ReviewScreenAdapter, can you rename to ReviewScreenAdapterStrategy
Should return OVERLAY_SYNC_INCOMMING or OVERLAY_SYNC_INCOMMING_NEW depending on ITask Sync state.
No need to wrap "in" in a BufferedReader. It is a LineNumberReader, which is a subclass of BufferedReader.
This is nice, but why not to collect all the dependencies that are not allowed and at the end throw an exception with all that not allowed dependencies? Then the user doesn't need to build N times to get each time a failure for the N not allowed dependencies.
What is this for? Seems like a no-op.
] could be a char
Please use braces. Checkstyle should pick this up.
It should be assigned
Since the order doesn't matter, you could initialize validSCTs as a frozenset rather than copy every time getValidSCTs is called.
lower-case 'u'
since it's the same forEach, why don't you call both function at the same time?
What's the compilation error you're getting for Enum.valueOf()? If I were to guess, I'd guess you'd need to cast handledType() to a Class<? extends Enum<?>> or something similar. I'm confused by "adds the endpoint that failed to the exception". As far as I can tell, IllegalArgumentException or JsonProcessingException both accurately and specifically label this exception.
can we use names like encryptedFile and decryptedFile for readability
This check is superfluous as super.connect() does the same check. We can safely remove this if block here.
Why this is public? Consider the following call sequence: 1. startMeasuringLatency() 2. reset() 3. endMeasuringLatency(), then you record a huge number as the latency.
this can cause some conflicts.. best thing to do is put this after that the maxHealth is upgraded, and then just health = maxHealth (like stated before by @Borsty)
Condition logs
We should throw a different string in to show that it will calculate from that string. For example: ActivityControllerTest uses "biological" and expects Profile.BIOLOGICAL to be returned - even thought it is technically not valid for the end point.
Performancewise it should be better if you directly work with the citations map (instead of keys and then get the citation for it). Maybe even something like referenceList = getCitations().stream().map(new ReferenceWrapper(...))) works.
This test should be adjusted since you removed the strlen change.
keep Optional return parameter in all enums
Add this to stay consistent to the other getters here.
Normally we don't deny access to admin user
We catch a generic exception here, so the reason for the failure could be different than duplicate key. I would change this error message and I would add the exception as well. Something like: java logger.info("Failed to save pushMessageInformation: {}", e.getMessage()); logger.debug("Details:", e);
We cha change here as well.
You can test the three parameters in one submit.
We can drop the "FileChooserService" now from those method calls, since the methods will be visible from this class.
@fanifieiev the same above.
If this wasn't in a test, I'd be unhappy as it's assuming a lot. Ok here, however.
the withMetricFactory overload seems confusing, we can be more specific with the type of metric factories?
could you use some constant for the boolean instead of true or false to ease the readability of the code please ? like this  static final boolean REUSABLE_CLASSLOADER = true; DependenciesReader.computeDependenciesFilePath(SimpleFileIOComponentFamilyDefinition.MAVEN_GROUP_ID, - SimpleFileIOComponentFamilyDefinition.MAVEN_DEFAULT_RUNTIME_ARTIFACT_ID), RUNTIME); + SimpleFileIOComponentFamilyDefinition.MAVEN_DEFAULT_RUNTIME_ARTIFACT_ID), RUNTIME, !REUSABLE_CLASSLOADER);
This line is redundant, request already passed in newTokenClient(tokenRequest);
why not just check string contains?
#701 asked for this lock to be removed, if I am reading it correctly.
This could be refactored by  return !UtilMethods.isSet(filterKey)? this.loadedFilters.values().stream().filter(FilterDescriptor::isDefaultFilter()).findFirst().get(): this.loadedFilters.containsKey(filterKey)? this.loadedFilters.get(filterKey) : this.loadedFilters.values().stream().filter(FilterDescriptor::isDefaultFilter()).findFirst().get();  In addition you can create a method called getDefaultFilter, that basically returns this  this.loadedFilters.values().stream().filter(FilterDescriptor::isDefaultFilter()).findFirst().get()  And call such as this:  return !UtilMethods.isSet(filterKey)? this.getDefaultFilter(): this.loadedFilters.containsKey(filterKey)? this.loadedFilters.get(filterKey) : this.getDefaultFilter();
I think you have these variables mixed up, should be switched
This should check that an error response is sent from Keycloak (<LINK_0> and that the error code/description indicates to the app it was the AIA that was cancelled and not the login.
It is permitted, but discouraged as a matter of style, to redundantly specify the public and/or abstract modifier for a method declared in an interface.  <LINK_0>
checkowner should be changed to : frontendState.checkPermissions("finishTaskInError", frontendState.getIdentifiedJob(jobIdObject), YOU_DO_NOT_HAVE_PERMISSION_TO_FINISH_THIS_TASK);
Instead of hard coded string, can we actually cache the response and return it?
Missing super method invocation.
@JonathanGiles, @srnagar, I'd like to see us create a guideline around the default serializer to be used when one isn't passed. In some locations we use JsonSerializer/ObjectSerializer and in others we default to using JacksonAdapter. I have a feeling we may need to go down the route of always falling back to JacksonAdapter, except with serialization formats we didn't previously support such as Avro and Protobuf, as using JsonSerializerProviders.createInstance may result in customer applications throwing an exception when they previously didn't. This restriction may only apply to logic in azure-core which could accept an ObjectSerializer/JsonSerializer as it cannot take a dependency on the implementation libraries.
I would store awaketime as attribute of this class and remove if from queueModelHelper
While in here, I'd just have the equals() method use an EqualsBuilder so all the inline-if's that were here before can be removed:  public boolean equals(final Object o) { if (o == this) { return true; } if (o == null || !(o instanceof RyaType)) { return false; } final RyaType other = (RyaType) o; final EqualsBuilder builder = new EqualsBuilder() .append(getData(), other.getData()) .append(getDataType(), other.getDataType()); return builder.isEquals(); }
possible alternative implementation of method: java return conceptMap.getOrDefault(targetTable, Collections.emptyMap()).get(targetField);
Do we use id any more ?
input is not @Nullable, remove annotation or add null check.
This counts down before the bean is actually initialised
>Boolean [](start = 11, length = 7) VerifyResult with one property isValid
do you think it's worth shuffling the server list here to make sure that if there's several servers that start from the same ordered list that they don't all just choose the 0th server (and thus force load to the same place)?
please, just for completeness.. call stop(true); here (after the method name change I asked you)
inline this
whats the super class here?
There should be a space between description and name
oups, two new list per event :p
nit: log effective rate?
You could push this bounds logic into the SequenceAndBound object itself to prevent mistakes - add some method like contains(timestamp).
repeating the same BIG_VALUES doesnt make it more readable.. either make a builder for batch subscription or aply some defaults, or just use values instead of consts
this map can be replaced with peek and injectSessionInfo can be changed to return 'void'
FWIW, this method is getting deprecated: <LINK_0> so you might consider using the Constructor.newInstance method instead.
I think you should rethrow the original exception, not a new exception without message
Could we remove the consumedDataType as it is never used?
Use readAsString(...) instead
What do we return, if we're not under AppEngine?
Can we introduce a createOrAlterPartition?
NPE if label is null
I don't think this method is needed anymore.
Is INFO level necessary or it can be changed to DEBUG?
Is it correct to maintain state in the view? Shouldn't the presenter keep the logic as to whether the view is empty?
This is a suggestion to remove unnecessary updateCache call: do the updateCache inside the lambda function at orElseGet(...) I know it is not part of this change, but that can be a small additional optimization. (The same in the other methods)
Should we not use a different SMS template here? Because the user may not have read her email yet, the SMS may be quite unexpected.
Why double and not BigDecimal?
let's remove executionplanRuntime start and shutdown in all attribute validation cases .Please make the change in others as well
Externalize the strings
suggestion if (m.find()) { ... }
I think, there is a wrong behaviour: If the file could not be created then at least an exception should be thrown and if you are logging then the file including path should be added to the log message.
public?
the same as line 89, there's no effect of clicking ot the Verify button
add "this" qualifier
Define a constant value for the strings which you are using in more than two places. Example :- Define a constant for "(" and reuse it.
It doesn't seem correct to have default implementation for getFilters return empty map. Throwing unsupported exception seemed better. Is there any particular reason you made this change instead of add getFilters implementation to TRUE instance?
For safety, how about checking c != null && c.length >=7 and if not, leave everything at 0.
The Expression in the message looks odd. Should be the param name. Will fix on merge.
Hmm, should we switch listenerList to a set?
This command is currently transactional (should it be transactional?), I guess it should be set to non transactional with compensation, so: 1. the stateChanged need to be called after the actual change 2. need to add the NonTransactive annotation 3. need to add empty constructor
how sure are we that ThreadLocalRandom will not generate the same numbers for a given seed? For example, if each local random was generating the same series, you will not have a balanced scheduling.
Now this should return true, since there are disks on the storage domain (Remember that you don't check the validate only the method checkDisksInBackupStorage) Change to assertTrue
Here it should throw an UnsupportedException and not return a potentially wrong result, same for contains and calculateArea
Don't we need to clear this?
Can we get rid of "/" here and let the Paths API construct the OS dependent path?
Does this mean we might have bad configuration that needs cleanup (via XSL transform)?
can be this(new ArrayList<Integer>());
Is this method worth it's weight in characters written?
This is a private method and it is quite heavily used. It should be fast. Now, NLS.bind here is not efficient, it is ok for messages/labels in UI and reporting, but outrageously slow for the hard use. I would suggest just kind + "/" + name
Instead of getting the instance here, it should be passed in in the event that we want to mock it.
Missing null check for game.getObject(event.getTargetId())
Should we init topologyConfigId in this function?
Rounding errors could induce unexpected behaviour
that could be merged into one line
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
We shouldn't be modifying constants. If these are truly constants, they should be statically initialized and then never changed. If these aren't constants, we should create them in before() to ensure they're being reset with each test.
It could be better using Constants, for example DAFAULT_NUMBER_OF_PLANS_GENERATED = 5
this command **dashboard.open()** looks as redundant here. To make code clear I propose to move **dashboard.open()** command into the **createWsFromJavaMySqlStack()** method, set **@BeforeClass** annotation above it and remove **setUp()** method at all.
Same as for the KeyPairType constructors.
I think this condition could be merge with the previous one.
we should remove try-catch-fail.
checkArgument(dir.isDirectory, "%s is not a directory", dirPath);  ? I know it's a different exception type, but still..?
Sorry, a typo here. The return value should be parent.
This call should come after super.onResume(). Also, I'm not sure if this will work for first time load, because client will be null the first time, since the peekRestClient() call is below and that's what initiates login flow.
should it be !part.isLocal() instead of part.isLocal()?
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "setHref" method. [![rule](<LINK_1>](<LINK_2>
public @Nullable Iterable... EMPTY_SET is never null though, how about supresswarning instead?
I am not sure what to make of this message > better not use it for testing purposes Maybe something along the lines of _Sender supports asynchronous requests only_ The fact that this method cannot be used is already clear because of the exception, isn't it?
we can remove the status variable by calling "return addEndpoint(endpointData);"
ditto error message
Wow that's really long.
extra space after openning brace - style check nitpick
This edit part (And the one for DurationObservation) needs to install a Notation listener, in order to react to Named Style value changes and refresh its Figure. Otherwise, undo-redo won't work properly (Moving the arrow line then undoing -> The arrow line is not properly refreshed) (I'll send you a code snippet separately for how to achieve this)
nit: For the new log, please do this ""clearCache is deprecated for changeType: {}", changeType". Minor performance improvement if we config the log level to error.
Probably doesn't need to be public.
@tsurdilo I have one question. Why is this persistence.xml in String and not in a seperate resource file, moreover, is it mentioned to be run only with PostgreSQL?
Can we add some message to this assertion? (and all others)
if new name is null, old name has been put as text i think we should here validate the text value and not newName/OldName.
Looks like all of the test server instances will be in-memory datasets, which is great for speed. Will there be any places where the test server instances touch the disk?
rename the variable to resources instead (bad copy paste I think)
Because of the problems mentioned elsewhere in this file, this looks like it doesn't update :)
Dtto. on aligning. In fact, I can see it all over the file.
fType can be null, which lead to auto-NPE. Perhaps null-check it? (not sure what would be a good return value, null, empty string?)
I'm wondering if we could use an [unmodifiable list](<LINK_0> here?
Please rename this layout file as well removing _new_api.
future calls in getResult are going to unexpectedly NPE because of this. either handle this in getResult or fail harder in the static block with a thrown runtime exception or error to prevent the class from initializing, and thus the server from running.
Move the parameter validation to the constructor of XHMMEmissionProbabilityCalculator.
filters method argument should be passed to isMessageInLogFile as an argument
int gets values up to 600 hours. that should be enough for the barrier.
Should this method become private so that other class can not use new HL7Parser201305Utils()?
I think so, otherwise registering on the Update will cascade up to the Handle.
Shouldn't #may# be displayed properly?
method never used
I think we should make this ctor package-visible only and introduce another one, which will be visible to everybody, without Target argument
can we use tryLock instead of having the set?
What's the difference between these two?
@ctsims Failure due to: this.mChoices -> this.mChoices.length
shouldn't be removed this one HibernateUtil.closeSession(); too?
Please use assertNull instead
Why overload all of these methods to throw an exception when the base class has an actual useful implementation? Look at <LINK_0>
I think this is not necessary you can initialise shouldShowDualPane directly here not need to obscure purpose. Same applies to setupNavigationDrawer()
please return this for all addParameter, this will enable: RunQuery(prms.addParameter(x, y).addParameter(x, y).addParameter(x,y))
Could you put doc.getCoreSession() in a local variable please?
same problem with Object.equals vs Arrays.equals.
Skipping?
Keep as one line or refactor.
@wwelling : Is there any guarantee that the default locale language will be included in the list of available languages?
no need for this
Can IOIterator only return IOServices? If not, a valid option would be to make next take a parameter targetClass (subclass of IOObject) and use that to rewrap the returned IOObject.
I'd prefer to see this as an abstract method and have each enum return the correct value
Same as above, please fix the code alignment.
Check for null
requireNonNull(parentMemoryContext, "parentMemoryContext is null")
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Missing return true
As below, do you need to create multiple HttpRequests?
Why setting the NO_IMAGE twice?
As mentioned on auth-service PR, we need to watch this setting and reload the auth-servers on change since auth-service is reading this from DB everytime anyways.
shouldn't it be Object instead of null ? as you can call toString or hashcode on a variable typed by a type parameter
Should this be derived in the constructor? To avoid potential redundant computations.
static comparator again
it should be private, welcome to the java world :)
contains serves better purpose than get method.
I gather vm cannot possibly be null here?
Just curious, why synchronized for the iterator? I see the same on the ObjectRange iterator but can't understand why it would be needed.
I dont think this is right. You have if isLocalPlayer under a check for isLocalPlayer.
change method name from isRobots to isValuePresentInRobotsMetaTags
Exception without message or stack trace
Same here @alepintus , this could be replaced by: Double[] doubles = Stream.of(tempStrokeDashArray) .map(Double::valueOf) .toArray(Double[]::new);
shouldn't we wrap the original e ?
Nit: else is redundant
Why not to enable lazyEval here?
It's probably fine to remove this check and the associated test.
Move to top of ctor, and: checkState(shape.length == width * height, "Shape for a character must match it's dimensions");
Links -> Link
Please use try-with-resources to close the connection.
I think the contract for this method requires that we do not overwrite slots, because otherwise numberOfEntries will be broken. Add assert? Allow overwrite?
oh I see, we are conditionally setting (vs adding a second header) nm
The version check would be much easier as a method in the Target class, especially considering the Target implementation is responsible for loading its own template files.
do we need to check for null?
blocking calls inside the SDK are not good. they can cause deadlock, perf hit, etc. We are not doing blocking calls anywhere else.
It's best practice to name the fields you're expecting to return, instead of using the * glob pattern.
Same for super.deactivate, you should call it last.
paths.consumersWorkloadConstraintsPath()
Why not print parserMap=null if it's null?
shell.getDisplay().getActiveShell() yields null. a check assertEquals(shell.getDisplay(), Display.getCurrent()); assertEquals(shell, shell.getDisplay().getActiveShell()); may make sense here The test succeeds when one test class is executed alone, but fails wheen it is executed with the AllWidgetsTests suite.
@deprecated unless you are going to use a DataBoundSetter as suggested by @KostyaSha
Should these cases be reverse? (i.e., don't instantiate the logger unless audit logging is on)
Variable organizationEntity
This is redundant in Mockito 2
Should we do this using spring jdbc ?
Isn't this always true here?
Please format this appropriately, it should be possible to fit every "part" of the message in a line.
Shouldn't we also synchronize closeReaders(), together with releaseHolder(..)?
Maybe make this a const instead.
These are the sort of tests where I think AssertJ really shines, e.g.:  assertThat(result.orElseThrow(RuntimeException::new)) .extracting("doi", "authors", "title") .contains("10.1126/sciimmunol.aan8664", "Patil VS, Madrigal A, Schmiedel BJ, Clarke J, O'Rourke P et al.", "Precursors of human CD4+ cytotoxic T lymphocytes identified by single-cell transcriptome analysis.");
Oh, I didn't know about this! Isn't it the same as boolean.class though?
This is not specific to this PR but in general, should we consider using Throwables.propagate() instead?
I think you can remove this nested else and use else if (!compact...
> dich auf die Probe stellen wollte The other thing isn't really German... > Freust du dich nicht etwas mit Flows a little better IMO
Do you mix 'httpClient' and client by intention this way?
could this not be something like  var isValid = stripeGatewayConfig.getWebhookSigningSecrets() .stream() .anyMatch(s -> isValidNotificationSignature(payload, signatureHeader, s));  ?
This doesn't wrap or nest any arrays. It just returns the array at the recursion base case.
matches: "Darwin", which I believe some OpenJDK builds might identify OS X as.
suggestion assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount);
ingest segment firehose?
It seems that in case of setting the Docker host the properties take precedence while in case of cert path the environment variable takes precedence.
Please consider using: TimeUnit.MILLISECONDS.sleep(innerLatency); It is not clear what is the unit of time that we want to wait.
It seems can be simplified by using seleniumWebDriverHelper.waitVisibilityAndGetAttribute() method
if privateAlignment is null and the received value is null, this will be called although unneeded (nothing was changed)
@tomjenkinson no, it shouldn't start failing. The recovery will just be replayed two times.
seems reasonable to also want to include the 'to' location?
I was instead planning on using the filterEntries method on the AdvancedCache. so in the list method it would be  try (CloseableIterable<Map.Entry<Object, Object>> myIterable = cache.getAdvancedCache().filterEntries(filter).converter(filter)) { for (Map.Entry<Object, Object> entry : myIterable) { .... } } catch (IOException e) { // exception ignored }
the way this query is written (a count), I don't think you will ever get a null result so I think you can cast to/return a long
Should clone this on return
I think this test isn't technically correct. It's possible for A != B but A.hashCode() == B.hashCode(). I think the correct assertion for the the hashCode part should be.  if( element.equals(other)) { Assert.assertEquals(element.hashCode(), other.hashCode()); }
Suggest check that artifact != null
With Logback, we don't need these types of guards.  java log.debug("Queing event: {}", event)  should do the trick with no penalty in performance.
You need to update TestExchangeClientConfig for this.
in several places you call getArguments() in a conditional and then use the value. I assume you did this because you know getArguments can't change out from under you, and is not a costly method call. As the reader, it's hard to tell that.
might fix your issue suggestion public void setTopics(ArrayList<String> topics) {
If I'm not wrong, the method can return void, as other mockXYZ methods. The return value is never used.
Field %s has unexpected type %s
new byte[]{} -> new byte[0]
Fix the annotation line placement.
this should be a one liner
You might be returning null here if it was never set. The code that calls it never does a null check. You should either set a default here, or mark this as potentially null using the @Nullable annotation or the Optional wrapper type and then check and handle the default situation.
nitpick: in general we transform to unmodifiableMap on the caller side not in the class that uses it. This is because it returns an unmodifiable view so nothing guarantees that the original map is not modified. Rule of thumb is call unmodifiableMap as early as possible.
I'm puzzled by this change. Why would you want to return Boolean instead of boolean? All your current consumers are now auto unboxing it into boolean, as I don't see related changes on this PR. So, you might get better performance on most (all?) JVMs by auto unboxing everything here. If you are returning null if value == null, you are effectively pushing a NullPointerException to your calling code, as they expect a boolean, but auto unboxing will not convert null into a valid boolean, throwing a NPE instead. So, it's probably better to throw it here and be explicit about your requirements. Even if you have clients expecting Boolean instead of boolean, you are now effectively saying: I'm returning a "true", "false" or "null". As a consumer, I would not expect that, even if the method returns a Boolean.
Why are we including fakeThread?
Please revert if possible
doesn't reflectionEquals checks all this things?
A session id is unique and complete. You don't need to wildcard it.
nit: you can remove the ()
Do not call repository method, when you can detect if the parameter is wrong. Use assert in the service implementation for catching invalid parameters.
You can directly use org.eclipse.sirius.common.ui.tools.api.util.EclipseUIUtil.getActiveEditor(). It handles all the potential NPE.
Should only be done if validation is enabled.
It would be good to use constants for property names
Sorry, this is a behavior change. Old code used COLUMN_TRIM=3 for cocoa, too. This change is about using switch over strings instead of ifs. Let's keep this a purely mechanical change. Don't try to fix oddities in this change. Do it in a separate change before or after this one.
The word "failed" need to be there either way.
It needs to process the "value" from the between predicate, too.
we can merge these two if statements to one
@diogofscmariano this doesn't look right
return Objects.hashCode(spec, name, config); When it's auto-generated, I just about accept having the verbose version, but as soon as we're modifying the code we should put in the easier-to-read-and-maintain approach.
declare throws please
SubMonitor.convert() takes care of that. Here it's needed only for the monitor.done() at the end. Where is this called from? Maybe it's better to do the monitor.done() at the calling site? Using SubMonitor consistently, you don't have to call done() anymore, _except_ for the top-level monitors that get passed in Job.run() and similar framework operations. Using SubMonitor inconsistently in a call chain may lead to strange effects, since the convert(original_monitor) will consume whatever ticks are left in original_monitor. So if one switches to SubMonitor, one has to drill down from such top-level Job.run() or similar call sites. I can't tell if that has been done here.
Note that this change isn't strictly backwards compatible. It is *binary* compatible, but the resulting object was originally mutable and is now not guaranteed to be mutable. In general, it would be best to not return mutable objects from methods like this, so I'm not sure if that behavior needs to be guaranteed or not (in which case Collectors.toCollection(Supplier) can be used.
Should be !getIsBatHanging() since the method is the opposite
Is there a better selector here? While this works, having to rely on the Angular component name is not preferred.
From the point of view of the time graph viewer, these actions select the next/previous event (time graph's ITimeEvent, not trace's ITmfEvent which time graph knows nothing about). I wonder if it should not be in Control Flow/Resources view that we should override the action texts?
Is it possible for this to be null? We always return a CursorLoader in onCreateLoader().
write why this is needed?
'this.' is not needed here. I personally prefer to remove it unless it's needed...
If you use administrationService.getGlobalPropertyValue(String propertyName, T defaultValue), it would simplify the if clause on line 124 below
@jhrcek now we only close jms connection here. @adrielparedes a better name is shutdown eventsmanager right?
Check equal lengths for strikes and impliedVols
This explicit type argument is not necessary.
Wrong code. Should be "if (id != null && (id.startsWith(idScheme))" only.
use an overridable getOperationTimeout() method instead
why depend on Guava's Object class when JDK provides the replacement for it? (and even more, why change it when it's already in place?)
you could avoid the second call to getRecordClass by doing  AbstractRecord rec = _map.get(i).getRecordClass()  unless you think _map.get(i) could return null in which case you need to be checking for that too.
I'm not sure I see the improvement in this refactoring either. It also ends up being significantly longer. What was wrong with the original code?
apiDefiinition - I know that this was converted to a stand-alone method, but please correct the variable name
print help all the time? the command > server alone isn't valid.
shouldn't this be .equals? since there is no guarantee the method will always return the same instance? Also, might be simpler to just do instanceof ReadRowsRequest?
According to the order, the users can override the built-in labels by customization. I think the built-in labels should prioritize the user-specified ones. WDYT?
Remove
delegate?
Remove?
Assert the actual host and port?
There's a lot more to cleanup like this (unnecessary boxing, StringBuffer -> StringBuilder (already done, just not pushed yet)), but please let us do it at least in _distinct_ commits.
... and this test is changed. From my understanding the descriptor is expected to be non-null and the createImage must return null.
Why not Collections.emptyList() anymore?
Not used in this plugin, but I see it useful outside (a way to get the list of repositories managed by this OrganizationFolder). I think returning the list SCMSources owned by the multiple SCMNavigators is harmless (and possibly useful outside).
if you have a secured instance (not sure if ATHs have this on restart?) then you may not see the "New Item" part.
non-blocking, but I'd probably fold these steps (as you may not always want to use the UUID type). Ex. TraceIdToBigIntegerConverter can mention that it is UUID formatted instead. This keeps the math together, but separate from id decoding
LogViewTest.testClearAndRestore failed. Maybe there is a possibility that Tree does not exist when LogView has no messages ?
@gitcliff , what happens when you leave out this change?
I dont think STATIONARY_WATER exists anymore.
For future reference you should use Collections.emptyList() for this.
It is not possible to easily bump SASL_HANDSHAKE schema without due to... (remove "without")
I think we should also switch to debug logging
rename duple to info
Synchronization at this point is not required because the cancelled method reads and volatile field into a local variable (either becuase you replace the AtomicReference with the original volatile variable as suggested above or because the wrapped AtomicReference is stored in a volatile field as well). Due to volatile, the read in cancelled is atomic. So either the m_leasedThread has ben set or not. Synchornization does not change anything.
You removed too much. RPM can not generate BuildRequires so they need to be generated. Just the Requires were not needed.
Is it safe to assume that there is no ':' in any of these strings? The line 181 above has special handling for decoding %3A into ':'. Seems like there is an expectation that client will send encoded strings?
I wonder what it means where we fail here. I assume the correct behaviour of this service kind of depends upon receiving the events. Isn't logging a warning good manners?
I would suggest you to improve readability by changing it to ctx.inventory.select().size() >= Constants.INVENTORY_SIZE
This attributie is not used, and not needed; please remove it.
you don't need a try-catch here. You can simply use @Test(expected=NullPointerException.class)
Are we still using temporary properties files? Rename method
Please use a constant here also, perhaps it will be wise for future usecases to specify the color as a constant parameter in case someone will want to make a red one color progress back?
Is this a server-supplied name? Otherwise we need to localize this i.e. put it in strings.xml.
While there isn't a strict contract for what getObjectValue should return, it's a good idea to return a json-serializable object that represents the value. This is currently used by the client protocol and can be handy for tests.
Is this check required ? At this point length will be greater than 0 as we will return null if the length is 0 at line 62 Strings.isNullOrEmpty(dimValue)
Shouldn't the user be deleted even if they have no session?
knownHashes is useless then, let's remove it
Probably it's better to start supporting <code>Job</code>s instead of AbstractProject (workflow, inheritance, etc.)
Could we please inster this assertion: java nestedNode.set("emptyField", new TextNode("")); assertTrue(expressionEvaluatorMock.isListEmpty(json));
Recommend this, makes for an easier test and guarantees the property you want. java public class UnstableOrderedIterable<T extends Comparable<? super T>> implements Iterable<T> { private final Iterator<ImmutableList<T>> underlying; public UnstableOrderedIterable(Collection<T> underlying) { this.underlying = Iterables.cycle(Collections2.orderedPermutations(underlying)).iterator(); } @Override public Iterator<T> iterator() { return underlying.next(); } }
Remove sout.
s/this.cacheAllTables/cacheAllTables/g I think we prefer not to use this to reference variables
I don't like to swallow an exception like this since it may give the wrong impression. Are we sure that this date format is always used by ES? If so I would throw an exception in this case. Or else at least make a loud warning or try the general purpose date converter or so.
Change the second part of || to an assert (verify).
please use getVdsGroup()
Do we really need this check? I think it's redundant.
It would be nice to use constants instead of the magic characters > < [ ] .
Please introduce "top" class constant so we are sure both getTop so setTop work over the same property. Please do the same for "px".
As mentioned in #1324, this map could be a immutable map?
If the user isn't using openfl, then we probably shouldn't go along and register a listener for every module. We have to add functionality to the module settings listener (or dialog 'save' handler) anyway, because we have to detect when the module's "project.xml" file name changes, and invalidate the cache at that point. (It should probably call the completion contributor to clear the appropriate cache entry, and then call this so that we can listen to the correct file. We could just depend upon this listener doing that, but it seems a bit like depending upon a side effect.)
According to: <LINK_0>, better use ex.getCause()
Maybe it's safer to use moveBy(double, double) here. Using this, the E2E will also properly function on smaller screens, as moveTo moves to an absolute position on the screen. After that, you can also revert the assertEquals(0, volume) that failed earlier. <testing, logic
Remove the pre-defined variable?  private WebElement getActiveDialog() { List<WebElement> elements = driver.findElements(By.cssSelector(".discussion-dialog.is-visible")); if (elements.isEmpty()) { // allow selenium to throw exception return driver.findElement(By.cssSelector(".discussion-dialog.is-visible.modal-dialog-approve")); } else if (1 < elements.size()) { // only one modal dialog should be visible throw new IllegalStateException("Only one modal dialog should be visible!"); } else { return elements.get(0); }
This selector is going to throw NPE on get() if extractionFn is null, so it's better to throw it in construction:  this.extractionFn = Preconditions.checkNotNull(extractionFn, "extractionFn");
you really do not need these temp variables....
The hardcoded License Level can be replaced by the enum LicenseLevel.STANDARD
no need for anything besides the static part here, right? if so, please use vmStaticDao instead
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
Does it make more sense to throw an Exception rather than silently accept the given comparator when it is null or invalid weight?
If you want to maintain the same behavior as before you should probably log this as ERROR since guava is logging it as SEVERE.
This should crash have crashed before now, right? the installer shouldn't be able to save itself without this flag being set, right? I feel like it's better to crash on save than it is to crash during runtime
What's this constant value? Please make it a static final and give a proper name to it.
Seems we should add ONLY_IPV4_ALLOWED and ONLY_IPV6_ALLOWED too. Lets also add them to the isEventLoggable below.
unrelated note. With current method definition java public static void close(Logger log, java.io.Closeable... closeables) {  java will create new Object[] for single closeable that is passed to the method. We'll benefit from a variant that takes only one parameter. Do we ever use this method with more than one closeable?
Just to be consistent with similar classes add requireNonNull for the args.
Note: Despite not mentioning it in the docs or the method signature, [at least this call](<LINK_0> (and potentially the one below) can fail with an untyped RuntimeException for various reasons. Additionally, I believe there are media types that it's unable to parse effectively, which doesn't appear to be handled as an edge case anywhere. We should definitely wrap this method to catch runtime exceptions and generally to gracefully handle not knowing the length of a video file.
Remove all @AddonDeployment annotations and leave only @AddonDeployments. Also, remove the addAsAddonDependencies below.
This changes API. While specifying less exceptions is valid, anybody extending this class can no longer override and throw CoreException (at least that's what my experiment with a checked IOException shows). I didn't flag the internal classes because they could be changed back if needed.
Please, revert this. Too hard to read...
Multimap never returns null, so we could get rid of this method.
Is this visible for testing ?
The user name would be incorrect if the VM was rebooted through SSH or by a script. Please just use a generic message like "Guest OS". Also no need to use String.format().
Can be static.
Should we double check whether requestedGrain is supported?
the check and get calls can race with the remove call. Also looking into the code, there is no remove call, we should remove the dn once it is dead ?
@aunyks you should make expected a Set to begin with so you don't have to convert the return value of the describe method to an array
Won't this cause the opposite behavior now where there is always an initial delay of _fullPeriod?
I don't thinks this method can return null. Please throw an UnsupportedOperationException instead.
should this be set if ret is false? I don't know.
Alternatively, String.format("(%s)", Strings.repeat(",", arity));.
valueOf does not support nulls - this will cause an NPE, just like the code before the patch. I'm guessing you meant to do something like this: return value != null ? valueOf(value.toUpperCase()) : null;
Compare condition at line 133 and at line 117
1TBS
since this method is called after the validate method, you can make the check shorter as you did in the executeCommand method
this method should return the same instance each time (meaning of "get"), store this value in a field named 'adapterFactoryRegistry'
Should add provider to the LOG.
log.trace
method withNoParameterConstraint is indeed somehow confusing. In my case, I'm always looking at the implementation to have an idea which I should use... I think that we should go a bit further and modify the MethodMatcher in order to have the following methods regarding handling of parameter: - withoutParameter : the method has no parameter - withAnyParameters: the method parameters are not considered and can have any parameter We could also modify the method matcher in order to fail if there is no parameter added and withoutParameter or withAnyParameters has not been called.
Do we need to specify the date format here separately, or would it be easier to reuse (with a little change to the default value's type) what is already included in Helpers, like: Helpers.getDate(parameters, PlatformSmartmeteringKeys.FROM_DATE, DEFAULT_FROM).toGregorianCalendar().getTime();? (Would help in using the same format everywhere and not varying from feature to feature, unless it would be necessary.)
Is this method ever used?
update etag and what about the blob?
Don't completely catch all exceptions. Some exceptions are not validation errors (for example, if cwltool was installed incorrectly). There should be three cases 1) passing validation 2) failing validation 3) throw exception on unknown cases
nit: this is a bit difficult to read (maybe just invert the condition?)
use ternary operator:  String metric = Math.abs(expectedYear) == 1 ? "year" : "years";
UUID is more expensive to generate than a SecureRandom, and since it doesn't have to be unique, just secure, there's no need to use UUID. Why not just use KeycloakModelUtils directly? It's what we use for example to generate client secrets.
This method removes all the orphaned disk after commit a snapshot. This should be always called as before
I think here we want to say @Column(defaultValue="true") in the annotation but have this translate to the return value of getTrueLiteralValue or getFalseLiteralValue when creating SQL text. So check the default value matches "true" or "false" before picking what text you put into the DEFAULT statement.
As long we we perform the checkNotNull(...) in getEntityTypes(visibility) below, I think we should do the same for stateClass as well.
getter
debug/trace/remove?
Ditto on direct return, can avoid the intermediate variable.
actually get() will throw if taskClass is not defined, instead of returning null. I think either do a scala option.exists() or something like orElse().
please use assert4j - assertThat ....
can use diamond operator, too, for all Or<> and And<> operators.
This might not work here, as here the configuration object can be not an instance of OzoneConfiguration, then ozone-site.xml and ozone-default.xml will not be added to resources. The check is done inside BasicOzoneClientAdapterImpl.java <LINK_0>
@whichonespink44 Because you are now registering all of the event handlers during pre-init, they will all be registered at this point if you are creating a world that is not a RTG WorldType. returning here only prevents the river remover from being initialised, but we also need to unregister our other event handlers so that we don't interfere in a non-RTG world.  java if (!(event.worldType instanceof WorldTypeRTG)) { unRegisterEventHandlers(); return; }
since no Wifi would omit the whole function, this if could be removed.
Message<?>
I think an attachment key would be ok, but we should also keep the existing check (i.e. we should not be adding the attachment key to exchanges that have their encoding handled by the listener).
It's probably not worth having the case for the default?
I think you probably don't need this. This is just for turning off insignificant network updates (e.g. cell tower info) when the screen is off.
This will mutate 'model' if model.has(...) would return false. Not a big deal, but more robust not to.
nit: do you mind negating this check so that you can un-indent the rest of the method? ("early return" style)
I see that you pass those parameters a lot VuapVideos.PORVATA_VAST, VuapVideos.VAST_VIDEO. Maybe you could extract method from it or hardcode those two parameters?
Yeah, it generally doesn't add much to logging, but in many of the situations you have here where you're just trying to log a full exception standalone it might be useful to slim down the logging output and make ever so slightly cleaner code. EDIT: Not saying you have to use it though :)
Agreed - this is a good candidate for unit tests
Can you please add a log message that we're skipping the CSD update because it's a Data Lake
Please extract the Globals.prefs dependency (and even better move the saveCustomEntryTypes method to the preferences class)
result.isEmpty() can be used instead to avoid creating an iterator instance.
We can't use any thread... There's the Scheduled Executor.. this is no good!!!!
what for you call load?
Need to return 1 when it's leap-day or year-day.
All these tests are returning a score of 0. You need some tests that return a good score for these cases as well
What is the use of map here ?
When would characterBuffer ever be null? Same question for getAndResetCharacterBuffer()
No magic numbers! =) Set a "float scalingFactor = 1.0;" variable somewhere please.
Throw UnsupportedOperationException instead?
You can manipulate the class list directly using: anchorElement.classList.add(); and anchorElement.classList.remove();
Style-nit: Don't assign then replace. Instead use a proper if-else: if (user.isBatchUser) { return queues.getBatchQueue(); } else { return queues.getInteractiveQueue(); }
Please use Guava's equal helpers <LINK_0>
Not used outside the class. Can still be private.
handleFailure not needed here, it is already set as defaul error state above
Shouldn't one of these exception be at least be logged ? I bet they can contribute to debugging.
If I'm not missing something, it looks like you are building the card field just to respond to this method. You are also building it with a constant, so I _think_ you should be able to just figure out what that constant is and use that instead.
I don't think that's an accurate message. Can't think of situation where "it's not started"
No need... getImage().setActive(active)
setRepositories?
inline
I would make it <= (allow equal case to meet requirement). Is there a specific reason to be strict about it?
To be clear, the name can be "full_acid" and "mm_acid". In fact. MM table can be created on Orc data.
Better to use the constant here, so an onlooker understands it tests the default number
Does it still make sense to request a batch at a time?
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
I would rather change the equals() invocations here to == (which is the more usual form anyways) which then would let the request go to the superclass implementation that may be able to do something useful.
maybe above in content = ..., add normalizeJson("[" + element1 , ...) and then remove replaceAll here.
Why not define listModelOptions.getDependenciesFor as a List to begin with? If the PL is restrictive, then any advantage in the public API being flexible? Is there a risk of running into conversion errors by simply casting it to a List -> would a for-each loop be better: <LINK_0>
Why is this method parameterized?
Is this toString still valid?
Why not iterate topics directly ?
Would it be cleaner to do record.userId = pageView.userId? Same for the other fields below.
Why is bindDynamicProducer synchronized, but this one not? I need to know more about this MessageBus stuff and where it is used from, to determine which behaviour is correct for this methods, but I hope you can provide correct answer anyway
Please remove this log, or lower the level to fine.
Please use interfaces where possible.
@vkuchyn let's use better English here and actually give an explanation people outside of the people working on this understand :) I suggest: > Rultor closed this pull request for you because your .rultor.yml specified the use of rebasing before merging. GitHub does not mark rebased pull requests as merged, because rebasing entails a change in commit hashes. Nevertheless all your files have been merged exactly as they would have been merged without the rebase option set. Also can we please move this string to the resource bundle that contains all other strings please ? :)
To really make this method overridable, shouldn't we add a (protected) accessor for m_bundles as well?
Why is this getting the old item and then calling refresh with that ??? If I look at the data provider & communicator, the latter will use the item provided by the former in the event and then update using that one - so basically this code here, to my understanding, will loose all the changes when the objects are different but even if they have matching identifiers. So to explain this: old bean: Person:{ id=0, name="Liam" } new bean Person:{ id=0, name="William" } identifier is id field. When given the new bean to refresh, this code finds the old bean using the identifier. Then it passes the old bean to data provider which fires the event. The data communicator gets the event and uses the old bean for refreshing things and the update is missed. Or am I missing something here ?
L233~L235 can be removed.
Static method import please!
The size of the usage array should really be based on the length of the input array. If 256 is really required, we should probably check to ensure the input array is that size.
@xiaolong-sn nit: Optional means you do not need to null check:  return Optional.ofNullable(streamConsumerArns).map(arns -> arns.get(stream));
don't annotate the first part
bug; need to remember the first via header...
please enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
Maybe this should be an enum?
do you really need it to be an atomic reference? could you just assign it to a variable?
Aren't we storing file size in bytes? Can we change this to just file_size?
You do this in a few places. Perhaps it deserves its own function in HadoopUtils or something like that?
notifyDataSetChanged() missing?
DeviceController instead of BuddyController
I would add a final here: suggestion final ConstraintType constraint = ConstraintType.fromString(constraintType);
Avoid calling getActiveStudentCurricularPlan() multiple times in the same method. Invoking the method multiple times results in a performance penalty that should be avoided.
re-use existing constructors:  this(cookieSpec, false);
It would be helpful
Better to refactor the method name isValidAddress to **isValidV4Address**. What do you say?
You might consider using Collections.singletonMap() for slightly nicer code.
TODO: Limit to last n notifications.
Local variable seems unnecessary here.
The default type should be String.class I think.
This can be written a bit more elegantly now using the isAnyFieldSet method, right?
Duplicated code. It should be getFormId(form). Also, if/when you change ExportConfiguration.fallingBackTo(), the signature change on ExportForms.getConfiguration() should be rolled back...
return value is unused
Same constructor visibility thing.
user will definitely not need it, it is quite internal exception, which we could track in the logs
Same concern as above.
We should probably move this into a camera2 implementation, because we are leaking camera2 implementation details here. As a thought a ImagePrecapture interface which by default uses flash mode, but in the ImageCaptureProvider if the device is legacy it would provide an implementation that would just return saying that precapture is not needed.
please add populate(...)
why this change?
no need for the manual check.
Initialize to null or immutable copy
vds.getVmCount returns the number of VMs that the host reports while isAnyVmRunOnVdsInDb checks that in the database. here, it seems that there is no reason to cal isAnyVmRunOnVdsInDb because the first part already checked the database, so we do the same check twice
Does not match conventional toString implementation.
looks like this can be static
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
ShellIsAvailable
How about something like this to make it more robust?  try { if (!isUniversalBuffer) { : boolean isLittleEndian = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN; if(isLittleEndian) { bufferClsName = "org.msgpack.core.buffer.MessageBuffer"; } else { bufferClsName = "org.msgpack.core.buffer.MessageBufferBE"; } } } catch { // Let's use MessageBufferU } if (bufferClsName == null) { bufferClsName = "org.msgpack.core.buffer.MessageBufferU"; : }
Remove
Is this a Warning or an actual error?
In the jira request Jeff requested that this be a required arg.
Why public ?
Needs a test of the output:  final ByteArrayOutputStream myOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(myOut));
Is qualifying this here necessary? The context looks to be MockChart already.
Arguments.length is already been checked for above, I think there is no need to do it again.
Is this needed? The menu item will always be clicked/navigated to from the UI thread.
60 seconds would be a better choice
before we would never throw an exception here, is it safe to do so now?
This max rows disagrees with the assertion, which is why the test is failing.
Doesn't this duplicate the nonNull check?
Typo here. should be service_type
Why revert the changes to use PropUtils? PropUtils will provide a meaningful exception when these properties aren't set, otherwise it generates an NPE.
@qaga .scrollToFooter() method is intended to scroll to global footer, not MCF. Depending on the screen resolution when test is executed (and jenkins has lower than you ;) and what exactly test is doing, test may fali. IMO we should write a method .scrollToMixContentFooter() and use it here and other tests instead of .scrollToFooter
Expire a bit earlier, e.g. after 29min? That way the risk (small as it is) of an expired token being sent is avoided?
A null arg should instead throw an IllegalArgumentExcpetion as it's an unexpected/invalid input.
It's only deletable if it's not saved?
I just realized that this will fail if the absolute path string contains a space since the full string is parsed by spaces (This is why no one should really use the full command string). So for this test method, you will need to revert to the prior state (using simple java command) and delete the final assert on the execute method. We have confirmed the execution works in testSimple and this method confirms the full argument parsing, so we can avoid the assert on the execute here.
added logError
I'd move the failure point above the for loop.
not sure how you get this when you don't instantiate via hk2 but manually
Why we use the VALUE keyword before ?
I think we want to make the string computation lazy, but not lose info. We could do that by overriding toString.
Instead of creating a File object you can use another FileInputStream constructor that accepts file name.
You can use Util.asSet instead.
what worries me is that the oldMessages is left unprotected between the calls and in theory could be modified.
We should add these as an internal API for now.
wow this is awesome. thanks for setting this up. fyi @emord we may be able to expose this list via an api call to formplayer if you think it'd be good to have in vellum
File
Should be set to null, especially as LockDecorationUpdater has not all its fields set to null on unregister() call.
this will recognize all props starting with "druid.metrics.emitter.dimension.", I understand that currently there are only two (dataSource and taskId) but in future we might add more and all of them will end up getting emitted from here unintentionally. Should we look for specific dimensions present instead of blindly taking all?
Must not instantiate ~~an element of~~ this class
Shouldn't we be using RestConstants.PROPERTY_UUID?
nit: make a variable and reuse
Didn't get idea of those .***IfAbsent methods. Why u need them? Irregardless of servicesProvider type u go through .registerInMethodRegistry() anyway which, by turn, sets corresponding dependencies.
If we say we never use null as key, we simply but a Objects.requireNotNull(xmllang) guard before the get(). This would also avoid the try/catch block.
WorkflowStateDto::new would then become a call to asDto
This would have an unexpected consequence if someone has dfwe${...}asdfa pattern right inside a password property.
this is really not needed for any of these. Perhaps remove them all? I don't really mind whether it's kept or it goes but it should be consistent.
Since Dates are mutable, a copy of startDate should be returned to avoid downstream side-effects.
Use Paths.get(directory).toAbsolutePath().normalize().startsWith(nuxeoHome.toPath().toAbsolutePath().normalize()) to avoid dangerous .. path components that would allow escaping the nuxeoHome directory.
I'm not sure that we should remove the mocked push. Did we talk about this?
is this used anywhere? If not, please remove
Unfortunately, H2 doesn't support that syntax. In DB2 this works by using from lateral (values (?1)) but I doubt this will work here. Can you think of any other SQL that might be able to produce the same result while rendering the template argument only once? If not, we will have to bail if encountering a parameter.
We're probably going to want this to throw some sort of exception so the UI can display that some notification that the write didn't happen.
Protected doesn't make sense on a final class.
int c = getCount(); but you can inline that in the next line too.
Use SelectionAgen in this case.
useless parenthesis
Dont throw this exception, but set it on exchange instead, eg exchange.setException, then its handled in the finally block using the configured exception handler on the consumer
Please move to a @before function
I think it would better with one condition statement. I also don't think the we need to use isMetricAttributeDisabled method as well.  if (!getDisabledMetricAttributes().contains(type)) { output.println(status); }
changing Jenkins.getInstance() and Jenkins.getActiveInstance() to Jenkins.get() is ok, as long as get() really is the right method in each situation - sometimes code uses different getters for good reasons. I'm not claiming that this code has good reasons, but it's a possibility one has to consider and I'd like to know what the justification is. However, any such changes are best done as a separate PR.
You can use  serializableItems.addAll(objects);  instead of iterating the collection.
What has the reason been behind this change?
Look like generally you change a logic. In previous implementation we collect expection only if it's instance of UIAssertionError but you change this logic. Why?
would have this protected and with indent adjusted
This behavior is different than what we had in the prototype. Since those impls were based on Redis and RabbitMQ, it's not so easy to compare with the local in-proc impl, but... The idea behind tap in the prototype was that the name would be something that should already exist and the channel would be where tapped messages go. So in that case, tap() is more like inbound() except that the source is a wiretap to be added to the (pre-existing) channel with the provided name. Don't know if that's very clear, so let me know.
Looking at the history, it's a convoluted way to set dirty = true in the parent class. We need it for that scenario:  java Select s = select().all().from("foo"); System.out.println(s.getQueryString()); s = s.limit(10); System.out.println(s.getQueryString());  It's also used in Batch.add. I suggest adding a setDirty method to make this more intuitive.
We want to make sure that the bucket name doesn't start with an upper case character, since it's one of the naming restrictions as mentioned [here](<LINK_0>
Given that quality is an int, I believe it is guaranteed not to be null, which makes the test unnecessary.
If this should really **never** **ever** happen, we should probably log it as an error, not warning.
u == Use.NDT || needs to be removed (otherwise, all math functions will be treated as non-deterministic)
Remove the InterruptedException from the signature.
Not obvious what this argument does. It looks like it's just to copy the identity? Why not just pass a PersonIdent instead?
At the point in the code I would expect that lock == value. I think it may be worth adding a sanity check for that. Could do something like the following. java private void returnRowLock(RowLock lock) { Objects.requireNonNull(lock); rowLocks.compute(lock.rowSeq, (key, value) -> { Preconditions.checkState(value == lock); Preconditions.checkState(value.count.intValue() > 0); final int newCount = value.count.decrementAndGet();  return (newCount > 0) ? value : null; }); }
Change log level to debug
if (, braces
detectedByOrder is not final, so the value could technically change between those two calls. Unlikely to happen, but semantically it'd be better to extract to a variable first. I'd also put parentheses around each side of the &&, but that's just me.
A lot of duplicate code with invoke. You can extract method with processor or create DTO object
this could throw a null pointer exception if a datacenter with that id was not found
I'm concerned about your fallback here. All of the fallbacks should already be applied when the config was initialized.
Ditto, will this break if we add repos at one point?
_nitpick_ I find statements like this a little bit hard to read, I would either: - surround the right hand side in parentheses: shouldNotReportIssue |= (calleeSymbol != null && "globals".equals(calleeSymbol.fullyQualifiedName())); - or create a helper method to do this check and reuse it in line 190, e.g.: shouldNotReportIssue |= isSymbolWithName(calleeSymbol, "globals")
Yeah, I'm also not sure why this needs extra sync.
I think we should make the default behavior to ignore the extension and actually crack open the file. That way it will definitely do what's expected, it just might be less efficient. If people understand it they can opt into the more dangerous but faster check.
I'm not too keen about having a FailedCompletableFutureRepresentation that kind of duplicate the production code. I believe we should simply verify that some subpart of the stack trace is present (a subpart that can only be in the stack trace) either with hasMessageMatching or hasMessageContaining, the rationale is that if such subpart exists then the whole stack trace should be there too. Whatever we do here should be applied to the other tests
@dain, Should this return int in aligning with getUnsetBits? The existing getSetBits (write bits into a BlockBuilder) returns void tough.
There should be whitespaces between the strings and the plus signs. Applies to the rest of jobs.
Small style nit: We don't use braces around simple statements.
Could you not grant each PhaseTracker instance it's own pool and avoid the lock altogether?
It was configurable before this change? You could add <property> <name>hbase.master.metafixer.max.merge.count</name> <value>11</value> <description>configure the max merge count</description> </property> ... to your hbase-site.xml and away you go? But maybe you think it deserves mention in the hbase-default.xml so operators can find it easier? If so, I'd suggest a fuller description. Thanks.
MoveToBlockAITask.builer().from(task).build() will crash because of the absence of the predicate. Not so good...
You can use guava preconditions check in this case : <LINK_0> Simplifies a bit the code.
what's the point of catching and then throwing the same exception type?
What is the point of the local var since it is immediately out of scope?
potentially binary breaking change
Ditto, can this still happen to be blank?
Because of u checked lock status of VM, I think that's why here it is better to use VmHandler.checkStatusAndLockVm()
This message means that the table of tableName does not have the partitionKey column. It would be better to print the partitionKey column is not the partition key of the tableName table.
This should happen within the future
Why not call CachingTable.delete(key)?
DO something?
Instead of suppressing an exception first and then checking for null, we should raise the exception within the catch block instead.
Could you make this variable final? Could you also reverse the ternary statement so that it isn't negative, i.e. isLive ? "" : "&t=" +  ? Thanks for your contribution.
Looks like format is missing in equalsAndHashCode
we don't know if these were used in extensions, can the things that were public remain so?
Looks like the file format is not uft8 which has resulted in loss of the currency symbols
Could return the value immediately.
Should it be also IllegalStateException here?
is this correct? if you use REPL, the rpc manager is non-null and the distribution manager is null, right?
Be aware that <b> using multiple filters on the same criteria</b> (id, priority,..) leads, in most cases, to <b>only consider your last filter</b>. Orth.
entity?
Is there a reason to always show the trailing zeros? I had tried to avoid that.
suggestion if (!Jenkins.get().hasPermission(Jenkins.ADMINISTER)) { return null; }
Use IllegalStateException ....
@fanifieiev please, use Split (Text) from cactoos or leave a puzzle.
Cannot we do this during the planing phase? Right after the plan has been built?
I believe the size of the strategies list matters more here. So I'd get rid of the check on lines 66-68 and would check whether strategies is empty then return null, if size if one then return the single one, otherwise compose them.
please add static import for Mockito functions (that goes for all places)
I'm not sure silent catch is good as after that url is null and it will create exceptions
spelling
Could you remove all of these empty lines in this method and below (navigateNextComponent)
For reusability, It's probably worth extracting this logic to a generic method that gets a SnapshotStatus. I.e. something like 'vmNotInStatus' and 'vmNotDuringSnapshot/vmNotInPreview' methods.
Some differences explained here : <LINK_0>
throws
you can just return keyInSet without having to set it onto referenceToLockKey and return null on line 105
many blank lines in here
'If" statements with 'else' branches should have curly braces around both branches.
Isn't it docker/Dockerfile ?
Ditto about checks. I don't think we need to duplicate them.
Location is always related to an activity. Therefore, I think it does not make much sense to just add an location here. It needs to be assign to an activity since only activities have locations.
Is this being read anywhere? plus we seem to be saving the same thing twice?
There is a guarantee that the first statement after a if is executed without being preempted. But only the very first statement [1]. So you could null-check directly on fTempFile here. It's very good practice to extract to a local variable in general, but here it's a very small method that does only one thing, it would be fine, imo. [1] I remember this I think from a class a looong time ago, but I can't find any references online... The compiler seems to agree with me though. Or it's a bug and I'm becoming crazy? :O
In toString() and log messages, we use "[" to denote lists, collections, arrays, etc. We use "(" to denote fields. So let's change this into: return "Pair(" + key + ", " + value + ")";
disposables is null.
Remove default.
@NielsCharlier try-with-resources?
Should this toString have errorMsg as well?
Can we get around this instanceof somehow? Should it be generally possible to invalidate EntityRef?
check that thow e doesn't crash media-server
Should be "this(true)".
Is there a case where authentication != null for anonymous users? In other words: can we remove the second part of the check?
The text is grammatically incorrect. Encrypted secrets *are* redacted Is probably a safer and shorter statement
Use getHttpPort() instead of repeating call to getAttribute()
It could be extracted as a constant name:  private static final String WORKSPACE_NAME = NameGenerator.generate(DeleteRunningWorkspaceTest.class.getSimpleName(), 5);
print status code may be to show difference between with and without response?
Sorry.. being pedantic.. in the onFocus handler you call a method enableDataModelerDocksWhenIsHidden()... would this second method be best called something like showDataModellerDocks()?
I think @dlotts added some code here for removing statements from the indexers. make sure that doesn't get erased here.
Return type should be the SearchResolver interface for autowiring to work if needed in future
Wait doesn't require returning the value. IMHO it's better to rename method to isFilenameSuggested(nameFragment) according to the actual commands.
In order to avoid the pleonasm, what do you think of renaming the token variable inside the Token class to: bearerToken? That way, this line would become:  java Assert.assertEquals(bitreserveClient.getToken().getBearerToken(), "foobar");
So here we add this fragment on the backstack, but earlier (line 57) we add the same fragment but without the backstack. Can you explain the different situations you are solving for?
This should be moved inside the if to avoid unnecessary work when the if is false.
Instead of Matchers.notNullValue() please, check that actual value equals expected value
can remove the 'else' clause...
Based on the API doc, ALL_KEYS behavior is now deprecated, please use an alternative.
i think dashes need to be removed from ikey here
Why not just ImmutableMap.of()?
should be loaded lazy
Please remove the System.out here...
Please add a log indicating that, something like: "stopping the session did not succeed, upload state has not been changed and it is still ${uploadState}"
@CatherineRomiyo didn't we wanted to get rid of this additional method? It would be much better to extend GET_EXPERIMENT_RESULTS to select the version and set this information with adapting the ExperimentTaskResultRowMapper, right? :wink:
Why not MyTest test = new MyTest() why casting to a parent class?
I think you can remote this jump to next line
We already have a function named handleNavIntent. Could those functions be combined? They seem to do pretty similar things.
change to getClusterDao()
Shouldn't this be a field so we don't have to create one each time
I'm wondering whether we should use GENERAL_IMPORTANT_CHANNEL_ID for both site creation success and failure?
Core.TITLE
H-How did this happen?? The project setting's Save Actions are supposed to add brackets to all 'if' clauses automatically...
<code> client.getNamespaceWatcherMap().getNamespaceWatcher(watcher)</code> will add a namespace watcher record if it doesn't exist. That doesn't seem right for removal. A new method in NamespaceWatcherMap is probably needed.
The CannotSerializeTransactionException and DeadlockLoserDataAccessException are both inheritors of the PessimisticLockingFailureException, so maybe we can go the way for their super class?
This should be a private method, it doesn't need any docs.
The partial field is only used to do system allocations. Now that you introduce useSystemMemoryPool, is partial still needed?
It could be renamed to reflect that it sets blockSize.
Should we move this outside of the if block to make sure it will always be set to false when stopping the transport?
I think method overloading is a better approach rather than checking for nulls. WDYT?
its funny to read return notSanitized(...) when the method should return a SanitizedText instance. Maybe we should rename this factoryMethod? Also using the classe name would improve readability:  java return SanitizedText.fromPlainText(...)  Or maybe the sanitizer.sanitize should return a SanitizedText instead of String...
rather check the flag outside the loop
Since the body of the for loop won't be executed if the collection is empty, you could eliminate the CollectionUtils.isNotEmpty check. Also, you could use ObjectUtils.isNotNull for the null check.
I noticed that you added a maxLength to the VineDefinitionComponent but it's not used anywhere. This 20 is the vine's length so replacing it with maxLength will implement it.
I still think this should be context parameter.
I don't think you need transaction here
Please add at least one project
Some issues with mixed tabs and spaces? Please configure your IDE project for spaces only.
can we avoid multiple return paths especially inside nested loops?
@tmarzeion I would probably extract this to separate method e.g. loadDiagnosis() and call it inside start(). The loadDiagnosis method can be reused later
could be simplified to return s != null && s >= seqNo;
Would make more sense to me for latch to always be incremented and decremented, when it reaches zero the event is fired.
since we're synchronizing this call we could also check capacity first, instead of instantiating the MessageIdTracker and throwing it away if the map is already full?
Maybe also check name is non null ?
Let's make these also verify the error message.
nit: "PhoenixTTLTool" here and few more messages below
this(new Symbol(symbolName), estimate)
Should be changed to the ExpressionUtils.createStandardEvaluationContext(beanFactory) - creates StandardEvaluationContext if there is no one in the ctx.
Same here - let's revert and move the logic to ReliableChannel.
Instead of just casting and letting the function throw an error (which most users won't know to catch), how about prefacing the cast and returning null on error? Requiring users to call isFunctionType() or isClassType() before calling the proper getXXXType() method is not very programmer-friendly; it's a recipe for hard-to-find bugs.
I'll reshuffle things around a bit - this is a bit strange to keep on the API because DedupFilterHolder is private
Error message parameter "name" seems to have been lost in the conversion
Can we update the old code with the exception logging convention we are following now. LOG.error("Exception while retrieving home community ID: " + ex.getLocalizedMessage(), ex);
It is better to supplement the similar check to avoid this action is called multiple times in practice. Maybe we can check the available exclusive buffers should be 0 in BufferManager instead?
Not sure this actually throws a MalformedURLException any more. As it is a test, why not just use Exception, the test will fail anyway if any exception propagates out.
Is it possible for this to be null?
@pedrofvteixeira , enc is not being used in the decode call. Is that on purpose ?
I don't think you should make this change. Using an Optional as a parameter to a method/ctor is problematic for many reasons, one of those reasons being the fact that you can't easily tell whether to check for null or ifPresent. On a cursory examination of code, I didn't see anything preventing someone from invoking this ctor with a null errorIndicatorValue, in which case you'd throw an NPE on this isPresent check.
It would be better if you could pass along this data, setting/retrieving a value in sharedprefences is a bit surprising
Lets replace with return new MkDocs(this.dir, this.name.replaceAll("[^a-z0-9]", "/"));
this needs to be synchronized. I got a java.util.ConcurrentModificationException when closing the view while right after opening a trace.
This is usually an anti-pattern, since we will crash below with NPE if path was somehow null.
When this stop command is run, have all the IpServers that use the tethering coordinator already been stopped? If not, and they are still running - is it safe to stop the coordinator?
Since its implementation is just one line, why not inline it?
This job is currently configured to have unique-by-entity & other constraints. You can see that by checking the old jobs that either 1) extend UniqueByEntityJob, or 2) explicitly define the methods isSchedulable & scheduleJob. The old HypervisorUpdateJob is doing #2, with the target being the owner, but it is also using a custom query during the isSchedulable method that not only checks for non-terminal jobs of the same type against the same owner, that ALSO checks & schedules these jobs in the order they were received. So it will only allow the job to run if it is the oldest of its type against this owner (see change f15807dde0e4ca0f08fcee7b94e7b4b29327e478 for details). Currently, the new way we do constraints is to add the constraint here, in similar way to the ImportJob/ExportJob: .addConstraint(JobConstraints.uniqueByArgument(OWNER_KEY));. This needs to be done now at a minimum, but it not take care the requirement of preserving the order. This is another topic in the list of things we need to discuss when @Ceiu comes back I think.
Same thing as above. We can create ObjectMapper once and use it over and over.
Should we use system properties instead of environment variables? Or is there no easy way for the PCT to specify system properties? I would use BourneShellScript.class.GetName() + ". SKIP_BINARY_GENERATION" as the property/env var name for better traceability wherever it needs to be used.
I'm not sure how frequently people use a different UUID generation scheme than the default UUID4, but it might make sense to compare the sample rate to Random.nextFloat instead. If you used something like UUID1 you're not going to get a suitable distribution here.
File separators need to be correct in tests too, in case of windows
super() can be removed
Let's only use DsfDebugOptions... as mentioned above
Could be great to return an empty map instead of null
These three lines are redundant with lines 291-293 below
extract method
return executeCommand.execute(action, resultCallback);
I am not sure about synchronisation around this variable. It is the first time I am looking at its lifecycle and it seems to me that we are not doing well. As you are setting it to **null** ...can we fall into an NPE?
increase to Debug-Level
I think this should be left in - when one arg checker is needed, I would usually check everything
better to use Files.createDirectories
replicas -> replica
We import it already, no need for the java.nio part.
The call to this() isn't needed.
This test case is actually using an empty string instead of a null string. Should it be updated to use a null string, or should this test method just be removed altogether?
please just define on the next row.
the two last checks can and should be squashed into one check - returnValue.getVdsError() != VdcBllErrors.SpmStatusError, I actually prefer !VdcBllErrors.SpmStatusError.equals(returnValue.getVdsError()) the first check can be removed, but that's up to you..if it's being changed into one check, the whole method call can be replaced with the check :)
I have a preference for single assignment for arguments. This is just a nicety.
Let's remove that line as it's not part of the improvements
why not implementing a template method subscribe that calls an abstract method which has to be overwritten
You need to use Arrays.toString(this.getDnsServers()) here.
This if statement could possibly be refactored to if (valid && doesAccountGlobalHaveAccountRestrictionCodeAndNoSubFundGroupCode()) { valid = isTheNewRestrictionCodeValidForEachAccount() }
Instead of calling init explicitly here, you could just call this() to call the default constructor ZKConfig.
use an overridable getOperationTimeout() method instead
I don't think this will work because the returned and parsed value is not used. I expected: this.clientAuthenticationMethod = ClientAuthenticationMethod.parse(auth);
minor: I would suggest this:  if (domainName != null) { domainName = domainName.trim(); if (!domainName.isEmpty() && domainName.charAt(0) != '.') { ... } ... }
Please add curly braces to all if statements.
Realm should have an overloaded method getClients(this), that just calls getClients(this, null, null). This approach will result in extra query to get the client counts first, to then list all clients.
Here we also need a default prefix for AsyncRetry.
you changed LCH.containsAll(TSCH) to TSCH.containsAll(LCH)
I think Runtime exception is not the best choice. What about FileNotFoundExcpetion ?
Unused variable
why UK?
add our good ol' friend remove() :wink: (Current would be correct for scala.collection.Iterator :-)) // does not override abstract method remove() in java.util.Iterator
With these usages in addition to those in [RegionWSServer](<LINK_0> this QueryResult initialization is getting very redundant. Could this small code block be extracted to a method in the parent class?
I think this should be else if (clusterPermitted); otherwise, you'll unintentionally increase the number of available permits.
Unecessary RuntimeException
why does the exception have to be caught?
why concatenate in the string below?
use sprint.getAttributeValue(AtsAttributeTypes.StartDate). shouldn't need to cast. Same for EndDate
long line
Nit-pick: typecast could be inlined here, avoiding explicit "original" variable declaration, since it's only needed here.
ABSOLUTE SHOW STOPPER.
@cyberone Can we revise this test without using random string? I don't see the need for it here.
Shouldn't this be DeveloperError ? When you stopPresenting before calling startPresenting ?
Minor: logger.debug?
Lets create printLastErrors in the kerrnal like osUser methods. Log will not be needed.
I think this is going in the right direction, but all these checks should be happening on setPemFile(Path path). The idea is that we don't ever want an ExportConfiguration instance to hold an invalid value. We will only set a value on ExportConfiguration.pemFile if it's a path to a file with a valid PrivateKey
It would be better to allow to pass the (java.util.function.)Consumer (or let this notify the event), to avoid the unnecessary collection/garbage.
Deprecate setConnectionId and instead of setAsString call super.setId method to avoid duplication
Why do we need operationTimeout as ctor arg. We can include this in the accept*Session APIs.
probably could make these strings public static final vars
how are we sure that the operation won't complete before the router is closed?
I'm not sure since it's a client setup issue, not a server-side issue. I would re-throw GeneralSecurityException (it changes the open API but at least it's not ambiguous).
spaces
Maybe another try with a multiple String[] ?
I think we should do it the other way around - first process the status and then the devices 1. because the status is more important 2. because if that is an external VM then we already triggered FullList - we should add the devices there to reduce the number of calls to VDSM
Use a variable for mit.methodSelect() instead of calling it 3 times.
Is this guy stateless? There should be a static instance() method on it.
Do not call dialect.getRowConverter during runtime.
You're returning the wrong type here - you should return CreateEcKeyOptions
In case zoneId is null, maybe put "system".equalsIgnoreCase(zoneId)
DITTO about isDebugEnabled()
You can use KryoCloneUtils
!inputSchemas.isEmpty()  - this is same check as inputSchemasAvailable right?
This function can be made static if you call getResources()... on the a argument
I might rewrite this as  java import javax.ws.rs.core.Response.Status; ... chain.doFilter(request, resp); Status status = Status.fromStatusCode(resp.getStatus()); if (status.getFamily() == Status.Family.SUCCESSFUL) { eventSinkProvider.get().sendEvents(); } else { log.debug("Request failed, skipping event sending, status={}", status); }  (It's okay to do == with Enums although you can also use equals() if desired) Or if you just want to stick with integers, you could just store the status integer before the if and then not have to use the isDebugEnabled() block.
Please make enable() and disable() synchronized and remove the shortcuts.
@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>
I assume we should have the same behavior as ExportVmCommand. Do we still need this?
Try Mono.when(sender.send(message), sender.send(message))
Really it is not a thread safe way to implement a singleton. here explain my point: <LINK_0>
I don't understand why we check debug level here but log error,
Please include the exception instance itself instead of just its message.
Don't do assignment to student but just return java return logic.getStudentForGoogleId(courseId, account.googleId);
use computeIfAbsent?
This seems to be used only in update()? Given that it is much simplified let's put it inline within update() then, and let's remove this method.
There is actually problem with this code. If server value is not set, we still want to use user value. Web app handles this situation.
nit: Inconsistent "should the space be at end or start of line" treatment.
we should lift the creation of the CassandraKeyValueServiceImpl outside of the lambda, and just have the lambda call isInitialized. I believe the lambda is invoked many times when starting up, we don't want to run into the resources problem that we had the other day. Yes it was wrong before too.
collapse into one line
Don't need the context null check here anymore.
![MINOR](<LINK_1> 'Severity: MINOR') Remove the literal "true" boolean value. [![rule](<LINK_0>](http://sonar-s4/coding_rules#rule_key=squid%3AS1125)
move this to 244, then can get rid of extra if check
Maybe explode with a precondition check that capacity is larger than 0 here instead of exploding out of bounds [here](<LINK_0>
pls be consistent in the error messages, see line 94
minor typo : normalized instead of normilized
the method is called "connect()" but the logs speak from "reconnect()" - it would expect to log about "connecting"
If there is no specific reason, we can make the constructor private.
Suggest naming this objectBindings
how do we know this call is for write? This message should be something like "Key not found for Id". Right?
This should happen in onUnload
Nice to have test cases. Are all the cases that we want to cover? Did also fail with an empty directory, or a directory that contained an unparsable file (not a jar, but let's say a text file). If so, it'd be nice to have tests for these edge cases too. In general, as inspiration we could use how /usr/share/java looks on typical linux installations.
optional: this would be more readable with an "import static"
This method should have default visibility as it was before to avoid synthetic access.
Why do you need checkNotNull() here? ChartSeries.getX() should be already @NonNull due to the package annotation.
Should we use a range annotation, something like @IntRange(from=0)?
maybe return ringTime.isBefore(currentTime) to avoid the if
Under what circumstances can you reach this line and have nextRec not be null? It's not modified outside of this method. Making it a private field would make this a little clearer.
remove and call reinitializeCharts on the viewer instead.
'this' is unnecessary in this context
Should not log an error, that's usually reserved for possible issues/bugs in the code.
This operation should not block, so probably do not need to run it in the sync commit executor. Could probably just call commit failed and return a completed future.
not needed.
Why close?
Is this a bug in SchemaUtil.getQualfiedTableName? This seems like something we shouldn't have to repeat everywhere.
I think it should rather be : '#?' instead of just '?'. I you use just '?' it will replace the query string if there is one (for example the tenant id could be removed)
is this a good idea? All this will lead to is a null pointer exception later on. Why not throw a descriptive exception here?
Why isn't normalized.toString().isEmpty() working?
As @mswiderski said, this should be also replaced with the feature of AssertJ.
okay so you already have this covered, no need for AnchorPointTest above?
[optional] I know that it is a kind of pattern to use the classUnderTest name for the tested instance. However, it doesn't always help with the readability. For me, this: assertTrue(backend.handles(ANONYMOUS_USERS)); is more readable than: assertTrue(classUnderTest.handles(ANONYMOUS_USERS));
New ADF should not be hard-coded but should come from the string resources. e.g. getResources().getString(R.string.default_adf_name)
I'm not sure we need a public getter for this, since this should be used internally only.
suggestion return !Jenkins.get().getDisabledAdministrativeMonitors().contains(id);
after overriding equals() and hashCode(), could you write a test to verify they work well? By using EqualVerifier, you can look for many example of that usage in James project!
Should this be consistent with line 40 above (getInt vs getLong)?
No logging necessary in the tests IMO
Should this be synchronized?
Why do you want to do this if you already have a hardcoded string in the .ui file?
I'm a fan of breaking lambdas into method refs: .map(AnnotatedElement::getAnnotations) .flatMap(Stream::of)
Could this be protected as well?
Consider using the validatePrimaryLanguage for testing the results, rather than converting them to lists and then doing the comparison.
nit: better to call eligibleForLoad(currInterval, interval) for easier code maintenance.
why not returning a Optional<String>?
Rename it to just key please.
Check for null before using options.
I think the "while (true)" loop should be removed. I think it is a remnant of the tryLock code. As it is now I don't see that it would ever loop.
What do you think about enforcing an *exact* SDK version requirement, instead of "minimum"? I'm guessing that future SDK versions might have slightly different font rendering or other subtle differences that could break our precise screenshot tests.
Since you are passing this to the superclass constructor, why not have a superclass manage the lifecycle of this variable? CryptographyAsyncClient can have a protected method getKeyId() to get this key id.
Very minor but let's try to be consistent with the order of the method parameters.
Add final keyword? Also other places when necessary.
nit: Slight formatting improvement suggestion String dialogContent = dialog.getContext().getString(R.string.confirm_deletion_message, " \"" + listName + "\"");
In combination with making configurationMetadata empty, we should also prevent this from be null
Do you need Integer.ToString? This might work: hostName = "" + 0xff & hostAddress + "." + ...
this((Run<?,?>)owner, ...) would be simpler and safer for further class evolution down the line.
why the casting?
i do not understand why to punish yourself, make it simpler.  final KafkaZkClient zkClient = createZkClient(zkUrl) try { ... } finally { zkClient.close(); }
filter.getComparisonOperator().getValue() could be set to ComparisonOperator.EQUALS because it is the only supported operator. Just the parameter not the string template placeholder.
Use a logger instead ;)
what you should do here instead is to update the adapter's item list.  adapter.setItems(ProjectManager.getInstance().getCurrentProject().getSceneList());  or  initializeAdapter();  although the initializeAdapter does more than that (would still work though). why? because when you rename the scene, the whole project is reloaded but the adapter's list not updated accordingly (i.e. the ProjectManager get's a new project but the SceneAdapter still holds the old scene list). this is really straightforward and there is absolutely no need to detach and reattach the fragment.
Since you're restricting this to 100 entries it's ok for now. Still, I think we should consider using a better data structure for the lookup operations, like a HashMap. One idea is to have the hashCode as the key and the card type binary-ORed together could be the value.
no point in synchronizing entire getInstance() (read+write), you should be only synchronizing 'write' to instance
hardcoded string "id"
Copy VF too
use existing method artToValidate.getModType().isDeleted()
This is wrong, should be entry.getValue()
This code now has a race condition. After checking if size > 0, Dequeue could become empty before calling pop. There is a method called pollFirst that could be used to do all of this in a single operation. However I am not 100% sure that pop and pollFirst take from the same end. java CachedConnection cachedConnection = unreserved.pollFirst(); if (cachedConnection != null) { cachedConnection.reserve(); reserved.put(cachedConnection.transport, cachedConnection); if (log.isTraceEnabled()) { log.trace("Using existing connection to {}", cachedConnection.transport.cacheKey); } return cachedConnection; }
shouldn't that be "noneOf", rather than "allOf"?
just concat the whole thing, do not +=
Being extra careful doesn't hurt but there is actually no need to check for null at this point. For simplicity's sake, I'd recommend removing the check as there is no semantic value in it. I would even go one step further and say that you can also remove the null-check around line 136 (radioButton.setChecked(mSelectedRole.equalsIgnoreCase(role)) by reversing the equals to role.equalsIgnoreCase(mSelectedRole) as the role is never expected to be null. Cheers!
minor, but the constructor in BulkOptions uses this.<field> for everything. Would be good to make consistent.
why unmodifiable in this case? maybe a copy which could makes the life of the caller easier?
Why is taskId passed in as the groupId argument? Would using "groupId" or a GROUP_ID named constant work here? If groupId is changed to parentId, then a named constant NO_PARENT_ID = "" would work well here.
Can this be private since there's a Builder?
I think you want to lock outside the try-finally.
Why make another beat? Can't you just make casts in the if case on "other" instead of making another beatrange "other2"?
Feels like we should check return value of schedule(), although I was not able to get a hanging thread here unless I changed LTTng Kernel Analysis to be non-automatic. I was able to get a hanging thread in CallStackView.getCallStackModule() line 1337. Also, in MemoryUsageViewer.updateData() line 153, StateSystemDisposedException should not be logged as an error.
shouldn't we just check startsWith?
Added a check, but with the jsonexception should never happen
Do we want to say how many were found? Just saying "Event records found" isn't really meaningful.
no isAudio, isVideo, isText, is Image all have the exact same code except for the string they check, so the code could be simplified into one generic, private method that is called by the for public ones.
Any of the ones defined as test extensions here-any of the MockXXX subtypes.
Can you use a toString method instead of a cast?
the cause should be logged in this case to help in troubleshooting.
Since clear is always non-transactional, I think you can ignore ClearCommand (or even throw an UnsupportedOperationException).
vfToUse might be null. This should not cause any problems, as setVmIdOnVfs seems to handle it correctly, but it might be safer to check against it (as was the case in the original code).
why not call the new method with null as third parameter?
NIT: this really isn't needed since this method returns false by default.
Please delegate to the other constructor using this(name, false); in the constructor body.
What's the purpose of the trailing - in logging msgs?
Either extract duplicated code in a method with single boolean argument or make the test parametrized.
better to have fail(); in the onSuccess()?
Redundant assertion
good simplification
Let's switch this entire block the other way around, i.e. throw should be the one inside the if block (guard clause) java if (userInfo.isInstructor) { throw new UnauthorizedAccessException(...); } // ...
This text is a good candidate for replacement of the hand-written key-value pair currently in Bundle.properties with an annotation that defines the text.
Can't this be cached?
I'd really, really rather use an enum to determine the view type and the layout resource:  java public enum EventViewType { TALK(EventType.TALK, R.layout.view_schedule_talk), CEREMONY(EventType.CEREMONY, R.layout.view_schedule_ceremony), COFFEE_BREAK(EventType.COFFEE_BREAK, R.layout.view_schedule_break), PLACEHOLDER(EventType.PLACEHOLDER, R.layout.view_schedule_placeholder); private final EventType eventType; private final int layoutResId; public EventViewType(EventType eventType, @LayoutRes int layoutResId) { this.eventType = eventType; this.layoutResId = layoutResId; } // ... }
I am not sure this trick works. You can be here when another thread calls increment function. You are not inside a lock
Missing super() call?
you do not need creating new instance of validatorLocator for every new sub-resource/subcollection, you can reuse instance defined in BackendApplication by adding [resource.setValidatorLocator(X);] in AbstractBackendResource.inject(). - it used to inject context ('backend', etc.) in to every sub-resource/subcollection,
Completeable.fromAction may be more idiomatic
It is better to use  java participantStatus.name()  since it cannot be overridden whereas toString() can.
add principal name to message?
Is this super call needed here?
Why visibility was increased to public?
Is there a specific reason for naming the various fields and variables in the Configuration class using the snake case, i.e., using _'s instead of using the camel case? If not, please rename them to use the camel case..
I generally put keys like this into a static class-level variable, although I know this is only being used once so not nearly as important. Just looked funny to me but might just be force of my own habit, so up to you.
Use correct class instead of IBity
It's either IllegalArgumentException or no exception at all like in all other constructors from this PR, like SecurePatient for example. For consistency I propose removing that check.
Is the user expected to build and place the jar into the "/tmp/storm-artifacts/jars" directory ? The extrasJarsLocation is already a dir. I think UrlClassLoader already handles directories. <LINK_0> "This class loader is used to load classes and resources from a search path of URLs referring to both JAR files and directories. Any URL that ends with a '/' is assumed to refer to a directory. Otherwise, the URL is assumed to refer to a JAR file which will be opened as needed."
not equals!
Without iterator it will throw concurrentModificationException, will not it?
There's no point clearing the old list if we are just going to drop it and assign the reference to a new one. Let's conserve the memory allocation. suggestion this.listOfGroups.addAll(listOfGroups);
you overworked here a little bit :)
Do all logic here. if push merge on plain ref: OK else if push merge on 'refs/for/ + plain ref OK else fail.
Why don't you return List of Enumerations? With this you will remove the logic in the constructor...
These look like they can simplify to: java binnedRanges.computeIfAbsent(location, k -> new HashMap<>()) .computeIfAbsent(ke, k -> new ArrayList<>()) .add(range);
Don't need to wrap in ArrayList
I'd remove //, or place it before the last .
Individual conditions also must not be null. For that we should add a check with org.junit.platform.commons.util.Preconditions.containsNoNullElements(T[], Supplier<String>) in order to avoid a subsequent NullPointerException.
IllegalStateException is an unchecked exception, it is not required to define the method as throwing this type of exception.
In this test and the other new tests, can we strengthen the assertions to cover all expected state? - fsRoot exists - workDir exists (if different from fsRoot) or doesn't exist (if we are testing the negative case for -failIfWorkDirIsMissing) - internalDir exists (if using working directories) or doesn't exist (if we are testing -disableWorkDir) - logs exists (if using working directories) or doesn't exist (if we are testing -disableWorkDir) - jarCache exists (if using working directories or -jar-cache) or doesn't exist (if we are testing -disableWorkDir) I think the existing tests are covering most of the relevant assertions, but it would be better if we could assert all expected state in each test. Ideally it might even be possible to generalize all these assertions into a common method that is called by each test.
I see you're synchronizing on initState here. The CdmServiceWaiter also has a reference to this same CdmState, and also synchronizes when using it. Does this guarantee that both classes won't use it at the same time?
("+min()+'\u2025'+max()+')';
I think this can only throw a ParseException, let's just throw that (no pokemon catching)
Don't use Strings here. Please read this: <LINK_0> <LINK_1>
This is not needed if you already handles the exception in the other method?
Hi @denlb , please replace this magic number 86400000 with something more readable, like TimeUnit.HOURS.toMillis(24).
Did you mean to reference the variable **USER_DIRECTORY** and not a String with the value of "USER_DIRECTORY"?
this is potentially confusing, please add brakcet to the if statement.
src/test/resources/experimentalData/input/ base path appears in 42 places in all affmatch tests, we could consider extracting this root path to some shared test variable.
This can be done with FileSystemItem.getStem(). If you want a one-shot function instead, create it in FilePathUtils for reuse.
suggestion this.gatewayMap.values().forEach(MethodInvocationGateway::destroy);  How do we live without this before? Should we consider to back-port it as a bug? What is a consequence not having this destroy()?
delete the "-" if there is no longer a trailing counter?
nit: make all of the methods package-private as the class is package-private as well. This also ensures we no expose these by mistake at some point.
I tend to prefer the more explicit style try { ... } catch (PackProtocolException e) { assertThat(e.getMessage(), is(...)); } fail("expected PackProtocolException"); Or even better, using JUnit assertThrows: PackProtocolException e = assertThrows( PackProtocolException.class, () -> ...); assertThat(e.getMessage(), is(...));
Can we inline any of these?
Wrapping an exception with another exception of the same type can be confusing in a stack trace. Better if we can wrap the IOException in another type of exception such as APIMgtException
nit: space between if and (
Objects.equal(f.testTagFilter, testTagFilter) (it handles null)
this.
Is this necessary? If I remove the update line everything seems still to work.
The name... CallGraphViewAnalysis, the View part does not sound too good to me...
Do either of the useIndex methods need to check the args to the method are not null?
Should be:  java public int hashCode() { return this.delegate.hashCode(); }
Shouldn't a cast to int be enough?
Why do you make this method chain throw exceptions up the stack when you just bury them in the end? If you never intend to do any handling of these exceptions, can you just handle them inside of the reLogin() method so the calls are cleaner?
Remove MiddlewareQueryException
The auto boxing can make this code crash in an NPE. If it is null, then we should use a default behavior (return true to keep the default behavior of the widget ?)
the printStackTrace is useful when it fails :) I have been there.
suggestion completedUpstreamTasks++;
I'm wondering if we should return "true" here. Wdyt?
replace with ExcelImportClass from Ecore
Will this fail the build if the cloud is not found? Is that the desired affect? I guess it would alert the user of an issue.
we probably can have Tailer bean with @Scope(proxyMode = ScopedProxyMode.INTERFACES, value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) instead of using applicationContext.getBean(..) here.
consider removing else clause
Crawling the view hierarchy directly using childAtPosition seems fragile - is there a more resilient way to find these items?
i see from above that this is following the existing pattern but it feels weird to me that this returns null rather than an empty list, especially when the provider.senders() method has logic to return an empty list when nothing is enabled.
Instanceof nightmare?
I saw use of UncheckedIOException earlier. Why not use that here?
please make sure you are rebased. this method was renamed on Feb 11.
Very minor: why does this still have shutdown when elsewhere that is renamed to disconnect?
should just have a method on the TsBoundPersisterConfiguration class for this, so you just do install.timestampBoundPersistence().getTimestampCreator() and avoid all the nasty reflection.
No sure, if we should do it this way. If no write mode is explicitly specified, the system default write mode will be used. If we decide to introduce something like a client option to set the write mode for a session, this would be overwritten by the system default. Why not having two internalWriteAsCsv methods, one with explicit write mode and one without?
Change requireNonNull to another assertion?
nit: cacheManager is null
if you keep the getParser method's signature the same, then getGroundParser is no longer a method that needs to exist.
default should the the system timezone - which means if you save this without making changes the behavior is consistent.
1ms=10^6ns
If a websocket is not closed properly on client side, is that something that a user should send us a bug report over? Secondarily, a pop-up message that says "failed to close" may not be very helpful to a user. If we show an error message to a user, it would be best to inform them of what happened and what they should do about it. Given there is no real impact to them, I'm not sure if we really need to show them any message at all.
Similarly: java return permission & 2;
reduce to debug
Extract this to a setUp method in a test and make _originalProperties_ a field
What is the problem of keeping throws XmlPullParserException?
Isn't this a no-op?
throws AlreadyExistsException ? seems weird
All of these magic numbers need to be Constants in the org.spongepowered.common.util.Constants, whether it's in a new nested class for Rail Directions or whatever.
Maybe an unmodifiable set wrapped around a concurrent map? Also the use of this. qualifier is not necessary in this context.
is there any need of try-catch block.
The check for null is not needed before using instanceof operator: "When using the instanceof operator, keep in mind that null is not an instance of anything." (<LINK_0>
Here it's really the "holiday calendar" that's not found, right?
The args are in a different order in <LINK_0> moduleResolver.resolve(groupId, artifactId, "jar", "exec", version);
Brace next to method definition please.
This can simply return NOT_AUDIT.
From what I can tell, this should be removed. Am I missing something?
You ignore result here. You need to return result.
+ IJBossRuntimeConstants.SPACE
Instead of printing to system output stream, let's use a proper logger
'. This item is not allowed. Please check your *.items configuration.
suggestion Table<?> table = (Table<?>) visit(context.alterTableDefinition()); return new DropCheckConstraint<>(table, getIdentText(context.ident()));
This code should also work for other mappedBy data types (i.e. be prepared for bidirectional many-to-many) suggestion .filter(Attribute::isMappedBy)
nit: indentation (or it this a gerrit problem?)
This misses the separator used elsewhere '-'
The @Override should be on this line.
Please use StringBuilder
Also, by default, PR builds should just run the tests with latest version and if environment variable to run tests for all versions is set, then we should do this.
Since we already moved to Java 7, you could use a single catch block with IOException | RuntimeException.
nit: space before {
Swap the order?
The tags should be included in the aspect, no ? Since we're using it to hash metrics in the aggregator.
nit: can drop the else and just make this if (..) { ...} throw new ..
why do we need this ? The type says it's a non-workspace typed element ... I'd assume that instances which are resources are rather of the super-class type
Does the patient actually have any voided diagnoses to make this test more solid?
don't need the "== true", it's a boolean :-)
all existing network attachments (returned from db) should have id set.
Should > 0 be > 1 then?
Is this a default estimation from some other location? If so, maybe use a static constant value so if one place gets updated, so does this place.
Seems like this should also use clock.
Since gets will most likely not be concurrent, done by the poller, do we need threadlocal isolation of aggregation? Synchronized aggregation may be simpler and efficient? Also, you are already synchronizing additions to the aggregate.
4?
putIfAbsent for something different and get afterwards to be sure that putIfAbsent hasn't changed anything in the collection.
is this correct ? Dont we need to drain the inbound messages first to ensure we preserve the correct order ?
Ditto:  assertThat(count).isEqualTo(1);
Yea, you can just invert conditions
The important noun in this noun phrase is message, not value. It's a message about a missing UUID.
nit java closer.register(directReader::close); closer.register(dictionaryReader::close);
An 0 byte will message is valid <LINK_0>
You can remove the catch (Exception e) { fail(); }, it'll give a clearer error when failing.
We should probably consider BeanDeployArchive changes / evolvement to allow for Class<?> objects to be passed to Weld directly instead of doing Class<?> --> class name --> Class<?>
Each test seem to do the same thing, and besides the valid/invalidXml nothing changes. Can we refactor this to not use as much duplicated code?
Should we consider defaulting to "<user.home>/.selion2" For SeLion 2 ? To allow SeLIon 1.x and 2 on the same host.
What about VUAP and its bottom part on Mercury?
What is the reason for appending 1 to the variable name?
This is a small nitpick, but maybe you should do the same as you have with equals (only doing 1 based on conditional). Or you are thinking it would give better spread since an interval is always multiplied by 31 where as the condition is never multiplied?
Use StandardCharsets.UTF_8 instead of "UTF-8"
Shouldn't this also be done for 'getInsertWithAutoInc()' and 'getInsertReturning()' ?
This stream is never closed. In general I recommend using the read(Func) method to avoid unclosed resources in a guaranteed fashion.
can it be cssSelector, not xPath ?
let's use Mockito verify
why . ? and no . in inflightOffsets?
Maybe this name could be more descriptive?
What does this mean "defaultSignatureTimestamp"? And what is the relationship between 2019? Also what does it mean to set "0" for the month? What happens when the next certificate expires?
Check for equality of error code
API breakage. The returned collection used to be modifiable, but is no more. I'm not sure if anyone will be affected.
public void writeToDSTFile(File dstFile) throws IOException { try (FileOutputStream fileStream = new FileOutputStream(dstFile)) { writeHeader(fileStream); writeStitchPoints(fileStream); writeEnd(fileStream); } }
I think that this check can be avoided as we already check if auth != null below
This will blow up at runtime if getActiveModule() returns empty optional
i18n please ?
return Integer.toString(index); is more idiomatic.
At the moment this method is called from somewhere else in CDT source code (use show Call Hierarchy to find where, somewhere in UI code, but I can't recall exactly). That call must not be made anymore from there because the breakpoint is not installed by editing the properties.
constants should be static final
this.distanceTolerance = distanceTolerance < MIN_DISTANCE_TOLERANCE ? MIN_DISTANCE_TOLERANCE : distanceTolerance
Is it possible to make this a little safer by including delimiters or the equals sign or whatever?
We should use LinkedHashSet here to be predictable and make debugging easier.
great, that's the way to do it!
same as above: We should use LinkedHashSet here to be predictable and make debugging easier.
use java.util.Objects.hashcode instead of checking for null value yourself
@divsidhu-26 The line should be less than 100 chars. <LINK_0> There should be a whitespace after each concatenation operator.
Add a message in case it ever fails
Add a message in case it ever fails
why change this to log an error instead of throw an exception? Stack traces are useful.
Please don't create a new list on every call of getDifferences(), but create the list once, e.g., on the first call, and then return the same instance. You might want to use an UnmodifiableEList instead, to fail early, if someone tries to modify it.
When performedWarning is false, "flush()" could also be completed, correct?
I don't agree with this description based on the code and there's no reason to be terse with it. It does nothing to ensure "correctness", it simply helps spread the most commonly used attribute value, which may or may not be correct.
Can we hit a concurrent modification exception if a worker finishes and is deleted, while we are iterating here?
This serialization is not correct. It leads to duplicate keys in JSON:  { "labels": { "label": "firstLabel-hzclient-1", "label": "secondLabel-hzclient-1" } }  An array of strings should be used, so the result would be:  { "labels": [ "firstLabel-hzclient-1", "secondLabel-hzclient-1" ] }
Not your fault, but both cases should be SanitizationHelper.desanitizeIfHtmlSanitized. Let's change it, and afterwards this block can be transformed into a one-line lambda.
Should be STACKTRACE_NONE instead because if stackTraceoutputMethod = STACKTRACE_BOTH the method will return STACKTRACE_SHORT
You need to provide description for the different methods that you have included.
nit: can use method reference instead suggestion .map(Transforms::processSingleResponseErrorResult);
What about base_Package, base_Property, base_Element, base_OpaqueExpression, ... ? This only works for stereotypes extending the Class metaclass. Other stereotype copies will have their metaclass extensions corrupted. Also, stereotype associations will be copied incorrectly (I think), referencing the wrong stereotype instance in the case where the referenced stereotype is also copied. This needs to work more like the EcoreUtil::Copier's cross-reference handling. And do we support associations between stereotypes and classes defined in the profile? UML2 API does. This code seems to assume that anything that isn't a metaclass extension is an EAttribute that is easily copied ...
The artifact's name should follow the NPM specification (<LINK_0>
keeping that constructor makes it more testable as you could inject a mock OpenshiftUIModel
note that this check is redundant - getClusterId would never return null
I guess Arrays.equals is the better choice.
should throw validation exception using collector.getOrThrowException() in prepareRun.
this can be set in the ui binder file no need to do it in the localize (we only do this above due to the DynamicMessages).
rename to action
Line length formatting again
How about inverting the logic, only log the functions loaded, rather than those skipped, and please make it a DEBUG level.
readAll here as well?
assertThat(conf).isNotEmpty(); is shorter and gives better error messages. The same 7x in this PR: CTRL + f "isEmpty()).isFalse()"
This can be made private as it's not required by any other class within the package.
Just a minor suggestion. It looks odd to house getQualifiedName method in YarnRestJobStatusProvider class and invoke it just at scriptRunner.runScript as a param. It could be better to either move that string generation to util method or move it to even jobInstance.toString(there by removing getQualifiedName method).
Should this assignment guarded by the lock as well?
hashCode should also be based on checkpointId and stateCheckpoints to match equals implementation.
also here, it should be: for () { }
do we need the bracket?
I was curious why we do decoding here? Does this break service bus? iirc, SB keeps track of deliveries when they are not in receive and delete mode to understand which ones to hold onto and when a user performs a settlement method on it, will then settle that delivery.
boolean
would data ever be empty or not the same length as plotterTable? if so, add a check for it.
Validation for timeout?
why static methods called as instance methods ?
Objects.equals can be used here too, since it's more or less the trend we have on the models
I'm still not convinced that stream syntax adds any value to methods like these. Maybe if Java stream syntax was concise, but it's not. I'm wondering, do you find this stream syntax easier to read than:  List<Field> result = new ArrayList<>(); for (Field f : fields) if (f.requirement == REQUIRED) requiredFields.add(f); return result;  ? The basic difference is that the imperative style describes what the machine should do, while the stream style attempts to be more descriptive. But I find the stream style uses an awkward jumble of function calls and symbols, and is still essentially imperative.
Prefer String.format("%n%nStacktrace was: ") to be OS agnostic.
== tests for reference equality, hence it could be error-prone -- it'd be better to use the .equals() method...
Why change the logic since the answer is always true?
As it is not synchronized this can lead to race conditions where a listener registration can get lost. If you simply instantiate it where it is declared above, then this cannot happen anymore.
Calling the mock methods directly and then asserting that the mock did something is just weird, a "mock" should be used to assert that the tested component interacts in a certain way with the mocked components. Maybe a better name would be TestProtocolServer?
negative logic
need not be public (same with the other functions)
I would have put Object as return value...
Although the proposed changed is technically correct, please revert this for the sake of readability.
Can you change the mentions of files to directory everywhere?
should loader also be checked if it's non-null so that if follows similar paradigm as client. This way can call close() from main()'s exception block -> case where initialize fails in initializing loader for some reason and the logic can thereby make sure the initialized client connection gets closed and is not leaked.
it is a 3 node cluster by default, don't need to specify it
Can you put the Y acceleration (-0.03) in a named constant in the class? e.g. VERTICAL_GRAVITY_ACCEL
Can validate MAF.
Tricky. The enum is perfectly valid I think, but you don't expect to get here. I'd make it IllegalStateException
Seems Copy-paste error, Change to try (TraceScope ignored = tracer.newScope("getSnapshotListing")) {
This feels like a change detector test. What in particular is it aiming to defend against? E.g. if we check that the output starts with "jgit ls-files", would that be sufficient?
I think this would be more straightforward to test if the getFromGetter() method actually read from a differently named private field: java public final String fromGetter = "ACCESSED FROM FIELD"; private String actuallyFromGetter; public Bean(..., String fromGetter) { ... this.actuallyFromGetter = fromGetter; } public String getFromGetter() { return actuallyFromGetter; }  This way you can just expect the value that was stored in the database, instead of munging it.
I am not sure if opening it up is good or bad at this point. Here is a bug in track1 that kind of *caused* by open-up (not really, but previous class not under "@JsonFlatten" will not be affected, but now it will, and hence the bug) <LINK_1> And we got this one there <LINK_0> Just saying it could be risky if there is unfixed or even unknown bug.
I am trying to understand the current functionality. If one of the cards(say card1) is checked, and then if 'select all' button is clicked, would the previously selected card1 be unchecked? Shouldn't 'select all' select all the cards irrespective of the previous selections?
@dmzaytsev let's test with the urn provided in the original ticker: urn:test-domain-org:valid:1
Can you use isEmpty() instead?
Do you need write permission?
so we all agree that we should default to development mode?
I think it's better to let intermediateDataSetID implement writeTo() and fromByteBuf (...) and just invokes them in IntermediateResultPartitionID.
Can we pass in the delay from this method, so SqsQueueService shouldn't need to know about capture process configuration
Why don't we use getNode?
Use Strings.nullToEmpty
Size in bytes, max Integer will be 2Gb, i think some crazy repo may have such number. Long looks better.
inline... maybe foreach
why should the order be as such? trial and error, no? better to check that they are != since the hash function might change.
always true
Sometimes it produces non needed objects. Seems like wasting CPU time.
This method could be written as  java public static void clearVisitDate(String[] selected) { setVisitDate(Arrays.asList(selected), 0); }
Can you use LocalQueryRunner?
Math.ceil here and "(int)(tmpFileSize / chunkSize) + 1" in onChunkedUploadStarted? Theoretically both are correct, while I have a slight preference for the integer approach I at least would request to use the same approach in both cases.
suggestion LOGGER.debug("Checking Docker OS type");
I believe it would be more understandable to do the following:  // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
Override
this.uri
Can you explain why this code was removed?
Shouldn't this call the empty constructor? Or the empty constructor has useless code inside of it?
The get() wouldn't have guaranteed visibility so why is this safe to do?
This is not safe from multiple objects trying to either close() or get() at the same time. You can end up with an object offered into the queue many times.
This is an opportunity for a nice stream pipeline. Not that it is absolutely necessary, but in my opinion, converting these utility methods to streams makes your intention clearer to see.
suggestion return "FakeImageSubstitutor";
I'd suggest to protect against null java this.signedHeaders = signedHeaders == null ? Collections.emptyList() : new ArrayList<>(signedHeaders);
You don't need these properties because they actually don't exist nor apply
This can go down into the try block
Same as above. This is a test. You should check that the return value is correct and examine some fields in devInfo.
(k) -> k suggestion return locks.computeIfAbsent(key, k -> new ReentrantLock());
Shouldn't we check here for IP ? Returning a null IP address when no ports are configured although there would be one seems not so intuitive.
Add create(Hit<T> ...hits) method to clean up a couple of calls of the form Hits.create(Arrays.asList(a, b)), Hits.create(singletonList(ontologyTermHit)) and Hits.create(emptyList()) to Hits.create(a, b), Hits.create(ontologyTermHit) and Hits.create()
I believe that there is some difference between indexOf(int) and indexOf(String). It seems parse methods are on hot path, so performance could be critical here. Please use appropriate methods for corresponding cases.
I doesnt really matter, just nitpicking: local vars are non-initialized. Good practice is to initialize them to a defined value. But sure, it doesnt matter here since the code right below will do it.
I feel like using Optional and null at the same time is a bit of an anti-pattern.
These 2 catch blocks can be reduced to 1 like: java catch (InstantiationException | IllegalAccessException e) { throw new Fragment.InstantiationException( String.format(ERROR_MSG_INSTANTIATION, fragmentClass), e); }
null as a key and .get(null) looks atypical and not readable on the go. It does require some context for someone to get the background on this.
Why do we have two such methods now?
I guess just adding these two lines to the top of the method will solve the issue. The other additions are logically identical to the previous version.
irc is not open if con is null initially. The logic here is a bit muddled.
I would completely rephrase this: > Closing connection to cluster {}
hashCode must use the name, since that is also used in equals
the secondary id patch has been merged, see how genevieve uses it for the scatter / how it is used by the statistics too
Same with this, if the logic is specific to VillagerEntity, it can be overridden in the mixin
future work: * to avoid confusion of the method usage, consider renaming to something like: 'getSnappableVmDisksForStorageChecks'. * remove the unneeded 'getDiskIdsToIgnoreInChecks' list and replace with some flag (as discussed...)
If we could get rid of null check, addChildrenProducerBatch and getChildrenProducerBatch could be removed as well.
Unnecessary parenthesis
inline: java return hash.addPage(page);
Probably \s is better: From docs > \s A whitespace character: [ \t\n\x0B\f\r]
Not sure if all callers pass non-null, but if the callers aren't careful, this could be null. Could verify with: suggestion if (requireNonNull(text).isBlank())  (with a static import of Objects.requireNonNull)
return getName() would perhaps be nicer.
<LINK_0>
@cvrebert maybe add a constructor for this common case of 10 random alphanumeric characters, false and true?
Have you tested that this actually works? IIRC when configuring the trigger a new instance is created, both via the UI and via pipeline script, so it's not the same instance that gets the stop and start calls.
you can use if (has(feature))
the UUID of the Worker should be passed to method peek instead of this random value
suggestion initColumns.add(COL_ID_ACTIONS);
Should we use "withSideEffect" as description to be consistent with current .withSideEffect?
@cvrebert for that we can pass Locale.ENGLISH to it...
Please, don't introduce unrelated changes. Let's focus on ConsoleReporter.
Where is this magic number coming from?
Are we assuming that metrics is non-empty?
Since IOException is checked we don't want to flood everything with throws IOException. Thus I initially had it wrapped just in IllegalStateException. Imo we should create something like TmcLangsRuntimeException extends RuntimeException which would be used to push the IOExceptions and others which we just want to crash for up the call stack and stop the command.
I'd go for avoiding putting synchronized on it and stating it in the docs. There could always be another sync'd variant created by the builder.
Can you add two constructors in RuleFactory? * RuleFactory() - default constructor for backwards compatibility * RuleFactory(ResourceLoader) - the new one to be used here I think, the resource loader should be a property of the rule factory rather than a method argument for parsing the rule element. In theory, we could reuse the RuleFactory instance for parsing all rules within one ruleset (which we don't do currently).
why object class?, maybe set type to null could be a better idea
url = serverUrl + userprefs, shouldn't all these use the full URL to the place with the API key?
Maybe we can extract this union+immutableCopy to the AggregateClass itself?
Why can't we add % into SPECIAL_CHARS and avoid using additional if?
Hint: it's most readable is to simply use google Guava after importing com.google.common.collect.Sets:  Set<String> StringSet = Sets.newHashSet("structCol.a");  The same as other test cases.
singular is good here, IMHO.
This should be shown
Return an empty list here instead
I thought we talked about making this a BitSet somehow. Have PackExt keep a static int that counts how many PackExts have been created and declared. Change its constructor to instead use a static factory method that automatically registers the PackExt into the VALUES array and assigns it a unique bit. Assume we only permit 32 PackExts for now. Then here we can have a simple int that is a bit set of the PackExts that are present.
Please use camel case. It should be fromWkt.
Please update java doc according to new parameter and exception adding
typo
Again, test for topic creation but replyTopicStubs
Is this subtype equality needed?
I'm not really a fan of shootTimelock - it feels pretty ambiguous (particularly as this is a boolean!)
Correct keyword order
Is this correct?
missed a spot
Did you take a look at this? <LINK_0>
Fortify only complain about comparing. We should stick to default toLowerCase and don't use "local.english". We only need to check comparing by using equalIgnoreCase without using local.english. Check checkConfiguredDisplay() method and always to use "constant".equalIgnoreCase("stringtocompare")
There are three interesting cases here. If the caller didn't call setAllowPushOptions(true), then we don't advertise that we can get push options and pushOptions is null. We can detect this case by checking the allowPushOptions variable directly. The caller was responsible for setting it to true, so if they didn't and they then turn around and call getPushOptions(), they are very confused. That makes it a good time to throw IllegalStateException(). If the caller did call setAllowPushOptions but the client doesn't support push options, then pushOptions is null. This is analogous to C git hooks --- Git sets the GIT_PUSH_OPTION_COUNT envvar to 0 when the client supported push options and sent none and doesn't set the envvar when the client didn't support push options. This method can behave similarly by being @Nullable, like you do here. If I called setAllowPushOptions(true) but haven't called receive() yet, then enabledCapabilities will be null. This is another case where the client is very confused. That makes it a good time to throw RequestNotYetReadException.
here we could use Matcher.startWith and avoid joining with last 2 empty strings
Is this a bug?
Wait, this is worse than the previous version. What happened to the assertEquals()?
Don't call this
org.ngrinder.sm.NGrinderLightSecurityManager
How will this method be used?
This can just return repository.hashCode()
updateValidSizePerContainerId
we should reference "resource" from Util.getResourceDir() no ?
Travis doesn't like this:  > Task :spring-rabbit:checkstyleMain [ant:checkstyle] [ERROR] /home/travis/build/spring-projects/spring-amqp/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java:340:33: Reference to instance variable 'logger' needs "this.". [RequireThis]  Any chances you can fix and we merge? Thanks
This looks like it could even be an info message.
Move this validation to PluginProfileService.
By no means I am against the idea of having in-liners for speed up. ( I love them so much in fact! Don't tell CM! ), but for the sake of maintainability, I would request to pack them into a method if that does not affect overall performance. It seems this part should be very tight since it is in protected area though. But... you know...
minor: use getIntInRange instead of getInt here.
Return type of SecurityExpressionOperations to reduce reflection overhead?
nit: Is this meant to be private? I'd think users should use create(...)
Same problem as in DefaultClimateProvider Replace this line with EnumTemperature.getFromBiome(Biome Biome, World world, BlockPos pos) here or it can't detect EnumTemperature.HELLISH.
Hmmm, does this need de-parenting?
Do a static import of OperationStatus so you don't need to fully-qualify the PollResponse. part.
write a function for this. Looks like this code is not repeated in 3 places.
Extra ; ?
Consider wrapping it in a method that gets the key. Use it in the getKeystorePassKey and getKeystoreUrlKey methods.
please put the statement on a new line and in between curly braces
Please move this line closer to TokenTypes.LITERAL_CATCH. Recheck code coverage after this move.
@vilchik-elena Typo? Shouldn't we have a "h" as in "Three"?
- [x] don't occur -> didn't occurred --- It was modified. 6a981ae1248bd5d530270f738a344df2f5ffc6f9
Maybe checkThat(cancellationFuture.isDone(), is(false))? Otherwise it will actually wait for 2 * milli milliseconds in this method.
Fixed this method in my branch: <LINK_0> Pls, merge my branch into yours, so as those fixes are o included in this pull request
If you are using an AtomicBoolean (and dont do anything else), you no longer need the synchronized keyword here.
Use enummap instead of hashmap.
can be simplified with stream().map() over map.entrySet (no need to use Stream.builder())
Since theoretically, order matters, shall we test both orders-of-operations?
What is this for? Shouldn't it not be needed for the integration test?
fLanes.isEmpty()
I'd just do if (Objects.equals(channel.get(), key)) { then it does all the null checking for you. Objects.nonNull is only really useful where a function is required (e.g. stream.filter) as all it does is add an extra method call that the jit then has to decide whether to inline or not (as compared to obj != null').
This is unused now.
StringUtils.isBlank(), because we want to avoid NPEs
Does this work with CRLF delimited strings? It looks like it's not going past the LF. Maybe you just need to call this method on the normalized string, and stop caring about CR. Also maybe it would be clearer to just return start + 1; here instead of breaking on the next iteration.
Old typo: 'excepted' should have been 'expected'.
Can be returned right away.
NACK for that Preconditions check, otherwise it looks good. Thanks for working on that. I need a bit more time to go again over all and check if anything might be missing. Could you provide a comparision of performance gains from that PR?
Give some help: "Float value found in query; use Double instead"
ObjectIdMapper.getObjectForId can return null and is marked as @Nullable, so we should mark this method as @Nullable too
Collections.emptySet() returns a singleton so is preferred here.
omit 'verifying' word
Could assign the sslContext to a local variable to avoid the duplicate volatile read
reviewed commit, looks ok. The framework should fail to start if we miss out any of these accidentally
Can this be "new DataSourceEnable(isXa())" ?
Are you sure it works with CodeMiningDemo (java main)?
nit: or String.valueOf(currentLeader)::equals
Here maybe you could use .map(RequestResolver::resolve).map(this::instance).orElse(null);
The indentation should be deeper.
You only need synchronized (YEAR_FORMAT) { here. And it will block with the .setTimeZone() calls above.
This is weird? Why is it about a totally different message?
moze return lookup != null ? lookup : insert(globalId)
Different defaults here to the field defaults...
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
Assert this before calling get.
I think it would be even cleaner if you do not use the variable: java getImplicitlyCalledConstructor(methodTree) .map(Symbol.MethodSymbol::thrownTypes) .ifPresent(thrownExceptions::addAll);
As described in our [policies doc](<LINK_0> all but the first test should be ignored
Why is this method needed, when only generateHmacSha256() is exposed as a Java action? Or am I missing something?
Just a system.out, no validation here
what if the user provides both cluterId and serverId?. So you could swap the above comparisons.
I guess there's never a time that this is null. But, we do sometimes check for null (like in currentConfig below). Why not here? I know loadConfigIfNull called from ApplicationInitializer, but if so, why check in currentConfig?
This doesn't look right. What if there are >9 questions?
We need to validate the type of the Object here. Currently we support String, Number, int, long, float, double, boolean, Date, and null.
Shouldn't be better to use a specific exception such as CanNotPushSystemEventException or something like that.
Can you use separator constant here?
what happen if options.getWidgetContentProvider() returns null ? we should return true for this use case
Can we derive the external resources from env, instead of just passing in an empty map here?
Do you care if the job completed successfully? I'd assume so which would mean you'd want to check the status before deleting...
I found this hard to understand. Perhaps it would be more clear as: !getNeedToWork() || FinalizerDaemon.INSTANCE.progressCounter.get() != startCount || FinalizerDaemon.INSTANCE.finalizingObject == null
0xF is a valid control character. All other cache keys use 0xFF as separator which is guaranteed to never show up in any valid UTF-8 stream.
Sucess -> Success
Use Guava Streams.stream(myStream) instead of StreamSupport.stream(myStream.spliterator(), false)
Can we just not call this, if isInitiator() == null returns true
SearchView's visibility isn't dependent on any of the discovery fragments, its visibility should be controlled using inside MainDiscoveryFragment'.
minor: would prefer that Cloud_Replica_Keyword comes before mount path since that would order the path from least to most granular
Since more state => more branches => more bugs, is there a strong reason to default to lazy initialization? This can be a stateless final nonnull if we initialize at declaration. That said, we might want to skip the member variable altogether[0] or switch to Joda time[1]. [0] <LINK_1> [1] <LINK_0>
maybe return false here at once would be better?
Let's please use the JWKSource to retrieve JWKs. That will allow you to use a JWKMatcher that removes some of the validation you are doing in parseAlgorithms.
please do only start any further threads or implementation once you know there are items available for the Tellstick binding (see providesBindingFor() as a possible hook). Please also stop this Thread when deactivate() has been called.
dump() uses the tmLog, please keep it consistent.
nit: This doesn't seem like it should belong in this PR
please reuse function you wrote above
[Checkstyle] INFO: '200' is a magic number.
NIT: please use parentheses in the boolean condition to avoid confusion.
Can also be replaced with streams java sourceFormats.stream() .filter(x -> fieldApprover.approve(x.getDataInfo())) .filter(x -> StringUtils.isNotBlank(x.getValue())) .map(StringField::getValue) .collect(Collectors.toList());
new ArrayList<>().stream().anyMatch()
in run method we should call collector.getOrThrowException. In configurePipeline method, data pipeline app will throw in an exception if validation failure carries any failures. however, this does not apply to any other methods
Is this a "WARN" or so..?
Let's keep passing excludeSpecialChildren instead of true to be consistent with VCS.
Separate timeout constant?
It is passively waiting for something external to tell it that the build is finished. What could possibly go wrong!!
I am missing something, method says if exists removeOldActivatorIfExists but the if that wrap, says if it doesn't exists !ioService.exists(activatorPath), to me seems like contradiction.
Why don't we init it automatically anymore?
Unsupported operation during POST?
minor nit, move the "as the max" capacity string onto a line on its own' merge it back to a single string,
No. use a constant, create it if needed, but you don't externalize constants, you only externalize strings that need to be internationalized
please set a modifier - protected seem suitable
why is the server mode set to OPEN in teardown?
This should call existing method, avoids maintaining the same info in two places (which is error prone). There's another PR with similar changes: <LINK_0> The methods getCweId() and getWascId() would no longer be needed.
Annotations on different line
Count doesn't need to be explicitly initialized since it is 0 by default
DiscussionsApi or DiscussionsService or DiscussionsGateway or DiscussionsClient
Why are we only adding this to this error message only?
Alias should never be null.
Does this break the Tunnel Bore collision? Hmm....not sure why I do this.
nit: consider flipping the condition
Use List.of
Can we include the name of the strategy in the message here?
Was the throws IOException required? If this worked before, I'd rather we not include it.
Why do you need to use Double.valueOf here?
Should the test eventually drop the table? (here and below)
Call this at the end of the method
Have you consider pushing this conditional to the callers? I think in both cases it would be the calling code easier to understand, it avoids having to jump around the class file to understand those locations. Furthermore, without this if statement the method body would be a simple stream & any match statement. Not that it matters too much, there would be a small performance boost as you wouldn't need to compute the full set of land units but could halt on the first match.
Please explain why this line isn't in the try-block.
Maybe we don't need to call 'frontendFailureEventListener.hide()' here, since 'CurrentUser.logout()' will invoke 'BaseApplicationInit.onLogout()' by default.
nit: it's an to and not ts
reset lock?
Generally endpoint is checked for being null and if it is an exception is thrown.
No :) we should fix the message :)
Is thre a reason this call isn't going inside the app initialization below?
you are using tags ones, please access value directly in for
Is it necessary to check if default handler present? Why could this happen?
NIT: Seems the approach of passing null token is a right one here, but it may impact <code> BearerTokenCredential</code>, which may start using the raw token field in other methods
In contrast to Lombok, Groovy adds visible annotation, while here we check only invisibleAnnotations, so that currently filter doesn't work.
If element doesn't exist, then first condition will return false. There is no _third_ option, hence usual if-else will suffice.
Why a message for name instead of key?
executor is null
This will break on Windows. portableString always uses "/" on all platforms. Please use org.eclipse.core.runtime.IPath.SEPARATOR
Is the backslash by purpose?
The smeltery only runs this every 20 ticks, or tick == 0
Let's extract this to FixturesTool (possibly in another patch before this one)?
I fully understand that this is simple to write but it is also very brittle. For assertions on the topology, isn't there a way to do a number of them without having to rely on identical text formats? For example, doing comparison of JSon in memory? or something else?
I don't see the necessity for this tests being ran over all storage formats.
Maybe use a variable instead of calling 3 times tree.expression()
Just "Kafka-0.10". The same to others.
... and use it here.
Is this an API call or an implementation (native) method call?
Just check if a is not null because getAnnotation will throw an NPE which is not related to types.
We should not remove debug statements.
Not important at all, but maybe using stream + predicate?
expects a String -> "requires a String operand"
Cool, you're fast. I see the goal of 99 coming nearer :) Instead of Stream.range(2, max + 1) please use Stream.rangeInclusive(2, max). That's the canonical use-case. Thx
I'm not sure this will 100% work. Table name can be "mytable" in which case your quoting is fine, but it can also be "myschema.mytable" which is quoted "myschema"."mytable".
Use Assert.notNull()
I find it very unintuitive to find this here... I'd suggest moving the log to PMD.doPMD, which is guaranteed to run once and a little more natural
the docs say that it excludes the executable name, but it doesn't.
Just call this updateNickname, as that's all it does.
Do they all have to be public methods?
use Command instead of separate parameters
I think we can easily avoid using a list here. How about: protected String[] getGDBCommandLineArray() { // The goal here is to keep options to an absolute minimum. // All configuration should be done in the final launch sequence // to allow for more flexibility. return new String[] { getGDBPath().toOSString(), // This could contain spaces "--interpreter", //$NON-NLS-1$ // We currently work with MI version 2. Don't use just 'mi' because it // points to the latest MI version, while we want mi2 specifically. "mi2", //$NON-NLS-1$ // Don't read the gdbinit file here. It is read explicitly in // the LaunchSequence to make it easier to customize. "--nx"}; //$NON-NLS-1$ }
Intentional change. Keep the originial.
suggestion throw new IllegalStateException("Only valid, managed RealmResults can be frozen.");
Why we are using ArrayUtils.isEquals not equalsIgnoreCase like in line 111?
I think it'd make users relieved if we mention in the message that FailedContexts are handled in the same way as ClosedContext.
[minor] start lowercase
Thanks @wb14123 !
This should be moved down a few lines to not break the formatting
Shouldn't this also be changed to super.selectedItemsChanged()?
this is a bit weird, is calling the toString method actually the right thing to do?
I don't know about this being static, I feel like it shouldn't since plugin itself is already static.
Shall check if it works with different case for the key. I mean, set the property name in upper case during create Db or alter db and try if we able to read it here.
I think you can guarantee that options.getOperationType is non-null in the GetBlobOptions constructor - unlike the range, an operation always has an operation type. So you could avoid the second null check above. This could be made simpler I think:  java if (options != null && options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { onGetBlobInfoError(e); } else { onGetBlobDataError(e, options); }
cmt msg: "Adapt the new Work interface to MultiChannelGroupByHash." Not sure "adapt" is the right word, since you're not changing the Work interface. "Apply"? "Use .. in"?
suggestion if (transactionManager != null && transactionManager.isActive()) {
this should be done in Nodes.updateNode() - so it follows the same route as setNodes() addNodes() and removeNodes()
This may be wrong for 2 equal instances, consider the following example:  java CheServiceImpl s1 = new CheServiceImpl(); CheServiceImpl s2 = new CheServiceImpl(); s1.getLinks(); assert sq.equals(s2); // <- this will fail.  Explanation: an empty ArrayList#hashCode returns 1, while Object.hashCode(null) returns 0 :cry:
don't use raw types - new Pair<>(vm, vmDevice)
Should we clear the loading_ flag here? (doesn't look like it effects correctness but would be consistent?)
I don't see this file
what exactly is this doing?
We need to synchronize this because the write can be performed concurrently.
matter of style and choices but I tend to think that this last part of the && should be implemented as a filter of stream on the parameters stream.
When this throws an exception the file writer may not get closed, consider a try with resources.
Probably something like (2 \* Integer.BYTES)?
Rule vs RuleImpl (see above)
Can we use the constant for "/processor-" defined in ZkKeyBuilder?
It's probably a bit low. I doubt GroupedJobInitializer use much memory so we could easily increase it a bit by default (like 100 maybe). Would need to check how many nodes are created after a few jobs are run in XWiki Standard. On extension side there is the root "extension" node and then 1 per namespace (so in practice 1 par wiki). It's potentially a lot more for the refactoring module since you have the root "refactoring" node and then one node for each element of each EntityReference which is manipulated.
could be just  this. belongsToRecentIndexSegment = this. belongsToRecentIndexSegment || belongsToRecentIndexSegment  don't see why compareAndSet() (which is used in multithreading scenarios) is needed.
DB and table name need not be set always. shall use String.valueOf(entry.getDbName()) as it return "null" string if null.
throw
shouldn't braek if retVal is false? actually (and this is just my opinion) i think it would be easier to understand if you return false once one is false: for ( MonitoringStrategy monitoringStrategy : strategies ) { if (!monitoringStrategy.canMoveToMaintenance(vds)) return false; } return true;
this method should be changed to private
Nit: not sure if change is by accident or not, but this made readability worse.
if you change this a tiny bit, ticket.getTarget().contains(posAsVec3d) => ticket.contains(posAsVec3d) and add public boolean contains(Vec3d posAsVec3d) {return getTarget().contains(posAsVec3d)} to the ticket, you'd open it up for all those things modders want to do with it (use energy/water etc).
so the name will be mac.domain? Is it changable?
This method should not be public or what's the point?
Could be replaced with executorIsShutdown?
What if a release with this name already exists there? The test will fail.
![MAJOR](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
How is anything below this line related to " Add API to append BaseComponent arrays to ComponentBuilder"?
Set the same as MEDIUM?
Why assertEqualsB4Left method name ? You also call this test with A4 model, so the method name is not appropriate. Change the method name, or may be this test shouldn't been in the abstract file test, or sould be divide in two tests. Please do the same change on the other tests that present the same problem.
Are you sure that one getParent() check is always enough? I.e., might there be ASTs where you have to check the grandparent or higher?
JUnit style is to always use braces for "if" "do" and "while" statements.
move if (delegate.isXhtmlStrict()) into assertOpenImplicitBlock
I think you can use the article object's lastModified as the return value here. You don't want to query for it once here and again in getData; you should be able to avoid this by extending EntityTransceiver instead of Transceiver.
Is there a chance that this will create a data provider that was not required? The data provider trace should be the child traces, not the view trace? Maybe we need to use the same pattern as the traceClosed implementation. But we need to do it before calling super.resetView() otherwise the entry list will have been cleared.
Same as other question, does this potentially result in class ids with spaces in them?
This should return a boolean rather than boolean.
Should we do an Assert.assertTrue on the return value of verify()?
Can this be protected. I assume only the ListModel is using it
Can be simplified to AccountLinkingStatus.ENABLED.equals(getStatus())
ACL.impersonate(ACL.SYSTEM); will set the thread context to SYSTEM "forever" the normal pattern to use is  ACL.SYSTEM.impersonate(new Runnable() { public void run() { ... } });
null -> UnsupportedOperationException?
So I believe the only way this could be null is if a configuration was saved without the <jdks> entry and then reloaded. I don't see how that could happen - but there may be some old version of Jenkins that could have done it. Would probably make sense to modify a readResolve() to set it to an empty list and remove this check and the theoretical possibility?
could be helpful to have a default value?
Great, thank you! In ideomatic Javaslang we access tuple fields directly, e.g. t._1, t._2 instead of t._1(), t._2(). Could you change that please for all methods here? The methods are useful in case of method references, e.g. t::_1 and t::_2.
I think we want to use .equals() instead of == here, since deserialization will probably lead to different physical instances being compared.
You could call labelChanged() instead of comparing.
Generating identical streams for the same key is not a good property of a *random value* generator.
FromCusror
These two lines can be combined into one.
I'd rename this variable to memberValue.
Can selectHyperLinkLabel be null?
you should use CtfTmfTestTraceUtils.getTrace(getTrace()) instead probably. the teardown method of the base class dispose the getTrace() the test uses.
Validate inputs to check if all required fields like registryUrl and credential are set.
Annotations should go on the same line as the method declaration.
ValidationException is reserved for use by domain logic to indicate invalid input. For a general purpose 'commons' method, IllegalArgumentException would be more appropriate.
This if and the list above can be removed completely.
I kind of prefer the old name - a "container" can contain anything, in this case it contains computation results.
I think we should add an _ in between the userid and the url, if the URL ends with an integer, it'd be difficult to decifer what's the userid and what's the url. Probably not an issue that would come up, but I thought I'd bring it up.
imho you should call writeAndFlush(...) and attach a ChannelFutureListener that will close the channel after the write is done. That said you also will need to schedule some timeout that will close if the write did not complete in a period of time.
to keep code consistency, you may use testK("v2");
Should reset the value in the config file too?
Why do you retrieve text of currently focused shell? What if there is a modal shell, some popup etc. Then this would be broken. Does the New docker connection wizard change its title while it is opened? If not, then you can remove this and on line 58 where you are using this text you can use constant again.
Is this not a shallow copy? Do we need to deep copy? You are giving a reference to ingredients not actually copying the array?
why do you need to lock this code? ExecutorService.execute is thread safe, isn't it ?
Given this requirement: If the setting for Hide Balance = ON then the balance should always be hidden when returning to the home screen (regardless of the last state) hideBalance should be set also in onResume()
Do we really want the entire stacktrace?
You can do getUnchecked() if you know the load() method does not throw any exception. The ExecutionException is just a wrapper that allows catching potential exceptions that get thrown by load().
suggestion var columnIdent = Symbols.pathFromSymbol(field) if (!columnIdent.isSystemColumn()) { context.add(columnIdent, field); }
Shouldn't also this need to be set to float?
If you want to be safe, you can do: if (mPrefix != null && mPrefix.length()) > 0 ) { On the coding style side, there should be a space after 'if'
Simpler: return partitionTostore.remove(id) != null; Also, should be partitionToStore (camel case)
That appears to be unrelated to this change (and wrong)?
suggestion Preconditions.checkArgument(latitude >= MIN_LATITUDE && latitude <= MAX_LATITUDE, "Latitude must be between -90 and 90");
Nothing seems to call the getAverage() method, so the TIMESTAMP_GRACE_TIME is never used. Or am I missing something?
Figured that since this is new code.. It should be fine from semver check point
matter of taste but why not rely on autoboxing ?
Wouldn't using a LinkedHashSet do the trick, avoiding the manual "add-all-once" handling while still guaranteeing a stable iteration order?
suggestion EMPTY_VALUE);
I would suggest using a StringBuilder instead for better efficiency. The builder also defaults to being empty, so you don't need to explicitly specify an empty string as the initial value.
Trade date required for trade. Now we have Position and Trade, when using 'Trade', the trade date is required. This has been changed recently (see for example BondFutureTrade). OvernightFuture should be aligned with the recent changes.
Please add technical details to the exception, here the referenced candidateId might be useful to be placed into the exception. If the future you will need to find out why so much 404 errors are sent back to the users, then you can see not just the candidate was not found, but which candidates id were referenced.
when you PR this to develop branch you will see I have added a checkActiveSession method you can re-use here.
I hate to be the one to complain about formatting... This method name needs to be prefixed with spongeImpl$ to be consistent with the class (though, @gabizou, [I thought the policy was to prefix impl$, not spongeImpl$](<LINK_0> Also, very nitpicky, but while you're there, can you remove the space between the method name and parameters, and the space after the method name?
getRestJiraClient() returns an Optional<>, but then you just use the get() assuming that the issue has been found. So the exception will be odd. It would probably make more sense to throw some special exception (e.g. IssueNotFoundException) in that case to make it easier to troubleshoot.
maybe also add the oldJobType blank check here?
why is this Noncompliant?
Couldn't this be an import instead of a fully qualified reference?
If this is expected to be thread safe it's not, as it can return for multiple threads even though there is just one element in the underlying store (not both threads can claim that instance).
I'm looking for a test something like this (I haven't run locally): suggestion final GHRepository repo = gitHub.getRepository("hub4j-test-org/GHContentIntegrationTest"); final GHContent fileContent = repo.getFileContent("ghcontent-ro/a-file-with-\u00F6"); assertThat(IOUtils.readLines(fileContent.read(), StandardCharsets.UTF_8), hasItems("test")); final GHContent fileContent2 = repo.getFileContent(fileContent.getPath()); assertThat(IOUtils.readLines(fileContent2.read(), StandardCharsets.UTF_8), hasItems("test"));
can't we use 'parameters.setForceRefresh(forceRefresh);' instead?
Ofri, here we have attested the host, and its result is trusted, so we need to move the vds status to up. But we involk InitVdsOnUp process, and in this process we attest the host again. How can we avoid the reduplicate attestation?
Remove this change please, as it should not be necessary.
tableScanPlanNodeId
use flatmap
I'd use a different config key (though I appreciate this is based on teleportenabled as used above) - perhaps "teleportauto"?
suggestion super("Unable to send a notification to slack:" + e.getMessage());
If it is live mode, should you assert this is set?
greage->create
Maybe move to constant. And the rv, of course. ;)
Needs to check (and return) if the context is null.
I'm too lazy to expand the whole file in the diff...does doCheck get called from multiple places? Could we just put the logic here?
you can express this as:  return Optional.fromNullable(metadata).or(Collections.EMPTY_MAP).entrySet().stream().collect(...stuff...);
the pattern MetadataSchema.DeletesSection.getRowPrefix() + SortSkew.getCode(path) + path could be it's own utility function, since it's used frequently. Perhaps: MetadataSchema.DeletesSection.encodeDeleteRow(path) or similar.
Would it be cleaner to just name this responseData? (The build method may just as well return the new response data immediately, instead of storing it in a local variable.)
Lets return the value of the apapter.createDirectory here ?
Assert.fail would be more appropriate here, if the if statement passes then the tccl is always not null.
This method indicates that the "value" map is expected to be <String, String> rather than <?, ?>.
this can be moved outside the function, as if rescheduleAt == null, then you dont need to make a getAndUpdate method call, but just a get, and then the function class can be one per parent object, instead of creating one per call.
Please do not create useless variables, it is more readable if you directly use:  java return ECApi.postLog(cache, logType, date, log);
import parquet.schema.PrimitiveType.PrimitiveTypeName; to simplify this
Invalid output schema
Annotate the method with @Nullable
I do not get that change. Why did you decided to have messages carry their encoding / decoding logic? I understand I gave that advice for the work @albinsuresh is doing, but in my mind the context here is different.
Maybe a good idea to check if "split" is assignable to "PhoenixMultiViewInputSplit" and then cast, else return an exception.
The visibility of this method can be private
space after ) (checkstyle will complain).
Change to include the original exception: throw new MojoExecutionException(e.getMessage(), e);
nit-pick: startCommit.hashCode can just be xored/added in since it is well distributed
This test seems to be weaker than it could. Could we use fixed clock and check for exact value rather than verify nullability?
NullPointerException expected
@Amejia481 on null we were previously returning an empty string, and here you changed that behavior into return null. Is there any special reason for doing that? Did you check which consequences that could have? I would prefer to return anything but a null if possible, unless there's a good reason for not doing it
missing space
I'm not a huge fan of continuing to to a label. How about populating filters with all the untracked entries and then remove entries that match the untracked folder prefix?
Also magic number here
suggestion if (!validatePort(targetTraceCollectionPort) && collectBuildTraces) {
Is it necessary to set 0 managed memory weight, by default it should be 0.
final?
This means we compute costs for all nodes even if we don't need them
Why these two options can't be populated directly by the SimpleRabbitListenerContainerFactory when that etBatchListener(true) is used?
I'm sorry to request something that doesn't feel great but I think it would be better for it to be just like anki - this bug wouldn't have happened e.g. if it was a straight port
NPE: timeGraphViewer is null before super is called. But I don't think the next line is necessary.
The intention behind the methods only called by the attribute name is to chain the calls as in: java id(ID).name(NAME).apiVersion(APIVERSION);  For non-chained calls, the idiom is to use setters: java setId(ID); setName(NAME);  In this case, because they are called from the constructor and returning and retrieving this wouldn't be very natural, I would favor the setters.
Did you mean processFuture.isDone() instead of its negation?
costly?
Why is syncPodsToDirectory being done during publishFinish? Shouldn't that be done at the start of the publish operation, like publishStart or something? My concern is if this is done after publish, it may be buggy. For example: User changes Sample.war. publishStart() is called, publishModule(etc) is called. You copy in the new changes of Sample.war, then you syncPodsToDirectory and end up overwriting your changes? Not sure if this is correct but its my current concern.
there is a bug here, reported to JDT (470535)
This seems esoteric. What's wrong with -0.0 here?
what do you think about: * whether makes sense to pass user from subject instead of getting user from environment inside HDFSCommand * from this function name seems like uploading whole list instead of a single note
remove cast to int
left operand is useless
Please add the class name to the exception message.
Argument name is wrong in the call to the arg checker.
I don't get this line - what we are testing here. We set exact input, why we are not sure about output?
Multi-line statements _are_ allowed.
What if login is deferred, wouldn't that code run too soon?
Can we just use ZoneId.systemDefault() here?
you don't need to call this every iteration, you could remember it before the loop
![MINOR](<LINK_2> 'Severity: MINOR') Use a logger to log this exception. [![rule](<LINK_1>](<LINK_0>
reportservice
wrong indentation, HIVE_CATALOG, ARIA_SCAN_ENABLED setCatalogSessionProperty(HIVE_CATALOG, ARIA_SCAN_ENABLED, "false") (ARIA_SCAN_ENABLED field needs to be changed to public in com.facebook.presto.hive.HiveSessionProperties)
need to add patientObj
I would prefer to have an index different than zero... just for sake of testing that it works with 42 or 67 (because everyone loves prime).
0 ?
in the current code disk can have no disk profile, which will lead to NPE/IndexOutOfBounds exception here.
accidental change
can you leave code better than it is now and move this path into private static field?
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
Eww use the builder
Why is this check needed? Doesn't the check below cover it? In fact, for complexity to be < 25M, tilecount cannot be larger than that.
In our testing subscriptions we can't create a collection with 1M throughput upfront. The workaround we have is to create a collection with 100K throughput and then scale up. Now with this auto deleting collection it means we have to do this manual process everytime. we don't want to always delete the collection. We should have a config option called autoCollectionCreateEnabled when present we should attempt to 1. create collection if not exist 2. delete the collection when autoCollectionCreateEnabled=false we shouldn't attempt to create or delete the collection, and if the collection doesn't exist we should fail.
What's the point of this change? If it does fixes the test case, why does it?
Were these tests failing on Windows machines?
Why do you have two beforeClass?
missing set to action and type
would be better to store as a local private variable (like locationContext / webStorage) and only inialize it once on construction. also fix the indentation here
If this does not hit often, I would vote for making this info.
Probably should be cloned here instead of taking a reference to an external object
There is a slight beter way to do write this. Will do it
Should use constant for the string
I don't think a template should be mandatory. you can always specify the list of packages on the command line
check your helpers, some could be static
Will probably look better to call the new ctr here, and move the initializations to it. i.e.: public VmLeaseParameters(Guid storagePoolId, Guid storageDomainId, Guid vmId) { this(storagePoolId, storageDomainId,vmId, null); } public VmLeaseParameters(Guid storagePoolId, Guid storageDomainId, Guid vmId, String vmName) { this.storagePoolId = storagePoolId; this.storageDomainId = storageDomainId; this.vmId = vmId; this.vmName = vmName; }
Indentation is spaces here when it should be tabs.
name dependency
null check here now
Runnable -> lambda?
yeah its not needed.
do you need to save this? What happens if you just do this instead?  this.fallback = fallback; // make sure we can invoke fallbacks on package-private interfaces for (Method method : dispatch.keySet()) { method.setAccessible(true); }
Should we change these final messages too?
You need to call configureConsumer too, see the other components
I'm not sure about this one. Please pull this out of this PR because it isn't related to timing and lets run some ad hoc examples to make sure we don't run into some nasty overflow/sign related problems.
What about if the clock moves backwards and you pass a negative or 0 wait?
It's not a big deal, but if you're using IntelliJ, you can get it to auto-generate toString, hashCode, and equals in the same style as most other Druid code automatically.
This method doesn't need to be static.
lambda
please keep the method with SignalServiceAddress parameter and just add a new method (with the same name) that takes a String and does the canonicalizeAndResolveSignalServiceAddress conversion.
Its probably better if we log JSON string here , helps in debugging on storm side.
invalidNamesor invalidFieldNames is better than fieldNames
I don't see a good reason to make this a java.util.function.Predicate rather than just a regular instance method that we call. We're always calling the same function (the predicate function is never something else). I agree that we should compile the whitelist and blacklist regex ahead of time, but that seems more straightforward to just do in the reconfigure function itself.
Static import
Now that we store definitions in the addWorkflowDefinition already, we should just remove this postProcessWorkflowDefinitions method. It will also nicely clean up some dependencies from other components.
default access
to remove, just use new ArrayList<>() in the constructor, one line below
new Double() is redundant here
return null?
Better: dataService.findAll(DYNAMIC_DECORATOR, DynamicDecorator.class).map(DynamicDecorator::getId)
since we are force casting we should use the same type for the instanceof
This is worth logging as an error
Use gov.hhs.fha.nhinc.nhinclib.NhincConstants.EXCHANGE_TYPE class here
Please also add a feature flag to show this only for pre-beta builds. (&& ReleaseUtil.isPreBetaRelease())
wouldn't it be safer to use isAssignableFrom?
RouterErrorCode mistmatch should suffice. If it fails, it will automatically print both the values
eliminate assert statement in ctor and replace it with IAE
int size = invokers.size(); for (int i = 0; i < size; ++i) { final TypedMethodInvoker<?> invoker = invokers.get(i); ...
We probably need to stop the remaining runningProcessors somewhere, right?
this.contributor
Did you want to leave this in?
Could use forEach
On one hand I agree, but on the other then I'll refactor how this callback works: in stopUldates() we set the callback to null, so we are not implying that we are not forwarding anything anymore (callback is null) but also that we won't receive any further update from downstream (because otherwise we'll crash). This second assumption is wrong in my opinion...
Do we really still need WaitUtils.sleepQuietly(1) here?
Use "test/testGrid2.json". It is the same as grid1.json and is reserved for tests.
qry -> query
Why masquerade as instructor?
If possible, please use an assertion explicite in tests, don't wrap a check into page-specific method
You can remove the public modifier since the class is package-private
why AbstractMap::hashCode is not enough?
Change method return type from String to void.
This suffers from the same problem as global channel interceptors. Let's say I subclass ChannelSecurityInterceptor, to send a Message<?> whenever a security violation occurs. This early instantiation will cause the channel to be referenced and, if it's an implicit channel (input-channel), it won't exist yet. It seems to me that the proxying must be done after the channel initializer has performed its task. Another min_value phase SmartLifecyle ?
Will this propagate correctly? I assume it is being called from the SyncClient thread?
Never set empty string to I18N. Gathering strings in source code will fail.
Test methods can more simply just throws Exception.
this would make 1 ms and 1000000 ns not equal. Do we want that?
u00AD and u200C should map to "" (empty string) not "\"" (double quote). The original JSON has "\\u00AD=>" ... but the quotes are around the mapping \\u00AD=> (map to nothing) and not part of the mapping!
how does this work? types shouldn't match right? I was under the impression that RemoteTimelockServiceAdapter took in a NamespaceAwareTimelockRpcClient?
Remove this. and the one below
if the assertion fails, one would have to run the test and debug why. WDYT about replacing it with assert that expects the count of **any** SHM mount to be 1 and then comparing the source & target? So that if it is 1, but source != target, we will see it immediately from the error
Don't we need to close the socket after socket connect since you are only try to check the connectivity?
There is a different method available to start with one delay of 15 seconds, and another period for all future runs. I think that is what you want here.
I think the main thing to figure out is in what cases we should switch back to the leader. We know about out of range errors already. Here are a few other cases: 1. Leader changes. We have to do validation anyway, so we can reset the preferred read replica. 2. The preferred read replica is marked offline in the metadata. 3. We notice changes to either the replica set or the ISR. Possibly we could just do 1 and 2. For 3, maybe we could handle it using a periodic timer to check preferred read replica status. One option would be to couple this with metadata.max.age.ms, which is what the original KIP proposed.
Nit: the kafkaProducer field is set, returned, then set again from the same value.
What do you think about returning Collections.emptyList() here instead? Then we can also annotate the method as returning @NonNull (and also drop [this check](<LINK_0>
Adding this to a field is good manner.
I would like to shorten the configuration names. If you are ok, could you please rename skip_before_chars into skip_before and skip_after_chars to skip_after?
List<FeedRange> feedRanges = new ArrayList<FeedRange>(feedRanges.size());
Duplicate code inside XMLDateUtil.long2Gregorian()
Declare the WebElements at the start of the class instead?
If we are swallowing exception here we don't need to addSuppressed.
I would prefer to put the longer explanation on rp.sendMessage() and use a shorter message in reject() (see below).
Remove "for AmbryDataNode"
This looks convoluted ... instead do String uriString; if (uri != null) { operationResult.addOperationResult(uri, userMessage); uriString = uri.toString(); } else uriString = "retrieving URI failed"; //$NON-NLS-1$
new Boolean skips the constant pool -- placing unnecessary pressure on the garbage collector. Please use Boolean.valueOf instead.
Code style. Constructor must be private. Make a static factory method named create(...) to create a new transformer
why is this public?
By the look of it, this won't work properly. getContent().add(foo) doesn't add foo to the endnote object
Let's simplify once again ;-) return sessionStore.read(AuthEndpoints.NAME) != null
I'd use ImmutableSet.of(this.resultStream) here
What sets the expected state to Lifecycle.RUNNING?
Can be made package-local
Minor: Can you use the ternary operator here.
assertFalse(...);
Please replace this with: if ( str.startsWith("\"") && str.endsWith("\"")) { return str.substring(1, str.length() - 1 ); } else { return str; } Performance will be much better than using indexof and creating an intermediate object.
can't you set the consistency level here?
I suspect the method names are swapped between shouldNotAddRedundantVersions and shouldKeepOtherVersions, as the former currently inserts 2 different versions and the first tries to insert the same twice. It should be the opposite.
Hi @treblereel, build failing due to this line. You are comparing session with itself. Looks like a bug to me. You can check it locally by executing mvn clean package -Dfull to see more details about this bug you can use mvn spotbugs:gui.
Personal opinion, it is confusing to mix format and offsetString, I mean third parameter of DMNSimpleTimeZone feel free to ignore if you think it is fine
typo: not -> does not
String.isEmpty() is used in other places of Oskari. No biggie - just a heads up.
this is an else, right?
Those 4 lines are identical in all methods - refactor into common method?
Use !input.startsWith to align with the parser above?
Remove
put the actual modid in there if you're going to do that not your name
i think it is better to extract all these listeners to separate classes. it would make code look more neat
Should these logging statements be set to debug level instead of info level? Also, if you switch over to using lang3 ToStringBuilder, I think that version of it does not allow null values for "reflectionToString".
Please extract this condition to method.
Add an empty new line here (make it consistent with other count handlers).
Multiple ';'
Definitely not! JMXFetch is known to have quite a bit of code that could use some cleanup, so this is definitely welcome.
I don't get it. This class is internal, and not really designed for subclassing: the intended way to reuse it is to construct with a custom supplier, it's not immediately clear to me what more subclassing would allow. Does this come from a concrete use case?
Could we do return System.getProperty(this.port, getPort(getProtocol()); here?
Same, this time even with wrong placement. I assume this call is based on vanilla code?
This should be replaced with this.color = color.getRGB()
suggestion public PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) { return _partitionMetadataManagerMap.computeIfAbsent(partitionId, PartitionUpsertMetadataManager::new); }
You could flip the .equals(..) below around to avoid the null check, or if you think that's not safe then you're missing another null check.
Can you pass "null" as the callback? It is not being used, anyway.
Use curly brackets for all if statements to keep the code consistent across the whole project
The passed in Authentication is ignored. We should leverage that rather than the SecurityContextHolder
This doesn't seem right. What are you trying to do here?
Did you mean to leave this in?
Did you mean AsyncReceiveCommits.Factory?
The whole block can be replaced with: return Collections.singletonList(Constants.REMOTE_TYPE);
suggestion private static boolean sHasRunWebBrowserCheck = false; private static boolean sHasWebBrowser = true; public static boolean hasWebBrowser(Context context) { if (sHasRunWebBrowserCheck) { return sHasWebBrowser; }  Since this is static and should not vary much, probably best to memoize this as it could affect performance. I haven't tested this suggested code but it should work or be close to working
@antonini please name it user, and initialize it with Opt.Empty
I think this message should mention that a new view is being created.
Doesn't offHeapEntryFactory.getSize() include the size of the LRU pointers?
call to 'super()' is implicit. no need to state it explicitly
Maybe use StringUtils.isEmpty(jobtracker) instead of jobtracker == null.
wrap with Collections.unmodifiableMap() ?
:o: Should we use StringUtils.isBlank() here?
What about the custom Hive version label in the component? We have to let the user know that it doesn't work with Hive 1.2.0.
In the get method which calls getChild we use property.getName() instead of field.getName().getPrefixedName() as the key in the children map. Can you make this consistent so that we're sure there's no discrepancy between prefixed/unprefixed?
No need for intermediate blob variable
I don't understand the condition on the length.
we should return from the loop once this var is greater than 2. One way to do also get rid of the set could be to use a switch here :  for () { switch(c) { case '+': case '*': case '{': nb++; break; } if(nb == 2) return true; } return false;
marshal is different than parse, maybe just from IOExceptions here
Can the magic number be explained some more (why 3)? or even more preferably show how its calculated in a static constant?
This can be private. Is there a reason to make it protected?
[Broken Double-checked locking](<LINK_0> pattern.
Just wondering -- is there any way to make this return an iterator, so that if we want to return just the first page of 100 results we can do that without fetching the entire list? Or are we stuck with the whole list because Criteria offers no other option?
200ms might be a bit tight, usually we go for 300ms for UI related feedback.
Using a StringBuilder looks like an overkill here as there is a single concat, we can just do .setPreference("_shards:" + shard).
this method will never return false, if it does, please show me how you did that, we have a bug somewhere else that need to be fixed urgently.
This should not be hard coded
I prefer naming variables by what they represent. In this case for example: returnedBodyPart or result.
In this case, the user's configured primaryAddress will never be taken into account. This might not meet expectations...
Is this RevWalk used? The ObjectReader should be released by r.close(), so I don't think this inner try { } finally block is needed.
ORing with BUTTON1 happens for macOS also.
needs done=true
{ } ?
Can you think of a way to avoid passing OzoneManager to this class? We now have a low level class depending on a higher level class and potentially a circular dependency.
Now that the ID is no longer required, we don't need it to be non-null
suggestion .filter(Attribute::hasDefaultValue)
Change to java transactionFactory.createBoletoTransaction(); transactionFactory.createDebitOfflineTransaction(); transactionFactory.createDebitOnlineTransaction();
negative logic
being able to do result.mStatus.mCode might indicate that somewhere in the way setting modifiers for GlusterVolumeStatusReturnForXmlRpc.mStatus wasn't done properly.
@xiaolong-sn when we have a map we can add a method public String getStreamConsumerArn(String stream)
assertThat(map).isEmpty()
nit: would it be clearer just to define the onDismissListener inline here?
HttpServletResponse.SC_NOT_FOUND
It looks like the same type of conversion of jDLMS DataObject to a value object appears in more classes. This might be a good candidate to move to a helper service like the DlmsHelperService.
'fields' should be applied only for top level json?
Shouldn't we use try-with-resources instead of the suppress warnings annotation?
maybe use new OkHttpClient.Builder()..., it's a bit odd that we are creating 2 clients?
Is the cost really multiplied by the length of the data type? What if you have a really long string, is it really that expensive?
throttleTier
nit: you can use assertThrows. There are a few of these in this PR.
Looking at [printNonZeroResultScenarios](<LINK_0> I think ambiguousScenarios should be treated the same as failedScenarios and always return a non zero exit status.
Change method name with prefix.
Might be nice to make this private and call it from inside of the HomeActivityUIController constructor.
We also need to make this public. Otherwise the client of the Iterator<Note> cannot see the blob that is attached to the note.
Useless check because it fTraces is always null when setup is called. It is called only once per execution regardless if only one test is run or the whole file.
Yea, we were trying to avoid changing those newMerger method signatures, which is how we grew setObjectInserter(). I wanted to drop the final part because I'm considering swapping in a different ObjectInserter/ObjectReader in RecursiveMerger that tries hard to buffer the virtual base stuff in-memory without ever leaking it into the repository as a stored object. Unclear what happens with a conflict and we try to load the higher stages with virtual ObjectIds. I guess we would then be forced to write those virtual bases out to the repository. But we could at least delay it until the top level pass, and avoid all intermediate stages. I'm not set on that approach. I may need to finish out the reader-from-inserter to really fix RecursiveMerger. But an in-memory wrapper for the virtual base might be sufficient.
Hmm totally forgot, this refactoring breaks backwards compatibility. Maybe keep using the old classes for Cifs for this release and return them from the CifsConnectionBuilder.
getLabelControl
I haven't read the diff carefully, but: PacketTransformers should not keep the RawPacket/DtmfRawPacket instances, because these instances and their buffers are re-used. I don't expect many DTMF packets, so a simple clone() should be enough.
Can be simplified to java return itemMaterial == null ? 0 : itemMaterial.getMaxStackSize();
Consider using assertNotSame instead.
shouldn't be migrate cluster syncrhonize... ?
suggestion sb.append(sortOrder); sb.append("}");
I saw hashedInputs being initialized during Bolt construction on client side as well. If its not needed, we can just remove it.
super(); is unnecessary as it's automatically called
Replace the exception by Exception, so your test is self contained.
This might be due to WIP, but we should not be throwing stack traces.
AssertJ on the collection, instead of the plain assertTrue?
This code can be simplified to rely on autounboxing.
getObjectId and getObjectValue can be null ? if yes please adjust this conditions
You can just call Injector injector = Guice.createInjector(); without any module for the same value.
this addOsTypes() method called in all versions of the /capabilities resource, you should be creating differentiation between older versions and VERSION_3_3 where new OSs became supported
Where did the 20% range come from? It might be more clear if it is a constant percentage and initialized in TNatsServiceTransport() with the other parameters around heartbeats.
> If we go for the approach where we use ORM + our own ClassLoaderService implementation, I think this method needs to change. It is not enough to just check whether the first loadJavaServices returns results. We need to call both loadJavaServices methods and then de-duplicate the results. A bit of a pita. +1 > I am also tempted to say, that we should check in all of these methods the internalClassLoaderService first. Actually wondering if - in case we know we're loading an internal extension/service which doesn't allow an override, we should not use the CLService but go via the well known parent classloaderservice. In case we want to lookup in both, then it would be correct to look for external overrides first?
Super nitpicky, but "InForm" feels like an awkward thing for this to be based on v. maybe "MainInstance" (IE: Anything rooted at '/'), just to keep the vocabulary within what is generally referred to in the EvaluationContext
Should this really be exposed as public setter?
should be defined here
Why not use the same trick with TimeUnit? TimeUnit.HOURS.toMillis(1)
Style-nit: No space after method name before parameter list.
This actually isn't correct. The "item" in this case that is being passed to the JSR-352 SkipListener is actually all the items in the current chunk. Unlike Spring Batch, the JSR does not provide facilities to identify which item within a chunk caused the error. See section 9.2.7 of the spec for more detail
It is always number or null?
BaseEventInfo.setLogLevel(string) does the same thing. So, we should used you new method instead and remove setLogLevel() from BaseEventInfo (IBaseEventInfo). If we do so we need to make sure that the test case are updated so that the valueOfString() method is tested.
It would be nice if we could skip the code duplication in passPersistableBundleExtrasToBundle(). Since PersistableBundle implements Parcelable, and we can create a Bundle from a Parcelable, maybe with a bit of tweaking we can use new Bundle(params.getExtras()) to convert the PersistentBundle to a Bundle?
The message must be adapted if the command returned is a "remove blank space command".
we should check for null and existence
What if configuration is empty?
This does not need to be public, let's keep private
The trimmed result is ignored.
You should use java.util.logging for this.
Maybe add the tag here as well.
isEmpty
perform the split here if needed, set to empty to avoid null conditionals if none.
could be reformulated as a filter operation on a stream.
Extract the string or the expression By.cssSelector(...) as a variable for better readability.
We have to validate the suffix here, because the user can pass a string which is not valid in Java identifiers.
Some TypedOutput instances can only be read once so consuming the entire stream will render them unable to write a second time for the actual body.
Here the name superClass is a bit misleading
Move after doExport. Probably should be LOG.debug, although it doesn't provide too much useful information, perhaps we can remove it
Could we fix position? You call validateCursorForNulls, but after that you call KafkaCursor.fromNakadiCursor, which basically does the same checks. From other side it is not clear why you call KafkaCursor.fromNakadiCursor and do not work with the KafkaCursor.
You should return void instead of Void, so you won't have to return null
StringUtils.ifNotBlank()
remove after script_end
Rewrite as: int c = methodName.compareTo(other.methodName); if (c != 0) return c; return className.compareTo(other.className);
Our convention is to create a new instance if members is null that way the method never returns null.
You can remove the this
method can be protected now (private if not isolated in tests).
Why do we need to have the initialized variable?
As CosemDateTime appears to be immutable, there is no need to return a new object to protect internal state.
nit: checkArgument? I am undecided myself, but shall we use IllegalArgumentException or IllegalStateException in those cases?
I am a bit confused that executeCommandAndCommitIfNeeded(ctx, command) does not set the lock owner and executeCommandAndCommitIfNeeded(contextBuilder, command) does - please move the checkLockOwner to the former.
Slight performance enhancement... suggestion revisionActions = actions.toArray(new Action[actions.size()]);
aspect
In case changing the code above then just change here to: updateGridSize(calculateGridHeight(values.size()));
Maybe we should define the int outside of the for? Not sure if this gets optimized, but I introduced a "bug" with String once, so I became a bit cautious with these things.
Consider extracting helper method tryConsumeFailedPosition:  @Override public boolean testNull() { if (tryConsumeFailedPosition()) { return false; } ... } private boolean tryConsumeFailedPosition() { if (numNextPositionsToFail > 0) { filterIndex++; numNextPositionsToFail--; return true; } return false; }
Either you put all the aspects in the list (in which case, you may want to change the name of the field), or just the duplicates.
Probably worth including a negative test for SOLID or 454.
This could also make use of createCloudResource method
whitespace suggestion public HaplotypeProbabilitiesFromContaminatorSequence(HaplotypeProbabilitiesFromContaminatorSequence other) {
If you just throw exception here - then this block doesn't really make sense, because you just throw what you caught. What can add value here is to create and throw AssertionError that contains the endpoint (like few lines above), because if mockMvc check fails - it does not provide the information about the endpoint.
You can do view.setTag(mainViewHolder == null ? new ViewHolder(view) : mainViewHolder);
Maybe add a function to the logger adding these "-" signs automatically in the right amount so every log line has the same length? <feature
This could go to beforeClass, right?
suggestion + " or 'getDataView()' according to the used data type.",
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
can we remove: declare-response, useless-assign and just return the object from the method-call?
Confusing indentation, did you mean to delete the other bracket?
rename to method
Separate file for each test. Rename it to avoid misunderstanding. File name should contain short information about its purpose.
should use TextInputFormat
Why not make the function static?
Use constant?
This should just return RealmObjectSchema?
What about calling super? Is it intentional we don't call it? If so - why?
Not needed empty line.
why not asserts?
I think it's better to check class here instead of byte. Byte value is error-prone. Or at least can be replaced with an enum (but IMO class check is better).
if we know the result, break out of the loop.
Seems like extraneous logging in this module.
It looks like a NPE-check on display is missing here (NPE-safety seemed to be the point of the initial null-check of control)
Can you make the old constructor call the new one (with a default value for the additional parameter)?
This should not be necessary.
This JobScheduler version of feed update does not obey mobile update user preference. In contrast, the AlarmManager version in FeedUpdateReceiver does the check: java if (NetworkUtils.networkAvailable() && NetworkUtils.isDownloadAllowed()) {  In fact, I'd suggest consolidate the actual refresh logic used by FeedUpdateReceiver and FeedUpdateJobService into a common method.
so here it's probably wrong then as well since you need to be able to save it with type 'null', to keep autodetect
FmsGroups suffer the same issue as FmsUsers. you'll need to calculate the group mapping somewhere around line 71 and add it into the UmsUsersState somewhere around line 78
nit: inline block variable
Personally I find index < 0 simpler to parse.
just throw UnsupportedException here, this method never called anyway since you've implemented ReadOnly interface
Suggest adding the current state to the exception msg as well
I think we don't want to remove this... otherwise character content (that's not an entity reference) won't appear properly.
this message will be appeared even when containerClient == null Also could you please add i18n for log messages?
I think we actually want this to just be... suggestion return appUrl;  The "/medic/_design/medic/_rewrite/" bit is the old format that we no longer need.
And if we are making it private then just return parameterDefinitions == null ? new ParametersDefinitionProperty() : this; and the field can stay final FTW
I believe this was a suggestion of @dwightguth: if computeHash() returns 0, set the hashCode to 1.
Comparing with [TestExecutionResult](<LINK_0> shouldn't this Getter return an Optional?
rigion should be "region"
ImmutableMap.builder throws an exception when tries to register another assigner with an already registered name. It will fail to initialize the class, which leads to NoClassDefFoundError and Snow Owl startup error. This registration phase should report duplicate assigners as warnings in the log and should only register the first assigner.
this function actually returning a Builder and not an URI. If you don't need the builder, return the URI directly or rename this function
It only rejects new tasks, so has no practical effect in this case. I would try shutdownNow, even with a bad support of interrupts by the thread
Equal values should not be tolerated. Any reassignment of already existing dimension or metric should be illegal.
maybe do this test explicitly with localhost:1234
I think we have an unwritten convention of using doPublish do such methods.
suggestion return tryActivateAndGet(e, item) != null;
in the save digest you use uppercase for sha
Suggestion for readability -- chaining calls to append: java StringBuilder errorBuilder = new StringBuilder(SamlConstants.SECURITY_ASSERTION_ISSUER_FORMAT) .append(" ") ...SNIPPED...  If you're feeling really crazy, you can even skip the StringBuilder declaration and just make the function a single statement: java return new StringBuilder(SamlConstants.SECURITY_ASSERTION_ISSUER_FORMAT) .append(" ") ...SNIPPED... .toString();
personal preference: private static final float CENTER = 0.5f;
Package name should be lowercase.
make static
java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(worldpayTemplateData::setState);
This actually can be private static. 1. First it can be static because it does not refer to this ZKFC object fields 2. Other methods are protected I *guess* because they are overriding parent class ZKFailoverController methods. When overriding, we can not change the scope to a smaller one (aka weaker access privilege). So here we keep the protected keyword.
This seems hacky, and besides why this is needed? bootstrapLayoutServer has an exceptionally block: java .exceptionally(throwable -> { try { CFUtils.unwrap(throwable, AlreadyBootstrappedException.class); } catch (AlreadyBootstrappedException e) { log.info("bootstrapLayoutServer: Layout Server {} already bootstrapped.", endpoint); } return true; })  Notice this CFUtils.unwrap(throwable, AlreadyBootstrappedException.class); It will throw a RutimeException in case of exceptions other than AlreadyBootstrappedException, which makes the returned future exceptionally completed . Thus in this bootstrapNewNode method you will get a exceptionally completed future of RutimeException with a TimeoutException wrapped inside.
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn row be underlying scrollable layer row that is already found at the specified NatTable position, so that it does change after scrolling. Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableRow = viewportLayer.localToUnderlyingRowPosition(viewportPosition.row);
We usually prefer people providing default value through properties file, we want to make the default value more explicit. Can you provide the default value in secor.common.properties?
why not do this null handling in read() and shouldn't the reader get closed in a try/finally ?
Make the fileInfo map immutable.
New methods should be guarded for cluster version eg:  if (isClusterVersionLessThan(V3_11)) { throw new UnsupportedOperationException("Not supported ..."); }
I'd rather see a single return.
A number of these tests don't actually throw an HttpMediaTypeNotAcceptableException. Will you please remove the throws from the signature where it is unnecessary? This way, the expectations of the test are clearer.
To test uncaughtException you need to call it :wink: Let's see what you come up with. Let me know if you need help or a hint.
these are repeated frequently, which is pretty dangerous for making these updates later. It seems like storing these flags (and the relevant serialization code) in a composed member object would be safer and save "do not repeat effort"
unnecessary new suggestion {"NA12891.over.fingerprints.r1.sam", true},
Any reason not to move this addPendingClient call into the existing conditional block directly above?
Minor nitpicking but we might as well be consistent in the way we test for this. See the change just above this one.
muss dies public sein oder recht package private?
Does this need to be public?
Missing a "break" (or just return)
While String concatenation is more performant, would it be easier to read if you used a [String.format](<LINK_0>,%20java.lang.Object...%29) instead to make this more readable?
can this throw any exceptions? If so should catch and make sure destroy is called on dbManager.
I guess 'else' is not required here since the if block has a return... personally, I'd find this easier to read:  MessageHandler handler = createDirectHandlerIfPossible(targetObject, targetMethodName); if (handler == null) { ServiceActivatingHandler handler = (StringUtils.hasText(targetMethodName)) ? new ServiceActivatingHandler(targetObject, targetMethodName) : new ServiceActivatingHandler(targetObject); handler = this.configureHandler(handler); } return handler;  ...but feel free to ignore that :)
You have to create a constant.
This is a filter. If we return before passing the end element event to the next content handler, we'll end up with unbalanced tree. Is this really correct?
Shouldn't the strategy identifier be referenced by its IDENTIFIER constant (which might be made public)?
Maybe something like this:  return allCriteriaWithNumbers.stream.collect(Collectors.joining(" or "));
columnName is null
call reflow() instead?
if replace entity.getOperatorId() with something else (for example number 5), i think that all tests will pass.
> setStatus [](start = 9, length = 9) isn't setexception already indicating the status of failure? #Pending
!cancelled cannot fail if cancelled is a primitive. If it does, the JVM or the CPU needs to be taken out of service.
Need the name/urn in the output.
Normally I would use Collections.unmodifyableList(...) here. I think the apache-commons variant is there only for JDK4 users.
Please check that version isn't null. Otherwise the automated null checks fail.
Use Collections.singleton as you did for attachments.
As described below: it's already not a first version. Please think carefully how to code onInstall() and onUpdate().
Please assert a return value.
I get that you're doing this so that exceptionCounter is final which you need for the forEach(), but I think I'd prefer to use AtomicInteger here
I'd really really like ByteString objects to be immutable, because we use them in a lot of places.
I think isCreatable( ) will allow numbers that can't be parsed into integers (like floats). I think a regex is possibly the right approach here. 0|[1-9][0-9]{0,5} should work (either just 0, _or_ a digit from 1 to 9 followed by up to five digits from 0 to 9, thus allowing numbers from 0 to 999999 without allowing leading zeroes, which would get parsed as octal and give unexpected results). I think this method could avoid the need for Apache Commons altogether if it was something like this (assume NUMBER_FROM_0_TO_999999 is a constant Pattern of the regex above and note the change of return type to int): java private int getBrowserScreenHeight(EpdqTemplateData templateData) { return templateData.getAuthCardDetails().getJsScreenHeight() .filter(screenHeight -> NUMBER_FROM_0_TO_999999.matcher(screenHeight).matches()) .map(Integer::parseInt) .filter(screenHeight -> screenHeight >= 0 && screenHeight <= 999999) .orElse(DEFAULT_BROWSER_SCREEN_HEIGHT); }
The ProductManager did flush when saving the core products, then again when saving the owner-products. Here it seems we're deferring flushing for when? Shouldn't we flush before CandlepinPoolManager starts processing the pools? (same question applies for ContentNodeVisitor.complete)
new Glob vs. toGlobPredicate() -- would rather use one approach either the factory method or the constructor but we shouldn't mix both. Maybe we should go with the factory method. What do you think?
already set in xml
Since this is class is becoming a shell that delegates all of its operations to a NativeImpl instance, wouldn't it be a better design to also include getCpu() in NativeImpl?
Don't allow comparison against both the name and the value. That's confusing.
Well this and whether silencing after X number of failed/merged transactions happens.
By doing so, you are changing the expected behavior for some weird cases. I would prefer to have a separate method like createAccountWithHashedPassword if the goal is only for CasC. In the current approach you are impacting users that desires to have a real password starting #jbcrypt:. I understand that the impact is quite small but such behavior could be potentially used by malicious users to achieve things.
when concatening strings with +, it's not needed to do .toString(). This gives the same result:  return singleBenchmarkResult + "_" + problemStatisticType;  Furthermore, it even avoids a nullpointerexception if for example problemStatisticType is null (which it never is in this particular case)
it's so beautiful
Another way that is more relevant to the backing data is results[resultsIndex].length
Add the force parameter to the toString()
@Aslan11 return statements are missed
For non-public methods checkWidget() is not required.
user OrderTable.TABLE_NAME instead of plain text. FORGET this, let it be there, let's put the constants reassemble work in the next phase if there would be such a chance in the future...
I disagree with this being on by default. Also recommend you change to Boolean.parseBoolean
remove "create=true" here too.
Why did you do this?
!false == true, so I think you need to keep setting the mapper.
If this always returns false setCancelled is pretty dang useless....
could you please rename all _ret variables ? that's the only remaining request before I can merge this PR. thanks
Since it seems like we might want to support this on line charts as well, consider moving the definition of changePointShape up to the superclass with a default behavior of doing nothing, then have the line and scatter chart types do the appropriate behavior.
Again the system.outs
Should you throw runtime exception?
getParent().getId()
Seems to be a regression in the merge: the checksum flag is missing.
Why does this do configure and save?
It would be rather preferable to create a new method with error propagation
Not sure what is the benefit compared to Collections.unmodifiableMap.
You could keep the default (i.e., false) in one place by replacing this constructor implementation with this(ErrorProneFlags.empty());.
Do you keep this at INFO level?
Range should be parameterised, the compiler gives warnings for it. Same for all other occurrences below
why remove the winning team from this game and add again ?
Remove "Exiting process now." from message here, should be in the runnable.
again, "remote installation..." might be a confusing error message when someone tries to remove a plugin
![MAJOR](<LINK_1> Make "getNumberOfCommas" a "static" method. [![rule](<LINK_2>](<LINK_0>
Please remind me why do we need this at all? Apache Ignite does not have compatibility between versions. Can we get rid of feature check entirely, assume it as "always true"?
exiting, so STDERR
nit: redundant casting
Try onRelease
The forServer == false flow looks wrong. If null is passed, then KeyManagerFactoryWrapper will throw (and we probably want the keyManagerFactory to be null in that case).
Might be better to set it true only if the value is "true"
Perhaps if we want to force this it should be synchronous on the current thread instead of putting it on a scheduler? I think even though you say now that's just a best effort to schedule it as soon as possible.
you can move these initializations to the field definition
Why is this now a literal and not a static final? Ideally, we could calculate the width of the terminal, but this is out of scope here.
Same here and above.
this function can be private
I don't think this is quite right. We should fall back to the conversion service if it can do it: suggestion if (canConvertFromStringTo(Long.class)) { idAsLong = conversionService.convert(identitifier, Long.class); } else { idAsLong = Long.valueOf(identifier.toString()); } return isAsLong;
It seems the atRootDirectory check is faulty. I get into a loop when pressing back on the music tab (currently only one I'm trying to test).
make "/manager" a constant
Code will be  String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith("I_S_D_A")) { str = "ORIGINAL_ISDA"; } return valueOf(str)
This could swallow interrupts etc? How about doing Exceptions.propagateIfFatal() first?
return (expression instanceof CallExpression) && functionManager.getFunctionMetadata(...
replace it by StringUtils.COMMA
Handle errors on listener invocation?
I'd create the domain first, set all it's params, and only then apply to image, but that's really nitpicking ;-)
This will give "public=="+publicPort. You don't need to include the "=" yourself.
public Collection<OperatorSpec>
throws QueueFile.<Error>getSneakyThrowable(e);
If there isn't a job, we should make sure there is with a setUp function that creates one that runs first. Or, alternatively make the test pass if no jobs are found.
Can this be called type instead of id? Also I'm not seeing a client test for this enricher, did I miss it?
Call the other constructor (line 86) with default values for the unused members here.
You can configure this using the @Mock annotation: @Mock(answer = RETURNS_DEEP_STUBS)
![Codacy](<LINK_0> Issue found: [Avoid unnecessary if..then..else statements when returning booleans](<LINK_1>
Minor: Not sure this is the cleanest way to write this. Consider Collections.emptyMap() or ImmutableMap.of(), or even just new HashMap<String, String>(). The first two are immutable, and I prefer maps to be immutable by default.
This is fine but it's a bit odd to see this instead of an if/else.
@erimerturk what happens here for existing records, which hasn't the subscription attribute before ? returns null or what? if so let's add default value true
I think we have to overload the constructor to not break existing clients using the old constructor. I suggest to add a hint to favor Aggregation.geoNear( ) over using the constructors directly. Should we actually do that for all of the operation constructors that actually have a static factory method equivalent in Aggregation?
What is the JGit community consensus about final variables? -used them every where -only member variables should be final -... I looked in the contribution guide and I didn't find anything regarding final variables.
typo: initializable
Revert this line?
let's use a better variable name than "s" (also and there are several such places, when would metadatablock be null? if nowhere, I think we can simplify the logic here)
Huh? The point is that a cast isn't necessary
Null check?
We probably shouldn't be calling a deprecated constructor from a non-deprecated one.
while (loop < maxRetry) will get rid of the extra if break condition.
Variable MetricsInterceptor might need to start with a lowercase letter.
This method can just throw an exception back to caller to decide what to do with the exception. It is not necessary to take in the Logger.
use protected access modifier instead of default (all-over)
This change misses the case where hasNext returns false no longer failing the test. I think the right thing is to not test the return value and to remove the catch and replace with an expected=RuntimeException.class on the Test annotation.
The FQN should not be needed here, instead the simple name should suffice when returning the required import through getImports().
should that get changed then?
Please check if the are any usages of this method outside this class. If not, please make it private.
getQualifiedName()
considering this is Actor state, and concurrency should be already solved by Actor model, is there any particular intention on using ConcurrentHashMap??
The code block added here (lines 29 to 38) is identical to the code added for EventBasedGatewayActivityBehavior, excepted by the fact that the first one has a break clause. Is this difference intentional? If not, this code could be extracted into a separated class which is injected where necessary to avoid logic duplication. In the case where injecting a class is too intrusive in the current code structure you can imagine to have a method in a common super class as well. What do you think?
Lets replace magical numbers with strings that represent them. Somewhere near the top of the code but with better spacing  java private final String PLAYLIST = "Playlist"; private final String MUSICLIBRARY = "MusicLibrary"; private final Map<String, Integer> DRAWER =new HashMap<String, Integer>(){ { put(PLAYLIST, 0); put(MUSICLIBRARY,1) } };  Then here you have  java if(position.equals(DRAWER.get(PLAYLIST)){ //more code here }  Also make sure that if's have braces {}
When we use updatedAt for versioning we are assuming that system clock is good enough as an indication of order, given concurrent changes are not very frequent, right?
you can do .orElseThrow here
Would suggest to make it private.
Is there some way to make this not hardcoded? I'd like to support other pluggables or even other types of PipeBehaviour that can connect to redstone.
Must be TargetCardInYourGraveyard
A better solution would be to Inject the StateManager and call clearSearchQuery (For how to inject see for example the LinkedFileEditDialogView dialog)
This should call the DAO directly as it did in 1.11
How about extracting this value to variable so it can be checked later on?
If createOcspResponse on line 168 is throwing an exception as the test expects, then this line will never get called and can be removed.
Given registerDisplayListener is in the if block in enable, this should probably be in the if block in disable also.
Is it better to do a non-empty check and remove the try block?
When using assertTrue()/assertFalse(), we should use the variant that takes a failure message so we can provide more information when the test fails (otherwise the printed failure message will just say "expected true but was false").
I see the idea, but I am worried about getTrackers() method returning fake data. users can attempt to call .getTrackers() and then add an item to the collection, and the behavior would depend on whether or not there were trackers before: it would return either a new **modifiable** hashset, or an **unmodifiable** set if there were some trackers stored already. one option would be to return an unmodifiable empty set
I am wondering if this should include a null check here as well. StringUtils.length(noteText), will return zero if noteText is null, otherwise return the length of the string.
use type.binaryName() instead?
announcement_webview variable name should be renamed to webview, 'announcementWebView' webview seems odd here.
One question: Should syncThread be a member of this class? Isn't it possible to initiate the thread where it is actually start, like you did in MemoryStoreImpl.initialize()?
can you change to: "Unable to generate UUID due to unexpected encoding error: " + e.getLocalizedMessage()
have this return UpdateFileMetadata instead of void so developers can use the builder pattern like:  java updateRequest.addUpdateTask(op, k, v) .addUpdateTask(op2, k2, v2);
This ParameterService method accepts a Boolean object, so you don't need to unbox Boolean.TRUE here.
Use long names please: options
We could consider 0 as being invalid as well. That would also help to revert that change: <LINK_0>
Did you intend to make this final ?
The only reason I can think of for allowing a null argument is to allow reuse of an existing builder where specifying a null day count would clear the previously set day count. That doesn't happen here; if the day count is null the previous day count is left in place and the method returns successfully. I think the behaviour should be either of the following when the day count is null - Throw an IllegalArgumentException - info.remove(CurveInfoType.DAY_COUNT) I don't have a strong opinion on which one it is.
Can we just use the more lenient comparison window always, and get rid of the OS detection? We are not really intending to test the system clock here at all, and OS-specific behavior should be avoided whenever possible.
This is what i mean. If i supplied two different dates, can i get different results basing on the date value?
printStackTrace()? Isn't it better to use a logger?
This is never used?
Returning Void.class would seem OK and more friendly.
I think an IndexOutOfBoundsException would be better here
I guess you don't need these maps, since you have those small objects?
curlies not needed
I'd rather see an overloaded constructor in ReleaseHelper and let the old one do this(cClient, false, null, null). The false, null, null part makes the code less readable at this place, because one has to look up what the parameters mean. Same with the usage in ComponentExporter
Good point! Forgot this was the constructor
Should this change be applied to other methods of this class as well (getAbsolutePath, getRequestUri)?
There are a bunch more of characters and even directory names that are reserved on Windows systems.
Can you please add a space after if for consistency (here and in other cases)?
i'd create a dedicated mapper for the UpdateVmTemplateParameters (see [1]), [1] VmMapper.RunVmOnceParams map(VM vm, RunVmOnceParams template)
Do we really need to wait for progress bar invisibility at the start of method? It is expected that workspace is completely ready to perform an operation, isn't it?
Update of keysSupplier field is not mutually exclusive...
Use type ChargeDTO in return responseEntity instead of ?
can this instead? return getNonNullRequestParamValues(paramName)[0]
Personal preference, feel free to ignore. When printing longs in situations like I prefer to look at hex over decimal.
this duplicates findEnclosingMethod on CipherBlockChainingCheck - should move to ExpressionsHelper or something similar
final :D
else if, just for consistency with the rest of the method structure?
Isn't this constant? Get and set this value once.
Gary, this test still doesn't pass for my Windows tail-wrapper: - By default > [message=tail: invalid option -- F, file=C:\Users\cleric\LOCALS~1\Temp\FileTailingMessageProducerTests\foo] - with --follow=name --retry -n 99999999 > org.junit.ComparisonFailure: > Expected :hello50 > Actual :8 - and through time: > java.io.FileNotFoundException: C:\Users\cleric\LOCALS~1\Temp\FileTailingMessageProducerTests\foo (Access Denied) How about just @Ignore it? There is no guarantee, that another Windows tail-tool will work differently...
This seems not being used, just deprecate it?
Move this call to the start of the method, since that's generally how it's done.
a small code style thing: the else clause is redundant. it could jut be if(forceAnsi) {return true}; return ansiEnabled && ansiSupported or simply return forceAnsi || (ansiEnabled && ansiSupported)
Typo specfied.
This map should be generified as well.
Should this be EVENTUAL?
nit: You can omit the explicit type args here in new HashMap<>.
resources is now just input. Remove the variable:  InputStream input = closer.register(targetFile.newInputStream());
No need to check if newText.length() == 0 then ... Additionally you are not checking if newText is a valid hex input but let Color.parseColor decide that for you. This leads to this interesting feature / bug: <LINK_0>
you're using the deprecated configuration API. Could you update it to use the new one? We're in the process of eradicating all usages of the old API. I already updated most other tests, so there are examples.
Any thoughts to checking client.isOpen()? I vaguely recall cases where that was an important check during system testing. It would be good to see any error behavior here be covered by unit tests so that we can verify the handling for these edge-cases that are hard to reproduce manually.
I guess XOR works but this is a logical test so I think a logic operator != is more appropriate suggestion assert permitAll != (rolesAllowed != null);
Use getOrDefault to preserve behaviour, rename to fromEnvironmentOrDefault.
expected and actual SQLs are now same, use simpler assertQuery overload
use getInstance().logError() instead of printStackTrace
rewrite: this.apolloEnabled = "true".equalsIgnoreCase(apolloFlag)
the action shouldn't fail if: the above & getParam().getDestHost == getVm().getDestHost()
magic number?
registerOn
Might be nice to have an overload which sets only groupId.
This constructor can also be private, I think.
I use Pagefactory with AjaxElementLocatorFactory for this.
bad styling - needs braces
I don't see a reason to use "Block" here, just pass this.
As it is INFO level that most end users will get to see in their main log, I would suggest to make it a bit more end user compatible, e.g. > Activated scripting support for ECMAScript We could add an additional debug log that then also lists all possible file extensions and mimetypes as well as the engine name itself.
adapted
Shouldn't we call super(conf, store, smallestReadPoint) instead?
nothing happens with activeScope, seems wrong...
Sorry, I didn't explain this well. Assert.state will do the if check for you as well, so we can remove that, too.
Since you are at it, can you please change this to long primitive type? :)
You should expect here only instances of type Long since you provided a separate method for other ints (integerEqual).
While this will do what you want it to do, note that Mistform Ultimus does not actually have the Changeling ability. This will generate incorrect rules text.
hell no
This is a code smell. You should have only one path to the super. Instead, call this(storagePoolId, null)
Shouldn't this also be called eventFloodRate?
This should check what was in the environment variable before returning true.
This breaks MySql in theory ... DefaultBeanLoader line 224
When you return inline mocks like this, you need to add the Mockito.clearInlinMocks() or else it won't be garbage collected.
I would rather simplify this to  final List<TestInfo> sortedTis = new ArrayList<>(testsForMutant);
Duplicate police, hands up! :police_car: Why not just do return !isAnyEmpty(css) at this method? Or return !isNoneEmpty(css) at isAnyEmpty() method? And the same for the methods isAnyBlank() and isNoneBlank()...
{ Guid idToRemove = nic.getId();
do we need a new instance of the selector each time selectExecutor is called ?
can't we use some standard format constant instead of this adhoc format?
Update this to using the public beginRecognizeContent API
I would do this instead: initialize(absoluteUri, contextPath, (initData != null && InitData.canBeCached(absoluteUri)) ? initData : null); IOW, no point in spending time on checking if the cache can be used if there's no initData provided.
I would call this something besides Dnd, it could be mistaken for Drag N Drop which has the same acronym.
lambda
What if get returns null? I think in that case rename should immediately return false.
Again, this should probably use the implementation from AbstractSet to ensure equals and hashCode are correct for Set.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 104-105. Do the same for the others.
Should probably not return false when len or offset is negative.
Can we use DataTools.parseInteger here to handle the NumberFormatException?
why the lazy? this will eventually always be called when build is called
Curious why you throw IllegalStateException in the other methods but not these?
If it's already suspended due to watermark then I think suspend should be a no-op (other than setting a user-suspended flag) - the actual suspend status of the channel should be (suspended by user | suspended due to watermark). IOW you can't override suspention due to connection count.
As mentioned above: Please filter out nulls and provide some unit tests to cover those cases.
What happens if I send both urls and tag?
Not related to this changes, but wondering if we need to construct ImmutableBytesWritable object. Can this method impl be reduced to:  return cell.getRowArray()[cell.getRowOffset()] != QueryConstants.SEPARATOR_BYTE;
Is this block still needed? because it was a workaround
here you may want to create a DMNContext actually from DMNRuntime instead
When you work with temp files, please use the java.io.File API. Use the function: File.createTempFile(prefix, suffix) and work with File tmpFile instead of String filename.
Return type should be changed to Iterator
Use <LINK_0> here. Way more robust.
Should removeReplica return a success boolean like addReplica?
again, I was wondering, what is the thinking behind making close() final, and process() non-final.
This is calling super.setAttribute() twice is that intentional?
Rename to setIfAbsent
requestDto.getBaseParam().setUserId(getLoginName());
The 'when' can be dropped from the log statement.
Print out the trash path.
If its needed to be cleared in init --force please do cleanup there too.
bufferList should not be null - you should throw a IllegalArgumentException
nit: annotations usually go on the line above, like with @Override
I am unsure about this one. Before this, we were returning a live stream, and after this we may be returning a closed stream.
It's not ideal to have this hardcoded, but then again we do the same for Cassandra
This causes a compiler warning because ApplicationContextProvider.getApplicationContext() is a static method. Perhaps it shouldn't be static - but I have run the application with this as a static call and it seems to work fine.
The rule speaks about code readability. I don't think readability of these methods are a problem. It's a rather bigger problem to call something "local" that is not local. As in local vs remote.
this should be synchronized as well
what happens if no questionnaire is found for the give id
Still a bit of code left over here from the old code, could you remove this?
See note in JQueryHelper. Needs a nullcheck if null is a possible return value of jQueryHelper.getFieldValue(selector).
I'm not sure about this change. Why get the plugin from the store when it's in the event?
I think we could avoid using the ternary operator since I could not find any other use case in the code base and it could be confusing at times
Want to use the property from TaskProperties instead of the default.
SQL 'like' is case sensitive
hardcoded string "id"
please avoid magic numbers - either add cmdEntity.hasEngineSessionSeqId() or add the -1 as constant in SSOSessionUtils (or to any other appropriate class) or static method to SSOSessionUtils.hasEngineSessionSeqId(sessId)
While *excessively* unlikely there is still the possibility of this producing a conflict. Perhaps we could get the current epoc time in milliseconds and use that number instead? Unless we are able to call this method more than once at the exact same time, it wont produce a collision from a data standpoint.
You should have an @AfterClass method that unsets this. Using @MockEJBStrategeyRule could save you the trouble, IIRC
why parallel stream?
Should this be a bundle message?
if (!templateOptions.getNetworks().isEmpty())?
The following avoids having to parse the format string and creating a temporary string. java String bitcoinUri = matcher.group(); outputBuffer.append("<a href=\"") .append(bitcoinUri) .append("\">") .append(bitcoinUri) .append("</a>");  Come to think of it. We also need to encode at least & in the href attribute.
I having three classes necessary? It made the code more difficult to read rather than the more obvious implementation. If we decided this had to work on OpenJDK and we wanted to use reflection (not convinced of that, myself), a static initializer could try to find the methods and leave them null if it can't. createStatement() could check for null and fail() if they are, or DTRT if they aren't. Then we don't need three classes - just one.
java return supportedProperties.stream() .filter(propertiesMap::containsKey) .findFirst() .map(propertiesMap::get) .orElse(null);
AppendLogs
I would say do an instanceof check and throw a meaningful exception.
Should throw a meaningful exception because it's not meant to be used in a context where snapshots would be needed.
Don't swallow exception.
Wrong method name in the error message.
Avoid duplicate code. Just call addOnSubscriptionsChangedListener(listener, listener.mExecutor).
same, pass the builder object in
This won't change the actual value. You'll need to set the actual field (or use the existing methods in Entity).
System.out? Booh!
Style inconsistency: space after if
this should stay in warn
getMainAst() I counted 4 invocations of this method, please extract to variable
Wrap or add a variable
I would error out here. A blacklisted algorithm should never be allowed for use.
I would prefer to use ConfigConstants.getConfigFolder().
Remove one ~is not a~
See StringUtil.isEmpty
Correct keyword order
Do we also support other kinds of view names? such as: Browse_items_Product$AndFamily_0.1.item
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Add if debug
suggestion annotation.maxCharsPerColumn(), annotation.ignoreTrailingAndLeadingWhitespace());
Change breaks equals contract, because equality doesn't take into account subclass names and this new hashCode does. To avoid that, use Objects.hash(AnchorVariableDemand.class.getName(), ...)
replace with return this == other;
you should also support \\Doctrine\\Common\\Persistence\\ObjectManager::getRepository for people getting the repository from the EntityManager
grafts should be volatile, and use a volatile safe pattern here: static State { final FileSnapshot snapshot; final Map... grafts; } private volatile State state; State s = state; if (s.isOutdated()) { s = loadGrafts(); state = s; } return s.grafts;
&&?
If there are a 1000 pipelines with 3 stages each (say), and a plugin wants to handle everything, won't this loop become slower and slower, because of the contains on a list, rather than a map? Might be worth checking the performance here.
I think this should use the full constructor  WebPage.newBuilder().build();;
you would want to check failureCount value here inside the if. If it is zero, you would want to return false. Otherwise we could miss a success.
instead of using addCanDoActionMessage and return false, you can use failCanDoAction method that does both.
remove toStirng
You probably want this to be a higher level - internally most things aren't logged at DEBUG. I realise that if a node is down this could cause a bit of spam, but INFO is probably okay.
Can use the String constructor with explicit Charset instead (Charset.forName("UTF-8") and remove the try-catch.
A little simpler to delegate to the new constructor.
I believe it's redundant binding.
mock
suggestion .withSystemErrorMessage("Failed to initialize 7-Zip: %s (%s)")
null check
Shouldn't be there a negation?
Was there an error coming out of this code?
Can we add remote? I assume that might add useful debug info.
where is the assert?
Is null a valid input value here at all?
What if you attached a new network to a nic? It won't have reportedConfiguration, but it is attached.
Please use a more normal looking address everywhere. e.g. <LINK_1> or <LINK_2>
Should this not be a double? <organisation
setName("Noop");
{] seems like a typo
Given this is on transactional path, keeping a list of scoreboards parallel to m_scoreboardContainers is good for performance.
random seems like an odd name. Something like rtp, randomtp, or randomteleport
why are you dividing by 1024 again here, when getFileSize() already does that? and the call to getFileSize below does not do that
Maybe we should add to this message that the limit was set on a topic and can be changed on it.
!pluginConfigurations.isEmpty() is the preferential way to do this.
do we need this clear() call? "toClean" is not used anymore.
Not sure what you mean.
HashCodeUtils hmmm, I see, this id used by the hash code.... Not sure where this calculation comes from to be honest, I have seen this in the old widgets, if HashCodeUtils.xxx(id) can be used it would be nice.
Please use English only for messages.
An empty string seems different than a collection with no items in it (which is what was returned before). Is this correct? It may account for why those JSON files are breaking.
throw exception instead?
invert if condition
Please use StringUtils.equals
The parameter needs to be 1 since the backup model node is one level below the cache
else branch is not needed
variable names shouldn't start with a capital letter
I would rather not put a number in the callback variable, something like: callbackIfTimeout
I really don't like this message in fact... "expected" does not make sense. I would prefer to have "This call can throw an exception" instead, and ideally, even the name of the exception!
Method calculate has 9 arguments (exceeds 4 allowed). Consider refactoring.
These 2 lines can be factored into 1: User user = Users.signIn(User.admin()). BTW, do we really need admin?
What if organizationDiscoveryIntervalMillis is less than 1000? Use MILLISECONDS instead
new echo server for every test or will a single one for all tests suffice? If a single one will suffice, then you could declare all variables used here as static and turn these two functions into @BeforeClass and @AfterClass
Shouldn't this be == 0?
log excepion also
You have got a factory that creates DefaultMultiFactorAuthenticationSupportingWebApplicationService objects, right? It needs to be passed into the factory, and from the factory down here.
I know this is a tiny thing, but the mis-match of UPPERCASE SQL and lowercase sql things is odd to me. I don't care about which one we use, but I feel like we should at least try to keep them consistent inside a single query ;)
Empty return isn't needed
I would call the new addNewModelElements directly
proxyPorts.stream().map(proxyPort -> "localhost:" + proxyPort).join("terracotta://", STRIPE_SEPARATOR) or something similar
chanelling Nils... spaces between ) and { and between if and (
raw type, needs <?>
First I would make intervalToIndexMap final and give it a size estimate in the constructor as you know how many elements it is going to have.
This should follow the normal exception handling path and let the caller handle the printing of the exception.
getValue needs only to be called once (nitpick):  return String.format("byte@0x%1$x=0x%2$x (%4$d)", Pointer.nativeValue(getPointer()), getValue());
Doesn't StringUtils.isNotBlank already compare for null?
This feels like it'll implode, let's see
just wondering...is it worth putting the rc == FMT check first for a short-circuiting efficiency improvement?
why is the compareAndSet() necessary? Why would this method be called more than once?
no need, you can simply use : if (destDomain.isBackup()) {
<LINK_0>
Suggest retaining untranslated strings and translating during rendering.
No need to check isEnable() here. Its checked in IdentityProviderManager before invoking the listener. That's the contract of the interface - to say whether the listener is enabled or not. Only UserOperationEventListeners we need to check this in the implementation because the method is not part of the interface contract. Its only there in the abstract class. This is because the interface was in kernel and we couldn't add the method in the kernel.
Selectors cannot be fetched from the database
Same here, not sure this construct buys us much.
Must be "replace"
Exception should be logged also for debugging purposes?
What if the session is closed remotely before the producer is able to close it? Won't closeLatch be uninitialised?
Labels must be externalized and internationalized (by creating a class which extends NLS and using a messages.properties)
useless cast from long to double.
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
I think LOGGER was legitimate in this case, because it is not related to slave logs
change this to TypeConstants.JAVA_LANG_RECORD
Looks like displayHeight is 0 when running in API 10. We'll still need to fall back to the original method of getting the height.
Why did you remove the stateData?
We use AssertJ library, our assertions look like assertThat(something).isEqualTo(expected)
%d%n, remove the copy and paste error.
Config file has GLUSTERFS storage enabled in 3.3, should this be changed here too?
Can this be part of the entity class instead? e.g. public static String PRIMARY_KEY_NAME = "googleId";
I don't think this change was intended.
This should be registered to the "standard" special paths, IMO.
Remove copypast
Since connectionStage is initialized with completedWithNull, this connectionStage == null check can be removed or checked against completedWithNull.
I wouldn't prefix with 'qe-' to make this shorter - the data-ouia prefix of attribute says it all - for use during testing.
you are ignoring the sync parameter. The recipients can be replaced with a single Address (it doesn't change since it is assigned in the constructor)
Point outside of image
nit: one liner: this.features = Objects.requireNonNull(features, "Provided features can not be null.");
Changes in 3 tests above don't seem relevant either.
Unnecessary
I am totally fine with this, but do you think it makes sense to just have all of our Resources return a common exception class with a code and a cause and then we could just switch on code instead of using instanceof?
why not to prefet it to return the value of the inner method ? so line 134-135 would look like: return failValidationCannotPlugPassthroughVnicNoSuitableVf (...); ?
Use a simple setter (notice that the setWaterLevelIncrementRatio doesn't have this side effect) and have either the AcceptorConfig set the default value, similar to how it sets 400 for Late Acceptance.
How does success/failure information get back to the callee?
The call to super() is superfluous and can be removed. The compiler will take care of this.
Isn't the offset the frequency of the cron job?
you can remove this line
Can we reorder this if-then-else? To:  if (StringUtils.isBlank(consoleProxyUrlDomain) { // Blank config, we use the proxy IP sb.append(proxyIpAddress); } else if (consoleProxyUrlDomain.startsWith("*")) { sb.append(proxyIpAddress.replaceAll("\\.", "-")); sb.append(consoleProxyUrlDomain.substring(1)); // skip the * } else { // Otherwise we assume a valid domain if config not blank sb.append(consoleProxyUrlDomain); }
A proper float epsilon should be used here. Flow-math has a value in GenericMath.java that can be used for this, just copy paste it.
Please not here. This is not a standard SWT table.
why zeros?
Why not : hostJobsInfo = (Map<String, Object>) temp;
Why is this necessary?
I would rename it to analyzedBefore => it's a project search, it doesn't make sense to search for project having been analyzed in the past : I would not put the "last" word
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
Now it can be simplified to Set<Set<SchedulingExecutionVertex>>.
would call it only 'buildImage' as the potential autopull of the base image is more an implementation detail.
@ankritisachan Correct.
The DefaultPluginManager was almost a "runtime view of/access to plugins". It didn't really know about plugin locations and the filesystem, till now. Are you sure you want it to know about that?
No space after ! (several other instances below)
scala.collection.JavaConversions -> JavaConversions
we shouldn't require the ?test param
I think this set of conditions is a bit hard to read, can you change it to something like: if (child != null && child.getExtractionType() == ExtractionType.MANY_TO_ONE) { return ExtractionType.MANY_TO_ONE; } else { return fn.getExtractionType(); }
why is this public?
getEmailAddress can return null.
Does this have to be after the above line? Seems like it may as well be right before. Or you could just check that the returned list is empty. Or you can do both.
The message is slightly confusing and should be "Contains duplicate CH profile:" (?)
check for null artifact before using?
Those functions are confusing because they may return null but under our assumption pdb should always has at least one segment. Maybe assert(entry != null) is more readable.
Thanks. will change it.
This doesn't have to be public. Just use default package access since only thee cache impl in this package has to see it.
nit: save Math.log(mLogBase)) as a constant since we need this frequently?
Since the method removeAppender(String) will have to internally call getLogger(String), what about changging to logger.appender(loggerName) to loger.removeAppender(appender)?
casting would be faster...
this returns the expression, you can combine this line and the next
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
remove this
is this even possible?
Do we need this to be public? I only saw it's being called in handleAuthentication.
Best make this private method.
assertNull ?
1. I would expected this kind of code to be in the parent component. 2. at first sight, it seems that the **BaseGridWidgetKeyboardHandler** may handle operation that happens on a *different* gridLayer (since the operations have it in the constructor) 3. as it is written, it is possible that the gridLayer used *is not* the one contained inside the gridPanel 4. it would be better to have this inside the gridPanel, since: it alter the gridPanel status; it must use a gridPanel' property; it is already done so for the other handler (addClickHandler)
Just minor Q - if you remember, from some last task, we updated the [ResourceType](<LINK_0> to add the bpmn-cm extension as well as the bpmn/bpmn2 already existing ones, you remember? Not even sure if you have the dependency available here, just asking because if the dependency is present, probably we can use the extensions defined on that type instead of using these constants (FormsMigrationConstants.BPMN2_EXTENSION, etc etc).
why did default change?
I don't think this is the reported issue; the problem is result.getReturnValue() can return null, which is not allowed by the handleResult contract.
Technically bind has exactly the free variables that are in the "toReplace" part. The inExpr can use varName, and nothing else.
Similarly to the static enum thing, I subjectively like to make enum constructors explicitly private even though there's no practical difference. Any particular rationale for this change?
Why Boolean, not boolean?
You should return the object returned by the saveAndFlush method here.
if there is no particular reason to make anything public then it should be private (or package-private in case)
Shouldn't this use one of the Guard methods?
remove "this."
nit: you can use Collections.emptyMap() here.
I think this doesn't need to be checked. CircuitBreakerRegistry create or get when you request a circuitbreaker. Therefore, it cannot be null, and it must be the same as the requested name.
prop: I would not add the client if it is already contained in the set.
with this change, the put order is not guaranteed any more. Let's say a sequence of put event: 1. put(1, 10) 2. put (2, 20) 3. put(1, 5) The 1st put fails at the 1st attempt and retry triggered. 2nd put succeed 3rd put succeed then the retry for the 1st put succeeds. Now the value for key 1 in the store is 10, while 5 is expected.
what about Collections.emptyList(); which don't need to create new instance
Maybe use Zlog so that we receive the error in Crashlytics? This might be too noisy tho :)
Could we please use field instead of f to be consistent with line below?
Why initial? Does 1 work? 1 should be the default (i.e. opaque) value of opacity.
Is there a reason we wouldn't fix this one also? Or is it not possible?
SpeedController not CustomSpeedController
Remove blank line.
This method and logic seems to assume that the list that's being passed in meets the following criteria: * The list is never smaller than previous invocations * The new warnings are at the end of list This is error-prone since it's hard to reason about that API and there's no way to protect against callers using it incorrectly. It's also unclear how this interacts with the clearWarnings method below. The fundamental issue is that this class keeps state (warningsSeen) associated with behavior that occurs outside of it. It'd be much cleaner to make it stateless and require callers to pass only the warnings that are new each time. Also, there may be bug lurking here. I don't think the list obtained from results.getWarnings() in the resultset loop satisfies the above constraints.
do we need a null check here?
remove
Remove whitespace
(nit) The wording of the exception may mislead some end users into thinking that they have forgot to do something when in fact this is an error on the developer's side. Instead, I would suggest something like "Predicates containing a NOT must be run through LogicalInverseRewriter." or similar.
Can we report this to the UI in a more UX way: I'm thinking about reporting an Info status to the databinding framework would be more user friendly
This would look more readable to me as return isGenotypeInTransition(g, transition) || is GenotypeInTransition(g, transition.complement()).
Should put a null object in the cache if the model was null. Otherwise repeated cache misses will result in going to file system again and again.
is it guaranteed this method is going to be called only once? IMHO it would be safer to perform clear on mockLocationProviders first
can it happen here that null is returned when current scene = null and project = null? can this be a problem?
This might throw NullPointerException. We don't want unnecessary crash if we can avoid.
Maybe it would be more robust to check just by IDs, to reduce possibility of bugs
I think a try-with-resources would be better, in case we raise an exception for instance.
This should either be a **protected/private/or default** constructor, and the **List** should be copied so the Pointer can't be modified outside of the class.  java this.refTokens = refTokens.clone();  as it is now, I could do this:  java Builder b = JSONPointer.builder().append("key1"); JSONPointer jp1 = b.build(); b.append("key2"); JSONPointer jp2 = b.build(); if(jp1.toString().equals(jp2.toString()){ throw new Exception("Oops, my pointers are sharing a backing array"); }
trace this one?
This api is deprecated. I would just rely on the onConnected callback which duplicates this logic anyhow.
**USB**
new ArrayList<>(numTrainingDataInstance);
Why not use constructor DRepresentationQuery.DRepresentationQuery(DRepresentation, Session) and directly call DRepresentationQuery.getRepresentationDescriptor()?
channelCount -> decodedBlocks.length for consistency with the next loop
Commons:Deletion_requests seems to be used multiple times throughout the code. Perhaps a there should be a constants file defining these strings.
Rather than catch the exception, you can add an annotation which tells JUnit to expect an exception and fail if it isn't thrown.
it would be better to wait for "Table properties" modal
@ikhvostenkov you shouldn't leave the parameter in the same line as ( if ) is not there. So this line should be more like:  PsLinkedin.parse( this.luserjson.fetch( new Href( "...
Windup/Discover/Java ?
Again: missed Math.abs() and {} arround procedure.appy(...).
you should use the getPropertyAsType method to get a Boolean <LINK_0>
You should agree with me that the casting here is a redundant silly work...
style nit: no braces here
It would be great if we could stick the messages to the original location that led to the creation of the forged method.
Please rename the setter and the datamember too
Warning: sometimes in the existing code there is a check of getModelAccessor() != null .
do all calls to this method are result of invalidation events? there can be also _local_ invalidations triggered after calling methods like imap#remove, imap#put?
It looks like, when the measurement system is changed, then this image is not updated. TourChart has a pref listener net.tourbook.ui.tourChart.TourChart.addPrefListeners() which already checks the measurement system, there the action image could be updated, access to the action is tourAction = _allTourChartActions.get(ACTION_ID_X_AXIS_DISTANCE);
nationkey % 17 = BIGINT '44' AND nationkey % 15 = BIGINT '43'
Given that this method is already dedicated to the issuer claim, calling String.format is redundant. Please rollback
line-break
Would it be make sense to add a sanity check that the key is >= than the previous lastFoundKey?
@ikhvostenkov why this?
... The whole point of ChunkGc being separate class was that the unloading logic was in that class. Now you moved it to CubeCache.
Let's use the old cleanUp method as I have modified it to support latest rest api calls. Sorry for the confusion.
This statement produces compiler warnings:  [INFO] [...] FruitDaoReactiveImpl__MapperGenerated.java uses unchecked or unsafe operations. [INFO] [...] Recompile with -Xlint:unchecked for details. ---  Would it be possible to extract the result to a local variable and annotate it with @SuppressWarnings("unchecked")? Alternatively, maybe we should consider annotating the whole class with @SuppressWarnings("all").
what if you query on a single timestamp.
The else statement could be removed.
Consider adding a timeout
I would prefer to use standard Java API instead and minimize dependencies usage when possible.
Do we want to lose the cause here?
I think it should be a static private field, for the sake of performance
I think assertEquals parameters are inversed
You will need null checks here. SystemSettings or Procedure can be null since minOccurs is 0 for those. If those are null, we need to use the default value of 10s.
This should not happened if there is not a bug but should we ensure that deferredRecordsSize is not less than 0 ?
Is coalesce(type, 'API') necessary given that there's a default on the column and all existing rows have been backfilled?
suggestion if (cmds().isEmpty()) {
@franz1981 I feel like you're the man to look into this... can you look into this one?
please replace this with return getUrlForWiki(wikiName) + wikiPath
Maybe extract the test string?
What happens if return null ? Is null valid? Shouldn't it be an exception?
similar
You can use return checkNotNull(Collections.EMPTY_LIST); The EMPTY_* static definitions do some sort of type inference, whereas the older .empty*() methods don't.
I think we should future-proof this by using equals instead of the != operator.
This could be instead be "[abc, bcd, cde]" with the changes I suggested
add some message info
I think the filter should be part of the TmfTraceContext. Please move it there.
Please implement as: java return IOUtils.readLines(in, StandardCharsets.UTF_8).stream().collect(Collectors.joining(System.lineSeparator()));  Also I think we should apply this for: org.drools.workbench.services.verifier.plugin.client.testutil.TestUtil#loadResource
Space after "enabled" please.
There should be an AppUrlTest class? I was looking for the test case that verifies the trimming of trailing slash but couldn't find it.
I mean there is no need to get a boxed Boolean either, Boolean.parseBoolean() is a direct equivalent which returns a primitive.
Same here. We should keep scopedObjects_ since scopeObjectsImpl would be weird.
Could have used ActionParameters#requireAdminUser(); Also could move the userService == null check from handleGet() to preProcess()
Checkstyle: ',' is not followed by whitespace. <review,layout
needs a newline before the }, see section 4.1.3 of the style guide. (The one-line style makes it harder to see where blocks begin/end, so it is not allowed).
UnsupportedOperationException is probably a better fit
Do you think creating a NoOpCheckpointHandler makes sense rather than have this null possibilities and null checks?
The name says "greaterThan" but the operator used is "less than"
It might be better to do assertThat(constraintViolations.isEmpty(), is(true) as the previous test uses this. Thoughts?
Inline method body to one line.
suggestion return apiVer.equals(sJsApiVersion);
This can return a short read. We should use a loop to try and get the full buffer length or EOF before we enter into the isBinary logic.
why do we need to care about the callback here?
It's time starting to use Spring build-in json converter
no need to collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)
Use String.format()?
keep field name
Add synchronized to this method
It is enough to clear caches just from one node, loop is not needed here.
Instead of returning false throw the errror
could we use overloading here for buildPropertyIsFilterType so that the method uses the DEFAULT_MATCH_CASE if it isn't specified?
String.valueOf(getTenant().getId()) ?
Brackets please - part of our code convention to always use them :-)
Should so much precision be lost at formatting time instead of during conversion?
Extraction to a separate method.
null check not needed with instanceof
throws RestApiException not necessary.
Please change es_inst to externalSerach. I know we have some "_" in our code but camelCase is a more common java convention.
Check for delta kind at first, then for equality of resources. It will be faster than this condition.
Perhaps break this up into 3 append calls, instead of creating an intermediate String.
I think the previous code returned [NoResultException](<LINK_0> and now returns null Is this what we want?
we want to verify that executeSQL is never called at all. The parameter I told you to use was wrong Please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean()); this way we ensure that the method is never called no matter the parameters.
nit: why call the method name data , instead of, say, joinBridgeAndLifecycle or getJoinBridgeAndLifecycle ? :)
vdsList cannot be null by the contract of the dao for fetching collections. Please replace with if (!vdsList.isEmpty())
this won't work if ... is specified after the parameterList
s/entity/entity's s/will be/are Sorry about the latter, just noticed this.
if (bytesAvailable >= count) looks simpler?
Even though this is a test, required fields should not be null. If this does not throw errors, it may well be a sign that the "required" fields are not properly enforced.
why? it should fail otherwise there's a bug here.
Hi @mernst, Thank you for your update to this PR. The new unit test indeed tests that the ctor does not blow on a null Charset but it does not test that the default Charset kicks in. Another update would be great.
Renamed segments -> segmentStore in next patch
redundant, class is @NNBD
I'm only mentioning this, because this kind of pattern is common in the parser (maybe it's not relevant here). In the parser when we have an attribute like "inInterface", which must be true inside of some context, then it's usually necessary to save the previous state and restore it. Like java boolean prevCtx = insideLazyExpression; insideLazyExpression = true; Expression result = super.visit(e); insideLazyExpression = prevCtx;  Otherwise you risk overwriting the "true" value if the bit was already set when entering the method. Now I don't know if nested lazy expressions are a thing in the saxon expression tree, but this may be a bug that comes up later to bite us
Nit: such casts don't always behave well at runtime and can hide some cryptic bugs. Although it's probably not an issue here, I would suggest rewriting it:  for (final Object key : tenantCache.getKeys()) { if (key != null && key.toString().endsWith("::" + tenantRecordId)) { ...
I think these can be supported if the booleans arte false
I think it would be much better to test the expected error message in the case when connector does not support this feature
Maybe an intent revealing name would be even better than setUp().
Why catching a generic Exception
if you want to support windows, use File.separator. You don't need a regex.
Isn't one method with a boolean parameter a better choice? Why create 2 methods? And why is the preference read in a UI class, shouldn't the clientUpdateService just read the property itself?
BTW, I thought it was only supported from version 12c in Oracle?
can we use a nodeId string that's not nodeId so that we know this actually gets rendered?
I think if you use -Ddocker.verbose=false then verbose logging should be disabled as well. Please add a check for "false", too.
Is it okay to aquire lock on each of every read of this property?
I'm not sure that using that much lines is required here. If it is, CG mandate the use of curly brace here: if body longer than one line.
nit: window and join are interesting not because of their identities, but because of their behavior; that they both depend on the "window" phase of the event loop. If there's an obvious name that captures this, it would be better. So, something like "hasTimedOperators" or something that captures the general behavior rather than the current known examples. If there is no such name in this case, feel free to ignore.
Typo here. Should be "owner is non-null but lacks an ID"?
/*error = */ null
What's the policy on curly braces in JFace? In EGit we would require them.
Mismatch count in the error message. You can leave the number out of our error message. It will automatically say expected 6 actual w/e
Can also add a getDriver() override that returns a cast of super.getDriver() to make this look neater
nit: session established -> session has been established
Please, let's put the sceneOpaqueFbo line after this line. And let's add a newline to separate it from the material-related lines, below. It somehow feels more related to the line above than the playerCamera.
why do you check if session != null? if you have engineSessionID you must create the session. request.getSession(true).setAttribute...
Reversed way? Managing connection should fire handle new session events.
I'd consider making new ListTablesOptions() a member variable so we don't have to allocate a new object to it for every call.
nit: make this final
move this method below getNextRecord so the class could be read top to bottom?
Does this risk that we only log the exception at debug and nowhere else? Or can we rely on the task that we did task.get() on having done a log.warn? Feels like we should report at more than just debug, but guessing that is already happening.
@paulodamaso the braces and return are not needed here
We could make this final and put current path assignment into else statement. @romani Would you prefer it this way?
Can use 8 space indentation here.
Is this not exactly string.replaceAll("^/|/$", "");?
I agree that this is the right thing to do. Thanks for catching this and fixing this. One concern I have is with the change of the exception type. I am not sure if changing it to ZkMarshallingError is the right thing to do because 1. ZkMarshallingError is usually thrown in and reserved for use in ZkSerializer implementations. 2. Changing Exception types may cause backward-compatibility issues. What do you think?
Maybe should check for >= 5.6.4 if [this](<LINK_0> is correct?
this is fragile for jenkins... could you make this code more flexible? what we use to do is create in the bean a constructor that get a map as parameter, so you manually instantiate with the value you want inside the map. and the original constructor, get the System.getProperties() as parameter to the next controller. so we avoid jenkins failures.
final?
Shouldn't it check if it returns a provisioning script file ?
If my consumer has had a service level set by a previous key, this will unset it if the next one is null/empty.  java if (!StringUtils.isBlank(serviceLevel)) { serviceLevelValidator.validate(toUpdate.getOwner(), serviceLevel); toUpdate.setServiceLevel(serviceLevel); }
I think we can use the @JvmOverloads annotation in the Aztec method in Kotlin to allow the Java side to call the method without the new extra parameter). Check out [this answer on SO](<LINK_0>
What happens when you try to add a channel twice? I think you should return an boolean to indicate success/failure here. Res: Done, a return type of boolean to indicate success or not
it is not cleat why you generate id here
Any reason to change value from 10 to 100?
What's the reason for defining this as three string literals?
shouldn't this be calling unbindConsumers?
Can remove else clause here.
Invert the condition in the if: suggestion if (hasTabsChanged) { setupTabs(); } else { if (viewPager.getOffscreenPageLimit() != tabsList.size()) { viewPager.setOffscreenPageLimit(tabsList.size()); } }
And I think using FINE would be enough.
you're not using the return value shouldn't it be... if (!super.equals(obj)) { return false }
You can use simple method "valueAsList".
nit: suggest "job id" and "filename" without capitalization
Rename var to instanceInZone? Then instanceInZone.getInstance(). reads a little more clearly?
Any reason not to do: this(replication, NULL_ID)?
Couldn't we request it in earlier time like in the phase of PS setup, and just check and wait here?
you should use the readFully[2] because the read[1] does not ensure that you read all length bytes. [1] <LINK_0>[], int, int) [2] <LINK_1>[], int, int)
add confirm dialog
This changes the state of the instance so that calling addNode would be illegal after this. Would it make sense to prevent that? Either by API or by adding a check in addNode?
since you are building this map in only one place (correct me if I am wrong please) then please use ImmutableSortedMap from guava. This way you are returning an unmodifiable version of the map
From @tvhung83 (extracted from <LINK_0> suggestion return Exec.newConfigSource() .set("guess_plugins", ImmutableList.of("jira")) .set("guess_sample_buffer_bytes", GUESS_BUFFER_SIZE);
Why does caching determine the behavior of the fetch? Why not handle the trimmed exception on the higher level. This seems like overloaded semantics to me.
could we change to List<Properties> or is this API fixed?
minor: Could make it Optional<Integer>
Is nt sorted always false here? can you remove the variable?
Since it's a query, use PublicContract.TRUCK_URI. The internal ones in the Contract class are only there b/c we can't do a write against a SQL view
the Bitmap config is also used below, it may be moved to the interface
delay is already completed; no need to wait :)
Need to ensure the offset inserted into the queue is increasing and equals to last message offset + 1 otherwise, poll logic will be impacted
Categories can be null here based on the old code.
so only the UTF-8 version will be supported? what about the version with the given charset name?
Why are we doing this conversion?
Is this change here necessary? It is new IOException, not logger.
This log statement I believe is also relevant when we're not sure if the connection from one client to a server is established. It is useful, I think we should leave it as INFO or DEBUG.
In the spirit of defensive programming, I think it would be easiest to have this reset() call to right before checkPacks. (Fewer hard-to-reproduce issues due to a caller leaving some state in the objChecker.)
Good idea , but this checking should IMO be moved to AppCredentials. The Os<X> classes should generally just expose the Os interface and then we do the mapping on the "upper" layer, i.e. AppCredentials
Individual conditions also must not be null. For that we should add a check with org.junit.platform.commons.util.Preconditions.containsNoNullElements(T[], Supplier<String>) in order to avoid a subsequent NullPointerException.
try-with-resources block instead of manual close
How about calling this(context, Type.LOADING_NON_CACHED); from here, making taskType final, and centralizing the initialization logic in one constructor?
suggestion return "entitlement";  By default SP translate attribute eduPersonEntitlement to entitlement and such name must match perun attribute friendly name.
Missing new line.
I think it would be more suitable to have a package-private constructor to inject the mock so we don't rely on reflection.
probably better to return List<GarbageCollectionStatus>?
Please don't hide any exception with logs... You could log the exception as well which would show callstack for debugging purpose...
Validate & assert call is repetitive, so this could be extracted to validateAndAssertFailure method
is this hyphen required?
I forget - will this automatically serialize and deserialize the fields of the DbxPKCEManager class? IIRC this approach has compat issues if you change the class on an update and this code tries to deserialize an old one. Better to be explicit and serialize any simple types, and then on deserialize call a constructor with them
I don't recall. @stustison could you weigh in?
nit: if 'builderLedgerId' is of type Long, then let the received arg type be Long instead of primitive long
Please remove.
properties is good enough for logs
This would be easier to read if collapsed
Your friend here is the Joda PeriodFormatter. You can tell it how a given format is structured, and then just call formatter.parsePeriod(timeString).toStandardDuration();. Have a look at <LINK_0> for more info.
As in places above, use  if (zone == null) { return null; } return createSecurityGroup(name, zone);  ?
IllegalArgumentException
should we rename access_type to token_type to better match the code?
would this be better as a clone method inside of RtpDescriptionPacketExtension?
The one below will be more brief:  java return Sponge.getRegistry().createBuilder(Builder.class);
We should use Guavas MoreObjects to generate toString() implementations like we have with other code.
log.trace
You may remove this.
Could we please use Objects.equals ?
should we be using getter method for metaDataStore incase we move the classes in different packages later ? Also do we require to add metaDataStore as private member here ?
@philsttr I've been giving this some further thought and I agree that we should make it easier for users to leverage an existing basic (default) implementation. So let's say we provide 2 implementations: SaveAuthorizedClientReactiveOAuth2AuthorizationSuccessHandler and RemoveAuthorizedClientReactiveOAuth2AuthorizationFailureHandler. Both would be public outer classes and therefore could be used by any requiring component. For example, DefaultReactiveOAuth2AuthorizedClientManager and AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager would instantiate both as their default handlers. A setter would be exposed for each handler but no getter. We could apply the same changes to ServerOAuth2AuthorizedClientExchangeFilterFunction as well. For SaveAuthorizedClientReactiveOAuth2AuthorizationSuccessHandler, we could provide 2 constructors - one that accepts ServerOAuth2AuthorizedClientRepository and the other that accepts ReactiveOAuth2AuthorizedClientService. What are your thoughts?
We check that request == currentRequest. This happens only for blockwise transfer. For block2 it's ok as this avoid to set context for each block2 request. For block1 this means that correlation context will only be set when the request will be completely sent. I think this is a problem. I think we want to set the correlation as soon as possible. Should we just avoid to call contextEstablished if correlation context is already set or just when it changed ? I mean in Exchange : java public void setCorrelationContext(final CorrelationContext ctx) { if (correlationContext != ctx) { // or correlationContext != null depending the behavior we want correlationContext = ctx; ExchangeObserver obs = this.observer; if (obs != null) { obs.contextEstablished(this); } } }
Did you consider using java.nio.file.FileSystem instead?
I think we should crash here by throwing IllegalArgumentException.
It might be cleaner to pass a type and not an instance. <LINK_0>
nickpicking - if you use 0.0 instead of 0, you'll save the promotion from int to double.
Do we really need MessageFormat? slf4j supports parametrized logging. (<LINK_0>
Casting to View before checking instanceof is highly suspicious
There's no need to use a regular expression here, nor remove whitespace; the parser will do that. return input.replace(",", " or ").replace("-", " not ");
Do you want to keep outputting ^^?
Maybe you could add a log message here to confirm the creation of the object.
This implements Java's comparable. Take a look at the flow/flow-math implementation (it can be found in the target generated source).
Don't return null. throw new ResourceNotFoundException() instead
With the change suggested above, this can be simplified to just throw ControllerLogger.ROOT_LOGGER.unsupportedCharset...
@droneboost what about the rotate field from MapStatus?
can you add some initial random delay. If not, every node during deployment will try to collect the stats at the same time.
Use a CamelKieConstants class declaring those headers. The convention is using *camel* case (of course :D) for the values. So CamelKieConstants.RESPONSE_TYPE --> "CamelKieResponseType".
No use doing this.game...
questionType is shown here, but in the test files, they show up as questiontype. I think we can go with data-questiontype here instead, to be consistent with the test files
This does not do what you believe it does :wink: Also, you need to take a copy when assigning it to the field during construction to protect against mutation from the object you received.
may want to consider making the "protocol" to be the first line to match params order
suggestion assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
Maybe use this((e, ctx) -> fn.apply(e)); instead?
I get an IDE warning suggesting this: suggestion return Collections.unmodifiableList(Collections.singletonList("<unistd.h>"));
I would eliminate the eventType variable, since it's only used once and doesn't add to readability.
Do I read this right, that we're doing the exact same thing twice?
I think it could be benefitial to have two overloads (jsonObject, jsonarray), very similar to what the sdk has
If distribution target is null, maybe makes sense not to emit this dimension at all.
Execute the search code system request synchronously on the current context.
Is this used anywhere?
why not throw t?
Please bring the braces back.
That's not best practice. We don't care if it's the same object.... This is just a boolean, we need to test for equality. Also you should use assertTrue...
Similar thing here: summary is not added to the end but is replacing the existing rows.
Could be an else if here as if we went into the if block LazyAvroCoder.threadSchemaSupplierFactory.get() will return null
assertEquals("int", bert.getTypeNameGenericsed()); what does sed stand for? GenericSeed or GenericSet?
It would be good to set to null the toolkit
transaction_time_zone
* style nit: move static method to beginning of the class * visibility can be reduced to private
what is the difference from this getconnection and other getconnections ?
Don't seems to send the latest patch set here !!
minor code style improvement: java Deadline deadline = Optional.ofNullable(Context.current().getDeadline()); if (useTimeout) { deadline = deadline.or(Deadline.after(requestTimeoutMs, TimeUnit.MILLISECONDS)); } return deadline;
Instance?
Style fix suggestion public void setIgnoredPlayerTimeout(IUser user, long time) {
Could we also test the case when the same report is mentioned in only typescript property?
Unfortunately this test is flaky. It will sometimes fail for the 1st time and almost always will fail for 2nd run.
Is null correct here? That seems weird...
won't this be a double-decrement?
With the exception of constructors, non-static inner classes and setters the this key word isn't usually needed.
May be this should go into the method which is actually doing the job. Also One log.info for the entire GC should be good enough; others may be downgraded to LOG.debug()?
Why is this returning null? Shouldn't it return the AzureLeaderElector ?
let's make a static util method to return the corresponding lock in the lock array based on block Id. e.g.,  private static ReentrantReadWriteLock getBlockLock(long blockId) { return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)] }  Then in both close and create, let's all use the util method rather than hardcode the same logic twice. In case we change the logic in the future, we only need to go one place
Is this to avoid the method being called more than once? If it is not an expected behavior, shouldn't we raise an exception?
I suggest a name to structure map to speed up lookup
I suggest to avoid the negation as there is anyway an else block.
Could we define 0 as a constant (e.g., RETRY_TIMEOUT_MS)?
expected value should always be the first parameter, and the actual value second, e.g. assertEquals("<p>_foo bar_</p>\n",html)
can we set as a constant?
If we're returning a new writable for each evaluation anyways, cannot we defer the wrapping to Hive by simple adjusting the return type, and return isPageview right away? Also ... if we're toString-ing everything anyways ... cannot we have String in the paramaters and let Hive do the work. (Not sure if that works, but for int and IntWritable it worked last time I tried)
perhaps "Offer was already..." or "Offer has already been..."
I don't think we should check if writing is permitted only if we actually detect that an update is necessary. Even if no upgrade is necessary that the system is in principle allowed to perform the write operation. Was moving this assert into the condition necessary to fix the issue?
Why the parameter here is query but it is milestoneQuery in the toggleMilestone method?
I think we should probably make this a protected method on AbstractBamFileIndex and implement it there for bai and here for CSI. Or we maybe make it abstract and pull out a common AbstractBaiFileIndex that is shared in common between the 2 bai implementations. It would let us clean up the constructor chain in AbstractBamFileIndex so there isn't any constructor you can call that won't validate the magic number.
This seems dangerous because it may impact many other test cases and introduce different behaviors depending on the order of execution of the tests. You probably should save the hooks that a re registered and reinstall them in an @After method
Isn't this wrong? It should either be attributes[attributes.length-1] (and overwrite the last entry in the array, which is probably equally wrong) or it should extend the array. The old code used a List so we could append an additional attribute to the end (Decision Tables support a "negate rule" attributed, Guided Rules do not).
Please add a new newLinkedHashMap method to our CollectionHelper. I'll work on pushing the changes we made in HV regarding the sizing. (With the current code, you always undersize the map)
How about a oneliner? return IntStream.range(0, NUM_OF_SNAPSHOTS_TO_CREATE).map(i -> createDiskSnapshot(diskId)).collect(Collectors.toList());
This breaks compatibility.
Can we make this method return a collection of Config.EncryptionLevel? I think it'll make code simpler - no need for ignored testName constructor argument and flat list of Config.EncryptionLevel can be returned.
in reviewing this we were concerned about the scenario where position legitimately throws an exception causing mark to remain un-updated. In this cas, due to the catch, it will lead to a silent error. There are several ways around this: 1. throw an unchecked exception instead 2. look at the specific exceptions thrown by current implementations and work with these 3. modify contract for position() to not throw, and simultaneously modify known implementations. if you have other solutions, please discuss.
Please indicate possible values in Exception message
Wouldn't it be more expressive in functional form? clusterFeatureDao.getSupportedFeaturesByClusterId(clusterId).stream() .filter(SupportedAdditionalClusterFeature::isEnabled) .filter(f -> f.getFeature().getName().equals(featureName)) .findAny() .isPresent();
Should this line assign the field instead of a local variable so the CSVConverter.getByteCount() method calls this instance of CountInputStream?
Nit: this can be a one line log.tracef("%s %s", this, satisfied);
as discussed, here we can just use the same high watermark as the low one - it will make the buffer's size more constant, instead of varying between 2 sizes. We can also get rid of the check of minimal number of lines we cant the buffer to be , since that check is already done in the preferences page.
This is missing an .in(Scopes.SINGLETON).
you handle all these exceptions in the same way so you can use multi-catch: } catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e) {
Never return null. Instead throw an exception, like: throw new OAuthException("Echo Api only supports two legged OAuth calls");
Shouldn't you shutdown the daemon thread before trying to stop the task threads?
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
We only need to log this if partition handling is enabled, else we will get a lot of warning spam I would think.
Then I would turn this in a one-liner.
the CDA messages of the extend won't be displayed in the CDA phase.
Intellij warns that 00 is octal. Shouldn't be a problem but maybe we can avoid the warnings by just writing a single 0
Passing null rather than exceptionHandler argument.
Should this still include the key's hashCode as well as adding the sequence hashCode?
Why is the useDelimiter("\\A") needed here? Or why not use the good old BufferedReader.readLine()?
looks like this is already called from within locks, so you might want to just mark it @GuardedBy(rwLock)
shouldn't it be according to the feature-supported?
Pls. use Collections.emptyList() instead.
remove map and put time
This logic doesn't seem right. What we want to support is running a particular check if its name was specified as a path token. This classes param should indicate the name of the path token to look for. If the token is present, we only render the check whose name matches.
If this returned an instance of Location, then presumably it could be automatically converted to json etc.
why not set these attributes on the command itself?
This return is redundant and should be removed
This test should check the specific number that applies to the test dataset, otherwise a wrong positive number could be returned and we wouldn't notice.
This log message is probably missing some context?
If treating as singleton (with static INSTANCE field etc), then should constructor be private?
I like this test, makes sure that a users data will not be dropped if they accidently init. After the init call, could make a call to Accumulo to ensure table still exist.
s/getInstance()/instance/ ?
style: static import GeometryType.GEOMETRY, GeometrySerde.serialize and GeometrySerde.deserialize
I wonder about this : this can become really tricky in case of parameterization with wildcard and raw type...
Path::of and also below
This method will always fail if the impl is not HttpCommandResult, but command result is not abstract and can be returned from the fwk. If someone uses this method in a completly valid context it will fail. I think that all the HTTPQuery/CommandResult could remain only on client side. And we could directly return the concrete type (HTTPXXXResult) from the KasperClient. And only when we really support other formats think about abstraction.
typo
suggestion ToolProvider.getSystemJavaCompiler() == null ? "Are you running a JRE instead of a JDK? The inline mock maker needs to be run on a JDK.\n" : "",
How about BooleanUtils.toBooleanObject()?
suggestion VirtualFile work = virtualFileSystem.resolve("/work");
was this for HTTP and HTTPS?
> Maybe we could just throw an exception instead. You can try to do it but I think it might be difficult with current classes hierarchy > Change the meaning of value from a plain user name to an ID (opaque to the user), in a location that is used in many places (even in the RuntimeDto). Makes sense. But I think using username there is a mistake that was done because of docs lack. @gazarenkov should be right person who knows what is supposed to be there. If user id then I think we should try to change it and run QA tests. I guess clients don't use it and everything will be OK :wink:
Assertion seems to be missing?
I wonder if the static methods should have been left as deprecated in case someone is still using those. But I don't know if there is ever such a case in application developer's code so probably this should be fine. Just another thing to mention in the list of breaking changes and that should be enough.
should we throw an error or atleast log this at info/error level.
@vbradnitski will be better to use Pattern.compile and then matches
I don't think we should escape on this level, we should explicitly escape title of a video when passing to a method, not in here. Let's move it to verifyVideoAdded(String videoTitle) in SpecialVideosPageObject
this.
Retrieving
Looks like the worst that could happen is that the values in the log message are not precise
We usually use a lambda expression rather than anonymous class.
Test data shows encoding issues. Possibly using .build(true) helps here (might have side effects)?
Aren't you decrementing the queuedQueries twice? First the query will get queued (queryQueued will get called), then the query will start running (queryStarted  gets called and decrements), then query will finish (queryStopped  will get called and decrements), right?
- this em still can be null - in that case I would not do the logic below. - please move the content of this method into the updateEmulatedMachines()
should assertOpenBlock(); here, and have a test that fails without it
Does this need to be initialized here and closed in the Coordinator? Would be better if a single class was responsible for the lifecycle of this object.
let's mark all of the ThreadBound methods as final, so long as nobody else is overriding them. The whole point of deriving from this class is to allow the base class to handle them, so why not make sure derived classes can't even accidentally override them :)
Could you use Strings.lenientFormat here?
Why are we returning the boxed Double?
Doesn't work without this line? -- it's already registered as a pre-result.
unrelated
I'd use equals to make it clear we don't care about identity semantics (readers won't have to verify the value that is being set), but it's fine either way java TRUE.equals(request.getAttributes().get(PRESERVE_AUTHORIZATION_KEY));
BTW, this is another potential NPE and "implicit statement" to rework.
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
This needs to also check if the individual components of the Pair are null, because whenever HttpRequestGenerator.buildNoAuthGenerator() is used to generate a request, it results in a call to CommCareApplication.buildHttpRequester() where the usernameAndPasswordToAuthWith parameter is of the form Pair<>(null, null)
Please revert these changes. While we build locally on Java 8, we target Java 6 and I would like to make sure it keeps compiling on these older jdks. Our Travis build sadly does not test on jdk 6 any longer as it was deprecated and broken in their containers :sob:
could you please change it to the lowest supported version now?
Do these need to be synchronized?
This should probably reject nulls unless you want to have the compareTo deal with them.
@jesuino it might be possible to have more than one editor opened at same time, so it's possible than more than one editor are going to get that event at same time. Aparently this shouldn't be an issue but I'd add a check to make sure that only the right editor is porcessing the layout component.
I know this was already like this, but it is weird we are dropping the view before creating. If the goal is to assert that it throws an exception, then we should assert on it, otherwise this is not doing anything.
Could not perform live snapshot due to error, VM will still be configured to t he new created snapshot: {}
If the function is allowed to return null, perhaps it is better to use Ints.tryParse instead of parseInt to avoid throwing an exception and return null instead.
I had to look at this for a couple minutes to realize that buildFsOptions is mutating the fsOptions. The .checkForScheme method doesn't return fsOptions or do anything else with it, so there isn't a need to assign.
Delete elements
This will incur a complexity of O(n). Would it make sense to work with a set/map to make that test?
similary
So this checks if it is delete or create action. However, you already did check it when you created the action. getValue(Action.SELECTED_KEY) will return you true if resource is assigned ( => this is delete action)
Sorry, null would be better: List<VDS> result = dao.getAllOfType(null);
This should be done using the EnumTranslator. For example, see VmGeneralModel - > updateProperties(). In addition, add the appropriate values to LocalizedEnums.java an LocalizedEnums.properties.
looks like this explicit cast was done to prevent overflow, hence I am not sure if it is safe to remove this cast same question for the other occurrences below
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
Invoking with null argument is an evil, please provide another method without arguments if it makes sense.
The logic here seems a little over complicated. Would iterating over the entrySet of the IntermediateResult and handle the Id and partitions array in another method simpler?
If I'm not mistaken, the visibility of this method can be restricted to package private
- GIven that JobRegistry really isn't an internal component and - The direction you'd like to take this functionality per the blog post associated with this Jira issue I'd say it makes sense to make it a first class citizen.
Any time you have a constructor or method which is private but called from a nested or enclosing class, the compiler has to produce a "fake" member with package-private access which calls the private member. Sometimes this process goes awry. Therefore it's usually better to make such members be package-private in the first place instead of private.
Any reason not to use TestUtils.tempFile?
@guiseco what's the Bundle args for here, since no arguments is being added to it?
If DeletionMeta is used outside DirectoryCleaner, I think it belongs in its own file.
this is not a correct behavior for a missing feature just leave the default implementation in such a case however getTicker is such a basic functionality I think we should implement it maybe I'll have time to help in the weekend
when you are calling validate during runtime. containsMacro("port") will still be true even and you wouldn't check port if its negative or not.
Is this a more appropriate place to call mMediationRewardedAdCallback.reportAdImpression()?
use Repository.isValidRefName(final String refName) to check if a given name is a valid branch name
The flow with nullable timingContext concerns a bit. It should not happen, but assuming it does, we are going to record effectively zeroed samples (since start and stop time would be mostly equal), which basically would screw / mess the metric. I would suggest to skip the record call in this case, or if we could, provide our own sample (since we know the time it took, timeInNS), what do you think?
format
The factory methods should be moved to DataManipulator and be renamed. E.g. DataManipulator.immutableOf instead of DataManipulator.Immutable.of. IMO it feels cleaner. Also applies to the mutable one.
I propose to deal with this in a new static method AsciiLineReader.from(InputStream is) and deprecate the constructor. This will be safer for the users of AsciiLineReader and will simplify the code here.
No need for 0L, 0 is enough.
suggestion // Minecraft client can take some time to switch protocols. // Sending the wrong disconnect packet whilst a protocol switch is in progress will crash it. // Delay 250ms to ensure that the protocol switch (if any) has definitely taken place. ch.getHandle().eventLoop().schedule( new Runnable()
Any reason not to include bypassRetry in the information with toString()?
Also remove these defaults if they don't apply to this provider.
Wouldn't Collections.emptyList() be better than creating a new list?
we should not use constants for these values. Better to have a method return value as otherwise everything have to be recompiled to pick up a possible change
I still see it.
Useless for two reasons: synchronizing on a field that changes doesn't do anything, and setting the value of something doesn't need to be synchronized (what matters for synchronizing is blocks of code that require the value to remain the same)
We don't really use final notation for local variables. I also think that this case might be shortened by moving value and actual value directly to assertEquals statement - exactly as in the method above
I think this white line can be removed.
Should you verify that the management node operation was called?
same as above. Use getAndSet(boolean)
Collections.singletonMap("dist", base) is better.
Might be more clear to just reimplement this without using Closeables... it's not gonna be a very long function.
Use @Slf4j in lombok.
Somehow it should be initialized by ancestor generic resolver (method or class)
If calling shutdown() rather than shutdownNow(), then previously submitted tasks will be executed. Is that wanted here? Should it call executor.awaitTermination()? I suspect probably not; not sure what synchronization it'll have with this call to stop() so blocking for those other methods to complete might cause problems...
I would inizialize this in the declaration and make it final.
Rather than having methods to modify createdAt and updatedAt, would it be possible to modify their JSON representation here instead? This would avoid having methods solely for the sake of testing in production.
java.net.HttpURLConnection.HTTP_NOT_FOUND could be used
This can be a static member of the class.
requireNonNull
I think its better we throw a unsupportedOperationException here.
Use a significant name.
i think you need to pass the SERVER_ID which you want to update the status.
this should get called at the time of deserialization. Use jackson properties to call this at the time of deserialization. CertificateProperties does it as an examples.
nit: can't you just return rm unconditionally?
Add full link please <LINK_0>
why we need to change this?
You can remove the explicit type argument. It's unnecessary. Thus the new code is new ArrayList<>(); < layout
This creates a Properties table. Copy'n'paste? ;-)
snappy?
license?
What might we be ignoring here? Debug?
this looks like a static method.
Exception is never thrown
typo: "not a join stream" Actually, this sentence is incorrect: "Parent ... must not be null, or not join stream." implies "parent is not a join stream", while it should be "this is not a join stream" Suggestion "The stream (" + this + ") must have a parent (null), unless it's a join stream."
return (splitTime > fTime ? new TimeEvent(fEntry, fTime, Math.min(fDuration, splitTime - fTime)) : null); }
This could be protected (more an internal detail than for external consumption.)
I don't think we have conventions around this, but this. is used inconsistently here to reference member variables. (ie. partitionManager doesn't have this). I'd prefer it without this. if there aren't any conflicting local variables (makes it more succinct), but I won't lose sleep if this change isn't in.
As the RSDL is useful in many context I think that it deserves a class to manage it. Would do you agree to add a RSDLManager class? Something like this: public class BackendRSDLManager { private RSDL rsdl = ...; public static RSDL getRSDL() { return rsdl; } } We can then put in this class all the specifics of building the RSDL for the backend, and avoid the loop below when looking it up. We could also reuse this class in other places where we need the RSDL.
Please add "this." to numStreams, indexInStream, numberOfValues to be consistent for all the fields.
This block is the same as updateAssignment; can you just call that?
This adds nothing.
How about  return INT_TO_VERSION.get(asInt - 1);
I think we can still leave this as max index -1, as we would only have one snapshot id here.
Please use brackets, even for one-line blocks
Out of curiosity, what was this actually doing before when UPDATE et al were passed? What was the cursor?
These debug statements should either be changed to trace or removed.
suggestion "32767," +
I'll kick off the review then. It's better to have these protected, since templates should report whether they support forShare or not
Can't we rely here just only on the MessageHeaders.<T> T get(Object key, Class<T> type) ? Right, that one is about IllegalArgumentException, but at least we will be consistent with regular MessageHeaders usage.
{}
it is better to either throw an exception or return Optional for such case. I see no good handling for null values in invocations of getFirstChildOfType method
I really don't want to be nitpicking, but to mitigate false positives I would add there also .isInstanceOf(IllegalArgumentException.class) and possibly even .hasMessage("Runtime exception occurred") or .hasMessageContaining(...) EDIT: It is also possible to enclose in lambda just a call to workingMemory.startProcess(PROCESS_ID);
I think we should add the LEFT JOIN FETCH for contact methods and home_address for all of these impacted *.jdbc classes with an HQL query. By not doing so, each of these queries becomes N \* M separate queries where N is the number of staff instances returned and M is the number of attributes on the class that have to be joined from another table (contact methods and address in the case of Person).
Where is this stream closed again?
Should we perhaps call node.dispose() here?
a candidate for runMultipleQueries? I'm not an expert on that... maybe you've chained them for a reason
nit: Is there a reason to change this from null? I find null to be more intuitive (in java) to represent no string, rather than a present string that is empty
I wonder whether this could be simplified with Util.fixNull(andTrim) or what they're called.
what about just using Arrays.asList() here? No reason (at least none that I can think of) for the resulting list to be mutable.
the variable is not required
Please change this loop to do { ... } while(). It is strange to see node != null after node.getLineNo().
Permission. -> "Permission denied."
I am finding it hard to follow the code here. What was an example value for redirect before and after this change?
remove whitespace
bernouliMatrix should have the same # rows and # columns with the input matrix. More precisley, it should have "the number of outputs of preceding FullyConnectedLayer" rows \* "the number of columns of input (the number of data instances in one batch)" columns. Number of rows and columns are **NOT** same with inputHeight & inputWidth.
Instead of asserting not null, let's better just check if the image we're interested in is in the list.
Should this still set response = FAILURE? Seems like an important logical change
optional: it would be clearer to assign directly 'agent = cap.substring(...)' since that makes it more obvious what's happening (setAgent can't be overridden since the class is final, but it's even better to not have to check).
You expect no response key but in StorageDeviceListReturnForXmlRpc you look for 'deviceInfo'. Please be sure that vdsm sends properly build dictionary.
Why check for NumberFormatException removed ?
Since you use builders and you may not want to have external code create new entries, just use the content, you can make the constructor private or protected.
These asserts will only work on debug builds, can we put in a different check?
return results == null ? Collections.emptyMap() : results;? The same for exceptions()
Maybe just set this as this.urn = "java:" + clazz.getName() then you dont need the transient java type
The meaning of this info log seems to be not clear, shall we please review grammar?
Magic number
Do we want to .trim() the 2 parts to avoid possible problems if an Authorization header comes like <key> : <signature> ?
Perhaps return boolean to say if the id was found (similar semantics to Set.remove)?
could change the name to sdbgLauncher
do we need to check doesTemplateExist(cruiseConfig) as at the controller we are doing a load_template before destroy Same check doing twice
I think it should return Array here.
suggestion Objects.requireNonNull(elementType, "List element type cannot be null");
That can't compile anymore.
to be consistent we should introduce constant for kie-deployment-descriptor.xml and possibly also use it in the tests
empty() instead of EMPTY for consistency.
String tableId
the entity should be VM (VAR__TYPE__VM)
Redundant, the call to this(vdsId, bondName, network, nics) already handles it
Can be shortened to if previous != visible
It's not *being* re-run, it needs to be rerun
One of the coding styles we try to adhere to is to always use braces for conditional bodies. Though more verbose it makes it easier to add else statements and is consistent with the rest of the codebase
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
nit: ... only once
if (um != null) { Framework.doPrivileged(() -> createUsersAndGroups(um)); }
String rule = ruleText; if (rule.startsWith("%") rule = substring(1); if (rule.endsWith("%") rule = substring(0, rule.length() - 1); return rule;
please limit the visibility of the constructor
How about using File.createTempFile() here? You can also combine that with File.deleteOnExit()
Do not return null, use Optional
this should be before the callback I think
why do you get the session here? move into condition where you actually use them.
Why not just this.gender = student.gender?
I know we already reached an agreement not to keep the old method signature, but let's double check - users shouldn't be extending this class, right? Should we still try to make this backward-compatible in case users are using this public method?
This breaks the public API of HttpMessage. But in this case, we have to break the API so that the returned value is able to represent the query parameter content regarding its specification. Nevertheless, I'd recommend to go wit a Map<String, Collection<String>> to keep the guava stuff internal and have an java standard conform interface to the outer world.
Better use #getDescriptorOrDie() that would throw an exception.
There are still a lot of calls to this method, resulting in errors that will not reference any BPMN element. From a quick look, many of those do have an element id that we could reference.
This will blow up the entire read. With Smallrye I believe if a Metric throws an exception it is caught and logged but the loop reading all the metrics continues, so other metrics get reported. A failure here though will abort the PrometheusExporter loop. Since you are providing an Optional it seems like this could log the failure and fall through.
this means a single "-1" will close this listener -> messages from other workers will be ignore -> test failure
Since we already synchronized on it, maybe should just as well put assignmentFailureWindow.putAll(this.assignmentFailures); inside the block and then it doesn't need to be a concurrentHashMap. To reduce two synchronization mechanisms to one
Can you remove this?
Should we log errors?
It's probably better to check variable for null before calling this method.
Fix this method with the prefix.
spaces before and after - you can use Ctrl+Shift+F to auto-format the selection (or the whole file if there is no selection)
if we compile the pattern we should also store it in a hashmap. otherwise dont compile it (costs more resources, but if we dont reuse it we do not have any advantages by it...)
or just call ignoreFailure(true) for consistency?
Won't this method modify fName, which is a string builder, so that whenever this is called it will just be appended to? You'll get name_prefix_firsttime_secondtime_thirdtime, or am I mistaken? I think you should either make a copy of fName, or simply start over and not keep it.
nit: this should be a different test, right? Something like versionDoesNotUpdateIfSupplierIsNotCalled
constant ?
Yeah I think it's fine
This code would have to keep being updated every time there is a newer version of the library. Would it be possible to improve this so that it could be a bit more dynamic and future-proof?
We should do these in a directory other than the system temp directory.
Instead of 'INVALID_NETWORK_FILTER_ID' you should pass null.
let's do it using lambda approach
If there is no slash then start index is -1 and then I think we should make it more clear that we dont substring it then, eg if (startIndex != -1) { .. } else { // no directory then return file as-is return path; }
@Gaurav-Deshkar having hibernate in the service layer instead of the data access layer does not look sweet. :) Can you point me to a failing unit test and i see if i can make some alternative suggestions?
We should not need to call this, the OptionsParamCertificate already enables the certificate.
Nit: Outside of helix-core module, we should try to use ZkClient instead of BaseDataAccessor.
Please move menu into arguments
should be "valid" instead of "valide". Should use NLS.bind() to construct the message.
Use getAndRemoveParameter(parameters, "xxx") instead which comes OOTB
Can we leave List<String> as return type ? All the other methods in RunImageConfiguration return a List for collections, and also it is not the most generic type which can be used here, I would like to keep it uniform.
remove validation on client
you will have different errors for different api versions, i spent a lot of time in this place
Every time we call getUsageRefresherListener(), it instantiates a new StorageUsageRefresher.Listener, is this intended?
Why is the assertTrueAllTheTime used? Isn't it sufficient to use a single check instead of 5 checks with 1s delay between them?
please replace with StringUtils.isNotBlank()
No need to change savings_account_submitted_for_approval to savings_account_submitted because there is two type of saving account submission. 1. Submitting Saving for creating a new one. 2. Submitting for approval.
I'm a bit concerned about this. In order not to flood - let's just remove this enum constant at all?
I'm not sure about this IF block. Why do we need it? Can we just store only the fboName and then get the fbo itself only when we need it?
This is a bit double negativey Wouldn't  if (cryptoEnablePgpInline) { ComposeCryptoStatus .... } else { return false; }  be more readable.
wrong return type in cacheMode(), transactional() and lockingMode() methods.
here is where appendToUrl method should be used
!StringUtil.isEmtpy(typeName) could be a better choice.
This means that we can't build interfaces with builders right?
nit: According to l.403, you want to use comma to seperate every fields. So, it seems like you lost a comma here, do you want to unify the format?
I guess we don't need to put "String" before this variable, maybe cuz it's already assigned? I put "String" in front of it when I used it but I noticed no one else had done that. I donno, could this mean it's updating a global variable that's going to mess things up in further tests? Just guessing here.
update index counter?
You can join the ifs. There's a content assist for that, it's awesome.
Should the new constant be used here?
Thank you for so fast turnaround @neetkee ! Well, this assertNotNull() must be first any way. Otherwise we end up with NPE already on a first binding.getExchange(). Please, fix that together with your name to the @author list and update for Copyright to the current year - 2002-2017. After that we will merge it.
Might be better to have a check for not null as first thing in this method.
if
Remove space.
@pettyjamesm why is this call needed?
Please throw an exception rather than returning if the chat color is not found.
This needs to return a completable future, not null
no need explicitly open transaction, only one save to DB, transaction will be open automaticly
This name looks more as some internal method name than test name, I suggest renaming it to something like activeRequestsTest or something similar.
Why is while used here?
please remove this statement or enhance it to something more context/meaningful
Not the only reason why we could get an exception here. I'd reword this to just "Failed to read time zone id file.".
just as a hint: we also have assertNoNull
This is a tiny micro-optimization but I'll mention it since it might add to readability: Sets.newHashSet(s.split(",")
@SrinivasanTarget I would like to advive you to  java assertTrue(!StringUtils.isBlank(driver.switchTo().alert().getText()));  What if the empty string would be returned? :)
Do we want + "/*_/_.xml" here instead?
Missed this one in the previous review, needs updating as well!
else empty ?
please use hamcrest matchers
NPE should not be catched btu the case where it might appear should be checked with if (smth != null). We definetely don't want to ignore every NPE.
shouldn't we use Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, as both Math.round() and ROUND() with 1 parameter returns bigint?
Can you use InstanceConstants.CONTAINER_LIKE?
Is there a need to check the action for null?
requireNonNull
Why create a variable for this?
Why didnt you prefix this with shadow like you did everywhere else?
I think flipping the key (string) and the function params for "read*" methods would make their usage more readable.
Is it an issue that in case the decorator fails (i.e. exception thrown in onError) that we never gonna call span.finish()?
I'd personally do a 'timeToNextRotate' method, then you don't need the +1 each time, but that's just me nitpicking
SOUT ;) ...and my question if this try/catch here is needed? If yes can we move this logic from test side?
@dogeared Rather than doing Authentication authentication = new PreAuthenticatedAuthenticationToken(account.getEmail(), null, authenticationProvider.getGrantedAuthorities(account) you should do  Authentication authentication = new PreAuthenticatedAuthenticationToken(account.getEmail(), null, account); authentication = authenticationProvider.authenticate(authentication);  this way you leave all the responsibility of how to populate roles and granted authorities to StormpathAuthenticationProvider. Otherwise, if in the future the Provider needs to do new things to authenticated tokens then this code will need to change as well. You are basically duplicating the responsibility of providing granted authorities here. Furthermore, the authenticationProvider.getGrantedAuthorities(Account) method is protected and you are only been able to invoke it because this class is in the same package. But it is not actually intended to be called from outside the class.
I think the reason this doesn't sync over to the model is that setValue doesn't fire events by default. Does it work with .setValue(sourceOnSave, true)?
Seems like an extraneous line to me?
Can this move to AbstractControllerService? It would be nice if the clear() method wasn't public.
Javapoet is a Java 8 project, so we might be able to use the linebreak matcher \\R instead.
The result variable should named as result
instead of an empty ArrayList, I would use Collections.emptyList().
possible NPE
We should also check if the xml file is the current app. i.e. check if the filename starts with DevMojo.this.project.getArtifactId()
We do not use single line if-statements throughout the project. Yes it's a nitty point, but I'd prefer you change it to curly braces.
methods? this check is only about fields.
start argument is not actually used. Is it meant to be?
I would prefer this to use Utils.isHammer(ItemStack), however you will need to check the ctx to be EntitySelectionContext and then retrieve the MAIN_HAND item of the entity involved. That is more complex, but our utility method should be used whereever possible, so that if our logic for detecting a hammer changes (currently using tool classes, may allow tags in the future), we only have to change it in one place.
It will cause onTracksChanged to be called twice. L1187 of MediaControllerImplBase (in the same patch set) might be enough.
Can't we throw something more reasonable? Also, I'd add a log here.
I don't know if they should be put inside this method or not. Should temp table be considered as staging directories?
Minor: Use Study.create() instead of new DynamoStudy()
Should we check that the attribute does not already exist on the updateMetacard before setting it?
It would be nice to rethrow some trace of e when check fails like  catch (PrestoException e) { try { ... the checcks ... } catch (Throwable failure) { failure.addSuppressed(e); throw e; }
You can use the size of the referenced mappers as initial size of the list
could be simplified.
perhaps use startsWith to match <LINK_0> ?
if there is an IOexception or any other problem copying the files the folder will be still deleted. there also should be some information for the user if there is a problem importing certain projects, and they should not be deleted if import was not working.
Since this is inside the same class, I think just "super(FLOAT_SIZE_IN_BYTES)" should work;
Two important things: - do not use absolute paths - never use / or \ in paths use Paths.get(...) instead or File.separator  java // replace "./foo/bar" with Path p = Paths.get("foo", "bar") // or String s = "foo" + File.separator + "bar"
Why not make the whole class final?
handle DuplicateKeyException
I still don't think this should be a fatal error _for the producer_. As long as we can still abort the transaction, it should be an abortable error. It's similar to the handling of GROUP_AUTHORIZATION_FAILED.
maybe rename the variable from _mesosStormScheduler to _stormScheduler?
you can use method getUrlForWiki (so you don't need to add empty string for article path)
nit: switch statement would be more natural here  switch (withNulls) { case ALL: return NULL_VALUES; case PARTIAL: return IntStream.range(0, ROWS).mapToObj(i -> i % 2 == 0 ? createValue() : null).collect(toList()); default: return IntStream.range(0, ROWS).mapToObj(i -> createValue()).collect(toList()); }
I don't think you meant to change this to NOTIFICATION_APPROVED, unless I'm missing something.
What about other error messages from server side (like 404, 500, ...) ?
formatting error.
import static Assert.assertEquals()
create the map here only when needed
It says "cb.id" but I don't think "cb" is anything in this query. So I think either change the HQL or if the code is not being called maybe we don't need this method?
Needs quote escaping
Another good candidate for computeIfAbsent.
I believe it should be moved to Test file
Do we need this anymore? Can't we just send back the empty string as a default?
Do we have positive parsing tests to ensure that all arguments are parsed well? As well as tests that ensure the wrong argument types are handled gracefully?
Need braces around statement as per the style guide
we can throw a exception here rather than return null
I think it would be nicer if the header extraction was implicit, i.e. it magically happens when you call addRowsFrom  and you do not need to manually extract the header with a call to TsvFileParser.parseHeader. This would make it simpler for users and remove a method from the public API. Yes, it may require a reworking of the insertInto implementation, but I find the following sequence a bit clunky and unnecessary: String[] header = parser.parseHeader(dataFile); ... .withColumns(header) The insertInto should be able to figure out the columns from the parser.
feedback session's course ID -> feedback question?
spaces before and after "+" (i think it's my favourite thing :P)
use optQuarkRelative and the use and if (attributeQuark != ITmfStateSystem.INVALID_ATTRIBUTE). It's better than relying on exception handling for normal cases.
We should chat about this return type...Please file a github issue so that it may be part of a post-preview 1 API review discussion.
Maybe just change it to this.interrupt(), since we're not overwriting it.
In the current version of the code, the result is reported regardless of which branch is taken here. I recommend you keep the semantics consistent and move the call to onResult here rather than in the if branch.
This method should be static and static methods typically go at the bottom of the class.
this.m_
Same here. Pattern can be static to the class.
StringFormat
We should explain in a message that signed isn't supported.
Why calling concat here? I would worry this would prevent StringBuilder optimization for +'s.
Hardcoded, this should be done in a better way. <bug
Not that exhaustive that 'a' is the right password.
missing uninstall "ws.jar" bundle code
You should externalize the string
Not required unless for test.
Same as before. Unnecessary extra operations for minimal gain.
You made this projected, but never call it outside of this class. It should remain private.
variable name should be currentapiVersion
Why we still need field "presenter" if you use Provider ?
The user can call getAccessToken()
seems like the formatter did not format these line, please apply it
I'd like to raise this point again: Since we changed the nature of composeObjectId to be static, we need to access AuditLogDirector statically. This is unwelcome and could be spared by injecting AuditLogDirector in order to use its methods.
I thought we did not have the processDefinitionId in the extensions json I thought we had only the process definition key in the extensions json And that's why yesterday in this class we tried to look up by key(and not by id like in the past) What am i missing?
Map should not be static. There us only single instance of JsonRpcServer so we can pass it around and call instance methods.
no no! There can be ANY exception. And since we're not using transactions here, we *need* to do db cleanup in case of failure and if we fail doing so we'd miss one VF, there probably should even be Throwable instead of Exception, because Errors can happen in our app as well. And in that case, normally, transaction would be reverted, be as we not have one, we should respond to that state...
Why is this 30 seconds buffer added?
This must be based on plugins capabilities instead of version 2.0 ?
?grant_type=authorization_code looks redundant It's standard OAuth2 param, it will be added here <LINK_0>
is details
Drop this change, I think. We have already peeked at the type. Why throw it away and peek again?
this and m_
The return value is never used.
suggestion assertThat(got).contains("Description");
Without a toString() implementation the reference to the handler isn't that user-friendly; I would instead suggest to use untypedResponseMessageHeaders.getTargetRestEndpointURL. Something along the lines of The handler for the url ({}) was already closed, but another attempt at closing it was made.
@anki2189 pls add a @Transactional annotation here and below as well.
:pencil2: Inline metadataReader
Hi @jsoltes you can use Assert#assertNotNull(java.lang.Object) method here.
Can't we save off the arguments here as well so they don't even need to configure the arguments call?
This logic has been used in different methods of this file. Perhaps we could create a private method, that handles that logic.
why a new String() here?
@fabriciofx This method is not defined in any interface, and I think that we don't need it: we should use cactoos' TeeInput to write it to any Output source. You can safely remove this guy
you can use sagaType.isInstance(...) instead.
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
No need to put __TS if there is only one case in the method as the method name can describe the case. Check other methods and remove them.
this map is private, static and intended to be immutable. don't change it!
Maybe we could use [Collections#emptyList](<LINK_0> here? > Returns the empty list (immutable).
Do we need to run it sequentially? Can we use stream API?
Add null-check for method parameter.
how would this parse data?
Please add to this method the check for the cluster feature compatibility: return isHotPlugSupported() && osRepository.hasNicHotplugSupport(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());
It's not a tree node.
can be private, and I think this would make it clearer what the interface is given all these proxy methods
Should we care about mutability of the map?
Unmap should not generate an error.
I'd at least use a constant instead of that hardcoded 16.
Can you use mInitialsListView and others defined in the init method?
<LINK_0>
Can we use constant instead of -1, e.g. IsoDomainListSyncronizer.SIZE_IS_NOT_AVAILABLE? Probably means that the constant should live elsewhere so both classes can us it.
I bet we should add some restrictions here as * or whitespace is not allowed as well.
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To submit changes you need 'Submit' rights on " + REF_CONFIG"."
We need this to return epoch in milliseconds (java Date interpretation) and not unix epoch (in seconds), so GUI will interpret this correctly. Try it like this: genEndTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli(); with all getters.
Negation missing? if (!cluster.isSetRequiredSwitchType()) {
Should this be using azureResponse now instead of creating another response instance inline?
please reuse the code in AbstractVmPopupWidget somehow. I guess that it will change here/there we'll forget the other one.
I'd be consistent with the naming of objc-module-overlay.yaml and name this testing-overlay.yaml.
What happens if status is false? I think we should set isLeader state to false, irrespective of whether release was successful or not.
In the event the client is trying to initiate an AIA, but is not permitted to do so an error page should be displayed rather than redirecting back to the app
Please use org.wildfly.extension.microprofile.opentracing.SubsystemDefinition#MICROPROFILE_CONFIG_CAPABILITY_NAME instead and make it public.
Why catching Exception here? Do not forget <LINK_0> :)
There may be a race if a user deletes this file manually - should we handle such cases as regular IO exceptions rather than assertions?
this endpoint needs to consume the whole stream in order to test properly
Do we need to null check mAlign here?
I think it should be viewmodel's responsibility not to return null, so this check should be moved there and here you should just call viewModel.getDate();
why waste time whitelisting it?
please use for the negative tests the following convention: assertThat(validator.validateStatusForActivation(), failsWith( VdcBllMessages.VDS_ALREADY_UP));
I understand the isOpen issue, but why you removed this.target = null; ?
We should be able to use slice.getInt(0) here.
Call its own method like ZkClient to reduce maintenance effort.
use getAddress to get a byte array instead - prevents the confusion on the other end that maybe the string is a host name and maybe it's an ip addr.
It is not clear to me why you are not passing the SSL context to the constructor. *(even of the test pass in my environment, it looks odd to me..)
You have not changed to use CommonUtils.loadResource() as requested. I still think it is rather important to do so.
Remove the modifier to make the constructor package private, and remove the null check.
Should we keep this void method if there's another clickUndeleteLinkInBannerNotification method returning SpecialRestorePageObject ? Also name could be a bit more precise ;)
instead of returning null please use throw UnsupportedOperationException("MkFork#json()")
A notifyDataSetChanged() call is made in LoadSitesTask.onPostExecute from loadSites() just below this line. We can remove this since it's redundant.
Add the following cleanup here:  functions.clear(); methods.clear();  "functions" because you forgot to clean it somewhere. "methods" it's a corner case, but in case of exception, we could enter in "visitCompilationUnit" in a dirty state.
This should use an actual Charset rather than just a string identifier. Similar throughout.
System.out.println(String.format("Find by footer locators: %s", locators));
This parameter shouldn't be necessary, now that we have split the variants and the header loading. This applies to the instantiation of the DbCollectionsFilesNameValidator object below.
Accidental box?
btw same true for fetchCreatedEntity() which is triggers mapEntity()
Please remove this extra blank lines
defensive copy here, this.objects = ImmutableList.copyOf(objects); or this.objects = new ArrayList<G>(objects); as appropriate
Add Preconditions.checkArgument checks to verify that the passed engine and buffer are not null.
Just curious. Would using jobId here work for high level API job? Besides functionality it will be better to not use JobId here. It's looks odd to use JobId in a factory for producer/consumer(In memory producer and consumer could be used outside of a samza job and doesn't have to be a part of a samza job).
Attribute value was removed is more concise than "Attribute (its value) was removed"
would be more consistent to use this.fileExclusionManager here
int?
return c != null && c.isMergeable();
No need for the extra variable here
If you think there's gonna be more rendering way in the future convert to a switch block, makes it more readable
This is a member of the class... This never should be happened...
Make an injectable "hrefToMessageId" function?
return m.method.equals(method);, instead of this line and next?
This is window-specific stuff. A better idea would be to use File.separator instead of the \'s
It is already set in this method, three lines up.
Do we need spy in this case?
It was like this, but it's confusing to me why it's calling super.getName() and super.getReference, because 1. This class doesn't override those methods 2. If it did override those methods, you would most likely want to compare this class' result, not the super class.
What about Kind.LONG_LITERAL, Kind.BOOLEAN_LITERAL, or Kind.NULL_LITERAL ?
The plugin now requires newer Jenkins core version than in 2016, maybe this check is not required anymore
use an overridable getOperationTimeout() method instead
@fanifieiev the same above.
java if (activity instanceof FragmentActivity) { showRateDialog((FragmentActivity) activity); }  I think it is better because not all developer use FragmentActivity even if SDK_INIT under HONEYCOMS.
Please use builder.xxx(...) instead of new ....
if you put it the other way around java if (configuration.getQuartzConfiguration().isEmpty()){ scheduler = StdSchedulerFactory.getDefaultScheduler(); }  you avoid the double negation - I find that a lot easier to read.
I wonder if its better to just use setHeight("" + delta + "em") once and have a single DOM element cover the entire span.
if getVM().getDiskMap() == null or getVM() == null, you have NPE here? is this ^ possible?
very nice!
Logging.
We should check whether the AbsSendTimeEngine is configured with an extension ID (e.g. getExtensionID() != -1).
sb.append(fIsPic ? "PIC" : "non-PIC"); ?
Remove this empty line.
why not returning the list type? Your removing the possibility to use list methods without a cast. Don't see the point.
I suggest to externalize this constant like the one above.
How aboot math.round?
This constructor does nothing.
I removed the empty constructor because (0|0) doesn't make sense here. So there are two possibilities: - set valid coordinates (preferred) - set gp to null and check it later
MOB: Check if it's an instanceof Number first, then possibly throw an illegal argument exception.
What's the rationale for this vs. just using a concurrent set implementation and adding the elements directly? I'm worried about the number of set iterators we might have sitting with this implementation - could be dozens of unioned and diffed Sets in here. Of course, we'd have to be more careful about read/write contention in this class with the other approach.
Thinking from the point of view of a developer implementing a client for Nakadi subscriptions, how is it possible for me to detect that this scenario is happening? Should I programatically match over the error message? Or is it enough to match on the status code? Is there any other scenarios that could generate a 400 other than this one?
Seems rather complicated to me; any reason why we aren't just using a fixed length here (e.g. Tv.TEN)?
rename tempvar
Make this method synchronized.
Extra trailing comma.
This should be a call to the logger and not to System.err (throughout this class).
declare final
Is this the only reason update can fail? If we run into datasource issues, connection problems, constraint violations (excluding name uniqueness), we will see "Duplicate Domain" as the reason in the logs.
Take care not to include client id/secrets in commits. Because this is now in your git history -- you will likely have to squash your commits into one and submit a new pull request. Note: This does not currently apply to the preview sdk as that is still private.
These two statements could be simplified just to return overlap <= getMaxOverlap() (no need for if/else). Better still, return overlap <= maxOverlap (no need for getter).
If you use CharsetDecoder rather than Charset then there's more control. I don't think we should re-implement a special codec - we shouldn't be spending our time implementing extreme edge cases right now.
So we assume all the soft constraints will use this formula? I don't think it will fit the partition movement constraint. My suggestion is that, keep the scale (max and min), only change the constraints individually which we are calculating the percentage. Those are the applicable ones.
Why do we need to check the paragraph start pattern here? This seems like the wrong approach to me, since it introduces unnecessary coupling between ParagraphBlock and DefinitionListBlock.
I think we have an StringUtils.isJson method. Maybe it needs a null check and a trim() but those would be good to have.
Maybe log the exception. Will help in understanding what went wrong here.
Ideally, this method generates a report that includes counts of the annotations that were generated (e.g. # of NEs of each type; # of coref constituents and # of gold coref arcs) and a summary of errors encountered (most important, # of files not read -- if any -- and their names). The goal is to allow users to accurately compute performance, accounting for annotations not read at all.
Would be nice to give the threads unique names. We use Guava's ThreadFactoryBuilder to help with this for other thread pools.
format your code, pls.
would a assert minLength >= 0 (or something similar) make sense?
Can getSamzaProperty (here and below) be private? Could you please move these helpers further below in the class file so that they are not in between some of the public methods?
suggestion .maxCharsPerColumn(4097)// .files(csvFile.toAbsolutePath().toString())//
It cost a lot of code in other places, but this looks much nicer to me now.
Doh! Thanks! Please leave it as CANNOT_...
super.tearDown should be called last. also this method usually comes right after setUp() before the tests
require non null
You might want to check if there is at least (and at most as well) one value in the collection, this will throw an exception if the values collection is empty.
I guess, if we want applicationStartupDependentResource to be generic (an interface) with different implementations, we should avoid logging database here, because we might be waiting on other things
We don't need to pass the labels in.
My concern here is that these methods start to grow in their parameter numbers each time we add some new config property ... But I guess <LINK_0> should help with this, right? If not directly then maybe we could add a "subcontainer" for these kind of properties...
can use a stringjoiner to avoid creating array  final StringJoiner barcodeQ = new StringJoiner("~"); for (int sampleBarcodeIndice : sampleBarcodeIndices) { barcodeQ.add(SAMUtils.phredToFastq(cluster.getRead(sampleBarcodeIndice).getQualities())); } return barcodeQ.toString();
Why have you moved field initialization from declaration to constructor? I think we should leave it in declaration for uniformity.
This is a bit puzzling. Is instanceof really necessary?
No need to check isEnable() here. Its checked in IdentityProviderManager before invoking the listener. That's the contract of the interface - to say whether the listener is enabled or not. Only UserOperationEventListeners we need to check this in the implementation because the method is not part of the interface contract. Its only there in the abstract class. This is because the interface was in kernel and we couldn't add the method in the kernel.
Possible NPE. In line 340 we could return null which would blow up here.
Same here. The binder should be able to decide how they implement this.
You can use org.springframework.util.StringUtils#hasLength to avoid the two checks.
This can/should be combined with the try ... catch block that follows.
spelling - cipher
Can you switch this to:  java this(new Persister());
Generally you don't sort the VMs, and in the one case where you do - you don't really sort them either, but just move one to the top of the list. So firstly, consider dropping this method, making edit() protected and add the logic only in VmAffinityGroupListModel. Secondly, you could drop the comparator there and just iterate over the items to find the specific ID and move it to the top of the list, the comparator thing isn't necessary.
It would be better to evaluate gitSystemConfig lazily in getGitSystemConfig(), so a call to discoverGitSystemConfig() can be avoided completely if gitSystemConfig has been set 'manually' before. discoverGitSystemConfig() is possibly slow and may even hang if the bash configuration is screwed up.
Multiple method(*) methods
Very minor, but these two lines could be combined together
I forget if Compute.randomInt gets you a number between 0 and x inclusively or excludes the upper bound.
there is already a patientService available for you. no need to get it from the context
@netudima can you create a new PooledByteBufAllocator instance in a @Setup method and use it ? Otherwise it may not produce fair results as it may have already stuff cached from before etc. You may even want to disable ThreadLocal caches all together when doing so to ensure you really hit the PoolArena. WDYT ?
It could be protected better
Ok... that's a way to make sure the test passes without fixing anything... :p
please fix setupnetworks -> remove
Yeah... What I don't like here that null as a message argument for the shouldFlush:  fileWritingMessageHandler.flushIfNeeded((fileAbsolutePath, lastWrite, filterMessage) -> ...);  That filterMessage does not make sense in this context at all. So, we should consider to introduce one more FlushPredicate contract to pass in only the flashable entry. I mean only with those two first arguments.
Should be "Breakpoints"
solid improvement for sure, no need to re-figure this out every time!
\r is for Windows only. Don't do that.
that's really ugly. There's no way for you to know what these parameters are about without getting to the method and reading what it really does.
@bokyoungbin A single query is partitioned to OperatorChains, and each OperatorChain can be executed in different threads. The stateful operators in the OperatorChains can access SSM so multiple threads can update the single shared queryStateMap. As @bgchun said, the implementation should be thread-safe. @bgchun Thanks for the good point!
I think you meant to return mainActivity.getSelectedSite() here.
shouldn't this be cross-platform?
If you have problems with locale-specific numbers, maybe explicitly add a locale to the printf here?  System.out.printf( Locale.ITALIAN, "The date is %tc\n", date );
VARIABLE_IDENTIFIER is too restrictive. It should include: * variables, ex: [$a] * indexed array, ex: [$a[$i]] * object property, ex:[$a->name] This is some valide php code that SonarPHP doesn't parse:  $t1 = [3, 5, 7]; $t2 = [9, 8, 6]; $i=2; [$t1[0], $t1[$i]] = $t2; // indexed array var_dump($t1);  Output:  [9, 5, 8]  Other example:  $t2 = [9, 8, 6]; class A { public $age = 12; } $a = new A(); [$a->age] = $t2; // object property var_dump($a);  Output:  object(A) { age => 9 }
Better to pass in the build directory (e.g. as a system prop) and don't use a literal slash to concatenate paths, especially after you went to the trouble of being platform-independent above. I do this sort of thing, too, but it's not good practice. Test code can be as clean as main code.
Minor thing, we miss ending apostrophe in the exception message.
True, now.
You may only call the c'tor here w/o assignment. Then you dont have to suppress the warning.
unwanted change.
no need to make new set object every time; change the variable type to Set
This "if" is not needed, the "putIfAbsent" method already performs the check, and it doees it in a atomic way, so the "synchronized" modifier is not required.
Could we please introduce a constant DATE_PORTION_LENGTH and then use DATE_PORTION_LENGTH + 1 in extractTime? Feel free to use any name of the constant but I think it will make code easier to understand.
s/commands/command
Is this not better to do in doStart instead?
This cast feels a bit out of place but I don't really have a better suggestion - maybe where this is autowired we could add a separate bean that has a return type of SelectedContentLister that returns the same object as the normal ContentLister bean?
Maybe jvm/heapAlloc/bytes/delta
user_id and is_filtered parameters not required
return asyncHttpClientMap.putIfAbsent(name, ahc) == null;
I would expect this to just be defined in terms of inspect, to avoid duplicating the details of launching the command.
Inline these into declaration
@yesamer I think that's to be removed. synchronizeFactMappingsWidths put the current columns widht inside factmappings, but we decided it should happen **only** when the user saves the scenario - otherwise rely on the "status" implementation to manage them
Why did you move the if from here? Should be- if (scheduledStatusCheckInProgress || retryCount > MAX_RETRY_COUNTS || reportsWebappDeployed) { return; } It is better to keep the if here over duplicating it to 'onError' and 'Response.SC_NOT_FOUND'
Authorization token is missing
Same here, make this package private.
These 2 lines can be removed.
Think you can use just %s instead of %[*]$s for these
Can't this be simplified using Math.ceil()?
I'm not entirely clear on how this is going to be called, but it has me concerned because this action is going to re-process a CSV file, rewrite a new file, and then run a python process.
@danielezonca This is missing the crucial test, i.e. the migrated version should contain "1.2"
Please change it to a normal null check and throw a IllegalArgumentException. This is more meaningful than throwing an NPE here.
This isn't null safe.
Nit picking, only mentioning it because we were speaking about different collection types, using a Set rather than List might be more appropriate since it holds unique values and being used to performa a contains check <LINK_0> Since there's only two values it is absolutely negligible performance benefit O(1) v O(n), as I said mentioning it since it relates to previous discussions.
Wrong error constant suggestion super(MediaWikiApiErrorHandler.ERROR_ASSERT_USER_FAILED, errorMessage);
Minor typo in variable name.
should probably actually check the results here, not just the size
return Optional.of(new Relation());
How about doing a toLowerCase here. That would essentially make column names case insensitive. CQL3 does this.
replacing this with helper method would be great
Again, use IOUtils.
Add messages to your assertions so that in case of an assertion exception you will be given usable details about what failed. To be applied in all assertions.
I'm getting a NPE here, processModel.tradeManager is null
I would rather have something like java serverEnv.useStorageFactory(factory).inTests();  That's a lot closer to the way we speak.
Better results can be achieved with code similar to line 60 of org.eclipse.ui.internal.monitoring.DefaultUiFreezeEventLogger.
please mention that this feature is a "teach preview"
Could specific exception be used here?
Objects::nonNull could be used here
Why did you change this? this won't work when running the tests from the published test jar
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
this.value = value;
toString() is missing the name of the class
check if message it's a valid string
Again same thing here, row vector/column vector explicitly? Make sure vector cases are handled.
@govind-menon maybe we can replace the "wait(1000)" with a Thread.sleep(100), the '100' instead of '1000' will lead to faster shutdown. does it sound good to you ?
should we have minimum? A limit of 1 byte doesn't make sense.
Replace first with parts.isEmpty()
Wrong place. This should be done in the setSamplePurposeDao method, where it was originally
Should this be an untypedUtils thing (or something not DefaultGroovyMethods anyways)
Collections.addAll()?
>credentials [](start = 26, length = 11) static
We may be better off to return null instead of an empty string here.
You shouldn't have to do this, instead make CohortMember implement Comparable
I think it would be reasonable to put any operations which are not expensive and can't fail into the constructor, which would allow you to eliminate the randomSeed instance variable and avoid overridinginit(). It's a subjective call, though.
Maybe a more meaningful exception?
Why the change to REPLICATE region type as the default? Should it be PARTITION_REDUNDANT, perhaps?
So the store does not get re-enabled and the other tests pass anyways? Stroke of luck and it's one of the last tests to be run?
Nice job
this could be Lists.newArrayList(deviceId);
Why don't we throw UnsupportedOperationException for these three methods? I think that would prevent users from falsely assuming there is support for it.
Nit: maybe ToolchainInfo.SKYLARK_NAME?
.toString(); is redundant here.
Configuration files are relatively small. Will this stream ever be sufficiently large to warrant this bufferred reading approach, rather than simply reading the whole stream in? We're eventually reading the whole stream into memory anyway. Why not just readFully or similar?
Consistency?
Shouldn't need to try catch here given the overload being called already does this.
new XmlContext() can happen above the for loop so we create less objects.
is this now guaranteed to be called from the event loop? I think so but just to double-check...
nit: can decrease indentation by avoiding this 'else'. if (contentLength == null) { return -1; }
There is a matcher that already does this: org.fest.swing.core.matcher.JButtonMatcher.
@diegolovison the warning should be logged when setting the queue size, not when reading it. This is what I had in mind: <LINK_0>
Wording wise I think it makes more sense to formulate it like: "Sign in to DataCloud"
static import for is
it seems redundant for defining this variable
why does this have to return the file?
When an exception is caught, it is expected one of the two behaviors: - log the exception (in this case: SilverLogger.error("Look named '"+lookName+" not found", e), see the exception e logged at the end of the error method) - rethrow the exception or throw another exception When this rules don't need to be applied, then we add an exception to this rule for the incriminated code in our SonarQube. For your case, in order to determine the better way to handle that, when the method isLookExist is called with a look name as argument, should the name exist in the look settings?
What about using stream api and directly have a return from the first line?
a GET request to generate identifiers?
Shouldn't it be styledText.isWordWrap() ?
nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment to pathElements is not necessary)
This function will only be called when the marker is present, so in practice the input parameter won't be null. Remove the @Nullable annotation (apply this to all parser classes).
Please fix formatting in this method.
This is not locking on key level but set object level.
better appendToMailbox(msg)
Please use FrameHeaderFlyweight .FRAME_LENGTH_SIZE instead of hardcoding
Might be worth adding an isFinishing() check before updating the views. WDYT?
From the first glance changed behavior of this method looks counter intuitive: if a passed argument is lesser than 0 a default timeout from a configuration is used. For me a check employed before asserting that negative values are invalid. And does this change really makes queries use a default timeout? I suppose a small test will answer this question.
The ID is used to restore old files (from an older release) so this must not be changed!
additionally (and this applies for both VNC urls), the colon character must be escaped, as the url will be passed to another url as a parameter
Can you wrap that into a method with an integer parameter for the warning number to return?  Collection<FileAnnotation> warnings = new IarParser().parse(openFile("issue8823.txt")); Iterator<FileAnnotation> iterator = warnings.iterator(); For loop: iterator.next(); return iterator.next();
unnecessary variable
IMO, it's better to look this up by interface.
i think here is return Strings.format("%i/%s/%s", task.getId(), language, fileName)
I agree this is very clean, but getNetworks() isn't a simple getter and shouldn't be called if you fail beforehand. I'd separate into two ifs.
reuse folderName
If I'm not mistaken this method is deprecated and we should use org.eclipse.che.api.promises.client.PromiseProvider#reject(org.eclipse.che.api.promises.client.PromiseError), no?
suggestion return new HashMap<>(connectorConfigCallback.get(herderRequestTimeoutMs, TimeUnit.MILLISECONDS););
This line should be removed
You better prefer string concatenation here
We're duplicating it in the constructor and wrapping it here in an unmodifiable List on every call? Can we do that in the constructor then too? Still not sure if it's worth it though. This costs performance wise. 2 proposals: Proposal A): in constructor: Collections.unmodifiableList(new ArrayList<>(justificationList)) Proposal B: in constructor: Collections.unmodifiableList(justificationList) I suspect that for DRL and CS-B, proposal B is bugfree, so the duplication cost of proposal A is a perf loss. For CS-D we can duplicate before giving it to that constructor?
@aschworer DASH used only here, you can inline it
Do you think we should avoid introducing another virtual/interface method call here, and another object instantiation for the lambda argument capture, or is that not important at this point? Maybe for the most common messages that are on the performance path (BufferResponse, AddCredit). BufferResponse is already avoiding this, maybe AddCredit can as well. If we want to avoid it, we could also go with this pattern: java final ByteBuf buffer = allocateBuffer(allocator, ID, length); try { // same code as in consumer buffer.writeInt(....); ... out.write(result, promise); } catch (Throwable t) { handleException(buffer, t); }  That way we only have the virtual call in the exception case, and no extra object. And it looks minimally more verbose/duplicate.
So this behavior isn't quite right. We need the buffering of data to only happen on when a marker is set (for reading the image metadata) but to NOT happen when there is no marker (during the actual full image decode). As it stands now this will cause a ton of allocation and GC churn in the latter case when we don't actually care about buffering. My approach was going to be killing this class for another InputStream decorator that used an on-demand list of 2K byte[] chunks for infinite buffering when a mark was set. In the ideal case only a single 2K chunk would be allocated. In the pathological degradation case it would just allocate additional chunks as needed until reset.
Can we name this something else? It's confusing to see field(field...)
could be in else
A better variable name than aLong is actualConceptsCount
@Exr0n call super().
Can we change the name of this variable? It's a little confusing to read usage.usage and think about it as a type Usage. Maybe storageUsed?
right now setPGStatupWait(Duration.ofSeconds(-1)) throws NullPointerException, when it should either silently replace with a zero duration, or throw IllegalArgumentException.
Since startTime is changing I would suggest to rename it to currentTime to make the loop condition more clear.
redundant, right?
These paths and file names should be extracted as constants, specially if they are reused in more places.
Static
These is ugly, also sometimes create a strange errors when working with java.uitl.Date Please think about using System.currenttimeinmillis (whatever) + minutes * 60 * 1000 and after that new Date(value)
If you want to go for a bit more type safety you could encode the Url as actual Url. This is probably not needed when the main goal is to produce markdown output, though.
I think the Travis build failed because you have a typo. The method is called getByteLength() (no 's'). If you can fix that and update the PR, I can merge this in.
Slf4j logging please.
Firing an event wrapped in try block... Never saw it before in our codebase. That's interesting. Can you explain, please, what's the motivation of this
If we change LinkedHashSet to LinkedHashMap with access order (check LRUCacheEvictor), don't we have a LRU bucket in that case? @calvinjia
null or empty is technical. We can just say something like: Schema must be provided.
Out of curiosity, where can this NPE come from? netif is known not to be null at this point.
Same kind of thought here, I would negate this if condition and get rid of the else block... but I guess it's a matter of taste really ^^
check false condition here and we can save one level of indent
space after if, and before {
Similarly, will this(toEntity()) work?
could rename pair to userIdPair or userSessionPair
Register receiver here if isReceiverRegistered is false
Perhaps you can use static imports for everything form Assertion?
Same as in non-buffered aggregator
Feel free to use Assertions.fail() for this purpose. Also, I would say something to the tune of "Environment mode not covered: {}".
There is no reason for these formatting changes
style-nit; no braces for simple single-statement constrcuts
Rebase error - should be used Helper.getCurrentUser.
better make these methods protected and move the algorithmGroup soly to the algorithmgroup class and override the methods where it is used here
Can you use DataConstants for the default values?
I would suggest answer.toLowerCase() to make secret answer validation case insensitive.
Exception is redundant
Would be logic the same if you rewrite code as  for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }  ?
Do we need a copy of the data?
remove synchronized
It will never be null
where is this constructor called?
Could you please always use curly braces around the bodies of if statements, even if they're one-liners?
You need to add the annotation here as well, as otherwise the delegate (i.e. the actual mapper implementation) for a decorator does not get the @Singleton annotation.
can we say show_notification instead of allow?
Please inline this variable.
This if clause can be removed if the Path in open on construction as a SeekableStream
why is this null (Although I guess it doesn't matter)
A HTTP header named "" should probably be treated as invalid, I think we should refuse it at construction, not try to coerce it here.
Nullable
The pattern that we've used so far is for the builder to emit content as well as possible, rather than failing. Consider doing something like: characters(format("{0}({1})",text,definition));
Why is this no longer static?
It might be better to use default values that are not equal to the Java defaults (e.g., -1)
Simply use Arrays.asList(). The list will be immutable but I don't think we add element to the column names afterwards?
requireNonNull
Why do you need to change the values? TestClassWithConfigSkipAndFailureSample was 3 => HAS_SKIPPED + HAS_FAILURE and is now 6 => HAS_SKIPPED + HAS_FSP. Is it expected?
Just because the code resembles C doesn't mean that you have to adopt horrendous naming standards ;)
I think that we should remove process if kill succeeded. There is one branch that leaves stale consumer that cannot be supervised anymore cause we removed it.
return super.getServiceName().append("config");
You should do this via the mocking api, otherwise this call is just being sent to the mock which doesnt do anything with it..
if you want to check if video is playing I would not rely on video feedback element. There is special css class added to one of divs related to player itself that appears when video is playing
should this also use the read option like the other iterator?
Can it be null?
Does the same cost lead to the change?
this is just syntactic sugar, doing so will make this line a bit shorter. return Collections.singletonList(PreConfiguredTokenFilter.singleton("homoglyph_norm", will become return singletonList(singleton("homoglyph_norm", it sometimes helps readability and is accessible easily in intelliJ by simply pressing alt-enter while having the cursor on the method.
Should this be if (!Strings.isNullOrEmpty(link)) { ?
> ... as the more important one. Is there any particular reason why is it so? Usually, it is the less important one and attached as suppressed.
I'd either remove this message or expand on it a bit (i.e. "Refreshing info for server X").
Why do you think this is better than Collections.EMPTY_LIST? It doesn't look like a necessary change.
asyncPageTransportLocation.orElse(location)
Make these String values as constants
Make these methods final so they can't accidentally be overridden
This should not be a hardcoded constant ("value"), but simply name. I know this won't change anything in practice, but it's just in case people copy/paste this code.
This should use the declared return type, not the instance type. Otherwise you can't use multibindings to create a Set<Set<String>>.
Is it OK that this may return null and nothing be done about it?
I think it would be interesting to test not only the status code but also the body, as it should contain the list of commit results.
Also needs Assert.notNull().
This SavedState constructor can be made package-private to avoid accessing a private member in the createFromParcel method.
I think that this assignment to "guid" already happens in the base class? Doesn't it?
Then use return String.format(URL, checkerInfo.getCurrencyBaseLowerCase(), checkerInfo.getCurrencyCounterLowerCase());, without hardcoding BRL here.
This way _all_ columns with Double type will be formatted with two decimal digits. It is okay for cost (which is essentially money) but it may not be okay for other columns, including user-defined (imagine e.g. weight measured in tons). I think that the best way to achieve the goal is to override method newTablecolumnext in GanttTreeTable and check if we are creating exactly COST column. We already use similar approach in ResourceTreeTable. Also, the same should be done with the editor, no? Otherwise the user will see values with 2 decimal digits, but once he starts editing, he will see something different.
Just let it throw the error.
Change s to serviceInstance
Missing @Override
just FYI, I think there's a method scrollAndClick()
@pinaf Oh, sorry. I forgot that we have 2 methods. OK for the second test. And also I wasn't very precise about users docs. What I actually want is the one more test (at leas a puzzle for it) to test that AwsDocs. names() can return hierarchical names if some files. You can actually modify the existing test for that.
Mostly we don't use chain and use only setters. Let's discuss it with @ybabak @YuriBabak I'd like chain
I think this should call getExistedPath(url) (or its equivalent if it gets renamed). The constructor used to call url.getPath() for its parameter, just like this method used to. Since the constructor now calls getExistedPath(url), _this method should probably call it too_ (for consistency).
\\n and not \n? Interesting
null check can be beneficial here
Is an empty itemType allowed?
ArrayLists are great for random reads, not so great for appending. I think by deafult it allocates a length 10 array, then reallocates and copies all the data when the limit is hit. Feels like a LinkedList would work better since we only ever iterate over it, right? Practically though, I'm not sure if the difference is measurable.
Why is this included in this PR?
why not use a concurrenthashmap?
Better use Double.isNaN(double) ;)
It should be new TajoRuntimeException(new InvalidCastException(...).
drilldown can be specified multiple times, looks like the previous code was incorrect in this regard. It should be uriBuilder.query("drilldown", drillDownArray, false) to not replace the parameter. I'm guessing this will be impacted by #167 though. Maybe it is worth moving this out into another issue as it is a bit unrelated.
This stream can probably be created using [try-with-resources](<LINK_0>
Use Assert.assertEquals instead.
Just use normal string concats...
Again, this doesn't guarantee INDEX bytes are read. My recommendation is to use okio to reliably skip X bytes.
public static int hashCode(double value)
Can you remove this logging statement?
Let's put the content of waitForAndDismissAlertModal here, and let that function call this one instead. The "click OK to dismiss" relationship makes more sense compared to "dismiss to click OK".
That's a hack indeed. There must be a way to trigger a refresh of the list view... (but I don't know off hand sorry)
Sometimes you use "/" and sometimes a variable/constant...
We use a ByteArrayOutputStream for other services (e.g., PD) -- any reason we're using a StringWriter here?
Delegate to createCloneUtils(Kryo kryo, ...)
Would be nice to add @return about what kind of values are expected here
Can you just rename this to cleanupTmp(); ?
It looks a bit odd to me that we finish the operation only if the migration removes a record. Why is it so?
getServicePolicy shouldn't ever return null. Based on how the Python SDK functions we return a policy object every time. In the case that it is in fact empty ({"factors": [], "minimum_requirements": []}), we return a policy with all the minimum_factors set to false or 0.
Translation here as well.
i am worried of the 3 here,did you set it as a conceptId any were up for COUGH SYRUP
There are tons of things that could have gone wrong in this call, and returning null from here will both crash or break other code, and has no clear semantic meaning. You need to figure out what can be failing here and make sure that it is handled
Can be simplified to java this.mockMvc.perform(get("http://localhost:543")) .andExpect(redirectedUrl("https://localhost:123"));
static imports
since you've changed method name to clickPublishButton you can also rename button to publishButton instead of savePageButton
I want to method accessor to be package private :eyes:
This method could be converted into a single (three-line) boolean statement.
I'd like to be able to configure generation in other worlds, too... Like Basalt in the nether.
Please add an assertion message to the asserEquals() call.
One output could be added many times. Do we need to prevent that?
THis should return empty array
May not matter, but did you check if this behaviour change has any impact? (The units were not taken into account originally, whatever checkPeriod value was passed in at construction was passed back out unchanged without considering the timeUnit...while now it will be converted from nanos into the given timeUnit)
We don't want markdown for debug builds by default. Same reason as CSS.
style nit: no braces here
Alter case also we need to set it. If it is bootstrapping on empty Db. May be we can remove the flag and just set it to true always.
extra space on this line
It would be better if this returned an empty list instead of null if no repositories exist. The same applies for the other methods as well.
should be "recoveryRate", not "recovery rate must be between 0 and 1"
change from admin@nhn.com to ngrinder-admin@naver.com
can be removed now
Here the preselection should be added.
storedContext.
dynamic.equals(jobName)? But, what is wrong on setting initial jobName in URI path? AFAIK this concept is not used anywhare in Camel, so please remove the check for "dynamic".
It looks like we verify these attributes, and then call the getLocalDBEntry(a, b) method below. Could we do the verification once instead of twice?
\n can be removed.
The two calls to repositoryFactory.getObject(); in this method can be extracted to a variable.
use org.assertj.core.test.Maps.mapOf to make code lighter.
This is charge_dialog_fragment not change_dialog_fragment
static import getInputFormatName
what if cdPath is already null?
The exception also needs to be modified a bit.
Remove instance creation here and other places ?
This method should not be public because this data source should return only settings domain entity
No need to catch the exception here, it was already done in the overload.
unnecessary change
current event row count / QueryableIndex.getNumRows()
Both cases behind if have common logic, you are using if statement only to determine which element use, so let's refactor it
De Morgan is really earning his keep this week! java return !getSupportedSearchParams().contains(queryParam.getKey()) && !isBlank(queryParam.getValue());
Shouldn't the new module have the id returned by getDependentAnalysisId()?
This may not be the right way to serialize the key. This depends on toString method which by default (if not implemented) returns address which will never dedup.
this should be: null == patternFilter
or suggestion Authentication auth = Jenkins.getAuthentication(); return auth.equals(Jenkins.ANONYMOUS) ? null : auth.getName();
Would it be simpler to rewrite this block as just if (subscriptionTryCount != 1)?
super nit: suggestion String filePath = "path/to/text/file.txt";
This seems to result in dates that look like 1970-01-01T00:00:00.Z. I think you meant to use SSS for milliseconds.
I'd say it hsould be called listFileNames (with a capital 'N')...
Correlate must have as joinType one of INNER, LEFT, SEMI, ANTI (i.e the formerly SemiJoinTypes), I think we should probably throw an IllegalArgumentException if joinType is not one of those
Better return File for file path. Same for all other methods.
There should be character '.' after the word 'totally'.
Good change making this an instance member, thanks.
space after if
This line appears twice in the file. As it's effectively the logical opposite of register, I would extract it to a method unregister.
don't hide exceptions - it makes resolving failures hard.
Consider renaming this method: its similarity to increaseNumOfStudents suggests it decreases the number of students by the integer passed in.
Please revert back to ArgumentPreparedStatementSetter as reading/writing BLOB is not required on the remove.
Although 2 will not fail the CS magic number check, it isn't clear why it's needed here. A descriptively named constant would help make that clear.
Let's not rush for auto registration logic here. We can split it into two PRs. For this PR, let's only have the interface and class implementation. Move the registration logic to separate PR.
add space, use formatter.
should slack be in here? suggestion return "Slack email User ID Resolver";
This is not legal: collections.emptyMap returns a non-modifiable empty map (and always the very same empty map). Invoking .put on it should fail. For maps with a single element, use Collections.singletonMap(...). It also return a non-modifiable map. Note that this is highlighting an trap in the Java language and API.
This should really use RegexWithTimeout, for safety.
please call super.onLogin() here since this is the same code
Need to verify that this is always followed by onResume
omit?
chain with previous line's assertion
You're sure caching the field isn't needed? It's still done for beforePassivate
end = Math.min(end, interval.get***End***Time());
nit: table variable is unnecessary here
don't need parens
is -> are ?
Use parameterized logging, like:  java logger.debug("Mapping: itemname={} & property = {}", itemName, property);
Same as above; there is no need to make this injector public.
Is this safe to do repeatedly? Or do we need to check and no-op if it's already present?
Please use static import for CompressionUtils. likewise addFolderToTar above.
In lieu of the validation in develop, maybe we can just say something akin to "syntax error, please check your WDL file" here
Unnecessary?
Can we use AssertJ's assertThatCode here instead of the try-catch?
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "Method not implemented for unspecified field" 5 times. [![rule](<LINK_1>](<LINK_2>
@exper0 full path HmRsHeader.VALUES_STR
Why we disallow a user to set null bookmark? (It does not make many sense, but maybe a user wants to break CC from this tx?)
You need to create own exception, when requires to change the default behavior. Please use a standard one for your use-case.
I prefer adding a case for something like json_type(1), which should fail the validation.
As far as I know, we do not have an issue on it as we are still trying to finish up DetailAST support in xpath.
delegate to setBody(publisher, -1)
yes, this shouldn't be here
Is this method exposed for testing? If yes, should it be marked @VisibleForTesting?
Is there a question here? Or are you answering your own question?
why remove the singleton check?
Will this be more readable with String.format
--> Failed to transform configuration parameter with key '%s' and initial value '%s'
I'd just go for the code below, as it feels a lot simpler to me:  public static Predicate<CharSequence> containsAllLiterals(final String... fragments) { List<Predicate<CharSequence>> fragmentPredicates = Lists.newArrayList(); for (String fragment : fragments) { fragmentPredicates.add(containsLiteral(fragment)); } return Predicates.and(fragmentPredicates); }
I would call escape here to be in line with the @deprecated message and to make sure that both escape methods behave the same (someone may update escape(String) without updating the deprecated escape(Object)). This is minor but it's a best practice IMO.
Set<String> seems more appropriate to me, unless there is some need to have values ordered.
What happens if id is null? Shouldn't you also use tenantId, or is it correct to ignore it?
You don't necessarily need constants for these.. Plain "" should be fine too.
Lines 1051-1053 are redundant.
Noticed that in SamzaSqlQueryPlanner.parseQuery(), there is already a SqlSelect generated for the part does the SELECT statement. Following this planner.plan(), in QueryPlanner, we are parsing the select statement again (as queryInfo.getSelectQuery() is returning a string). One question: can we do a single parse instead of double parse?
Why linked list? I guess ArrayList would be more efficient...
do we need a try-finally here to ensure any close action gets called?
As far as I see - this is class for default exception handlers. Maybe default one for NoSuchEventType is NOT_FOUND?
Not a deep copy
Please use assertNotNull from TestNG and fix indents here
all these methods can be package-private
Maybe tokenise? getTokens is a bit general for what it does.
Use FluentIterable.filter() or Iterables.filter.
suggestion return SystemUtils.IS_OS_LINUX && gnomeLoginKeyring.isPresent();
I think that the "Support" word isn't needed in these names, it is better to name them just "generateStructReader", "generateStructWriter", etc. That accurately describes what they do.
I think this needs to be on all windows. Otherwise, if I quit Eclipse with multiple windows opened, when it is restarted, only one of the window will have the listener (the one that has first focus). 1. Open a source file in the first window 2. Open a second window and open the same file 3. Exit Eclipse (File > Exit) 4. Start it again 5. Close the window that has first focus 6. Start typing errors in the remaining window: they are not reported
== is sufficient.
I think this should not be public, right ?
Why are we setting it to new a new empty CompletableFuture? Is removing not sufficient?
why not directly assertEquals(LOW, fCondition.min()); ?
Is that possible that tethering inactive but tethering restricted is updated to restrict? If yes, the logic here may be not correct? Another question is that when tethering is inactive, should we still show notification? Is that wired that there is tethering restricted notification when I do not even enable tethering if I understand it correctly?
This could call the one argument constructor instead of this.requestData = requestData;. It will make possible future refactorings easier.
Would prefer new IntObjectOpenHashMap<>() here. javac will infer the correct generic type, and then there's less work to refactor in the future. (This trick was discovered fairly late in Myria, so hasn't made it through much of the code.)
Should this close happen in a finally block?
elapsednanos.
we will need to call ShouldBeEqualByComparingOnlyGivenFields and give it the fields differences.
Technically, wouldn't it be Class<? extends ClockProvider>?
why any? use mIccRecords
I may be wrong, but it looks like we're scheduling all cleanup jobs individually. This also means that cleanup jobs could potentially run in parallel. What happens if there are multiple cleanup jobs, each using all available processors? There will be lots and lots of context switching in vain, won't there?
Feels like it would be neater to have a single event handler for this which then dispatches to the two methods.
can we add a Toast if mSite is null? I know such a situation is unlikely to happen, but in that event then no action is performed and the user is not informed. Maybe we can fail in the onCreate method in the Activity itself. Not a direct part of this PR but it seems there are several checks on mSite not being null that could benefit from having this check right from start.
In the original version, both "in" and "out" were not closed at the end. Why do we close them now?
Collection is not usually returned in these cases. Also, sorting each time this method is invoked is not too efficient. Maybe we could find an implementation of storageFields, which would have its keys sorted automatically.
session could be set to null on dispose().
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
This prefix should probably still be there as it is actually logging in the "correct way" to the actual build log. Also should maybe be doing double logging here, once to the build log and once to the scan log?
As this is single element list we could use: java final List<Element> updatedElements = Collections.singletoneList(mock(Element.class));
@original-brownbear does it need to be IOUtil from plexus? Does it have some special property we need?
Do these constants really need to be removed? TestCatalogValidation.java appears to have similar constants. Is something in this test impacting the classloader?
Can't we use Objects.equals(value, name.value)?
style nit: replace tab after "selection," by a space
Hi @nahuel-soldevilla Thanks for reviewing this! I agree, Pattern.compile will have a performance impact if it is called multiple times. So I decided to improve the code and do literal replacements instead of using regex to avoid creating Pattern and Matcher objects.
times(0) -> never
we already have this in tmf.core.Activator now. Since this plugin depends on tmf.core, it will already be loaded. Is this necessary to call this again?
Odd indent on line 86 and lack of braces makes this code confusing. Better to use a newline and { } around the if body to make the intent clear. Fixing the indent will also help.
null email will fail here. lets prevent potential NPE, even though theory is UI will never pass it.
Could you add the type parameters to the constructor calls here and below?
You can spare this call when !result
Could we use RecordBatch.NO_TIMESTAMP here too?
The constant should be a static variable. It looks like it is converting megabytes to bytes? If so, how about 'MB_TO_BYTES_CONVERSION'?
requireNN
magic number
just millis shoud be enought
IMO this would read better with a ternary operator rather than the if (...) { return ...; } return ...; pattern.
You need to make sure that all WebView methods are called on the UI thread. (I know there are many violations of this in this file, but I've recently fixed them all in master - <LINK_0>;a=history;f=tests/tests/webkit/src/android/webkit/cts/WebViewTest.java;h=af35f626ad97d30ef3ca4ce89a679cd2cb0138cd;hb=master - and want to keep it that way when this auto-merges to master)
This seems redundant, and bad practice to assert based on the text of exception message. The e instanceof MyException assert below should be sufficient.
set to final
IMHO we should remove this log message at all.
maybe rename the ReadPreferenceType field from readPreference to defaultReadPreference since that's not necessarily the ReadPreference that's going to be used.
I guess you can use Objects from java 7 here and on equals =)
you can replace it with a direct call to providerDao.get(getCachedVm().getClusterId())
invalid_scope in place of invalid_request
Does the pageNumber start at 1 or 0? If it starts at one, this conditional could be wrong: pageNumber=1, totalCount=7,pageSize=5 would return false, but there is still a next page.
Update this method to return Optional<ConnectorTableMetadata>
Use brackets for single statements (I know we are very inconsitent here but this should be the goal)
Just a quick first browse-through: Shouldn't notifyListenersAboutRemovedElement(...) also be called with existingElement?
Should the list of required attributes be validated against the list of editable attributes?
Use: return Optional.fromNullable(request.getEntity()).transform(Functions.toStringFunction()).or("").getBytes(Charset.forName("UTF-8"));
Exceptions other than LockException need to be re-thrown. Otherwise Jobs executing the operation are treated as executed successfully. Other question: can a Job executing an operation be treated as successful if the following happens: 1. Operation fails with lock failure 2. User removes lock by confirming pop up
@thiliA Can you fix this exception as well?
![MAJOR](<LINK_0> Constructor has 8 parameters, which is greater than 7 authorized. [![rule](<LINK_2>](<LINK_1>
Never use \n in printed output, because it is not portable across operating systems. Use %n instead.
Why not to include the incorrect pattern?
Maybe rename into suggestion ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,
Perhaps pulling the instructionType int into a variable in the line above would be better for readability. Just an optional suggestion!
This is not going to work. openFile directly delegates to the underlying file system. The input stream does not use cache at all
Is this not now simply standaloneprojects?
suggestion assertFalse("Should not resolve model one dialog", resourceExists("/apps/test/model1/cq:dialog"));
Redundant else block.
for checkNonNull, Objects.requireNonNull is preferred. And the labels should be externalized
A bit of a nitpick but we're creating a hashmap with preinitialized capacity of (at least) 16 to put at most 1 element there.
nit: not sure how often are these called (if ever) , it might be better to use String.format(..) or equivalent. maybe needed in some other places.
Should this really be the case? This seems kind of sketchy - no matter what currency I try to use, Ess will have it but not really because all currencies are this one? Does Reserve have some additional UI on top of this which hides this detail for single currency economies?
I suspect the first submission will hold the thread and rest will never have a chance to run.
intentional?
directReplyToContainer might be null. Although I agree that this.channel is fully depends of the AsyncRabbitTemplate.this.directReplyToContainer, but let's modify it to avoid such a noise: ![potential_npe](<LINK_0> By the way it would be better to provide some message anyway. It is used in the event downstream:  consumer.cancelConsumer("Consumer " + this + " canceled due to " + message); ... publishConsumerFailedEvent(eventMessage, true, null);  And minor: no need in the RabbitFuture. prefix for the this.channel
Unsure about this one, encoding measures makes for invalid or problematic GML in output, I'd do it only if explicitly requested.
Name this variable sharedPreferencesEditor for better readability
This looks... unnecessary? Why don't you just call execute on the work plan? The main advantage is that you would get rid of this weird synchronization map.
allow overload with OpenEngSBModel
Make an unmodifiable copy here?
We should not have to set the servlet path for this test to pass.
Without a retry count here, are we avoiding infinite loops for when we keep getting 401s (e.g. password changed).
add empty line below
I think it better throws exception when else, due to it need such properties in request.
should be N/A. Also - shouldn't this be localized?
I would like to preserve cases. It reduces the possibility of name clashes. In any case I think you should use the package sanitizer utils here too to be sure to have it coherent with the rest of the code
If groupId is not specified, this is usually simply the same as ID by prior convention. It is possible that a constructor need be added to AbstractFixedIntervalTask to account for this combination of parameters. Can you modify this so that ID and groupID are the same in the absence of an explicit groupId?
Obtaining the reference sequence needs a dedicated method.
Behavior here is a bit different from the docs, which say the value is rounded up. Since this allows a lane limit of zero or the total limit, it is a bit inconsistent with disallowing maxLowPercent from being 0 or 100 percent.
@thobe If cluster told you about these fellows, why are you so keen to forget them? If they are not doing their job, send them to the back of the queue. But they _just_ might come in handy later. And cluster will update you with a full view some time in future, right?
perhaps perform the revert through RemoveImageCommand in revertTask() - that way the image would be removed completely in that case (also from the DB) i and we will benefit from the additional logic in RemoveImage.
Could you change this to use ManagedInstance instead?
preconditions check that executor services must not be the same
Space.
this looks suspicious, since it returns an empty array both times.
[nit] file.isFile() instead of file.exists() && !file.isDirectory()
If for some reason the setup() throws an exception and mTableContext doesn't get initialized, then the parent class's cleanup() won't be invoked. I don't think mTableContext != null should be a precondition of this method. Perhaps just use IOUtils.closeQuietly() so the call to super.cleanup(hadoopContext) is still invoked.
Is this thread safe?
Couldn't we have the timeout check implmented in the OsgiSurefireBooter (or a parent) instead? It would most likely allow easier reuse.
Please update and then I'll pull it in. I'd rather not pull in tests that'll fail.
Since this class uses exactly one Renderable you might as well create it in the constructor and don't use the pool (or extend it, although I'm not sure that fits the scope of the usecase).
why do we need this to be customizable?
I don't think the cast to (Boolean) is needed
please limit the visibility of the constructor
Initialize in field declaration
would a ForbiddenException work here or is just a WebApplicationException thrown?
Now, I think we need a class with constants shared across the package. Please consider. We have too many magic constants that are obvious, but still are "magic constants". Can we have something like IndexOf.E for example?
I'm not a Parcel expert but I think we want to write this out unconditionally. If we don't, I think the constructor will byte offsets will be wrong for the other values.
probably a good idea to ignore NoNodeException here since there is a chance that between the exists() call and the getChildren() call above, the node could disappear (if so, ignore and then return the empty list below)
I assume you only loaded level3 for testing, right? Please change it back to be able to load all 3 levels. <bug
Shouldn't this call the other form with payload as the first argument?
please put each parameter in separate line :)
This does not look correct in terms of isolation of objects. Why is this call needed ?
You use the gameOverText in both branches of your if-statement. Also, I think it would be better to just use one variable for this, which you give one of the two possible texts. And to get this text, you should use a controller instead of this class, to keep as little logic as possible in this class.
i strongly disagree with removing the check for vm is null, can you be sure that there is no case that vm is deleted before getting here? this code is called for almost all async tasks IIRC, including remove vm this is defensive code that i believe was introduced because of a bad experience...
1. please remove the "Lun" from the methods name, as this resides in DiskValidator, if you want you can perform the check when the disk.getDiskStorageType() is LUN, otherwise return valid result 2. this method is very similar to the previous one (isReadOnlyPropertyCompatibleWithInterface), I'd merge them to one method that'll get the interface/message as the parameters.
String.format() can make this more readable.
just return Optional<String> that way the implementation can decide what to do if the value is not present.
i'd add first assertNotNull(entry); which is a proper assumption prior to validating the entry data.
suggestion return false;  Let's not do unnecessary pulls
1. Replace expires to expiry 2. We could have more meaningful message like "expiry must be minimum 1 second to maximum " + TimeUnit.SECONDS.toDays(DEFAULT_EXPIRY_TIME) + " days"
You don't need to fill the body of that method, you just need it to use it as lambda.
NoCloneClones sounds a little weird. Just name it InputNoClone.
Unnecessary parens around return value.
This one could be misleading as we are not really listening for errors on this one even though we are reading from stderr. Could this be separated from this method?
An ASSIGN expressions requires a variable to store the value. So the first children will be an IDENT for sure.
should be named ignored to satisfy the "log or throw but not both nor neither, or express decision to omit handling" rule
Is there a reason you cannot use Collections.emptyList()?
Shouldn't this be finalize() instead?
Remove this. Should be caught by table.remove()
Maybe we can combine two if clause together?
should be reversed: RANGER_USER_SYNC_ROLE_TYPE.equals(apiRole.getType())
Here i'd assume we'd either call super.toString() or throw IllegalStateException since it cannot happen.
Shouldn't maxBlockId = MIN_BLOCK_ID + NUM_TOTAL_BLOCKS -1?
undo
Here we use it as the same key as we use to create the fReviewList
you should be validating here ^ that either id or name is provided
!this.closeStreamAfterSend || this.isSingleUse ?
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
typo
Please use { ... } - this increases code readability.
You can create method integerRange(int min, int max) that create the range and doesn't pollute the test with unnecessary code.
why this method is not static? just like convert()?
getNameConstantOperand().equals("getPackageName().equalsIgnoreCase") This will not work. When looking at the operation INVOKEVIRTUAL, there can only be one method being called at the time. getNameConstantOperand().equals("equalsIgnoreCase")
why it's appended to the beginning?
I feel like it might make more sense to use a instanceof check here rather than caching the ClassCastException. This means we don't get warnings if we're using the Fragment in contexts where we're not interested in the listener (tests for instance).
This implementation forces single events to be submitted. I believe other SDKs allow _multiple_ events to be submitted using their submit methods. I would check to make sure the semantics are consistent here between SDKs. Also, I don't recommend using a PrintStream here. It swallows IOExceptions. OutputStream.write should work just fine.
1. it will, you'll know which line was broken, 2. you can add a message to assertTrue()
I think this needs to be a protected Localization call with an english fallback. Localization might be broken if the app install is broken.
you should be calling 'addLinks(populate(' on the entity you're adding, otherwise it won't have any links and won't call doPopulate() when All-Content header on the request path.
Probably not part of this patch, but IMHO, we should be pessimistic and use Math.ceil and not Math.round
As far as I remember, returning a Map was causing errors for swagger API client generator.
Do all versions of ps support these options? Just wondering since this monitor will only work on Linux.
Ugly unconditional type casting, I think it would be significantly better if we could check instance type here and throw warning/error/exception if that does not suit our logic instead of implicit type casting. Does that make sense for you?
If that's the right fix then the method name is very wrong.
Use logger instead for sysout for logging.
use the root controlMapper instead
100 chars
feel free to change any of these to lambdas too. Much of this is pre-java8 code which is why there are callables/runnables all over
The two lines are too long... Line breaks can be appropriate.
It should return CanOpenState, not Enum
I think it's better:  GoAssignmentStatement assignment = PsiTreeUtil.getNonStrictParentOfType(element, GoAssignmentStatement.class); return assignment != null && assignment.isValid() && isAssignmentEqualsSized(assignment) ? assignment : null;  Please, use lambdas if it give some gain in readability
Should this constructor be protected?
in hind sight we should use a constant here to avoid allocation on each call.
Can we keep the original constructor SpliceSchemaWatcher(String schemaName and let it call SpliceSchemaWatcher(null, schemaName)? Maybe we can avoid touching so many ITs.
Perhaps we should guard against getting back null, so can throw exception with the missing name rather than just an NPE.
change to interface list
Why do you cast to HostProviderProxy?
can we reference this 500 constant somewhere?
nit: truncate should be faster than delete <LINK_0>
You can eliminate these ifs by using String.valueOf() below. Using String.valueOf() where toString() is used is a nice approach in general, in that it works on objects and scalars alike.
... should **decrease**
Please considert moving this to line 421, and change this to positive condition
There should be brackets on the preceding while in order to make clear that the new code is intended to not be part of the loop.
So, you're silently ignoring the requested cacheName here? That's not correct. JCache CacheManager seems to support multiple caches.
1. Whatever this pattern is (see next item), should be a static, ideally; regexes are relatively expensive. 2. I feel this regex is more complicated than need be -- you're using lookaheads I think, whose syntax I always have to look up. They have their place, but can't you just have the pattern be Pattern.compile("dockstore|admin|curator|system|manager")? And then change line 273 to if (matcher.find()) { ? I may be missing a more complex case though. 3. I think you should leave a backdoor for admins and curators. We may want to use some of these for ourselves.
avoid contractions in error messages
I thought it nicer to catch it early instead of letting it fail later in some Ordering or such. But we can throw a NPE instead yeah.
The user is trying to access a partition that was not requested. I think we could raise IllegalArgumentException directly to the user.
You're assuming here that at least one gist exists in the account. This assumption is rather fragile. How about creating a new gist in @Before annotated method and remove it in @After annotated one?
Since we create the vectors above from its components, we could just use those directly in the constructor
Another case or just returning the conditional
Instead of creating a new Optional you could return the same one removed: instancePlan.
- This statement could be removed (treeContext is already initialised). - There are some mixed indentation chars.
Same suggestion as above about using the remove() function to instantiate the local updateHandler variable.
There is no lock here, you might check mListener, but it might get set to null before you access onSuccess. Seems like a race?
may be one line?
again, unnecessary double-retrieval.  scope = mgr.active(); if (scope == null) throw EmptyStackException; span = scope.span(); scope.close(); return span;
I don't think inputStream can be null here.
The real question is: How can we have a tab in the UI but no entry in nameToChatTabController? That should not be possible, so here we're just concealing a bug. Hint: synchronize access to tabPane.getTabs() and nameToChatTabController on nameToChatTabController.
Wouldn't Assert.hasText() be more appropriate?
Why not using this http_prefix variable?
What if the scan's filter is a FilterList that contains a PagedFilter?
We want to avoid using PlatformUI.getWorkbench() at (almost) all costs. We should instead use the ContextModel, just in case we're making multiple modifications.
Wouldn't it make more sense to have this in the setters? Sorry for being a pain. I think we are almost there.
this needs to return responsesObject (converted to Map) or responses depending on null status of the two. see how this is achieved for responseSchema and schema in response
I don't think it's required.
No need to do this every time, just make a field in the constructor.
In order to have consistent behaviour, if there is an empty result, we should return a 204 NO CONTENT response instead of an empty 200 OK.
Use enum instead of boolean
We decided that seats are linked to tickets. How would this work if 1 user has multiple tickets?
We usually static import these sorts of things
Not necessary.
Can combine 2 lines above and use constructor which receives disk-id
Should we throw new UnsupportedOperationException(); here the same as in UnsureResponse as it should never be called?
missing null check
usually errors are logged with the following pattern  logger.error("Error while parsing diagnostics", e)  any reason we are doing something else?
I'd love to see some docs on the scope of the AppRunner - currently, appRunner.run(app) allows for multiple applications to be run with the same instance of the runner (atleast the api does not disallow it). With this change of instantiating the StreamGraph in the constructor, are we restricting the scope to running a single application? If not, how do we distinguish StreamGraphs of 2 different apps on the same runner
We're getting long enough here that I'd be tempted by a small Builder, particularly as it's pretty easy to switch revpos and seq by accident in Java's world of unnamed arguments.
Will we use a different configMap than this one for storing the completed checkpoint pointers? I no, then onModified could also been called because we added a new checkpoint pointer.
Log a message describing what is being cancelled.
can you collapse these conditional branches into a single boolean expression?
That implies next can be called without preceding hasNext call, is that possible?
Shouldn't this be passing through the parameters 'timeout' and 'timeUnit'?
Collections.unmodifiableMap?
I think it would be simpler that we let the caller checking this dependency but not the record method. So just do if (stateChange) {} if (dataChange) {} if (sessionExpired) {}
waitForElementClickable()
static import getDeserializerClassName
before click wait for element clickable (ajax thing)
This should be java.nio.charset.StandardCharsets#US_ASCII
try to rewrite to addedEnvironmentVariables = new HashSet<>(); without this and space in constructor.
nit: probably enough to just say Cannot provide both Refreshable and Supplier of runtime config?
@vilchik-elena The RSPEC (rightfully in my opinion) says: primary location on extra "(" and secondary location on extra ")". Your location is the whole expression. This is too much, as in:  ((function(){ // all your code here var foo = function() {}; window.onload = foo; var a = 1 + ((2 + 3) * 4); var b = 2 - (1 + ((2 + 3) * 4)); var c = (( 1 - 4)); }))();  (the whole function is highlighted)
Flip the arguments here, since for JUnit (unlike TestNG) the first argument should be the expected value, and the second the actual one.
try to use Integer.toHexString with padding correction
Here we catch the ClassCastException to check whether the inpustream has implemented an ByteBufferPositionedReadable interface ? I don't think it's a good way, because the catch{...} block need an full stack and not so efficient . How about use the following : java if(in instanceof ByteBufferPositionedReadable){ //... }else{ throw new UnsupportedOperationException(...) }
Reschedule another attempt? If the Agent port is enabled, there is no valid use-case for the dead thread. It would also indicate that there is a pending problem if the thread is alive and rejects to stop
isNotEmpty to be safer?
should this be joining(", ") ?
rename 'viewPart'
[minor] Space after Exception
We should probably just use a try with resources here. At a minimum we'd need the close in a finally block. Something like  public static boolean hasLogMessage(String logFileName, String logMessage) throws Exception { boolean found = false; Path logPath = LoggingUtil.getInServerLogPath(logFileName); try (BufferedReader fileReader = Files.newBufferedReader(logPath)) { String line = ""; while ((line = fileReader.readLine()) != null) { if (line.contains(logMessage)) { found = true; break; } } } return found; }
let's rewrite these tests with java 8 love like in Throwables_assertHasMessageNotContaining_Test. should_fail_if_actual_has_a_message_containing_some_of_the_given_strings: java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; // GIVEN AssertionInfo info = someInfo(); String content = "expected description part"; // WHEN expectAssertionError(() -> throwables.assertHasMessageContaining(info, actual, content)); // THEN verify(failures).failure(info, shouldContain(actual.getMessage(), content"));  I think this is much more readable and elegant than try catch (due to the tests being written for Java 7 at the time).
This can be combined with the above if since both blocks return false.
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
This else is not needed.
suggestion Set<String> capabilityNames = capabilities.getCapabilityNames();
The synchronized can be removed.
Probably the following java Preconditions.checkState(updatesEnabled, "Cannot make updates after calling mutate."); mutation.putDelete(TabletsSection.BulkFileColumnFamily.NAME, bulkref.meta());
spell out ret
If the User supplies a value x < Integer.MIN_VALUE || x > Integer.MAX_VALUE you're going to default; however it could lead the User to be confused as to why the generated salience values were not as expected. I'd be tempted to at least log the substitution of their _provided_ value with the _default_. TBH I thought you'd eluded to throwing a RTE when we were discussing on IRC.
createURL accepts a lot of parameters. for a better readability please use local variables to name them, e.g.: createURL(spaceName, docName, action, queryString, anchor, wikiName, context)
Not sure if this is still needed.
why static?
little space missing here ;)
remove
This is effectively final class, so just throw new UnsupportedOperationException()
Don't store selectedExperssion as a global variable. Retrieve it inside the method.
Why do you set property to the outer class field? Please refer directly to isVoidContext from inside the same object: java isVoidContext = voidReturn;
getClusterId()
Bad variable declaration.
this is a bit weird. Why isn't this function in the inner class that uses it?
Mixed indentation chars. (There's an extra space after the equals.)
I do not think it is a right fix, because it would impact the XML loading from what I see
The user may have selected a project. It seems to me like this check should also consider that?
FYI, 2 can be replaced by ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER
getListeners() is already synchronized, why do you need to synchronized(this) too?
fSelectedThread is mutable and nullable, and this method is not synchronized, which means it could change after this check and still throw a NPE. It should be extracted to local variable.
In my opinion we should handle exceptions from processing signals here, especially those that could be thrown from updating topic or subscription.
Hmmm, this might be problematic in the future. If you start a cache manager and will be clustered, it needs to be amended via TestCacheManagerFactory so that it uses different mcast settings when talking to other clusters, otherwise it can create all sort of funny situations. In general, all cache managers should be created via TestCacheManagerFactory. It's there to do the right amendments to the configuration to work as expected in a multi-threaded testsuite.
is normal to have a / ?
Can use parseLocalDateForSessionsForm here
This line can be moved up to the @Before method too.
This will create 4 connections and not 3. You either init the index with 1 or use '<'
won't this throw a parser exception if the json is malformed?
LinkedBlockingQueues are synchronized, I don't understand the need of this notify call.
That's not logic for this method. If we are here, we have to be already sure that it is our own group. The real problem is definitely in the ForceReleaseMessageGroupProcessor implementation. We have to check for its presence there. All other logic should not be affected. Please, make this remove() method protected.
Here we're just testing the same things twice, right?
Abstract classes should have either abstract or final methods, nothing in between (preferably). Mark this method final.
let's do split and trim, without regular expressions (first regular expressions are often error prone, second they might introduce security problems)
Could we factor out the reflection? So we deal only with the value in here.
Not backwards compatible.
remoteTimeout() is the correct one.
Isn't log file moved after sometime ? Can we get that new path ?
A simpler way to do this would be to make this just bool(state.get("ScoreBoard.OfficialScore") without the state. We can then filter out the Clock changes if we want to.
static import
can be java public Seq<E> getErrors()
In classes that implement Comparable it's preferable to implement equals() as this.compareTo(that) == 0 after the initial type checks.
Even though these two are "CMAS Severe Alerts", shouldn't getCmasSeverity() still return CMAS_SEVERITY_EXTREME? Spec says "Severity of Extreme, Urgency of Expected..."
Why do we need this? Is it necessary in test?
If we are using equalsIgnoreCase everywhere, should we really change the data? There might be other reasons we are converting to lowercase.
Did you mean findFailedChildCommands ?
Should this just make a single call to CoreUtils?
Needs some validation on the value itself. Even if it is provided by our implementation, just defensively check the argument.
Let's inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml());
I don't see any reason to get the analyzer name from the PropertyMapping instead of passing it to the constructor directly. It just pollutes the PropertyMapping class with information that shouldn't be relevant to anyone except this class.
Please add access modifier, private probably?
Not a deal breaker but line breaks should be present in long lines. For future reference
suggestion if (keyedStateBackend instanceof CheckpointListener) {  Ditto.
Are you not using the Eclipse formatter? The project owners are pretty strict about so changes are easier to track.
cannot remove this?
- When user haven't made any selection, then 'pendingShowItem' might be null, so we should add a not null check in above if
What does this snippet do?
change to : java protected void closeWatchRequest() { if (this.watchRequest == null) { return; } try{ WatchCancelRequest watchCancelRequest = WatchCancelRequest.newBuilder().setWatchId(watchId).build(); WatchRequest cancelRequest = WatchRequest.newBuilder() .setCancelRequest(watchCancelRequest).build(); watchRequest.onNext(cancelRequest); }finally { this.watchRequest.onCompleted(); this.watchRequest = null; } }
return Optional.ofNullable(language.getFileExtensions()).map(Collection::stream).orElse(Stream.empty()).anyMatch(extension -> path.endsWith(extension)); ?
this breaks the replace untyped subapp with extracted type feature I recently did. I think the problem with my code is entry is null for update type and non null for change type. Therefore a fix could be to put in the constructor an else{ entry = fbnElement.getTypeEntry(); //or what ever the correct method is } Withthat my canexecute should work. also some other ifs below could be removed with that.
correct to "All categories were clicked" not "was"
can we have a constant instead of 100
Collections.<String> emptySet()
this convert should do some logic (e.g. if the source is null than return emtpy list or something like this). Here it would be enough just to "return source;" or have no converter at all.
The throws part is still there. This part should not exist.
I had to add this; otherwise, the interface java files were just removed. Methods in interfaces are public even if they are not marked as such. An interface could have a default method whose body should be removed, so we may want to fix this some other way.
This if check isn't particularly useful.
I know this synchronization pattern was before the change, I'm just confused what it tries to accomplish? ie, if noBitmapRealtimeIndex is not created then all threads can initialize noBitmapRealtimeIndex simultaneously, doesn't it look strange?
The status is supposed to be for human information, so using it for code logic is a bit dangerous. And I only see a setStatus("Done"), not "DONE", which shows why this is brittle. You should at least use a constant in both places to show commonality. But why do you even need to check the status, given that onGroupJoinCompletion() seems to only be called if the work ended successfully?
Why making it final?
Actually the logContext.logPrefix() should have the format of stream-thread [%s] task [%s] already, so all the log4j entries are good. For exception messages, we can just get the prefix and then encode that into the exception message.
This is a duplicated check, as this is only invoked after command.hasFlows() is true, so not required to invoke it again. If you absolutely want this check, I'd opt for java if (hasFlows != null) { ... }  as it is much easier to read.
Needs to be "getLocalizedMessage()"
Do we need to throw an exception here? Silently dropping the volume may not be a good option.
Could use a lambda e -> performAction().
Why are we using hash code here? And it doesn't feel right to me to change the state of the object with the hash code like that. Correct me if I'm wrong, but after calling this method, if the name is foo-123 (123 is my hash code), if I call hashCode() on this object now, I won't get 123 again. If that's the case, we shouldn't advertise this as the object's hash code. I'd take a random UUID personally...
s/5.0/5.1/
Better message i think is "Error : trying to retrieve session from disconnected client." Also should this beat warn level?
Can we add some description? Does deregister mean only deregister interest but keep it for as long as lease_duration expires or it means you revoke it right away?
If line 33 throws an error this line won't be reached. Prior this PR that delete would always be executed in a finally block.
The cast is no longer needed
You are not setting the endpoints for this client
I think we should create a defensive copy of the Map
Don't print the stack trace if you are going to rethrow as a cause
Ranges.open(junoStart, lunaStart).contains(version) makes for more readable code. I'm not sure which of open(), closed(), opendClosed() etc. is needed here.
Imho this error doesn't imply that NULL is returned... What's the end user supposed to do here?
Can you make 0, 4 as static final variable? e.g. TYPE_VALUE_OFFSET, VERSION_OFFSET
Could store database.getId() in a variable. Also, some places below.
This line does not need additional logic for the unsupporting languages. I've updated my patch to fix it. Please try to rebase your patch, thanks!
In this use case, we are defining default behavior for the user in the case of passing null. We don't know if a user wants true or false, but we're forcing using one of these. The same rule applies to all of the changes below.
Wouldn't it be easier to leave the project method unchanged, and here just return: return project(mq, input, projects); ?
This changes the behavior to no longer notifying the player whose gamemode was set.
It was recommended to use the existing DGVa branding, so these details should be converted into: * Database of Genomic Variants Archive REST Web Services API * the Database of Genomic Variants Archive team * www.ebi.ac.uk/dgva * dgva-helpdesk@ebi.ac.uk
It would be clearer if "6" was replaced with EpdqStatusMapper.EPDQ_AUTHORISED_CANCELLED
Since this won't change I'd move the loading of this information into the constructor so you don't have to do file io every time this is called.
Why this change on ReplaceUnderscores? (sorry if you already explained it, I don't remember... )
Need to use a reusable buffer.
>byte[] [](start = 11, length = 6) We're updating all methods to return a data structure rather than a simple type for forwards compat. This should return DecryptResult which has one property plaintext.
final
I'm ok with that
internal methods are still in use.
This can be combined into one line.
missing return?
I think the exception needs to be serialised and sent back from the server. It might not always be an IOException. Right?
Maybe worth adding the pattern to Util? public static <T> List<T> Util.unmodifiableList(T[] elems)
I think its cleaner to do Boolean.toString(Boolean.parseBoolean(distribute)). That way, you're not having the string "true" in your code.
I think it is better to use MAC_POOL_ID here and avoid assigning to resource.guid later, that way this test won't need changing if resource.guid is changed or its visibility changed.
Change "so" to "and" probably (I think it sounds better)
I'd inline this variable.
Probably this should be return NullHandling.replaceWithDefault() ? false : doubles[index] == null.
@jomarko If there is nothing preventing this, move all those "context.getScenarioGridPanel().setFocus(true);" inside commonExecution
Check if nativeVideo is null. This can cause crashes.
What else do we do with the HLLs? Could we exercise all that as well if it's easy?
use ShellIsAvailable
why do we need this change?
LOG MAN LOG!
no need to compare against 'true'. just: .when(provisioned && computeResource == null);
This uses eager string concatenation in a lazy parameter, which is typically a blocker. Now, this is not a performance critical path, but I would still suggest to avoid this, because it sets a bad example for other contributors to immitate (in then more critical parts).
StringBuilder
Why the difference depending on API level? Just curious.
wait.forElementClickable
Is it possible that start > end? IIRC System.nanoTime should be safe, but not sure about getCurrentThreadCpuTime(). If somehow we get start > end, the abs value of start-end will be a junk/incorrect measurement, do we want that? Or do we want to omit such measurements? (I prefer latter btw).
should be checking against 'configuration' on the 2nd assert (copy-and-paste error: storage)
Let's just cut it if we can. All configuration should be done in the constructor (or sooner).
Please ping Alexey or Joe Wertz about this. I have the same concern here about an API change as I have with displayResponseHeaders, and this looks to be a bigger issue as the method is overridden quite a bit. Perhaps add this method and leave the existing one, and then call to the existing one before calling handleAttachedFile. That's a more complicated API but doesn't break anyone. That's what I've done to evolve controller classes like AbstractAddStepHandler.
why not: return result.addAll(cacheMap.keySet());
We do a newline after annotations (in 99.9% of the cases). But please leave it as-is. I will reformat the whole codebase soon according to our formatter. Maybe I will take that opportunity to customize the Sputnik/Checkstyle rules then.
are you sure both are mandatory? i think at least updating "action" *only* makes sense, no?,
this can be extracted to separate method further simplifying this method. Do it if you want, I do not insist on it.
a UI/UX consideration - worth noting also that today's date is highly likely what the user wants, given that stewardship events are likely to be added when they are carried out. I say this because my initial thought was "If we default to accepting to today's date, that's what the majority of users will choose". It turns out that's ok.
If groups (and their subscriptions) are not durable - based on <LINK_0>, then maybe it makes sense to shut down adapters for groups that aren't listening anymore ?
rename 'child'
ImmutableList.of
unnecessary line break
Since we will serialize as Map<String, String> getFromMetricsMessage will return a Map<String, String> that needs to be converted to Config like this: new MapConfig(getFromMetricsMessage(GROUP_NAME_FOR_DIAGNOSTICS_MANAGER, CONFIG));
This line may be executed many times. Do filter comparison without creating temporary objects. This can be achieved by preprocessing of filters.
It's funny you could mutualize the code and send the status? no ?
So you first set this.keywords to a non null value, and then set it to null? I guess you wanted something like:  if (keywords == null) { keywords = new ArrayList<>(); } this.keywords = keywords;
I didn't see any system test for config-tool repair unlock
It looks weird. Do we still need getHivePrincipal for the AuthorizationUtils? We can move the implementation of these three APIs to the translator. And remove that in AuthorizationUtils.
static import wrappedBuffer
I think we can keep this "final".
Copy-paste in the exception message below.
Similarly, you might want to create a new Set based on the set you received, to ensure the contents aren't changed by some external object.
How come we don't reuse KeyBasedMapOperation#threadId since it's already there?
Usually, we do the opposite: the constructor with less parameters call the constructor with more parameters (with default values). java public FakeTestNGMethod(Class<?> clazz, String methodName) { this(clazz, methodName, null); }
use new Guid(String) - this literal can't be null
It would have been shorter to inline this variable and not have it in scope. :-)
Is toString() required? It's already of STRING type.
move the check and assignment before the other checks to ensure the behaviour is not changed.
might it be clearer if you said rawBytes.length - (endOfTableName + 1)? not particularly fussed here
EDIT: this is identical to what Liam just said. Just making sure I'm following along - this bump from 8 to 10 is to allow for these two new log lines, right? ([75](<LINK_0>, [106](<LINK_1>
[minor] could you name it resourceGroupName
UtilKtKt isn't a great name.
consider using a switch(res) {...}
For PerunObserver you can return all resources immediately.
UDP is a datagram protocol, so it doesn't require frame decoder.
Maybe we can return an empty Properties here (perhaps a static constant empty props so we don't create a new one for each instance). It would save a null check everywhere that uses it.
Why this change?
you should check the cache doesn't exist, plus that no suggestion to use the cache is logged
Make sure to unescape the url path before using it. I've hit this in actual usage.
A future refactor might place this method in the enum directly.
We have ASYNC_INIT_DELAY * 5 + 1 twice here (well, the other time, it's 5*AID+1 ). Is it worth extracting a constant here, like SEVERAL_INIT_DELAYS?
This bloc of code is repeated many times, should be centralized in a single method.
I don't see sense from this if (MobileContextHelper.isInWebViewContext())
This if-else block can be simplified to: menu.findItem(R.id.menu_item_search).setVisible(config.getCourseDiscoveryConfig().isCourseDiscoveryEnabled())
@JimDeanSpivey can we go with a foreach? for (final LineRange range : ranges)?
Do not try to parse the sever list if the command has failed (mStatus.code != 0)
Floating semicolon
please use long
Probably safer to replace the null check with StringUtils.isNotBlank(changelogPartition)
Why not use capabilities directly here?
Do you assume that if startColumn is not null, endLine and endColumn will not be either? Or is it fine to have two last as null? If it's the first case I think we should also check them!
@ekondrashev why not just rsp = opt?
Why use a java.lang.Boolean and not a primitive boolean?
merge the try/catch with the one below?
Probably just wants to be start or startPhase or something if now generic.
nit: any chance to make the message assertion more specific? :)
We can do the same thing here too right?  public List<Modification> latestModification(File baseDir, final SubprocessExecutionContext execCtx) { P4Client p4 = getP4(execCtx.isServer() ? baseDir: workingdir(baseDir)); return p4.latestChange(); }
java if (GenericUtils.isEmpty(expected)) { return new Pair<>(false, getFingerPrint(key)); }
We don't need super here
Exception is never thrown within this method. suggestion public void testStartProcessFromNodeIdsWithTimer() {
also here please use Short.MAX_VALUE
This synchronization block should be replaced with a collection that handles concurrency, like ConcurrencyLinkedQueue or Collections.synchronizedList()
log
Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap
Do you want to check if the thread count changed because right now this log message will be logged on every catalog update which affects kipling
please move compilation of pattern to class field, to be done ones, for whole execution of checkstyle.
indentation, here and rest of PR
Replace with Objects.requireNotNull.
I wonder if this change would result array allocation and extra cpu/memory consumption issues
May be static imports for TimeUnit values here and below?
Similar to DistinctCountAggregator
Statistics-enabled were introduced in 6.3.0, so there is no need to set them to true for 6.3.0, only for 6.2.0
I think this could just be: if (searchPacksAgain(pList)) continue SEARCH;
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Flowable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
I would prefer the use of local variables to resolve calls to something.somethingelse.somefunction()
You could just use String.replace() to replace the ROLE_PREFIX with an empty String and use the resulting value as the role name,
you can use parameterized logging here
Style nit: unneeded curlies
fetch should already happen in Service
I'd do the increment outside of the if (log.isDebugEnabled). The call is cheap, and if the log level gets changed on-the-fly to debug then we want the message to have an accurate call count.
Return early so you don't enter STARTING state? Call handleStopKeepalive with ERROR_INVALID_PACKET?
Unrelated change. Should be in a separate commit.
this may impact web-ui code. Do we want to expose Snapshot in API?
This seems to fail the test when SmartLock for Passwords pops up the dialog for selecting a saved email/pass combination.
Replace with logger
I still think that this is pretty strange. What about just returning a FrameLayout in onCreateView and re-inflating its content in onConfigurationChanged?
Sounds like a workaround for host misconfiguration issue.
Could you please rename also _result?
we should probably check in the canExecute whether we reached the start of the list
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Is the reason that we have to have isIncludeAllProperties because of the search index? Seems like we would really only need the one you loaded.
The Exception is never thrown.
nit: call it uae?
repeating code line.
if we attempt an operation and it fails, recordFailure will be incremented, but recordError only tracks the cases where the when we encounter a problem that the framework cannot retry or skip. In the first case, we may still be able to retry or skip the record. In the executeFailed scenario, we should recordFailure() every time, and only recordError only when we have to fail the task.
Better way to get the proper schema is to say dataContext.getDefaultSchema() ... taking schemas[1] is actually not guaranteed to work since schemas are sorted alphabetically and then you rely on the filename (which is used as schema name) to be sorted after "information_schema" :-)
assertFalse is kind of weird here (it's like saying we expect that it should be anything but self). Can we change this to assertEqual (and the following assertFalse(s) as well)?
I should probably have asked this in the previous review, but why "addFollowingAccounts"? We don't talk about accounts mostly in other parts of the code. It could be ambiguous with the BIP32 feature of the same name.
throw exception?
Please change user back to USER_YODA here.
What is the use of this metric? There are no I/O or cpu intensive stuff being done within this method.
Could you: - call TreeUtils.annotationsFromTree() - use AnnotationUtils.containsSame to look for the annotations Then you don't need to change the visibility below.
It would be better to make value a constant too
Don't we need to reset alpha here? Drawables share a global state.
Initialize it to Collections.emptyMap() right away so you can forget about the null in getOpenstackMetaData(). It will also save some unneeded allocations.
I guess you mean !o.isNull("name")? Which by itself would be enough. No need for the o.has("name")
Since we're not doing any extra validation here this is confusing to me. How about java if (fields.isEmpty()) return new Factory(delegate); return new RealFactory(delegate, fields.toArray(...
Missing Unstable attribute.
Shall we extract that setup step? It's repeated in every test below.
rename 'variableName'
Good catch, thanks. Fixed <LINK_0>
The cleaner way would be to use nio classes only: Path path = Paths.get(fileName); if (Files.exists(path)) { // yada yada
edgeCacheDNS as a static variable since it's used a few times?
If a future completes successfully and returns null, then do not want to take the exception handling path. Maybe the code should do : java if(exception != null) { //handle exception } else { //handle result }
The DAO should not swallow exceptions. Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).
Let's do the same way @jleandroperez did on iOS here <LINK_0>
Are there any PA genres that we don't have a mapping for? i.e. is this an exhaustive mapping? We're gunna get nulls in our Set otherwise
let's make constant with "web-java-spring:stop tomcat" command: STOP_TOMCAT_COMMAND_ITEM_NAME
what does this do if key is null?
The output of this call should be checked and if it's false I think it should bail.
@ikhvostenkov please name it json
why var4? Resources.NotFoundException e would be a bit nicer..
Mutualize with the other matcher on tags
suggestion deletedAlarmIds.forEach(alarmId -> {
You don't need to call the validator, it's called automatically via AOP advice around the saveObs method.
power down
I don't think "resolveMember" should create a new symbol. We should find another approach
Let's make this InternalServerError
1. unless there are other reasons I'd rewrite this as context.get(Config.class).getRendering().getDebug(); and I'd avoid storing the config. 2. Can you check if by any chance the RenderingConfig class is available straight from the context?
Just want to make sure I'm understanding this correctly, previously we weren't looking at these childnodes but now we are?
Why not extract receivedId before switch block? (reduce the duplicate code)
Feels like this null check can be included above.
This method has a really weird contract. 1. Why is it public? 2. Why does it return its incoming argument without any adjustment? The name of the method makes it seem like this would be returning the total offset instead of the size. The methods in the non-delegate writer all do this call first with the name "verify" which makes it clear that the intent of the method is to do some state checks...
I think this test should be moved to options instead
Since the classes in the cache are now changed, we shouldn't do this. We can either change the keys here. That will give us new space in cache. Or we can delete the cache on app update.
You could have LAUNCHER_NAME be an abstract method in the base class, and print this message in the base class.
what is this doing? Is there a reason we are setting the max frame size to anything but rsocket max frame size?
call intValue() and then there is no cast
I think you can probably change the return type to List<? extends Target>
This is passing isBackgroundLogic but the param name for processJobForDisplay is callForegroundLogic. Seems like we are flipping the logic here when we should not? Or just one of the names wrong?
I'm pretty sure it ends up being lower cased because the registries do not support capital letters.
Why is this changed? We want to resolve the product content on the incoming data (pinfo) not the existing product (pdata)
Remove /Dev Team
I see no reason to introduce msg here, you could just use serializedPayload
Isn't (ctx.executionMask & MASK_WRITE) == 0 && (ctx.executionMask & MASK_FLUSH) == 0 the same as: (ctx.executionMask & (MASK_WRITE|MASK_FLUSH)) == 0
@fraggjkee Would recommend to put something to make test fail if inside the catch block. Because right now the test will still pass even if parsing completely fails (line 43). After a quick look I found the following method to do the trick: junit.framework.Assert#fail()
Need a null check here.
This is actually not an effective way to test that the exception is thrown. If the exception is not thrown, the catch block is never executed, so the assertTrue() will never fire. You should instead use a pattern like try { lock.acquireLock("key", 10); fail("expected exception"); } catch (LockNotAvailableException e) { // stuff } I frequently like to extend this to Exception thrownEx = null; try { lock.acquireLock("key", 10); fail("expected exception"); } catch (LockNotAvailableException e) { thrownEx = e; } assertNotNull(thrownEx) as a double-check that we did indeed throw an exception.
Two ;;
Test the change against an account in prod tenant which still doesnt have Dec-12 bits .
verify(client != null, "client cannot be null");
Since a lot of these catch blocks have essentially the same error, it'd probably be better to use the multi-catch syntax, just to clean things up a bit. The original exception should be passed as a parameter, so we don't lose portions of the stack trace.
Should TREEHASH be a HashCode?
I'm not sure we actually want to eat this error silently. A parse error here means that HQ is setting the header, but in the wrong format, which means that the phones will all just silently fail to properly use the feature correctly, but without anyone's knowledge.
Seems like all of this could be extracted into a strategy function to compute the topic given the table ID (e.g., topicName(TableId)), and a second method to compute the partitions for a table ID (e.g., sourcePartitions(TableId)). We could have separate strategy implementations for each protocol version, and a particular strategy implementation can be passed into this class.
:question: is it safe to use Charset.defaultCharset() here? Some systems have different default charsets. For example, Windows vs Linux.
the original code does not make toLowerCase(). Why did you add it?
Shouldn't it be No handler was subscribed **for** command?
This is again an assumption. Anything in the try block can throw IllegalStateException right? I would suggest logging the exception message here.
Shouldn't we call PostLocation.companion.equals here?
Please don't use sysout. Logging is your friend.
You can replace java if (tfj.getTask(name) == null) { throw new JobCreationException("Unknown dependence: " + name); } else { t.addDependence(tfj.getTask(name)); }  by java t.addDependence(Optional.ofNullable(tfj.getTask(name)).orThrow( () -> new JobCreationException("Unknown dependence: " + name));
Should the condition here and the condition on 153 the same?
what if the VM is highly-available (so it was automatically restarted) or the user managed to run the VM before coco got it? I think this command should lock the VM but it is tricky..
Assert.fail inside a callback like this seems kinda weird -- usually asserts run inside the main test code. Would it work if this is just a re-throw? Like throw Throwables.propagate(e)
You missed new StringBuilder().append("[Test: \"").append(m_name).append("\"")
See above about not blocking the calls for futures. In any case it is probably less verbose to just block and work with the result directly. Also, the contract for Store#renameLabel is that if one checks that the current name exists and the new name does not exist before a call to it, then if the #renameLabel call returns successfully and the future does not contain an exception, then the label should have been renamed. This means it is not strictly necessary to test that the label is renamed here, it's enough to call #rename and block on it to make sure it does not contain an exception.
Twice the same call.
what is a PropertyValueWrapper? Why do you need it?
Please don't do unrelated refactor work next time
This check seems a little fragile at first glance (not sure why.)
If I understand correctly the *_KEY strings aren't needed now, and what you want to do here is pass to "params.setAffinityGroupMap" directly the result of "mapAffinityGroupMapping": params.setAffinityGroupMap(mapAffinityGroupMapping(...)); What am I missing?
Add invariants
just pass sparkJarFilePath.toString less number of changes will be required in the code.
Nitpick: Please pre-compile this value on class creation by adding it as a private static final   line below the definition of searchProviderUrls above.
The same.
The phrase "repartition" has a better ring to it. But here I prefer partitionBy for 2 reasons: 1. Consistency between the operation name and the operator spec name. 2. REpartition implies that the input data is already partitioned in some fashion. PartitionBy implies nothing and just describes what will be done with the data.
Need to be a bit careful here since getRealmIdentity should only return a non-null value. I think we should throw an IllegalStateException here if we have a null value at this point.
We tend to use IllegalArgumentException for these kind
Conditional is more clear as: !getZooKeeperInstance().isEmpty()
If we encounter the opposite is there anything we could do to fix it? Or would it not matter?  if (latency <= 0) { LOGGER.trace("Computed a suspicious latency of {} for {}", latency, operation); return; } DistributionSummary.builder(...)
This seems to be unnecessary. I also get the label after removing this.
@jomarko Thanks.. I'd have made this Integer.class.getName() too
Log/throw?
StringBuilder instead of StringWriter would be more traditional choice, not that big of a deal though.
this should be on System.err
I don't think the new method resolveProvidedProducts is needed. We could simply use the existing resolveProduct/resolveProducts methods to lookup any existing provided products we have, assuming they were already created. spec tests would have to make sure that the provided products are created first, and then create a marketing product that references them. The only reason the resolveBranding method was created this way was because you can't really create a branding standalone. It is an entity fully owned by a product.
read the values and validate
How can this work? This is going to insert MAXED_POOL_MARKER into the bag.
No need to explicitly load tables with query if you are using the latest build
Could we move this call elsewhere given that in some cases it becomes unused? (e.g. if partitioned and partionedIndexName != null then we don't use the result here)
not a field
the line .map(l -> l.stream().findFirst().orElse(null)) might be equivalent to .flatMap(l -> l.stream().findFirst()).
I would suggest providing more clue about the exception like  throw new IllegalArgumentException( "startTimeNanos [" + startTimeNanos + "] should be greater than 0!" );  to help debugger a little bit.
remove this log
is double call to structIsNull.toBooleanArray() intentional?
suggestion log.debug("{} old entitlement certificates deleted", count);
Make the code fold to the next line when the code is too long. And probably put this text in the strings.xml?
Seems unlikely that dataRef would be null having just assigned the result of a class constructor to it.
static import
byte[] sysMutexPhysicalTableNameBytes = getSysMutexPhysicalTableNameBytes(); If I understand correctly what @ChinmaySKulkarni described in the ticket, this call will still result to an admin.tableExists call to check the existance of SYSTEM.MUTEX/SYSTEM:MUTEX and you didn't changed that.
[ERROR] alluxio.client.file.cache.store.LocalPageStore.get(PageId, int) may fail to clean up java.io.InputStream on checked exception [alluxio.client.file.cache.store.LocalPageStore, alluxio.client.file.cache.store.LocalPageStore] Obligation to clean up resource created at LocalPageStore.java:[line 78] is not dischargedPath continues at LocalPageStore.java:[line 79] OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE
This statement slot.getValueList().getValue()) could cause an NPE
columnStatistics
Why do we handle error like this?
Why parseDouble and then convert that to int instead of directly parsing to int ?
This can be removed? (Being added later.)
please move it to line 168, just to make it look cleaner :)
Do we missing some enums here?
The change to Optional requires now to do a check here for presence and a get at line 87 and 85 which internally does that same check again.
Suggest JSON related capabilities be isolated to the JsonUtil class.
What if it takes longer to initialize? Would it be possible to use something like await().atMost(1, MINUTES).until(() -> kafkaProducer.isReady())?
The code point loop that now exists in this CodePointCursor is sort of duplicated elsewhere too. Would it be a good idea to port those places over to using it too? Also such objects will probably be optimized away since they don't escape this method, right?
what's the reason for this extra variable container?
We should first find out if we have to select one/deselect all and then do the right thing in the UI only once after the if-block. This avoids unnecessary UI changes.
check if monitor is cancelled?
These should be done through a sink.
If the length of the legal last name is already the max length, then the legal first name would get truncated to an empty string. I think this code may handle it, but if you put in an explicit check for that, it may make the code intention more easily understood.
How about raising an Audit log for failure? Otherwise, it may be difficult to track which snapshots failed
I'd go with if (fileEntry == null) {return false;} without else allowing to remove one indentation level for the successful case.
Making the hierarchical project representation default breaks the test coverage. I ran the build on our CI, you should be able to check the results [here](<LINK_0> (credentials: guest/guest). If not, please let me know.
Do not like the idea of an automated test relying on some mutable repository in some personal account.
Calcite allows a pure string interval value, if BigQuery only allows int64 format, we should check and throw for other non-integers values.
I wonder if for future-proofing this check should come _after_ all of the internal ones? Seems like we might want to default to the assumption that we override the superclass's parsing behavior if we supply our own parser for something.
can we java docs about what formatDateString is used for?
same typo as above
Can simplify using Objects.equals <<LINK_0>,%20java.lang.Object)>
Since there is no marker, It seems that containsMarkerForEmptyTxn should be false.
Why is MillisecodnsPerSecond a function. Sounds like it should be a constant
is that needed? is not isAutoRefresh sufficient? In any case, forceRefresh represenatations will be refreshed once because representationsToRefresh is a set.
Add a check here to verify that the serialDataReceived method was not called.
suggestion "The @MessageHandlerInterceptor must be on a method."));
build the log message when needed
New local variable does not seem to be used anywhere.
wonder if here we should remove the tbl_posts.is_wpforteams_site and tbl_blog_info. is_wp_for_teams . wdyt?
Can we not duplicate the text here?
suggestion if ((en instanceof GunEmplacement) || (en instanceof FighterSquadron) || (en instanceof Jumpship)) {
please remove alias setting (should be encapsulated in addManagedDevice
This can be replaced with a lambda. Also some nesting can be removed from the conditional:  java boolean isDoubleClick = ... && ...; if (isDoubleClick) { ... }  In future we can factor this out further maybe, since double clicks are fairly commonplace.
This assertion should not be removed. It fails because getPayload() now sets the position to 0 before returning the ByteBuffer. Then flip() will make the ByteBuffer empty (limit=0). But it should not have been called! It should have reset the position to 0 instead (but even this is no longer necessary).
append "from state manager"
RFC7252 responses may be piggybacked. If so, a ACK for a ACK is not compliant. Dose OSCORE change this? Are piggybacked responses not used with OSCORE?
What if Clock.currentTimeMillis() + timeoutMs overflows?
I'm a little confused by this, and its likely just me not knowing the full code. Why synchronize something that you're spinning off into a thread anyway? Are you getting duplicate notification? Are you expecting the thread to be synchronized as well?
extract false to a constant declared in the beginning of the class to declare the intent of the parameter, which then can be reused throughout the test file
:ant: safer to use  groovy def port = img.withRun('-p 12345:80') {c -> c.port(80)}
I'd suggest to introduce a lock to guard accesses to running and all other places where it is accessed. That way we will prevent concurrency when shutting this component down and when the ZooKeeper threads trigger an update.
Do we want to keep pretty printing on?
Works with two duplicates but what happens if 3 or more?
![MINOR](<LINK_2> 'Severity: MINOR') Remove this unnecessary cast to "Object". [![rule](<LINK_1>](<LINK_0>
without testing i dont think File.createNewFile will change the access and modification time of a file if it already exists?
Add check on list-length==3 here too? It would be a better error messsage.
I think for simplicity you can even have AddressHelper.getSocketAddresses method return Addresses and do the primary secondary separation internally (It seemed to me that such generation can be the responsibility of AddressHelper.getSocketAddresses). I see that the method AddressHelper.getSocketAddresses is only called from this place which should be an easy change.
I believe this is incorrect - if no configuration is specified, we should use the global configuration, not 'no' configuration (i.e. an empty Map). Please confirm with @alzimmermsft (and maybe ensure that all other client libraries aren't doing this either!)
supportingConditionValue -> supportingConditionStringValue
I think we should detect bad keys during initialization rather than runtime, store the cache as a field, and simply log rather than throwing an exception. The runtime exception can be controlled by resolutionRequired. We certainly shouldn't build the cache on every call, but it needs to be cleared/rebuilt whenever the mappings change.
There is no getIscsiInitiatorsByVdsIdAndStorageTargetId in InterfaceDAO only getIscsiInitiatorsByHostIdAndStorageTargetId (Host instead of Vds)
same here, don't requery and maybe use a single logger object?
I don't think these messages should be localized. Imagine a situation when you get an bug report from a user from China with these messages in the log.
The behavior as implemented seems appropriate. If called on a nonexistent file, we return false; if anything else goes wrong, we throw an exception. Right?
Actually, in that case the winding order parameter would be set, but with a enum value that is not handled here. So it would be good if the message would state that it encountered a parameter it does not know. It could also state the enum value's name.
Can be replaced with a lambda.
Do we always have to use amqpAnnotatedMessage even for messages that don't need this?
nit: extra space here
same as above. the new value should be lockValue
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
Any factory with parameters we could use for testing?
If "analyzeTypes" has its own methods, then there should probably be a new "analyzeServices" method.
Add this here: registerHandler(getView().getFeedBackImage().addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { if (feedbackLink != null && feedbackLink.length() > 0) { Window.open(feedbackLink, "_blank", null); //$NON-NLS-1$ } } }); This automatically deregisters the event handler if the widget is destroyed, preventing potential memory leaks.
can you please rename those intents to expectedWhateverIntent and actualWhateverIntent. its really hard to read the way it is now, and really hard to comprehend which part is test setup, which is produced by production code. also please move the assertion to the respective blocks where you create your expectedIntents.
You can avoid using arrays by using AtomicReference<>
Missing blank line. Don't know why the formatter doesn't add it in some cases.
@vidurananayakkara Do the necessary changes to fix above TODO
why we need totalNum != 1? I think currentNum <= totalNum / 2 also applies to video cluster where some colos have only 1 replica.
This should be removed
Please use a parametrized message <LINK_0>
Confusing parameter name. The type is that of the aggregate, not the event. The fact that it's the type derived from the first event, it not relevant in this scope anymore. I suggest using "aggregateType" instead. Also, the method should allow inexistent types if no substypes are declared in the aggregate, to ensure compatibility with 4.2, where aggregate type wasn't used to initialize an aggregate.
Can't we return just a value here? Why do we need a) Supplier b) Future?
I think we could improve further by hiding the isDefault parameter. There's only one default version, but all those calls have to mention this false argument, which is obscure unless you know what it is, or are in an IDE. We could just have addVersion for non-default versions, and a separate addDefaultVersion method
suggestion if (mMicToolBar == null) {
Why do you need both AuthenticationScheme and AuthorizationMode to determine if you have to retrieve an access token?
object not result
remove space at end of string
Ok, this is a bad message. I'm someone that says that there's no such thing as an expected exception in general, because exception really are an extraordinary event per definition. So 2 options here: 1. This is supposed to be an impossible condition, in this case throwing an IlegalStateException would be more appropriate here. It should contain a better message why this state is illegal though. 2. This exception might happen from time to time, in this case a simple message explaining what happened would be sufficient already.
Shouldn't need to specify the event types, as this is handled by the annotation itself. This is for remote listeners which we don't have access to the annotations at this point.
in main(), since this is a usage warning, please leave as println().
use Java 8's Optional.
This should be a tracef or removed.
Should not be needed.
isn't this a normal compensateURI which passed from user? so it can be user-endpoint:user-port/something/compensate? How can we be sure that parent LRA can be extracted?
Make these constants?
If run in the UI, when mutiple validators are used, this will lead to multiple dialogs being displayed to the user, each after one validator succeeded. It might be better to log normal messages here (e.g. info instead of userInfo) and provide a general summary requesting the user's attention after all validators completed.
should we add a sort here?
typo, should be timeElapsedMillis
The condition could also be changed to !brand.getChipValues().isEmpty()
I'd recommend updating this error message slightly to return the ID (as it's more useful to reference the problematic object). So, something like "The ID " + id + " resolved to a template item"
intend was fine before
rewrite messages without we
Would be better to make this test class based on the @RunWith(SpringJUnit4ClassRunner.class) anyway: less context loading - better performance! Yes, the outbound-adapter-parser.xml should be renamed to the CassandraOutboundAdapterParserTests-context.xml to be loaded by the Spring Test Framework.
What if the application name is an empty string?
But in this case, the uninstall part will be executed only if the script part succeeds, right? If script fails, there won't be any uninstallation...
Again naming
I feel like there should be a better way to build these strings. Maybe there should be a static method in every interface that takes a bool and returns the singular or plural or an enum with both values and then a function that can generate the string from count+noun maker. Just a thought.
nit: Expected value should be the first argument in assertEquals.
it appears appendTime now simply truncates at micro precision. that would seem to mean that nanos += 1000; would be sufficient here.
should this is isKotlinAndroid?
Please catch (IllegalParameterException e) directly (same in other methods)
Will this ever be true anymore?
Same here - this would be good to assert that the explain plan looks as expected once those changes are made.
Why did you choose 9999? That's a valid pid.
can start the search at nul: cmd.indexOf("\0\0", nul)
Instead of having to do this, should line 248 call TCMF.createClusteredCacheManager instead of addClusterEnabledCacheManager? This avoids the leak altogether.
it was written in lambda expression? any reason why you change it?
this default case could be merged with the 3 known claims above (which are dates as well), or rephrasing, this could be deleted: java case PublicClaims.EXPIRES_AT: case PublicClaims.ISSUED_AT: case PublicClaims.NOT_BEFORE: gen.writeFieldName(e.getKey()); gen.writeNumber(dateToSeconds((Date) e.getValue())); break;
please also set invoiceDetailEntity.AD_Org_ID here
Why have you made this public?
Should we pull this string into a constant?
I think this is in-correct. Don't we want to use getIdleTcpConnectionTimeout ?
why not check for null?
this should just be " + rules.select(quantity)
why?
Compared to the previous use of compareAndSet(), I think this block is much easier to understand, so let's keep it as is here.
Suggestion: I doubt we can have a null Set since we initialize this with new Set on FullEntityOvfData. but I guess that since we also let it be initialized with the constructor we should be on the safe side
I see you making this pattern several places in the code to loop through all the states. It seems really inefficient to me. Is there a reason we can't just keep this information precomputed somewhere?
Nit: is it necessary to do this only if the networkagent has ever connected? Or can we do it all the time?
This approach would scan through all aggregations and sum up the retained count every time it's fed data. As an alternative, we could use a system similar to the way that QuotaWatcher works. Each aggregation session would be initialized with an AtomicLong (wrapped behind an interface) and would be responsible for incrementing this every time it "stored" data. Querying it would only be a matter of reading its value here. We might also want to consider tying these two systems together, since if the aggregation system "runs out of quota" there is no need to continue reading data from the backend any longer.
at least on the mac with a retina display, the last line is not included in the rectangle. maybe this is the reason: isn't this is the top of the last line? the rectangle should go to the bottom. maybe use fEditorBottomIndex+1 here and then subtract 1 pixel?
Shouldn't these 3 removeXXX be in the same transaction?
Why do you need declaration of this variable here?
please remove alias setting (should be encapsulated in addManagedDevice
Move this block into the if (format) case.
propose to put for (Map ...) into if clause in current implementation log.trace will be not executed
similar to above, this layout comparison would fail if there is transformation. Probably want getBaseLayout
Better handle NumberParsingExceptions here?
Should we use removeCachedItem here?
Just to make sure the volume is at maximum, since you removed this line: <LINK_0> suggestion simpleExoPlayer.setVolume(isMuted ? 0 : 1);
remove this line
neither -> either
this is the core of the fix, isn't it ?
This should not be necessary if we set linkedArtifactNameSuffix in CcLibrary
Is it possible for this listener to return null?
I would move this logic to get an enum from an int to a static method in the enum, similar to the method fromValue here: <LINK_0> That way you could read the servertype here, or at any other place, directly as servertype = ServerType.fromValue(Integer.parseInt(arguments.getString("TRUSTED"))); and the field trusted wouldn't be needed anymore.
Final result can be written directly (without computing the intermediary values: return y1 \* Math.pow(y2 / y1, (value - x1) \* xDiffInv); (remove lines 55 and 56). This should save one log and one exp computation. firstDerivative and getNodeSensitivityForValue should probably be adapted also.
@erimerturk we should keep the catch for InterruptedException separate in my opinion. In that case I believe the thread should stop.
We can replace the iteration with labels = Collections.unmodifiableSet(new HashSet<String>(parameters.labels));
Should we expect a more specific exception here?
Given you only check the Bloom filter for brands it might be good to not updated it with the IDs of series and episodes. Reduces the chance of a false positive.
nitpick: can be simplified to script.getCommands().stream().anyMatch(cmd -> cmd instanceof DescriptiorCommand);
Are you sure that this "name" pattern is the same as the name pattern for groups? Because it seems to be used for user name in this class.
we need to review a message which makes sense for someone who doesn't know the db structures. And match it with a troubleshooting doc stack trace.
Hrm, I think there are more whitespaces in this method then there needs be?
With those 2 lines, you'll instantiate a new FilterInputStream whenever this method is asked. Instead, the generated filtered inputstream must be stored as a field and returned if already existing.
Take care: you should _copy_ every single field you set in the binder. To avoid having to manually keep them up to date, better use the [HttpUtils#copy](<LINK_0> method.
@reggie7 was there bugs in the Impl? If this is updating the Test to work w/ JDK11, why are there a bunch of changes to the Impl itself? Changing the impl without explanation why is confusing :(
Will be easier with a generic parseBlock() method, we don't need to parse the packet header, etc.
We need to fix this
Change to fine level as if this ever happened it could happen a lot and fill logs
Please add a case like { ? = call pack_getValue}
Problem here: getContentResolver() returns a NULL value when in context of SyncAdapter. It's necessary to check that the returned value is not NULL and, otherwise, call instead getContentProviderClient(). Have a look to other methods in this class calling getContentResolver().
Optional ... sorry to repeat myself.. just pointing out occurrences.
this.joinAddressIndex seems to mean "last processed position", but you're existing here with joinAddressIndex (the loop index variable) being not processed. Am i missing something?
I think we should simply supply a default header in the beginning.
I may be mistaken, but I think this will result in a desired row group size of 128 bytes, not 128 megabytes. I would suggest using the ParquetWriter.DEFAULT_BLOCK_SIZE constant instead of a hard-coded value.
Wrong filter -- it must be "another target creature", not "you don't control". See example of FallOfTheHammer with target tags usage for same ability (but please, test it after changes -- is it works correct or not).
Break before the second ||
I like that you move the checks for feature toggles to their own private method, it removes clutter. However, I would suggest to be more precise in the naming: you're actually checking feature toggles that are relevant to the creation and update of subscriptions specifically, and this should be reflected in the method name.
What if the above command fails?
To clarify, + 1 is for the local operation, right?
I think you should use assertions from junit/assertj.
It's a minor detail, but three of these four checks are faster than isSuperTypeOf and isAbstract actually weeds out many.
Debug, not warn?
Here task for each cache group can be executed by different threads. Let's use single-threaded execution here.
I think the name "arrivalTimeUs" is a little confusing.
This is definitely wrong. You don't see the error because this integration test is ignored in your case. Read again this test and you will see that dom won't be changed by this line. You're actually not changing anything, this line does absolutely nothing.
Why do you have this construct here? Why are you not printing a stack trace on an IOException? Isn't there a way to hand over the exception to JUnit?
applicationId and applicationVersion might both be null. Or one of them. We need to handle this here
Should the variable name then remain as messageBuilder?
Ha... thanks so much! I have not been following this section of the code so I was not aware of what changes have been made recently.
@tarilabs You can use KieServerAssert.assertSuccess(ServiceResponse<?> response) here - <LINK_0>
you know what it is about
good call in checking for size > 0, and having it assigned to a var so it's not evaluated every time. Thank you!
Any chances to see consumed messages and verify their headers for that IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK? And probably after pending verification call the ack and see if there is no pending afterward left.
If wanting to express the real count of the children with the CHILD_COUNT constant, rather use IntStream.rangeClosed(1, CHILD_COUNT).boxed().collect(toList())
In Ceramics, I made [a helper](<LINK_0> to get a list from a EnumObject. Might be a little cleaner than the loops.
wouldn't setting this to false cause a correctness issue? GetBlobInfo relies on getting and returning the BlobProperties of the metadata chunk. So shouldn't this be passedInBlobProperties.isEncrypted()?
I think returning null is problematic because it might cause an NPE in BackendSnapshots - Disks/CdRoms/Nics - Resource, which invoke this method and reference the returned VM. Also, I wonder whether in the first place we should return a snapshot which doesn't have a VM configuration. In such a case we should either fail with some 5** code or omit the problematic snapshot from the list, and write a warning to the log. As this case is very rare (but possible) I think it's ok to omit the bad snapshot and write a log message about it.
If we confirm that special characters are not supported in catalog/schema names, we should definitely simplify this as this is hard to understand.
I'd rename other with current, or something like it, to make it more clear that we're overriding. I'd also log info or warn when the converter didn't override the current one, so the user will know that his converter was not registered.
Why do you need to change this?
Same fix as the other array usage.
Why add this whitespace! Could we remove it?
canExecute() does not check for this case but relies on canDisconnect(getData()...) to make the decision. It would be consistent to do the same here and delegate that case to disconnect(). And actually, disconnect() already checks for an empty array, so we only need to remove the above if check
The construction of the mavenBuild object is mostly the same for the 4 new projects. It should be factorized.
There is a high potential of NPE with concatenated calls.
since you are touching this line, can you change (long)(-1) to -1L?
Does this receiver gets close() , So that builder close the connection.
@grainier Can we get the meta data size calculation out of the for loop so that the if condition and retrieval of meta data size does not repeat for each iteration? i.e. outside of loop, do something like metaSize = streamDefinition.getMetaData() == null ? 0: streamDefinition.getMetaData().size(), then within the loop, simply do a return attributeLocation + metaSize;. However, since this code does not seem to be in the critical path, let's do it only if doing such an optimization does not compromise readability. WDYT?
why not call makeRemoteChanges?
make it more functional and return here a data structure that contains three module classes and then if you remove those three module fields this object will be completely stateless. This is just an idea.
It's very nice that you used the new logging approach to all of the tests. I think we can use it also here. What do you think?
I think you can use the 2-parameter method instead of passing an empty Map.
Do this outside the if
Worth wrapping this call, the response might be big.
Please use, NetworkCommonUtils.isVlan
So this means we are not doing any validation on requests with a "path:" "email_collection_mode"?
@Oak experts: Using ReadOperation here (and in 2 new methods below) which only does an is-session-alive check (which we want). This is not a write as it does not change the repository (NodeStore) in any way, and it's also not technically a read from the repository, but it seems that ReadOperation does not particularly care. Please check if that approach works.
fileName here should actually be the derivative directory, which I don't think is currently being created. You should create a subfolder in the tmpDir for that.
Thread.interrupted resets its state (<LINK_0>, so this should include 'else { break; }'.
Should we only do this for send only folders?
Can it be just a regular for ?
prefs.hideEmptyPane() If you look elsewhere in this code e.g. onLineNumbers at line 292 above you will see we "wash" the value through the prefs object and get back the value the prefs object would have used. This is just in case the prefs object is doing normalization of values or something crazy.
Can you add a Timber log line here.
This test implicitly relies on timing, and hence it may be flaky. OTOH 10-second timeout should be enough
DEFAULTID+".default.layer"
Can we assert the value instead of assert size?
What about this else case. Here also scheduling fails but we are not showing any error?.
We should not catch the specific exception at Util class. Catch it in API class and send the response code accordingly.
Seems a **)** is missed here
try-with-resources?
why was this test removed?
p can be pendingMove.
This seems like logic that should be split out into it's own function.
I would put the super.canDoAction() at the beginning of the CDA because the implementation of InitializeVds() already uses the storage pool by id (getStoragePool()), so I think it will fail here before getting to the super.canDoAction
Can a result be null? (i.e. do we regularly need to consider whether source is attached)?
There is a chance that cluster will be null at this point which would cause NPE.
remove, nextDouble is in [0,1) range
Exception should be logged
the internet claims that "broadcast" is a single word
You could use streamCapturedEvents.
I would also mark the deletion of the temp file when Jenkins exits with [zipFile.deleteOnExit()](<LINK_0>
nit: I haven't saw this. used in this code. Is this new pattern?
This doesn't work, instead of removing /q? it removes /q and leaves the ? behind. I guess we need something along the lines of uri = uri.replaceFirst("q\?", "#") or something of that effect.
Need to use parameterized logging instead of string concatenation.
Can these be initialized inline?
I assume for Apple Pay this is going to be under six digits (because we don't have a full card number, just the last four digits) but I don't fully understand what's going on. Could you explain it to me please?
Can makeObservable call subscribeOn before returning so that you do not have to repeat it everywhere?
You are still changing things that are unrelated to your change. 'assertThat(entries).hasSize(3)' as it was before is better.
I think it's a little bit more than this. There shouldn't be any "+" concatenation. Should all be .append() I already proposed to addressed this issue (HIVE-23540), but happy to defer to this PR <LINK_0>
So parallelLevel is 1 because aggregation is done client-side instead of pushed to the cluster, right? Would be good to doc the thinking behind calculating the cost throughout.
Move these into a separate function.
I see that updateParameters updates the command params and persist the command. I'd recommend to do the persistence here, i.e. out of the updateParameters method
Do we need .publishOn(Schedulers.parallel()) here?
nit: sameAs would be sufficient.
A more readable alternative to this would have be: StringBuilder builder = new StringBuilder(getActivityId()); addWithHypen(builder, getActivityName()); addWithHypen(builder, getWorkPackageId()); addWithHypen(builder, getName()); return builder.toString(); where addWithHypen is: private void addWithHypen(builder, String value){ if(Strings.isValid(value)){ builder.append(" - "); builder.append(value); } }
Then we should use a builder: java BoundStatementBuilder statementBuilder = videosByUser.boundStatementBuilder(userid).setPageSize(ITEMS_PER_PAGE); if (page != null) { statementBuilder.setPagingState(Bytes.fromHexString(page)); } ResultSet rs = session.execute(statementBuilder.build());
Can be removed altogether, since typeManager is just passed through. Let MapBlockEncodingFactory and SingleMapBlockEncodingFactory validate that
Yes!
Minor: The dbActivity != null clause in updatableStatus is redundant with the dbActivity != null in the if statement. You could simplify the whole thing to if (dbActivity != null && (!UPDATABLE_STATUSES.contains(dbActivity.getStatus()) || dbActivity.getClientData() != null)) {
Avoid using System.out
Condition is backwards again.
I think you should strip the % sign only if present. What if gluster changes to return 90, instead of 90%?
name of operator: Validator ? also rename variable accordingly.
If we allow for the Unknown type we should probably store the actual name of the tag used and use it also in the equals method and the toString method
Why are we doing a list query when we are only expecting one result. If we use unique result we will not need to use get(0)
same issue here, this breaks dependent-post-aggregators
This *must* be backwards compatible and also work with with old saved states that do not have that caret position.
We can use '==' to compare two constants
Are all these needed?
suggestion SolverStatus previousSolverStatus = solverStatus.getAndSet(SOLVING_ACTIVE); if (previousSolverStatus != SolverStatus.SOLVING_SCHEDULED) { // This job has been canceled before it started return problemFinder.apply(problemId); }
I think we should log the next flush
Minor: We don't need this, as in line 827 it is already being done.
nit, add a space after the comma
Shouldn't we test the return value of createWithPrimaryKeyField()? How about  RealmObjectSchema objectSchema = realmSchema.createWithPrimaryKeyField("FooNonNull", "pkField", String.class, FieldAttribute.REQUIRED); assertSame(objectSchema, realmSchema.getSchemaForClass("FooNonNull"));  ?
I realized this is just moved, but should this be synchronized to this as it is in the running state?
I'd make this a throw new NullPointerException("metric == null"); instead
They're milliseconds now ;). Please check other locations in the change too.
What about characters from other languages like Chinese or Japanese? Or some special French characters?
uue DICOM_CLIENT constant if possible "+" + DICOM_CLIENT
both cursor.getOffset() and cursor.getPartition() are not marked as @Nullable. Why have you decided to check it for null here?
@1m2c3t4, thanks for the PR! Can you please format the code in order to follow CloudStack code conventions [1]? From:  if (obj == null) return false;  to:  if (obj == null) { return false; }  [1] <LINK_0>
technically you can express this as two filters for slightly easier readability
use lambda here instead of anonymous ??
Suggest you return an Optional<String> since you can return a null. Your code where you use this function doesn't check for a null, which makes an argument for why you should be returning an Optional. :) On the other hand, if you think this is such an unlikely/impossible occurrence, which is possible (if UTF-8 encoding is not present, nothing's going to work, probably the same for SHA-1 algorithm not being present, not sure about UnsupportedOperationException), then maybe you should return a String and throw an exception.
We don't need to compute compactionTime at the end of this method anymore.
Can we use String.format for readability? Applicable at other parts too
public synchronized void notify(final List<URL> urls)
nit final, applies to next line too.
I think a more comprehensive test would be to first check that the number/size in columnMetaList matches the expected final size. Then check each individual column that is there, if they have the expected caption names.
You should use NOT_INCLUDE_DEFAULTS
you probably want to add adAggregationId into here as well.
this at least needs to check if the chunk is loaded. unloaded block = inactive block.
What about using: java String ext = FilenameUtils.getExtension(zipEntry.getName).toLowerCase(); boolean isSupported = SUPPORTED_EXTENSIONS.contains(ext);
This class seems version-agnostic, but you hardcode version 2.4 here. Perhaps this should be a parameter to getNewConnector?
I need to spend a bit more time understanding the interactions between Exceptions and BugsnagException but so far its a little confusing how BugsnagException now represents an array rather than just the individual exception value, and in particular might introduce a situation where the "cause" exception of a Streamable might be skipped from serialization. The deleted logic in Exceptions may have been more correct and simplify the execution path between BugsnagException.toStream, BugsnagException.serializeException, and BugsnagException.writeThrowable.
Should it just show that the target is invalid?
not necessary?
For my understanding, does that mean Hadoop api requires target path to exists before call to concat?
As discussed, please file an issue for further investigation on this. This is good for now to release this as this issue was already noticed in smoke tests and would be better to get this fix out before customers are impacted.
Is this not an unstable state and calls for manual investigation ?
Use constant (also later in this file)
same as for NIO, lets set serverCnxnClassCtr to NettyServerCnxn by default
I would extract the code in the brackets into another protected method - "connectionClosed()", for instance. We can pass the reason of the closing as an attribute. Overriding this method would allow clients to do something else before terminating the session. What do you think?
Why not just: if (deleteEmails.contains(preferredEmail)) { throw new UnloggedFailure(1, "--preferred-email and --delete-email options are mutually " + "exclusive for the same email address."); }
Could we change this to "/services/Soap/u/" + ApiVersionStrings.getVersionNumber(context)? It's easier to update API versions in 1 place.
Looks like it should be 1, not 0.
Why adding the second condition?
Unnecessary empty line. Moved up one line it might work though.
I'd make that method take a health url as parameter, so it can be ~unit tested
Probably best to throw an exception or create a failure if quantity, short quantity and long quantity are all not populated. Silently setting quantity to 0 feels dangerous; it's reasonable to expect clients to always provide a quantity (can always be manually set to 0 in the input if needed)
Please use trimQuotes method in LiteralUtils : <LINK_0>
There is no need to mock api calls to implement this test.
consider moving all setters of diskToUpdate to a separate method for more readable code. Perhaps it's also better to prepare the object diskToUpdate before the transaction is opened and not when it's already alive.
Why not using valueOf( updates[1] ).asObjectCopy() ?
You should always pass in e as the cause (and thus make your Exception types accept an optional cause).
The MacroExpander knows info and global nodes. Why should TreeWalk care to call all this in the correct order. That knowledge about how to merge current,info,global should be hidden in the MacroExpander.
Note that the type parameter is new, so you need to consider that this parameter might not exist for some old mentions: maybe it's handled later in the code?
Its not hooked up to the OkHttp client right now, how are you envisioning wiring in the metric registry?
please remove this duplicated line.
What do you think about moving this logic for "normalizing" urlPattern to JerseyEnvironment#setUrlPattern, if we expect users to invoke this method from the application class?
You should return an empty RepositoryDTO here
channelIds => channelNames
maybe list the set of known commands here?
Missing braces here, checkstyle is failing.
Please, check that runtime is not NULL
I wonder (in the other patches too) if we really care what the absolute values are. Wouldn't it be enough to check which one is higher?
was this a mistake?
looks like there are a lot of these instances. Please update all these to use BooleanUtils
Yes It should be 0 as it is already the case for the DefaultRCPMatchEngine registered in o.e.e.compare.rcp plugin. We could add a more detailed description to this match engine to inform users that any other MatchEngine should have a ranking > 0. I will propose that in a new patchset.
Could you remove final keywords ?
This should not be public - we don't want folks from outside the plugin calling this.
Extract properties.getRest() into a variable.
SocketChannel is configured in both SourceTcp/SinkTcp and TcpEventHandler (i.e. send buffer size, etc) , would be better to have a single or at least not a duplicated place where the socket is configured.
Shouldn't this be in else statement as right now I believe it will be executed twice in case security manager is enabled
This should remain a .equals test. Feature maps have some peculiar handling and I remember "==" being a problem on these
String logArg = log ? "TRUE" : "FALSE" feels more Pythonic to me.
maybe better to do indexSegment.getVersion()? (if you still have that function).
Recommended to use >= instead of ==, Even if there is a problem with the write lock, it will not cause NOT LIMIT Cache
Always use isEmpty() (negate when needed) instead. Rationale: <LINK_0>
These are all ListenableFutures, you should be able to use Futures.allAsList().get() For future -- the driver uses Guava quite heavily, so most of their future stuff is Listenable* and uses Guava's executors, etc.
We could still use SuppressWarnings.class.getSimpleName().equals(getAnnotationName()) instead of the Strings ... but for readability improvement, this probably should go into a simple private method isSupressWarnings().
@Serranya same here. See above.
this seems a duplicate so it can be removed or (maybe better) changed to potential.
else exit?
what happens when there are multiple hadoopy shard specs?
Iog the node information there with these warning messages. I am guessing it would be useful for debugging in case of issues.
Throughout the file you're calling the same File() constructors several times (even on the following lines), it would be better to store it in a variable
This kind of indirect testing could be dangerous. If the code changes for any reason your can end up with a test that tests nothing. Prefer to use the assert to directly check the expected outcome of the method that you unit test like CommitInfo commitInfo = launcher.calculateCommitInfoForBuild() and then check the commitInfoDirectly. As a proof, I already proposed above to directly generate the CommitInfo for IPBs so the gitHubHelper).commitInfoFor will not run and the assertions will not happen.
Same with this, should also be debug
You can use lambda syntax here to save some indentation
compUnitCost -> compBlockCost? or blockCompCost?
this seems like an unsafe type cast...
Better solution for OSHI, definitely, although I still think we should trap the null in the other code. But why use -1 here when we have a hres variable (already a HRESULT type available to us? The correct fix here (and 12 lines earlier) is just to include hres as the second argument. :)
> blank [](start = 81, length = 5) blank. #Closed
nit: 1 -> map.size()
This could be one line
value == null is not a real case ? You can rework your condition as it: castedValue.values().stream().allMatch(Objects::isNull)
isn't this repeating the same feature ID as the method ingestTimeRangeData() - if so, thats dangerous, feature IDs are meant to be unique
We can move this variable to class level, because it is used by more than one method.
This will be set to 0 from the json if grpcPort is not set. You can check for 0 and put -1
This should be a DEBUG, not a WARN.
One thing to be careful of here is that write access implies read access in our model.
This is not so good - messages is an unmodified collection wrapping a LinkedBlockingQueue. contains has to iterate over the contents which is not good for a large group. We had a similar problem in the AcceptOnceFileListFilter and we solved that (INT-3572) by maintaining a Set parallel to the queue; we can't use that technique here, though. Looking at SimpleMessageGroup - it's really not so good for large groups - remove() requires iterating over the entire queue as well. This probably explains Ryan's performance observation. We should look at using a (synchronized) LinkedHashSet instead of the BlockingQueue and compare the performance for both small and large groups. If using a synchronized set is too expensive, we might have to end up with 2 stores - one for small groups and one for large.
Are we deliberately choosing to do nothing if the publisher is not found? That is, is this expected to happen for some requests? If not, I'd suggest we change this to Publisher publisher = Publisher.fromKey(pubKey).requireValue() and remove the conditional. If the exceptional case of the publisher not existing occurs, an exception would then be thrown
I think that neither BACKLOG nor KEEPALIVE are useful for UDP...
@BenjiLee If you pull my changes from master, you can just pass the ComponentName to ISegment and use ISegmentImpl.getShareTypeFromComponentName(componentName)
The comparators could be organized under one class in the core plugin: SyscallComparators.START_TIME SyscallComparators.END_TIME etc.
This appears unused.
Please use SanitizationHelper.sanitizeForCsv() here too.
createPackageMapping was a better name
Suggestion: Maybe introduce a NoOpQueryUpdateEmitter for this purpose?
Thank you, I hate these traces. They are confusing as hell since they don't trace exit from all possible paths. Based on what you did below, didn't you mean to also remove the entry traces at the beginning of this method?
suggestion NamedArrayList.select(all, Messages.GitHubSCMNavigator_withinRepository(), NamedArrayList
Collections.singleton(Uri.fromFile(file))
nit: don't really like this flagging concept in the same method. I would suggest putting the related code to the place where the flag is true.
This validateAndThrow(prefetch) , in other PR we were validating earlier when user is setting prefetch . Should't this go there.
Map<Object, List<ITestNGMethod>> instead of LinkedHashMap<Object, ArrayList<ITestNGMethod>>
Do we have a test of a Remover spec with an or?
maybe we can add [COMMIT_CURSORS] as a part of the logger definition?
Do we really want that? Needs probably be discussed at the demo
or just assert equality to singleton list, or use Matchers
Can you please use specific exceptions in the method definition instead of PerunException ? Thank you.
You could check that we are still at branch_1 and file b exists/has the right content. Otherwise the checkout may have just completely ignored the specified path.
Stick an @Override on this.
double check that the group is still here
Wrap this function in a method
rename to toRemove
:point_up: this seems like not everyone would be using references to ebi? Put it in Defaults.java
Why is this not based on context.getCurrentUser()?
I think it'd make sense to only register this unwrapper if JavaFX actually is present. HV currently runs on Java 6 and later, and on 6 (and earlier releases of 7) JavaFX is not present by default.
nit: you can use monitors.forEach((server, monitor) -> { ... })
it is safer to have constant on the left of equals
The reason why I suggested to make the retry method package private and write tests against it is because you can override the policy for tests. With the current setup, this test is going to always take ~ 16 seconds regardless. Given our builds are already impacted due to tests, I'd suggest to override defaults to smaller multipliers and values for tests.
Even though currently StatsLoaderImpl#needsLoad() is hardcoded to true, it still should be called here first.
The initial state of this test represents an out of sync cache-through setup. Not sure we want to try to make sense of behaviour with a broken initial setup.
did you mean assertThat(mutated.getTimestamp()).isEqualTo(1519200753)?
I don't think, that VOADMIN and VOOBSERVER should be able to use this. For Resource it's ok, since they can somehow manage Resource, but facility settings belong to facility manager.
I think the correct format is $Var, ie: $VmName
ArrayColumnGetter didn't support array of decimal type. This change supports decimal array, but decimal values will be converted into string values such as "[""1.0"",""2.0"",""3.0""]". Could you fix the problem?
Please also make sure the sessions is valid getSessionValid(sessionId, false) There could be sessions that are not valid because the user has logged out but not cleaned up yet.
Grammar. These should be two separate sentences. Personally, I would also change "Can't" to "Can not" or "Cannot"
BitSet seems like a good idea. I think it's worth changing StreamSupplier.buildStream to take a BitSet for segmentsToFilter. I'd also add a check for log.isTraceEnabled() to avoid the toString().
replace with .contains(checksumType.getAlgorithmName()) to be less confusing?
It seems we can use a bit more advanced algorithm to find a match. We rely on the fact that all indexes (positions) returned by the iterators are ordered ascending. In addition we sort the iterators by the current index (e.g. using priority queue) and then try to match the first iterator with the last one so that try to perform firstIterator.advanceAtLeastTo(lastIterator.index) skipping matching iterators in between. OK, if we find a match (index of the first iterator == index of the last iterator), otherwise the firstIterator becomes the last one (because it advanced beyond the current last one) and we repeat the process of matching the first and last iterators.
Why catch Throwable and not just ResourceException?
Instantiating the download monitor could also be in the condition succeeded block
remove distinct
nice simplification!
check for return value and throw if false?
Companion
We had the check for containment in a method of, I think, AddTooltipManager. So it should be extracted, if it doesn't exist already in a util class.
I think we should log a warning message here, as it makes no sense to have a JoinField without the proper annotations.
No need for the debug lines here, please.
same for this return
You do not need to include the Thing UID in the message as this is the status of exactly that Thing.
Pull the help printing behavior into it's own function or class
This might be triggered by submitAllStoredDownloads right? Would it be better to say: "Already running download for DownloadBatchId: %s , ensure you are not duplicating identifiers."
Perhaps move this variable out of the try blocks as well and close it in the finally before transport is closed. That way there would be a single try block in this method.
It's probably best to throw an exception here; someone has called process with a programmeId, and expects that programmeId to be processed. If that doesn't happen because of an error, then let the caller know and they can decide on how to deal with it. If you log and do nothing, they can't make that decision.
Minor: Would be better to add java docs for this the method.
Why this change? The policy regarding asserts, project-wide should be discussed in the dev mailing list, probably.
This double-try-catch logic for extracting a long-or-double seems to appear multiple times in this PR, I would suggest wrapping the whole thing into a helper method in NumberOperations so that code chunks like these can be a one-liner. The stack trace of any resulting exception should tell the user what transform it's from
I believe this shouldn't run if tryAssignTasks.putIfAbsent returned non-null, as it means some other thread is handling this task.
maybe group this all into a function "initializeIdenticon" or something like that
In addition, if you have question passed to the StudentFeedbackSubmissionEditQuestionsWithResponses, you don't really have these two variables.
rename to adapterFactories
nit: I think it would be cleaner if we useString.format(..) here
We don't need this else block. Just return the otherFactory.getTransport(trans)....
as dicussed early today.. changes in this class should be removed from PR
getRoutingTableAsString is only for debugging/logging!
Same thing, public API that may now return incorrect values.
Why add the reference back to the UML element?
This listener is not being added to ZAP.
app profile id is a value provider, the null check doesn't make sense
This will look weird in the logs :smile:
NPE if there will be no metrics in test group .
You are loading this class again from the new class loader and setting MANIFEST? That seems only necessary because of my earlier concern about ModifiableURLClassLoader not delegating to parent first, so ModifiableURLClassLoader loads a new EmbeddedLauncher when Launcher want to access it's MANIFEST field. So why not parent first?
Why not using bridge.getId().replace("fffe", "") like below? Get it once, store it in a serial number and reuse it below.
Shouldn't this have already been set based on either being set when changing the combo or when the user deliberately switched the combo? Or is this set the true change to the system, and getSelectedColorsAndFontsTheme() reflects the combo?
I think it's enough and I'm sure someone will complain if it's not :D
I don't think this default should be changed.
why are you writing these dockerfiles to the user's home directory?
Call it ..._DIVIDER please :)
@aleffert I might prefer more methods rather than a concrete "ViewModel". But I gave it a try. Is this what you are imagining? <LINK_0>
Could you extract a constant for this Pattern?
There was no InvocationDispatcher in this version.
Is this the right error message for when context.getChangeRequest is null? The "if" part doesn't seem to have to do with the status of the developer, but I could be missing something!
Was looking at this line and was wondering if that is really needed, is it not sufficient to just check for NoAvailableExecutors exception? Also, pickedExecutionCount will include executions that was picked by another Scheduler-instance, i.e. not running in this executor-pool
I'm not quite sure I get why we need this. Could you please explain?
I feel like the callers might want to know if it completed successfully or timed out?
32 should be replaced by Integer.SIZE
Whitespace: brake "=" to a new line.
this can be improved as well. There are a few ways to format query results into appropriate format. JSON is one, this plain format is another. How about 1. Create a seperate class ResultSet (basically a table), with reference to Query 2. Query should be immutable 3. Add ResultWriter with two implementations JSONWriter, TableWriter.
use rexBuilder?
The siteIdentifier is unique enough that we don't need to check the past history anymore (IMO).
should be 1024 \* 1024 = 1048576 = 2^20
You're removing Index objects from a set containing strings. You probably want to do:  Set<String> original = stringifyIndices(originalIndices); Set<String> updated = stringifyIndices(updatedIndices); Set<String> added = new TreeSet<>(updated); added.removeAll(original); Set<String> removed = new TreeSet<>(original); removed.removeAll(updated);
Just a minor note: throw org.apache.calcite.util.TestUtil#rethrow(java.lang.Throwable) should be used to rethrow exceptions in the test code.
assert is empty
statements may be not only on items, but also on properties - are you validating those somewhere?
We should make this configurable in the properties file, using a property called http.auth.preemptive=true/false
The int here is the concurrency level not the size of the collection, we should be using default constructor. Also all of these are declared as ConcurrentHashSet, I think it would be nicer to just declare them as Set instead - there is no API difference and always prefer interfaces.
this should be true since your test is WithClientAuthentication?
we should use {} and parameters instead of string concatenation
No questions during refactoring progress.
Make this test consistent with the default authentication type, and change it to use api key credentials?
Two more times(1).
another note: you may want to use the new command interceptor in testKeyOnlyWrittenOnceOnOriginator
This should be ERROR.
Use Slf4j API:  log.info("Connecting to ATSD at {}:{}", serverName, port);
@Abdelaty Don't remove this - this is a functionality of the no internet connection snackbar. Just create another if statement below it.
constant?
We could check if the index is writable before creating the indexer: suggestion if (!isIndexWritable(i)) continue; Index.Indexer idxr = i.indexerFor(update.partitionKey(), update.columns(), nowInSec, ctx, IndexTransaction.Type.UPDATE); if (idxr != null)  The same applies to the other usages of isIndexWritable in IndexGCTransaction#commit() and CleanupGCTransaction#commit(). Alternatively, we could transform the set SIM#writableIndexes into a Map<String, Index>, and iterate its values this instead of SIM#indexes values in the three places. That way we wouldn't even need the isIndexWritable method.
I know it's unlikely, but if something happened where the failed login count jumped over the maxLogins value, and somehow didn't actually lock the account, then we never would, right? Can we keep this comparison as >= and add a separate if inside this block to send the email only when the == comparison is true?
instead of set csv separator in singleconsole contructure.. it might be better to set it with separate setter. singleConsole.setCsvSeparator(String csvSeparator)
This doesn't seem like the right place for this. Why are we collecting interface info for a latency collection set here?
Change "Devices" to "devices.xml" so user knows specifically the file name that cannot be read.
Why catching an exception and throwing it directly again? I would earlier argue for a check of 'unknown' types and put a check on the known ones.
Okay. I think we should probably inform people that a consequence of this could be that the backup lock might not have been released properly - and if there are problems with taking out the lock, to release it manually. Also, would it be safe to log at WARN? I think if we have well established procedures for users to help themselves (and we do in the docs) then that should suffice.
The order of the arguments is not correct. It should be:  assertEquals("Task attempt's internal state is not " + "SUCCESS_FINISHING_CONTAINER", TaskAttemptStateInternal.SUCCESS_FINISHING_CONTAINER, taImpl.getInternalState());
It would be better to declare this in the throws clause and not handle it, since it should trigger a test failure.
Similar note for local variable app renamed to application in other methods. Maybe it should be:  Map<String, Object> application = ActionContext.getContext().getApplication();  That would mean changing existing references to application into this.application (like in beforeResult()).
rogue log statement
I am not sure "later jobs" is a clear label. Then again, I can't think of an optimal label. "Later jobs" seems like jobs that will be handled later. Maybe "More recent Jobs", but it's too long, or "Newer Jobs"?
The same synthetic method here.
use logger templates instead of string concatenation
You can use lambdas in tests now.
We can move this right above cgroupMemResourceHandler.prestart() similarly
Be consistent, return "Entity " + id + "could not be moved"; Also, either remove trailing "world" from above or add it everywhere else
Typo in variable name. You can test if there is any change in trackedSymbols and create instance only if necessary. It will be often the case that symbols won't be changed.
suggestion client.incrementCounter("jenkins.job.stage_completed", hostname, tags);
If done with a ternary then no intermediate declare/storage is necessary. Not a huge difference, but simpler and shorter... suggestion return sb.length() > 0 ? sb.insert(0, '(').append(')').toString() : "";
What's the purpose of this?
nit: nothing wrong here, of course, but seems a bit funky that we didn't use putAll in the same way as in when setting up the request
Should this be inverted?
nit: This check rather looks like an assertion. No matter what arguments are passed to this function the equals function should never return null, as the null case is explicitly checked before. For such assertions usually verify is preferred. (same for others).
I don't think the first segment of the file name should be treated as an 'extension'. I should be able to create, for example, profile.di because that's not a *.profile.di file.
Do a URL encoding of this value. The service name can, for example, have spaces and/or special characters.
Why do we need to add GCM_TAG_LENGTH here? recordBytes doesn't seem to include any tag field. cipher.doFinal(recordBytes) appends a tag implicitly?
LOGGER.trace are not very useful in unit tests.
Avoid _null_.
Why add SaslException here?
Would Objects.requiresNonNull() be better here?
There's really no value in debugging the same thing that you're throwing here. We might want to hide the internals from the user (although as a command line utility, I'm not sure there's much value in that) and not throw the internal IOException that occurred, only debug logging it; otherwise, just the throw should be sufficient.
Use new loop strucutre: for(Category cat: resCategories) {...
use node.isPartial(), to maintain the properties of the node being rewritten
@maria-farooq we should provide a description to the log message
typo
you can make expiration an Integer and already assign it here, like this: java Integer expiration = ns.getInt("expiration"); if (expiration != null) { m.setExpirationTimer(number, expiration); }
esource -> resource Also you probably don't want () around {} which is replaced for attr name, since in other messages you don't do that.
The MOVE_FILE_TO_FOLDER_AND_RENAME should still be enabled if the file is already in the correct folder, but not of the correct name, or not?
The arguments are swapped.
Base64 sometimes contains = as a trailing padding character. If that is present, and you just run "token=$base64" back in as POST input as a form, maybe the = is being eaten by the form data parser? Its been years since I have worried about the standard for form encoding, its possible that =, & and % are special and must always be encoded to avoid these sorts of problems.
this is only used for eclipse-update-site. It has a special "aggregator pom" (poma.xml) which I don't understand why it should be there/what it should be useful for, so just ignore this for eclipse-repository and keep it as it was before.
This should never be filtered, as in theory the list of allowed origins doesn't depend on the permissions of the user. I think you can use VdsDao.getAll(), without parameters. I'd also suggest to add a new method, and a new stored procedure, so that you can get only the host names, and not all the attributes of the host, as doing so is a waste of resources (joins, etc).
all the above logic should be called only if reconfigure gluster option is selected?
Could be implemented directly in KubernetesAuth implementations as a method such as public void decorate(ConfigBuilder builder). It would require pushing the kubernetes-client dependency up to kubernetes-credentials, or at least the kubernetes-model part of it. It has been mentioned in another thread (<LINK_0> that it would be valuable to extract it into its own library plugin later anyway.
make it abstract public or public with a default implementation and move specific implementation in the child classes
so deep! can't we extract some of this stuff?
tasks should always relate to a organization, we should set a public flag for this, if a non-coduno organizations owns the tasks, they should be able to update it etc, it's not possible anymore if we "unassign" public tasks from organizations
Exceptions should really not be swallowed. Keep and eye on formatting too ("}catch" -> "} catch"). Since these are new files, it's handy to just go with an IDE and mass format them using the java coding conventions, spaces, 100 chars long lines).
Another good candidate to use builders.
Isn't this like eventually(() -> store.load(1) != null)?
Please indent inside the try
can this be renamed to withMandateId?
hostnameKey
can we fix formatting here?
Please, do not mix German and English. Please use one language or use a translation key for translatable error messages.
Maps.newLinkedHashMap()
else keyword must be on the next line accordingly to code style.
Line length 120
I'd rather run only the PurgeListener on the Executor.
This change (stage-->i) is completely pointless, and makes the code less readable.
-1 as a time is plausible on embedded systems, I recommend Long.MIN_VALUE.
Good catch suggestion int lengthOfLongestEntry = StringUtil.encodeUtf8(stringDefaultValue).length;
You are updating the dependencyInfoAvailable flag here, but you should also cover your tracks in the "catch" block below. If the query fails, you can be sure that no dependency information is actually available. Right now, a failing query creates an illusion that there simply is no parameter defined. Given that this private method is only called from the constructor, the cleanest solution is to make your computed "dependencyInfoAvailable" value the return value of this function. Then you have a clean flow of logic and no hidden field updates that future generations of maintainers will surely miss.
Another alternative would be to add a method like skipLockDuringClone() that CloneCommand can call.
you can use values.mapWithIndex() here, which avoids the unsafe below
No need for a separate declaration.
just use context as sync obj.
should this be a separate method? I find finish a bit big. But I don't feel too strongly about this.
I think hasOut is being deprecated here <LINK_0>, I think is better to use getMessage instead
Adding a check for this listener?  Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'float com.github.chrisbanes.photoview.PhotoView.getScale()' on a null object reference at org.wikipedia.gallery.GalleryItemFragment.lambda$onCreateView$1$GalleryItemFragment(GalleryItemFragment.java:128) at org.wikipedia.gallery.-$$Lambda$GalleryItemFragment$IT7mfODMYoIdODz3RDiJxJ5SW2c.onMatrixChanged(Unknown Source:2)
This could be optional (same for other fields not required), to not have to add all the properties to all entries.
shutdown the pool in a finally block
This conditional is unnecessary. List element is never null.
The old formatting was easier to understand.
This dropout section is obsolete. Replace if statement and content with applyDropOutIfNecessary(training);
ICDKMolecule instead of SMILESMolecule adapterType is the class that is asked for in this case ICDKMolecule as indicated in plugin.xml
Put this logic in a separate method?
This is a regression. Can we not throw a CCE here? If not, we are re-introducing #357.
This is a bit expensive as it allocates an array list for every entry. Since drag events can fire very quickly and impact performance we need to use fast/low level APIs that ideally wouldn't trigger allocations. I suggest doing something like: java int componentCount = getComponentCount(); int staringPoint = 0; int endPoint = componentCount; int direction = 1; if(root.getLayout() instanceof LayeredLayout){ direction = -1; endPoint = -1; staringPoint = componentCount - 1; } for(int iter = startingPoint ; iter != endPoint ; iter += direction) { Component currComponent = root.getComponentAt(iter); // ... }
Maybe Failed to reload Lua scripts after reconnect
Open the drawer at the end of this function, so if user changes this to use a different gpkg with no feature tables, the same code still works.
true usually means success. this is a bit confusing. Can you make it opposite. meaning handleFailover would return true if succeeded.
the loadFromFile allready logs errors on failures. is this warn really what we (all) want to do here? I'd expect a return or even a throw of some sort.
Should this line be conditioned on whether prometheus is enabled?
Maybe you should extract d.getKey().getId() to var
This query, however, *does* need the division by two, as we have two blocks of params in the query.
you're using the RegistrationHelper in the LostPasswordController ... maybe it's time to rename the class or extract some logic to a separate one.
suggestion Optional.ofNullable(allItemsCache.get()).orElseGet(HashSet::new).stream()  Small optimization.
can you externalize this String to the messages.properties aside this class since it can be displayed to the user
We usually do this with the holder. Add a new field the in holder class, which is initialised and related code is created on demand (lazily, when we call holder.getViewDestroyedField()).
I would suggest to put this in a "finally" block.
openSansSemiBoldFont  rename it to a general name like semiBoldFont.
Shouldn't you save the returned parameters in the list?
variable names should not start with a capital letter, that's for class names
I would skip that as it doesn't harm to use the openshift lookup with a registry. prefix, too. Its probably more confusing to have this special case here.
A couple of nits: - bulkDownload should be final. - rename bulkDownload to bulkDownloadIcon
Declare it as a member of the class. We will gain in readability. To be generalized on others test classes.
Why do we do it at the individual file level rather than dir level? Each consumer is writing to a dir composed of PID and thread id, so those dirs are specific to a given instance.
We'll want to keep the existing host support around.
a refresh is missing here in between the updates
use the constant here?
use expireAfterAccess
you can get the bundle even easier: FrameworkUtil.getBundle(getClass());
Perhaps also log the stacktrace, it is useful in a lot of cases, or better yet use processException
isn't it from another PR?
@cuenyad use TermId.LOCATION_ID instead of 8190
what if store is missing?
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
The selectTraceType method could probably get the TmfTraceType.getInstance() directly, that would avoid the tt variable at the caller and changing the signature of the method.
This is just a suggestion, but when author and blog name are same, maybe we could show txtAuthorName instead of txtBlogName which is bolder and more prominent. What do you think?
Instead of this, inc numFailed in the loop above.
mType is originally 0 anyways so its k
I don't think pinning should disable this action.
I don't follow this bit. If it is persisted then return?
We should avoid creating the instance when we don't add it.
We should also reset progress and hide it here?
Is this really possible that urlProvide is null? We require CanonicalWebUrl now.
clear() won't shrink the HashMap. [WeakHashMap](<LINK_0> maybe better in this case. An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use.
this is definitely not necessary, the try-with-resources block will call walk.close() automatically.
Use <code>Strings.isNullOrEmpty</code> that is more efficient than equals with another String.
this does not have to be final
We should probably use StringUtils.commaDelimitedListToStringArray here.
can be changed to lambda
I _think_ this will get run twice. Once on the Indexer and once on the local worker. True or false?
Should be SmackException that is expected to be thrown here. And that by getNodeConfiguration() I'd assume, hence the lambda should be smaller.
Method allJobsWithOnAnnotation has 32 lines of code (exceeds 25 allowed). Consider refactoring.
could we not just stash the APns objc?
Hardcoded string (+1 more below).
Could possibly avoid the linear search in each loop iteration with something like the following before the loop. java Set<String> importing = Arrays.stream(exportedFiles).map(fstat -> fstat.getPath().getName()).map(fileNameMapping::get).collect(Collectors.toSet()); Set<String> imported = Arrays.stream(importedFiles).map(fstat -> fstat.getPath().getName()).collect(Collectors.toSet()); //ensure Sets.union(importing, imported) equals new HashSet<>(fileNameMappings.values())
rename to childItem
Why not use early return constructs everywhere instead of zoneNumber = ?
Are these really severe logs, or can we log them as warning?
Same thing with this one. Also I don't see any fields annotated with @Mock for initMocks?
you may want to log the exception
If the object is currently instantiated by relying on the statically defined values within ImportInformationSpaceConstants class do we need to check the nullability of those fields here and in similar places below?
Can you factor out the first conversion to make the if more readable? Moreover, why not use a switch-case statement?
What about if geometryData.setExcludedTypeList is no set ?
why not fail quickly here as well since you claim to require a TaskListener below in getRequiredContext?
Remove printStackTrace and catch and log the proper exception
what does changed mean here ? better name ?
You can remove the need for the finally statement by using a [try with resources statement](<LINK_0>
Since this property typed boolean, you can use: Boolean.toString(vmInterface.isPortMirroring())
When we're passing () -> false in, we could pass in something like CommitLogProcessor.neverProfile()
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
can this bit be extracted in a method?
Would also be nice to add validation for partition keys and check that the column names for clustering and partition keys are correct and that the ordering is right.
What about calling closeEntry instead? Will that work out?
I think this whole thing will be more intuitive if you name this variable as waitEnabled or something, and do the following where this method is called:  java boolean waitEnabled = !remoteColo; for (...) { ... if (waitEnabled) { waitIfRequired(); } }
Same as above, I think you should mix timezones.
I know this isn't introduced here, but is it actually useful? This check looks like it has been here since the initial OSS commit, though in that form it looks like it attempted to do something if size was less than 0. It seems like this should happen, and we don't actually do anything other than alert if it does happen, so does it really qualify as an alert? The main reason I ask is it seems like the 3 places we are calling DruidCoordinatorRuntimeParams.createAvailableSegmentsSet() we then immediately fill it up afterwards, perhaps it could just take an Iterable<DataSegment> instead and could just produce the populated TreeSet directly if we didn't need this alert.
This is wrong design, we should not touch inner classes ever. Instead, let's use new Provisioned(..).acquire()
Not sure this is correct: * catalogEffectiveDate = now() * that.catalogEffectiveDate = null * => catalogEffectiveDate != null && that.catalogEffectiveDate is false and that.catalogEffectiveDate != null if false * => if is false but they are not equal?
entityManager.find(SessionData.class, sessionData_id) ?
This is wrong as you ignore thrown exception - I suggest to NOT use streaming API as its also TERRIBLE sometimes as in this example being overly complex and causing you to do try .. catch and ignore exceptions.
The i == Const.POINTS_NOT_SUBMITTED might not be necessary because the return value is the same as the else clause.
Can you put this into a private method or so. That will help to make clear what this is doing.
Can you elaborate in which cases stop can throw RuntimeStartInterruptedException?
suggestion LOG.debug("The underlying Yarn version does not support external resources.", e);
Could you remove 'final' off this line for consistency with line 88? I see that you need it on line 87.
Please put this in a subsystem.
Partially my patch solves an issue with trylock. Whenever we receive an event and the lock is already taken we loose data. Do you think the code will handle using events here?
Can this logic be added in the catch, this eliminating the need for both this "if" statement as well as the "setDefaultValue" variable?
String url = selfRedirect(item.getUrl());
commited->committed
This should be conditional: if (action.isSetVnicProfileMappings()) { ... } We do this in general to avoid the possible side effects of running that code when the request doesn't contain the value.
cleaner to use gauva's ThreadFactoryBuilder instead of having to write our own. you could also remove the AtomicInteger then
another char loop
Shouldn't this be not equals ? as the semantics says cluster modified ? You can cache the time if the check equals to avoid doing the expensive call. But the time needs to be intialized before the cluster is initialized.
It will fetch heliun.json from web everytime. It this intended?
Why is asList called? The callee, getCombinedAnno, will make a copy anyway.
If you find yourself nesting further down then two levels its generally a good practice to refactor the code into smaller methods.
Is that called a lot? Because we now have a o(n*m) instead of o(n) given that value.buffer is an ArrayList
Super minor point that if this was a Stack you could pop(), or a queue you could poll() and it would be a bit more clear how you're using the datatype.
getClass().getSimpleName() is quite expensive. You could extract it a a constant
Use logger instead.
The log level needs to be reset to default after this test done.
Please drop this, we don't log the rest anyway. The plugin framework logs everything if in debug mode.
why is this an Option exactly, when it could simply return an empty Seq instead? @danieldietrich?
You missed to add compareList as parameter here.
can we keep this test case? "s3a://" + BUCKET_NAME + "/test/"
Logging
I'm not following this logic. Why have two script hashes for loading the same script, LPOPLPUSH_LUA? Is this second one supposed to load workerScripts/fromMultiplePriorityQueues.lua?
I guess instead of setting to 0, it may be more future-proof to AND-off the bit.
Is it possible to set it to left align? Looks better imho
I would rather choose Eclipse or JBoss Tools for the default product version
unnecessary concatenation on the same line after some formatting changes
The test fails for me on the regular basis:  org.junit.ComparisonFailure: Expected :3 Actual :4 <Click to see difference> at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at org.springframework.integration.ftp.inbound.RotatingServersTests.testVariableLocalDir(RotatingServersTests.java:144)
Would it be possible to move the save/replacer logic into a shared Impl class + Interface with default methods? It seems to be a common use-case for Jenkins which could be reused in other model objects. Having it in external class may help, especially when/if somebody starts working on pluggable storage stories in the core
I tend to think that this check should not be required if flowFromMethodInvocation return an empty list.
We should be testing for feed with two clusters.Please make that change so that your code is thoroughly tested.
unrelated change
i'd remove this error handling here? (as it presumes createHandled)
v should be renamed to view and follow adequate variable names everywhere
returnedComponent.setForeground((item != null && !item.isPublicAttribute()) ? JBColor.GRAY : table.getForeground());
why there is no getTestSuiteNameToExecute in this case?
Technically, after a return, no need for an else.
s.a.
I wonder if we should have it as a configuration property (see TestcontainersConfiguration) /cc @rnorth @kiview
Should use setTableName() here.
Shouldn't this raise an exception instead of logging if the put is not applied?
Please move this line right below .setTotalWaitingStatCount(totalWaitingStat.getLeft()).
The if can be replaced my introducing an apply(FrameworkMethod method, Description description, Object target, Statement statement) method in RuleEntry.
Math.pow(10, -10) is a magic constant.
Minor - but should be hashToInstancesSn rather than HashToInstancesSn
Consider using spaces (instead of tabs) for indentation, to keep the same format as the rest of the file.
Since this is an enum now, wouldn't it be better to use switch here?
First note: your cast could leverage a ClassCastException (no instanceof check) Here should should try to change the next page (each pattern will have its own configuration page) if this is not possible, then it could require to have a configuration page whose create control method delegates the construction to the pattern provider (instead of this provider returning the page)
This will create flood in the event tab
Have you tried this with a task plugin? Won't this fail? I mean, if you have a task plugin as well, registered, then this can cause a problem, right? Every plugin load will call the pluginLoaded method in this class. That will, in turn, call this method. This call to packageAsRepositoryExtension.getRepositoryConfiguration() will (I think) fail, because it will send a JSON request to the task plugin. The code on line 51 above (earlier code) was getting the metadata only for plugins which have a reference of PackageMaterialProvider.class. What is the equivalent for JSON messaging based plugins? How are the capabilities of the plugin verified? Maybe I missed something?
The way this is done, you're giving the sum of all reds, greens and blues and give the "divider" as a multiplier (which are the opposite of each other). Might want to divide r, g and b with divider and leave out the multiplier parameter, instead add the distance variable to the event, so mods know how far they should search.
These are deliberate. Using for each allocates an iterator, which we avoid by writing the loop ourselves. Same with the rest of the loops unfortunately.
It might be better to just remove this line.
Math.max
You may want to use assertEquals ? The advantage would be that, when assertion fails it will tell you what's mismatching. There are lot of asserts like this, please change if possible.
suggestion logger.info("REQUEST DIAGNOSTICS: {}" readResponse1.getDiagnostics());
should be a private constructor, because builder is used.
debug/trace/remove?
suggestion if (Util.isEmptyString(roleName)) {
better to use logger here so that it can be used in other places?
Align this class with Double version. E. g. in Double version methods go in different order, and the logic is different.
You could consider adding a logging statement here. This method has three code paths of which two contain a logging statement. Keeping this the same for the three paths could make examining a log file to determine what happened a little easier.
java docs ?
Since the log is now detached from the build log I think we need a timestamp at the beginning of every log line to be able to correlate better with other logs.
isn't this more the currentTotalWidth?
This can just be replaced with docMatches.matches.compute(), I think?
Shouldn't this be replaced by the other procedure? Or do we need two?
the first Double could be double
if paramBrickFromVolume == null or paramBrickFromVolume.getId() == null again, you could return false
This became complex to understand because you're ending with tests leveraging @Before setup and some tests don't. I would rather keep the design of the test which is shared between all migrator tests.
a Fragment should not use the settingsDataSource, It's the presenter who should invoke request to save data in data layer but through of a use case, please create also SaveSettingsUseCase if not exists
What happens with parsing? Failure or silent?
this should be done before fixAddressesForDomainMode
While this made sense for ConsumerComplianceJob ( no point in calculating compliance of a consumer that has been deleted ), is the same true for import as well? I feel if some one explicitly requested an import, and owner no longer exists, we should error out the job.. we do face the same problem with spec tests where owner is already cleaned up though, so im split. thoughts?
should this be before ranger
This can be extracted and be reused below.
If this is a generic executor service provider, then I don't think we can be this specific and call the payload a "message". What about s/message/payload/?
suggestion if (direction == Direction.OUTGOING) {
When would sql be NULL?
keepBranch ?
nit: pass cause in constructor.
Do this in resetScaleAndTranslation or resetInternalState.
Do we need synchronization here? Will the object be created multiple times?
We don't need this variable if you improve the code structure.
Please write a unit test for this. That will probably reveal a bug. I think what you wanted to write was resolvedComparisonBranchName.matches(resolvedBaseBranchName). <LINK_0>
I think you can just do instanceof Map here and cast object to Map, to avoid the copy. The instanceof check would make it safe to use @SuppressWarnings("unchecked")to suppress the compiler warning. But, I don't think it's a big deal either way.
Style : 8 spaces continuation indent
I believe the minimum is 1 for each of these, don't think it matters too much here, but would be good to consistent
Can you change the variable name to newMember
Can you file an issue about this? The fact that these aren't pluggable for varying sql impls is not ideal. This shouldn't have to have a this kind of translation.
<LINK_0>
I think this can be a foreach loop as well.
The implementations of Cache (such as net.sf.ehcache.Cache.java which we use by default) are all highly concurrent. There should be *no* reason to synchronize on the cache object. Please don't.
This will introduce a easy to exploit security issue as the referer information can contain any kind of string which must not be a valid URI nor a URI leading to the application.
This return seems redundant.
Please consider adding a Preconditions.checkArgument to check that certs is not null.
gratuitous, revert
Since getStreamIds returns a Set, could you change the expected values to compare to Set? I realize that testGetStreamIds should have been originally written to compare to a Set instead of List.
should this be error() instead of info()?
suggestion if (segment.getRelationshipDirection() == Direction.INCOMING) {
Rename this to refChildElement or refChild
Now when we conditionally added comma we don't need to do a substring(0, length - 2)
The isBindToVm is misspelled, please rename to isBoundToVm. This line is being repeated in different broker implementations. Please introduce the method below in Cloudlet interface (and the implementation in CloudletSimple): java /** * Checks if the Cloudlet is bound to some VM, if that VM is created and belongs to the Cloudlet's broker. * @return true if the Cloudlet is bound to a VM created for its broker, false otherwise */ public boolean isBoundToCreatedVm(){ return isBindToVm() && this.getBroker().equals(this.getVm().getBroker()) && this.getVm().isCreated() }  The DatacenterBrokerSimple.defaultVmMapper should call this new method.
You can use Collections.singletonMap.
Should this be a warning and not an info level message? It seems like it shouldn't happen.
You could use System.lineSeparator().
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like:  if(!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(user)) && !AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) { .. }
Is there a reason we don't batch the ids in the DeleteRequest?
Well the animation looks really cool, but I think it's not needed!
This should take the input content-types as parameter to sort out which processors to use.
Rename the JOB_NAME constant to APP_NAME.
is includeChildren ever used?
Meh: could swap these two conditions, so that !singleValue can short-circuit the isIterable call.
nit: need a space after "class"
Missed a null check...
no use for printer. Session can be a local variable. No need for putting in the constructor.
Same here, move to a reusable predicate and get it injected.
uh, oh - there is no Function equality. A Function cannot be part of a Map key.
you can remove leaseHolder == null && it will always be true
I think we can't modify the code like this. the contextId can be either joblet node or context node
I guess you need to also run the background task (i.e call execute()). But I don't like the fact that the constructor has the side-effect of running a new thread. Thus, I would propose to let CitationStyleToClipboardWorker inherit from BackgroundTask and rename loadCitationStyles to call (so that it overrides the corresponding method in background task). Then the statement above in basepanel would become new CitationStyleToClipboardWorker(...).executeWith(Globals.taskExecutor).
Extra line
Should this be getSession(false) ? getSession() is the same as getSession(true). I ask because create() below does an exists() check and if false does a getSession(true). But it seems like that exists() check would never return false since ^^^ will create a session.
better to rename like fetchDataBannerInfo as isProblemXBlock seems boolean return type method.
space missing
Original failed to read was correct.
Can you elaborate what this operation does, because it is not obvious why result of this operation is never used.
Still using ctx here
Extra space
Is there a reason not to clean this up in a finally block sooner?
java.util.Map.Entry -> Map.Entry -> Entry is enough (already used in other places).
final
We have already make use of generic type so why here we still need to cast?
Verify the body of the request too.
Lets use VectorUtils.of(...).
Check null edit part, model Checl View type for element before casting
nitpicking here - wouldn't it be better to place the 10 constant on a static field?
nit: You can iterate from offset to offset + length as done in other loops in this PR. There are several similar loops below if you want to update them all.
Not sure why you need this here. By adding this as part of the activation logic, then we don't have to worry about it.
suggestion if (s.isEmpty()) {
not possible to combine with the test below?
Since this method no longer returns null, let's change the return type to int.
I think "Parent" here is going to be a confusing word to whoever is reading this error. It would be more helpful to describe "There was no XForm definition defined" and probably to also list the XMLNS of the form (although that may be more useful in a notification since it will be technobabble to most people)
This specific if(){} else if(){} has two branches with exactly the same code. what is the reason for that?
Same here, shouldn't we stop startup, when roles are missing and can't be created ?
Seems like we'll get stuck in the "build in progress" state if the user decides not to proceed with the build after seeing that they have busy terminals?
I know this method wasn't added in your PR, in fact I added it so FreeTypeBitmapFontData can be subclassed to override methdos, but this feels weird. Probably would be better for FreeTypeBitmapFontData to take a FreeTypeFontGenerator rather than have FreeTypeFontGenerator create or populate a FreeTypeBitmapFontData. Thoughts? If we agree maybe I do this after your PR is merged.
This isn't how you implement cooldowns
Bit verbose, we probably just need the stack trace suggestion e.printStackTrace();
Let's use ternary operator here.
We need a small correction here. Spec says: > return false if any item is false, else true if all items are true, else null The previous implementation was wrong, but good opportunity to fix.
Do you want to go ahead and make this change? If you are unsure either I or @hschmack can help you with it. If not, open a work item.
isAllowedUser was purposely put below matchesSyncPath logic since it's a more expensive operation. Trying to ensure this function is as absolutely efficient as possible for resource fetches not involving remote assets, since this logic executes on literally every single resource fetch happening in AEM, 99.999999% of which will be for things other than remote assets.
Where is this logic around rendering a json array to string used in this PR ?
Can you structure this as a series of tests rather than a nested if/else clause? It's easy to miss that return validatePredicateValue(...) in the middle.  java if (!(clause instanceof Map)) { String msg = String.format("Text search expects a Map, found %s instead.", clause); logger.log(Level.SEVERE, msg); return false; } /* etc. */
Does this need to be instantiated again?
This line can be pulled outside directly in line 158.
In this method you are doing the commit on both the ResourceResolver and the JCR Session wrapped with the RR. Please just stick to the RR and omit doing the same for the JCR session here, it's not necessary (because the RR is doing that internally already).
does this .usePlaintext(true) change the behavior?
Is this the default in the new API?
One question. run() is called in every iteration, right? If so I'm curious it would be reasonable to generate a plan which can be possibly changed due to the migration in progress.
@NielsCharlier please refactor to try-with-resources. Shorter. Less error prone. In this case, an Error will leave the InputStream unclosed.
Why are you using HOUR here? Hour returns the 12-hour clock representation, while HOUR_OF_DAY returns the 24-hour clock. If you used HOUR_OF_DAY, then you would not need the next two lines. What am I missing?
Making this configurable makes no sense. For mongo, it will always be the string "mongo".
I think we should also check that there aren't existing etag conditions. If they pass in an old etag that they want to target, and we just got a new one possibly after some updates, we might not be reading the version they requested.
Are not we unconditionally expecting exception cause due to internet connectivity here. Suppose to take error message from ErrorUtils.getErrorMessage function.
Using this specific cunstructor probably prevents using any other inplementation of DbEngineDialect (in fact there is a single imlementor), because only this class has that. If that the only class that we can use now then let's instanciate that by "new" rather this dynamic way. Alternatively, can we use Qualifier (like @Named) annotations in order to specify which instance of the class we're interested in?
Why do we remove the first character?
I think it makes more sense to calculate a weighed average here (weighted by the isotope intensity). In other words, if I have 2 isotopes in the same container and isotope 1 has 100% intensity and isotope 2 has only 1% intensity, it makes sense to report the mass value closer to isotope 1 mass.
I would suggest defining a new error code for this type of exception. BKException.ZKException is a bit confusing.
For an empty slice (Slices.EMPTY_SLICE, we have a single instance per JVM) value.getBase() is NULL so we can overtrack those in the else branch.
Didn't you yourself publish a library to avoid having to call this directly? Could be useful here.
How about adding an initialize() method to Mod11CheckValidator which takes the actual argument types instead of the annotation. That'd be a bit more straight-forward than creating the annotation proxy just for retrieving the values from it.
What was wrong with this line?
How about "just now."?
Do you want to return null from here?
match all initial values using a separate methods as said earlier.
Maybe extract processOldOrDeletedMessage() to reduce the nesting here.
are start /end / duration necessarily here?
Here you are initializing the taskGroupSuccess with true while it is true by default. We should set the task group success with false and only then update it to true
Despite type named MultiThreadModeConfiguration I would prefer singleThreadModeConfiguration for variable, as in fact you have single thread mode here.
There are some System.out and System.err print-outs in this class. What's that about?
You will hate me, but I meant of course all places where Display.getDefault() is used :)
you've switched the key and value order.
Is there a response code enum we could use instead of '200'?
some log finer/finest that this happened?
This token is used for login right ? Since this is confidential information avoid from logging them
getMacAddress() -> getInterface().getMacAddress() Why this change?
add fail() after insert
Moving Integer.toString here seems cleaner.
Duplicate code (see line 76). Create method?
Please watch the spacing, and be sure to never use tabs.
We could raise exception there.
S/b "Sending back not supported."
can you update this block to avoid double call on OpenAPIResolver?
It seems this could result in null. This may be rare but shouldn't this be tested ?
to avoid null check and get in a state when serverCapabilities is never expected to be null, this could be made async with getInitializedServer().thenRun(() -> { if (supportsWorkspaceFolders(serverCapabilities)) { LanguageServerPlugin.logWarning(...); } else { onUnregistration(reg, () -> enableWorkspaceFolders(serverCapabilities, false)); enableWorkspaceFolders(serverCapabilities, true); } })
We have too many nested try/catch/finally blocks here mixed with throws statements. Could we simplify this?
java throws Exception  may be replaced with  java throws ReflectiveOperationException, UnsupportedEncodingException
Could we avoid converting the integer to a string and then back again in the isValid* function?
When performing actions after a long-running async task, we must always, always check whether the current activity still exists, either by checking isDestroyed(), or isAdded() in the case of a Fragment. Otherwise, if the user has closed the current activity, this code will crash.
Might be nice if you can skip save if doc is not changed.
Nit: you can shorten column_a to a or x
Could you add the word "status"? The old message had missed it.
Does this need to be synchronized somehow?
suggestion assertThat(params1).hasSize(2);
change to new GoCipher().encrypt(..)
For this and many instances above this line, align [C]alendar with [T]imeHelper.
we must only take the first show and the first enable rule into account, or better only one of each type (so it is generic)
is preferrable not to nest all of the if/else if we can return. Its easier to follow that way.
The variable returnMe is probably useless as it can be replaced by a simple return everywhere it is assigned (lines 79 and 84).
Can we define "" as public static string METADATA_URI_FOR_PEER_DOWNLOAD in CommonConstants.Segment and reference the same thing in the server as well, to detect peer download? Once we decide it is going to be "" all components need to use the same thing, so might as well make a common definition. A change to this will need to be done keeping backward compat in mind, if at all someone wants to change it. thanks
Please review. if watcher is null, removeAllWatches is done. If not null, removeWatches.
You should be using equals to compare strings
Could this be lower-cased since the contains checks are looking for lower-cased strings? Unless there is a reason this must be case sensitive.
you should be able to do ((Number) original).intValue() instead of checking the class. Should be a little more robust in case there's a silly jdbc driver that makes all numbers Doubles or something weird like that.
remove
- typo ("for with") - log message could be more clear ("Unknown session while logging in anonymous" or sth) because warn is visible with the default log settings - should this be warn level anyway?
This is soooooo much slower than UsefulPsiTreeUtil.getChildOfType(expr, HaxeReference.class);. And I'm really starting to wish we had static extensions in Java. Maybe it's time to look into using Manifold (http://manifold.systems) in this project?
I would recommend putting the boolean condition in parentheses for readability.
Public method, where is readWriteLock
<>()
Please try to omitted the steps that are not necessary...review this in of all your TCs
switch all the tests s/CLIENT_RECV/CLIENT_SEND as it makes more sense (because it would be an error to have only a RECV annotation)
can you remove the 'return' or replace it with 'setWindow(null)'? (to prevent a blank dialog)
There is no cluster deactivation, forceDeactivation should be false.
move to parserhelper
Could you add the exception e as the cause to this newly thrown exception.
listNode.asList()
Looking at this pattern, I wonder if this would be cleaner: * Introduce a new UsableResource class * Have it have the same three states are we have now, but also a USED state Would that work? Better or worse?
Missing doc blocks on all of these methods.
Why was this removed? Not sure what it is trying to accomplish but seems unrelated to the overall goal of the pr.
Nit, most given methods should take a parameter. Something like:  givenUnitWithAttackPower(2)  If there is no parameter, and the return value is very generic, then something like the following would be typical (note the 'any' word):  givenAnyUnit()  Otherwise the given should probably spell out what is special about the thing that is being returned, you've done that in the example of: givenUnitIsAir()
Both are toggled offline?
These variables are used in both methods. Can they be declared as class variables?
you can replace to originalPath = (!originalPath.endsWith("/"))?originalPath + "/":originalPath;
This just gets sent down from Hq, I assume?
This should probably have a ; at the end?
I'd suggest returning the ID instead, the key is more likely to change than the ID.
List<Partition> results is not used.
Make the number a constant and explain there why.
I would make sure this isnt going to throw an ArrayIndexOutOfBoundsException
Should create a new ArrayList to wrap this.
I would rather do this calculation in tested method as in case of cores.
Having a class wide TestingRpcService would avoid this casting here.
should be GTE ?
Copy&Paste-Error? suggestion minLuceneScore = engine.getSettings().getFloat(Settings.KEYS.LUCENE_MIN_SCORE_FILTER, 30);
If the element we are looking for is "<log>", this code returns the location of the 'l'. It must be the location of the '<', otherwise it requires an extra loop (or will fail if there's only one event).
Is it possible for mediaFile.getTitle() to be null?
just checking you want these to be java asserts? production jdks are almost never run with asserts enabled
Let's move this into an else {} to the if() clause in l.1001 to avoid clearing then putting up the notification again.
Maybe we could follow up on some JMH benchmarks for this kind of stuff. Given the amount of work that has happened already up to this point I'm wondering if this is even worth it.
The new structure of Winery uses RestUtils instead of Utils. Please follow that.
use log pls
this might all be clearer if you call this eventClass? At the moment the line below  Event.eventTypeForClass(eventType)  is a bit confusing
nit: getLocalVersion may not always be cheap. It would be good to cache the result instead of calling it twice.
Why are you operating on Blocks rather than comparing lazyCompactPagesIndex.getEstimatedSize() with eagerCompactPagesIndex.getEstimatedSize() ?
minor nitpick: logger message is not equal to the method name :smile:
I suppose this is always true the first time because there are no connections initially?
Do we know instances when it won't be a TextAnalyticsErrorException?
This method consumes the entire monitor twice for each pass through the for loop, so won't report meaningful progress. Consider fixing using SubMonitor.
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
try / catch Coingi missing
I think that we can remove setResult(ok) soon, since it's for compatibility with vraptor 2x.
In the refactor patch I changed a logic reconstructing the original initialization method here, to avoid depending on JP data on input.
Please use if statements with braces (that's why CI fails)
The fixing comes from method.getGenericReturnType instead of method.getTypeParameters ?
How are these changes related to JDK 8?
If this catch is only for that new URI(..) on L 495, it might clarify it some to just wrap that one line that is throwing the error, that way we don't have unnecessary extra code inside of the try block
Unrelated feature. Please add a new PR for this one.
In general, you want to avoid ByteArray{Input,Output}Stream classes. They are excessively synchronized. We have ByteBuffer{Input,Output}Stream in the aQute.lib.io package as replacements.
You may use String constant here, move to constant file and refer from there. Eg:- DRIVER_NAME = org.apache.ignite.IgniteJdbcThinDriver;
is passing 'null' for subject intended change?
as discussed verify substringBetween does the right thing for us
lambda?
Similar problem here too .. exception handling seems to be misplaced.
can we please agree on adding brackets even around single line conditionals ? This is according to the existing style and less error-prone (believe, I hit that when adding a second line). Also, would prefer to have spaces between if( but I'm less dogmatic here ;-)
Delete the if, isPresent will work fine as Gabe says below.
Sorry to rehash this, but I have to say it at least once: this stuff is so hard to read.
For some reason (probably because it was a convenient way to override the optional attribute for REFERENCE for this tool) ReorderSam has a duplicate command line arg for reference. There is one in the ReorderSam class called REFERENCE, and one inherited from CommandLineProgram called REFERENCE_SEQUENCE. Both of them are used in the tool code, but only REFERENCE is properly populated by the command line parser. This code should be fixed so the variable usage is consistent. It might be best to just remove the local REFERENCE variable and rely on the inherited REFERENCE_SEQUENCE one, and just have the code throw if the argument is not populated. I think that would retain the behavior and remove the ambiguity.
Move Boolean.TRUE.equals(ignorePolicy.get()) to a static method called isIgnorePolicy
can we use batch evaluate of expression here?
can't you just set the style in the uibinder file?
Actually the file name is "gitgit.index.v3.skipWorkTree"
The naming of this field might be confusing if one looks at the complex map importer and this class side-by-side (both maps are "extended" in a sense, but the additional column is different in meaning). Please rename this one to hasMapTargetDescription or similar.
what about make a new method in AssociativeCommutativeCollection which returns the union of all three collections? In this way, you have shorter code in Visitors and Transformers. Besides, next time you want to change the contents of AssociativeCommutativeCollection, you don't have to go through many different places to make the change.
I don't understand why we need to wait here. Could you explain?
Don't you need to pre-emptively serialize this string so that the PL deserializes it back into the string that the user provided?
Can we assert anything?
4 spaces
I see test which check messages for containing no viable alternative, but do they also cover FailedPredicateException?
The comma looks odd to me. I suggest either removing it or replacing it with a semi-colon.
how about adding the message from the exception to the log message to provide more information?
nit pick, but Collections.emptyMap() would be better optimized here.
What happens if next() is filtered out? Does this attempt to retrieve the next flux emission or is Mono.empty() returned?
You need to get the previous state if it is changed.
Does this lock the table from inserts while the query is being processed?
This part won't work with the keys you registered selectors under though?
See general note on error handling and recovery.
Won't this break if the system's standard charset isn't UTF-8?
Worth including the sender address?
what's going on here? This seems awfully complicated. Is there a reason you didn't just use a StringBuilder and concatenate the ints 0..expectedResults-1?  java StringBuilder sb = new StringBuilder(); for (int i = 0; i < expectedResults; ++i) { sb.append(i).append(','); } input.putString(0, sb.toString());  [or something like that; you may need to convert the int to string.]
We reject the file because its name does not end with .xml, I do not think we should read it.
I think it's more readable if it doesn't fit on one line, move all parameters to the next one.
too many single letter vars. perhaps make t -> txn and v -> snapshotVersion
there's a typo in this error / log message "ctp" should be "tcp"
No, please log these. The Activator has a static log() method on it to make it easy.
This always returns a String, so why are you down-casting it to an Object?
Same as above -- Pending all queries infinitely might be hiding another issue in the cluster
As above, this seems wrong.
This should be ConflictException
Doesn't this risk overwriting files? e.g. if a project had resources config/foo and config2/foo. If possible the approach should be to copy the files with their directory structure intact.
One large window might skew the avg even the process are invoked after it, so this logic will catch both contiguous long window or spikiness. Please make sure it's our requirement.
Empty reporting rules are the default so this line is redundant.
we should increase errorCount, log a warning and return null instead of propagating the error so the query can still complete even if the cache is having problems.
I don't understand, why do you think FQN should be fn?
This is called ETag elsewhere (see CosmosAsyncItemResponse.java: public String getETag()). you Have it as Etag. we should be consistent on this.
You split images string into tag and image name multiple times in the code. To avoid duplication you can probably extract that logic in a new method.
Should this be based on total pending size in bytes vs msgs?
Collections.emptyList above and .emptyMap here?
Dejaria directamente el return asi: _return numTasksRunning == numTasks;_ (poner lo otro al final es redundante)
Unneeded?
I think there is no reason to push publisher here, if we push connectionFactory via four lines above. else if (this.applicationEventPublisher != null) { would be enough.
Space after comma.
conjunction (and disjunction) are commutative... should we implement that in the equals / hashCode ? (no, I'm just messing with you, don't loose any time on that :).
authenticationAttribues --> authenticationAttributes
can we just use !getIsNew() instead ?
Minor nit: Missing line carriage after @VisibleForTesting
Why not let the setup() method itself throw an exception in case of failure, instead of returning false? That way it'll be able to provide much more detail regarding the reason of the failure. You also won't need the 'return true' boilerplate for the successful case.
Looks to me like a possible or even likely issue. Please add logging ob **warn** or **Info** Level. suggestion } else { LOGGER.warn("skip copyObject reason: identical reference"); }
We should use categorized errors when possible: java if (!partitionStatistics.containsKey(partition.getPartitionName()) { throw new PrestoException(HIVE_METASTORE_ERROR, "Statistics result does not contain entry for partition: " + partitionValues); }
What's the goal of this assertion ? Isn't it .isEmpty() ?
If this was the self-assignment, I think it's still there.
Not sure this is necessary? The fieldType should already take that into account. See org.hibernate.search.backend.lucene.types.dsl.impl.LuceneStringIndexFieldTypeContext#getFieldType. In particular, if the field is not searchable, indexOptions should be forced to IndexOptions.NONE. You could disable norms and term vectors too, at least if they are not explicitly set, but I'm not sure it matters if indexOptions is set to NONE.
Suggestion. Move this nested try block into a separate method or catch the exception under the main try-catch block.
style nit: no braces around single line blocks
verify result (e.g. it's not empty)
I'm not sure if return null in ZS is that great. Perhaps just return current state and log a message of some sort? At least Log a message.
In the past two lines you can now use outputFboUrn.
also log if it is enabled or disabled
We just want to remove the OneSignal.getVibrate() call here. As a backwards compatibility for pre-O devices the OneSignal backend will still send "vib" depending if the Notification Category has this set.
Null-check
I don't think this is necessary for String types like language -- only the primitive objects need the special bindNull workaround.
also a mapping rather than grouping
does the instance become unusable or why create the builder twice?
Why make this static? Shouldn't this method operate on data within a Message instance?
This device seems to be unused. Can it be removed?
Perfect, that's just like I expected it how it should work.
Space after for ... e.g. for ( ... )
1. We are providing core level support by protected. Any reason ti change it to private? 2. Create one more method with Multimap than change it here.
this.
Hi, we use "stopIcon" instead of "cancelIcon" for generic "cancel" button action. Please change it here. Otherwise it looks great and can be merged afterwards. Thanks.
Maybe just .forEach() instead of stream().forEach()
I don't think you need replaceAll here just replace since replaceAll is for regex.
assertThat( query ).assertThat( query ) ?
seems like we should return userlist (would be empty) here? or L475 should also return null? might just need to be consistent
I agree with @jeremiahjstacey here about not needing StringBuilder here. This in fact is a pretty common pattern throughout ESAPI and I'd prefer to not make this occurrence different than the others, all which already seem to work and do the right thing.
Please introduce a variable to reduce casts.
Doesn't it make more sense to have this in the init() method, or maybe even in the ctor?
Can we use meaningful variable name?
When could the type be null in this case?
no need to log anything in this case ?
use Arrays.asList(...) for short lists.
Let's call this variable stars or starred. Better avoid compound variable names: <LINK_0>
Same here. Let's separate the two cases of not having amount and having illegal amount. Also, log that the amount is ignored.
move this logic into certificatemanagerserviceImpl class
intentional at error?
Move lines 66-73 inside rwInExpression since IASTIdExpression is a subclass of IASTExpression.
I know this isn't new, but might be worth investigating if there are faster hashes that are unique enough for this (not necessary in this PR, just thinking out loud)
Nice clean up!
can you get scheme from the location URI rather than caching the old scheme?
Missing final
It is done automatically, yes. All of us have developed Java for more than a day ;) But: 1) imo this is exactly the kind of change that cause unnecessary conflicts (right?) 2) often these are nice for debug breakpoints 3) there is no reason to not have them. there is no performance penalty
Why set the value if null check next? Check for null value of currentSessionDetails and if not null then only call currentSession.setSessionDetails and continue further.
sb.append('.')
The test might run slightly faster if, instead of reading the file twice, the test moved the originalResult up to line 37 as an initialization and used the originalResult.length for this assertion. Just a thought. Also, if we have asserted result.length is equal to originalResult.length, we don't need to test both in the loop below. Just a thought.
This guy belongs in a finally clause
No need for a second thread in this test. It would be simpler to verify the flow control properties of the monitor if you post a bunch of events to the progress monitor right from the UI thread, run the event loop until it's empty (rather than for 4s), then assert that the number of events posted to the Collector was exactly 1. That will run about 1000x faster and won't have the potential for flakiness if the task scheduler does something strange. The first test is sufficient for verifying that the monitor works correctly in the presence of multithreading.
What does this change do?
To align with the rest of the codebase, please leave the final keyword off of local variables.
use getValueAsLong()
here it is better to choose a dot notation for metrics because it easier to create aggregation rules on collector: hitCount -> hit.count hitRate -> hit.rate averageLoadPenalty -> load.penalty.mean load.count, load.exception.count ...
I believe that whether it's SOFTIRQ or RAISED_RUNNING, in both cases you want to return SOFTIRQ?
hmmm. so 1,.,2 will return a null value? I guess with primitive doubles we have, to...though we could use NaNs for that. maybe when we support 4.3....
Was this accidentally included into this change?
does this need to be both or neither? Sort of makes sense that they'd both be required fields, but it's not totally useless to have only one. E.g. if min for x was 10 and you had a predicate where x < 8, you'd know that nothing matches.
Looks like we don't have a timeout here, does it mean we will retry to verify forever if standby's apply phase is stuck? In this case, we need a user to enforce snapshot sync?
Using a positive variable such as first is usually easier to understand than a negated one.
I vote for making it an ERROR level message.
Consider the following operation order: 1. init() and reset() is called at the same time. 2. In init(), the code reaches line 652, but not start yet. 3. At the same time, in reset(), code reaches line 776, and tries to shutdown the thread. But it cannot, since the thread has not been started yet. Note, in java doc, "Interrupting a thread that is not alive need not have any effect." 4. Then the code in init() try to start, the thread is started. We have a leaked thread, eventually.
I think it could be a bit more efficient if you do  if (!hasValidLicense()) { //When no License, we only allow the system workflow return new ImmutableList.Builder<WorkflowScheme>().add(workFlowFactory.findSystemWorkflow()).build(); } final List<WorkflowScheme> schemes = findSchemesForContentType(contentType); ....
Could this and the previous line be combined? To reduce the nesting?
matter of taste and style but I tend to prefer :  programState = pop.state; if(!instruction.hasReturnValue()) { programState = programeState.stackValue(returnSV); }  one less branch...
can be written as assertThat(logList).containsExactly(logEntry2, logEntry1). Does all 3 previous checks at once. :) I must admit I didn't use those more advanced assertions myself...
here you should do a negative check for the same value "bar0" as the one you check after the deserialization.
we still need to have an option to run with the old language format (as a subdomain)
org.eclipse.che.api.project.shared.Constants#BLANK_ID instead of hardcoded string
If CamusSweeper extends Configured, you can get a Configuration using getConf().
Please rename objectoutputstream to use camelcase naming.
Perhaps we should filter on dev pool type here in case we ever use the consumer specific restriction again.
This assert can never fail.
I guess that if there are no reviewers there is no need to set the receive-pack service.
The exception should have some error messages.
Keep specialised exceptions, I guess this would become throws NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, IOException, CertificateEncodingException, KubernetesAuthException
I am not sure why we need to have types here. If the THEN is a literal expression of type string (the value itself could be numerical), then we are always going to project string values. Why do we need to run over types here?
.query(query)
How about we use the isBetterOrEqual method from GeneticAlgorithm class?
Do we need to error out if beginValidTime.isBefore(endValidTime) not met?
This looks generic can/should we move it to some utility class (and also write integration test for it)? Happy to be deferred, so not in this PR.
encodings ?|? name it methods
Thanks, this is much clearer! I think we don't really want to crash if an app developer accidentally doesn't add EXTRA_PROCESS_TEXT... Can you get rid of the assert and just write the following? if (search != null && search.length() != 0) { Last nitpick I promise :)
string.format or let's use stringBuilder to make it more readable ?
Missing call to checkNotNull here which gives an extra warning
this comparison is wrong, shouldnt it be threadGroupCount > estimatedThreadGroupCount?
better to use Type than String , make the service less tightly coupled.
it's probably better to do this at the top of the displayNewPage() function, to capture any other cases where this might be possible.
The same as above, bad performance
It looks like the final two branches do the same thing. Were they meant to assert different things?
This seems like it would be problematic. I would have to wait a default of 5minutes for tablets to be migrated to a new server in a pool (because the pools would not be recomputed). Did I miss something?
This could be simplified to Objects.equals && Objects.equals to avoid nested if statements.
I think quick return helps to highlight the important code vs check code: java if (parameters == null) { return ""; } // ...
Currently Tal is working to remove storageType checks from the storage pool level so getStoragePool().getStorageType() won't be available. More than that local storage is limited to local data center so why you can't use just StorageType.LOCALFS?
Revert?
Why isEmptyOrNullString? Should it not be just empty string?
Add java doc
<%s> ? no strong feelings, it would be consistent with the Variables view
How can this be correct when the bounds above are 16 and 64?
I would move this check to inMemory() in the builder instead and throw an exception there instead.
You can probably call only once this method. You do not need to do it in every iteration.
Could you move this operation into NotebookService ?
necessary?
Is there a way to have this check in a top-level place and avoid having this once per Listener method ? Like at instantiation for example, and we wouldn't even register the listeners at all ?
Fire might suggest something is wrong and confuse people on success
Not sure if TeammatesException should be used here as it seems to denote some sort of logical error in the system, rather than failure with datastore or GAE.
@yesamer I see two issues there 1) that getPropertiesToHide is meant to need the selected column, so it must throw an exception if selectedColumn is null (because it means there is a bug in the calling code) - if you find a way to enforce that please do it 2) if undo/redo needs to call that method, it means that some needed information are missing from status, so you have to add them there; said differently, when calling undo/redo, status must have all the informations it needs to set the scenario
computeIfAbsent() returns the proper instance of AtomicLong, so you can just call incrementAndGet() directly on that instance like below. This is better because we can avoid unnecessary get(). java totalSuccessfulTaskCount.computeIfAbsent(task.getDataSource(), k -> new AtomicLong()) .incrementAndGet();
Should also support .less and probably some other formats
Long i should be long i. Please inline start and numCols here.
i do not know the whole context, however shouldn't use a more efficient structure here, such as Set. The contains could be Log (N) instead of O (N)
belonging -> "which belong"
This reduces usability for console and other environments where the clickable text is not available.
we expect our schemas to be of type RECORD. This is a good test case to have though, should check that this throws an exception.
nit: add braces (preferred for all blocks)
use it directly there. (via variable)
assert two address objects
this should only be set if the configuration contains values. Otherwise the header should not be set.
we try to avoid usage of lambda, sorry ;-)
would it make sense to have those booleans hidden in MongoQueryMethod so that we could just call method.isCustomQuotedQuery() or method.isCustomQuotedFields?
{ } blocks please.
instead of creating a method setDataServiceManager, you can use TelephonyTest's replaceInstance().
Do we need some sanity check to avoid newly added acls conflict with existing ones?
Why are you sending the NOT OP message? They are not op already, so this should not need to be happening.
Same here: includeDetail ? weekActivity.getTotalActivitDurationMinutes() : Optional.empty()
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
Although it's short and neat, changing the value of a variable in the same statment as comparing it can easily get confusing. I would recommend using a for loop (e.g. for (; number > 0; number--)) or decrementing the variable inside the while loop.
remove
missing braces
nit: blank line before method
This variable name and its type confuses me
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
consider moving this logic to the backend entity, you can do it simply by defining a default values for the username/port variable in the entity, the grate benefit of this change is "one-place" change when you need to change the defaults, also this is less error prone for the clients which won't have to define the defaults by themself
how are we going to differentiate flows for different resources (like sdx or distrox)?
as mentioned below, the option should be already resolved here to the path (if any) for calling buildArchive
The name and location of the properties file is no longer configurable. If that is the intention then just hard code it directly and don't do any getProperty calls or tests: System.setProperty("com.arjuna.ats.arjuna.common.propertiesFile", "commitmarkableresourcejbossts-properties.xml");
I'm worried this will get noisy in production. Looks like a debugging print out?
Do we even need this section in here anymore?
System.out.println(".....recording id") . >>>> delete recoring id part, not needed for list
Should we return an error status with the exception here?
Honestly I would rather recommend making a seperate PiglinBarterDrop interface for this instead. (You can also just make it extend RandomMobDrop for simplicity). Because this is a bit un-intuitive.
this is not a correct replacement, the implementation of the StringUtils.isEmpty is: java null == s || s.trim().length() == 0;  This is why I have been asking contributors to use StringUtils now my concern about inconsistency is back, somewhere we will check just string, somewhere trimmed string. I understand we do not wan't a dependency for whole stunner just because of single method, but we shouldn't make exceptions and copy code. Because then it is a habit not and exception. however if you think there is no existing util class available in this module and not worth to add it there. I will not block merging.
Use ProxyFactory.getContextId() instead of contextId...
consider consolidating this and the block in L:131-138  if (batchOperation.size() >= MAX_WRITE_BATCH_SIZE || !iterator.hasNext()) { table.execute(batchOperation) }  This will get rid off the special redundant code to process the last batch
When could the cause ever not be null?
The style guide [requires](<LINK_0> a space between if and (. Might as well fix it while changing this line.
should this be an error? if a user provides the wrong data, are we going to log it everytime? for me it is an expected situation, not an error... at most a warning, but I would go for an information or even a debug log: the only reason I would need to see that information is if I'm trying to understand why something is not working as expected, not everytime a user provides wrong data in prod... at the same time, you could also argue that it is the responsibility of another component of the system to enforce that? your choice, I just wanted to raise the point :)
Could we have a utility method in DiscussionThread that returns the AuthorAttributionType based on this logic? Also, these lines is a quite long, maybe they should be split.
I think geoms should always be defined, and always have length 2 (hence my suggestion to use a P2 type above). If in some branch the geometry split would not happen, I would expect an uninitialized value of geoms == null.
I suggest using toTraceId() consistently everywhere, not mixing get- and to-
I think these two cases are correct, but I kind of like the idea of all paths of this method ending up calling saveDeviceId just so it's easy to verify that we never put ourselves in an inconsistent state.
I don't think this needs to be a complete implementation, just return the Xid[] with xid or null depending on whether its still available for recovery
This will fail in NPE if editorInput is not an instanceof... do not leave the "else" unwritten: } else { throw new IllegalArgumentException("Could not save comparison model"); } or "return null" in "else" if the case is not problematic and the caller can handle the null itself.
There's a much simpler solution here:  java mHandler = new Handler(Looper.getMainLooper()); synchronized void highlightView(...) { mHandle.removeCallbacks(mHighlightOnUiThreadRunnable); mHandle.postDelayed(mHighlight..., 50 /* millis */); }
great, thanks !
Inline
Stepping through the test, it appears this header is being set to "ht/tp/:///e/". Don't think that's quite what we want :) I believe you need to make a PID out of fcrepoBinaryUri and ask it for its id before passing it into idToPath
else { is redundant
You can skip encoded_tag_keys
nit: I like to assert the list size first and retrieve items from it second, so that if it's empty the assertion fails rather than the test throwing an IndexOutOfBoundsException.
We can take communityId out of this uniqueId computation, and with it, the line above that sets communityId = null. The DB path accounts for userId, orgId, communityId, and all we need to associate it with a user account is userId. If a portal user if logged into a community, the userId will be different. If an internal user is logged into both org and community, the DB path will be different. Hence, the uniqueId should always be unique with userId + dbPath.
you should throw the exception at the very end - outside of your try catch.
trailing space at end of the template string.
Probably more an unboost enchantement. The AI uses the Outcome for some target decisions. Boost is positive and means its cast on own creatures. Unboost the opposite.
Hi! Thanks a lot for your contribution! It seems like the java 8 map implementation changed the elements order in the entrySet().iterator (used in the DefaultDefinedMapMetaDataModel constructor), that's why this test fails, because it expects the item 1 to be STRING, and the item 0 to be NUMBER. The best way to fix this test is just to requiere the map size to be 2, and that there exists one STRING field, and one NUMBER field, no matter their positions. A good approach to do this is by using:  org.apache.commons.collections.CollectionUtils.exists(<collection>, <predicate>)  This way the test will be much clearer! Could you please perform this change? Thanks!
cant we make profileQname, targetHostsQname constant fields.. There are several other places we can do the same.
If something shouldn't be there at all, it's not the debug level. It has to be the error level.
Why isn't the implementation is in base class?
The finally should wrap the entire method ("Always unload before returning") Otherwise, if everything's fine, this will: - Load the resource - Go to Finally => Unload the resource set - Check the contents of the Resource -> It has been unloaded and will always be empty
You can do mFs = mCloser.register(inputPath.getFileSystem(conf)) (applies to mReader too)
For these, is there a method System.assert(condition, message, exceptionType) that you can use rather than constructing a new exception within an if/else?
use 'L'
Do we need to maintaining type information upon return from this method? Currently, once this method returns we will lose the concrete type and the caller will need to check the object type if they want to access the extended message properties.
Why can't you use the logging infrastructure and set the log level accordingly? Include that in log4j2.xml:  <Logger name="org.jabref.logic.importer.fetcher" level="DEBUG"> <AppenderRef ref="CONSOLE"/> </Logger>
Total can only be 0 once. Is this what was intended?
I know I LGTM'ed this, but it looking at its usage makes me second guess that decision. How would you feel about amending it to: F.qualifier().exactFamilyMatch("family").startClosed(...).endOpen(...) Or something else, range(family) is too misleading
If you make a change here make it:  if (logger.isDebugEnabled()) { logger.debug(.....); }
Is there any reason why we can accept only UiStringRes and not UiStringText? Have we considered using mUiHelpers.getTextOfUiString(this, messageHolder.getMessage()). ?
style nit: missing braces
Are you sure this will never NPE?
This is the EC policy patch again. I don't see why abfs needs it at all.
Style-nit: Space before {
te1.getPos().equals(te2.getPos())
@ok2c bot sure we want to suppress IO errors in non-interactive mode
this test should be testing oldValue , this also means that condition is not covered by tests (field is never null here). However I would suggest to replace whole thing by calling ProgramState.put(field, newValue) instead, reusing the logic which is already there.
initEditMessageAction logic belongs here.
Since this is an infinite loop I think at least a WARN if not an ERROR is justified here.
If writeSegmentFile in SegmentUtils was made public, this code could be reduced to a one-liner (as in the methods calling the public readSegmentFile method above).
Are there not more language fields set than this? There is a main audio language element, no?
Please compare the current and previous for the following:  FlatRow.Cell previous; for(FlatRow.Cell c : cells.values) { if(previous == null || !c.getLables().isEmpty() || !keysMatch(c, previous)){ combined.add(c); } }
All of these builder args (like, last 16 lines) should be handled in superclass constructor already... was there a reason for this?
it's strange that we use the Collection interface here which doesn't reveal it is ordered but here we rely on the ordering. I think we should better use the List interface, this would also allow to directly access the last entry
What is the purpose of this removal?
Current database is automatically created and dropped. You don't need to do explicitly.
THe order here is wrong. we have to accept the query before we build the entity projection. THe entity projection includes parsing code that can throw an exception/error. Those queries wont' get logged. Also - accepting a query could move to the handleRequest function
Define this as static constant: java.util.concurrent.TimeUnit.MILLISECONDS.toNanos(1)/2
Ditto input1
If there is several methods in the hierarchy, this call will raise too many issue.
Braces?
Why not catch NodeSourceNameAlreadyExistException instead of checking type ?
Should this throwable be logged as warning?
It looks like this function handles a member get() function, but not a non-member get() function? Structured bindings can work with either.
Please, add this line back as it was before (to reduce diff).
Do you intentionally use a TopicPartitionReplica which is not provided in the response here? I guess that it is to ensure that its future is not completed, isn't it?
Shouldn't this condition be just "if (returnValue)" without the negation? With the negation if something failed prior to this code (for example if the name already exists) then the value will be discarded and replaced with the outcome of "isGlusterDc...".
nit: please extract the message to a static string
nit: should we log the effective rate here?
typo: "Pipedlined"
creationDate, sample fetch, and permissions should be handled in Service
Null check.
I'd also have a Capatabilities test for completeness (checking the feature type is gone, but the others are still there)
isEmpty
ERROR messages need to be externalinzed (anything other than DEBUG, really)
maybe use contains() instead.
Would prefer to have it joined here. There's no need to leak the info about how recent changes formats its argument all over the code.
use try with resource ?
no need to have this check as it is already done in the enclosing if condition.
Looks like you can use subquery(LOOKUP_LOOKYLOO) here instead?
string.equals?
Again seems weird
got out of the dashed line
not needed?
@shivtej1505 what about extracting the lines above to a separate method ? You are doing same thing twice so I think it would be better plus the method name like enableDownloadButton would make it easier to understand code fast :)
Maybe microseconds instead of nanoseconds are better here. I don't we need nanosecond precision for wait time, and it'll be consistent with the procedure execution time statistics.
Either just set or pass the return value to the next line.
Best practice is for the first letter to be lower-case, so it should be idpSecToken. (this also applies to the other 2 similar usages below in this file)
Note that since this is waiting in node but not sh it only exercises part of <LINK_0> (when <LINK_0>/commits/58b127fa34cd10bfc76659b86292832965fe7c95 was added).
here too, ditch the timing information, no one will use it. at some point I'll finish metrics and it can go there
This is much easier to understand! I still think the tests we have for this should be more comprehensive in terms of properly checking the properties on refunds, that refunds and charges sort by date and not by type and that refunds outside the date range are not included. However, it's fine if these aren't implemented until the new DAO is actually integrated.
required?
Unknown is not exactly accurate because some other types (e.g. INSTRUCTOR_COURSE_JOIN, NEW_INSTRUCTOR_ACCOUNT) are known but we just don't cater for them, maybe not now, maybe never. Email type ... is not accepted. is more accurate.
Is there a reason why we need the color picker for this test? Why was this changed from .setColorResource(R.color.pocketpaint_color_picker_transparent) ?
extra blank line
maybe better log message would be: String.format("Resource %s is not found on the classspath so the property %s is not replaced.", classpathResource, key)
What happens if the init fails? shouldn't this be in the finally? that way even if it fails it won't get other threads stuck.
if this method can be called more than once, then clusterParticipant should be either volatile or AtomicReference.
Can this check be factored out into a separate function? That way there's no risk of openInputStream and open getting out of sync.
Intellij should be able to auto-generate a toString for you (Code -> Generate). Then you don't have to manage pulling fields out of objects like SSP. SSP already has a toString anyways, and the auto-generated toString would use that.
should be left null or not put in the map because the map is not meant to be a friendly output for the user (TMC does that) => TMC would be the place where a missing value would translate to MISSING. In the backend (and json), the valueshould just not be there. Like any other optional fields in the topology.
Same as above. Is this the final implementation?
I think this check here is unnecessary since this situation should not ever happen. I think you can use here just synchronizeGroupsStructuresRunning.setValue(false)
I think element duplicates representation. We should reuse representation here.
Should this include withExpirationPeriod()?
suggestion server.getFileStreams().forEach(UncheckedFiles::closeInputStream);
maybe it is better to log each hook run? I would also consider moving the loop into runHooks method or so
unrelated changes
remove extra new lines
Return the buffer to the pool?
Shouldn't the order of the parameters be the other way? Since first argument is "expected", so this might mislead you when you see the assertion error.
I wouldn't add the break unless we have a performance problem and we know its here?
Maybe keep this buildFrom. The intent is to improve existing stats, so retaining any new fields should be OK. If, however, you insist on setting all fields explicitly, using ctor directly would be cleaner.
Shoudlnt there be a hasError() method?
i guess to begin with, this call 'removeIfLedgerNotExists' is redundant here. 'removeIfLedgerNotExists' should be already taken care by "entryLogMetaMap = extractMetaFromEntryLogs(entryLogMetaMap);" in 'runWithFlags' method. 'removeIfLedgerNotExists' call should be removed from here.
We might want to consider using <LINK_0> instead of the string "/"
why not fail in un-supported versions ?
Beware - if the String contains multibyte characters, this will blow (a german umlaut will be encoded as 2 bytes if the native encoding is UTF-8). I would create a byte array on the java side.
This separation is awkward and results in our calling the ICommitMessageProvider2 twice, which is unnecessary since it already returns both the message and the desired caret position in the first call.
What happens when format is NULL?
why the synchronized, the segment store is thread safe? Making fPixel size a local variable rather that an class variable might be a better fix for concurrency?
We usually don't go through the double check...
could you please perform an extract method and put the common parts in one method that both letterify methods call? Thanks
i think you can probably remove this method altogether
Maybe add this statement to the GlowPlayer#setGameMode method instead? That way, this fix would also apply to plugins changing a player's game mode.
final.
Does start get assigned a new value? or it will always be 0? If always 0, then should it be a constant instead.
Why use a random number? Did you try a graduated system (spin for N times, yield for M times, park)? Also, did you try Runtime.onSpinWait() in any variation? I think we'll want to have the number of spins be configurable, and the number of yields as well. When 1 CPU is detected, the spin counts should be fixed at 0. We might want to make onSpinWait usage (if any) configurable, since the pause duration is variable between CPU families; ideally we should (eventually) be able to detect the target CPU and CPU count to get a good guess at optimum parameters if possible.
This introduces a dependency on the Java scripting API. Is this desirable?
in terms of code readability it would have been easier if the cases were grouped (conditions keep being repeated): if (pathFragment.startsWith("/") { if (currentPathEndsWith('/') { ... } else { } } else { ... }
TemporaryFolder should take care of this.
Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
What about the case whereby a unit is assigned to this transport according to the unit but not according to the transport ship?
Redundant cast
s/"+/" + an extra space
If there are no hosts available for this op, shouldn't you warn that ALL the domains were not synched?
do we need to do something special here for Windows directory separators?
Since this is the only place where mCallback is used, perhaps we can avoid holding a reference to mCallback and simply use this here:  if (getTargetFragment() instanceof Callback) { ((Callback) getTargetFragment()).onSuccessfulInput(editText.getText().toString(), callbackId); }
A path limited RevWalk is needed here to find the commit that last modified the file at the selected path or else the previous commit may contain the exact same version of the file as the HEAD version. See CompareWithPreviousActionHandler for an example to use.
suggestion private boolean addToResources(OffHeapResourceIdentifier identifier, long capacityInBytes) { AtomicBoolean status = new AtomicBoolean(); resources.computeIfAbsent(identifier, (k) -> { status.compareAndSet(false, true); OffHeapResourceImpl offHeapResource = new OffHeapResourceImpl( identifier.getName(), capacityInBytes, (res, update) -> { for (EntityManagementRegistry registry : registries) { Map<String, String> attrs = new HashMap<>(); attrs.put("oldThreshold", String.valueOf(update.old)); attrs.put("threshold", String.valueOf(update.now)); attrs.put("capacity", String.valueOf(res.capacity())); attrs.put("available", String.valueOf(res.available())); registry.pushServerEntityNotification(res.getManagementBinding(), "OFFHEAP_RESOURCE_THRESHOLD_REACHED", attrs); } }, (res, oldCapacity, newCapacity) -> { updateConfiguredOffheap(newCapacity - oldCapacity); for (EntityManagementRegistry registry : registries) { Map<String, String> attrs = new HashMap<>(); attrs.put("oldCapacity", Long.toString(oldCapacity)); attrs.put("newCapacity", Long.toString(newCapacity)); registry.pushServerEntityNotification(res.getManagementBinding(), "OFFHEAP_RESOURCE_CAPACITY_CHANGED", attrs); } } ); Map<String, Object> properties = new HashMap<>(); properties.put("discriminator", "OffHeapResource"); properties.put("offHeapResourceIdentifier", identifier.getName()); StatisticsManager.createPassThroughStatistic( offHeapResource, "allocatedMemory", new HashSet<>(Arrays.asList("OffHeapResource", "tier")), properties, StatisticType.GAUGE, () -> offHeapResource.capacity() - offHeapResource.available() ); updateConfiguredOffheap(capacityInBytes); return offHeapResource; }); return status.get(); }
QQ: Can anyone create the container or only the processor which holds the lease on the blob? Since I haven't looked at the Azure JobCoordinator, I just want to make sure there aren't multiple clients competing to create the blob.
Shouldn't be a need for this line.
Please print all status messages to System.err. It's generally good practice, and it'd be nice to try to keep System.out clean in case we ever want a command that outputs something like JSON to stdout.
What's the meaning of returning false without truncating? Is the file in a consistent state?
The principal ID is the user ID not the object, you should increment for the object ID ONLY if it is of type VM
same as below (constructor without criterion)
Is that type of exception suitable for the 'keys' service? (OpenStackException)
invoking m_es.shutdownNow() again before throw exception would guarantees the shutdown.
Attach the exception to the warning.
You probably only need to call setX() once :)
numBlocks? or numLocalBlocks?
Hi, Thanks for elaborating on the previous patch :) The problem with this code is - a. It's not clear (but you were nice and explained ;) ) b. I understand the fear from NPE, and that we want to protect ourselves (as more than 99% of exceptions are NPEs), but I really really don't see an options that vds will not have compatibility version, but I may of course be wrong. What do you think? as you understand my issue is with the String clusterVersion = Config.DefaultConfigurationVersion; code. Thanks!
It looks this method is not called in ProzessverwaltungForm - so it displays all processes and templates.
Worth using an empty set (i.e. Collections.emptySet()) when null/empty instead.
i18n
this condition should be reverted - else, index-out-of-boundaries-exception guaranteed.
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
This should be refactored to be if/else if/else, instead of using conditional operator.
How is this meant to work? Are you assuming that assertions will only be enabled in testing? If you need some logic to only be executed during testing shouldn't there be some sort of internal flag indicating this?
Unused variable
IntStream.range?
Aren't you supposed to test if the previousOrder field has been set
Because this is a Text Box, it will need the 'modifyListener' like the Spinner widgets. Without it modifying the contents of the text box don't register as needing an 'apply' when changed.
could this raise an IOE? If so, that disconnect() afterwards still needs to be called, so make close() a catch/log operation. IOUtils.closeStream could do this (and it includes the null check)
I am happy with either, does geometryType capture coverage cleanly?
Instead of having the Id as constants, why don't you create all the entities as constants? This makes the unit test shorter and easier to read
I am unsure: return ret;
use consoleLog
No need to log all of these separately, the exception message / stacktrace will say what it is, can you collapse it in to one catch block please
Minor style issue - finally should be on the same line as the closing brace of the try
We shouldn't catch the exception over there.
extract method suggestion assertTimeoutPreemptively(ofSeconds(5), () -> executor.run());
Can we move the FlowMessageBuilder implementations to the parser module and let the parser do the dispatch by an abstract method (something like protected abstract FlowMessageProtoOrBuilder buildMessage(record, enrichment). In addition, there are a couple of methods below, which still do BSON stuff. Are the still needed?
Why the token is supported only for Resource but not for Page ? In case of a Page there will be locking on the page instance and it will work sequential but it should still work, I think.
Would .size() > 1 instead of !.isEmpty() make sense here? Do you think assuming that a tank that has a tank list of 1 will stay at 1 and return that one tank's content when asked to "anything"?
Is there some reason why are you declaring these variables before initializing them? It reduces readability for no apparent reason.
This method can be moved to the GraphAndEdges class with together with makeKryo(), save(OutputStream outputStream) - making the GraphAndEdges responsible for serialization.
Do this globally for all the error emits.
since min <= max, this can be reduced to: xmin >= x && xmax <= x + width && ymin >= y && ymax <= y + height
FYI, the recently-added Timers.singleShot(200, () -> { ... }) would be a more succinct way of expressing this. <LINK_0>
Using an NPE catch as control flow is not a good pattern. It's better to do the null check by hand.
could be defined at line 1064 since it's not used before there
PLease, add translation
Is this also needed for non-first parents, too? I haven't thought it through. (The non-first parents can be encountered via RevCommit.carryFlags. I'm not how to quickly tell what code assumes that a RevCommit is parsed and what code doesn't.)
release should be in finally block.
maybe we shouldn't include confusing characters together like 1 and I, 0 and O, . and ,?
are you sure about the name users?
This looks... odd. Can you tell me how to reproduce the issue you're working around? I'm concerned we may need to do more than just ignoring the call...
we could use the carbon.properties file as well to pass the property
getIntInRange() for both? or atleast neg/0 checks for each of these three configs if you don't already have them.
If only one-side has been reconfigured, this method treats the other-side's metric as valid and collects them, during system reconfiguration. But those collected metrics will not represent the stable state of the system, because reconfiguration of any one-side definitely affects the behaviour of the other side.
What's the difference between this test and the test on line 194?
This is not part of the cl, but this will not work, see here: b/141323834 #9
What line(s) of code do we need to catch IOException for? Seems like you're already handling IOException internally.
I don't think this should be changed since on the reactive side we don't support anonymous users.
I guess EclipseLayerEx should be in the catch block
not sure what find and account means
Why all these additional newlines? there should be only one
Can we refactor AmqpConnectionManager to make connection factory injected and avoid modification of the class that is under test?
There is a copy-paste error here. TSK_WEB_BOOKMARK is added to orderingMap six times. It accidentally works out because all of the currently supported artifact types are all using DEFAULT_ORDERING, and that is also the fall back if an artifact type is not found in the orderingMap.
extra space
What about refreshPlugin(Refreshable plugin) below? Shouldn't is also call repositoriesViewRefresher.repositoryRefreshed(rp) if the plugin is a RepositoryPlugin?
You can delete this. You don't use mapboxMap elsewhere.
nit: use TextUtils.isEmpty instead of a null check for strings.
Lib has a utility to do this.
It may need a generic exception (or other design) to indicate (or know) the capture request is issued or not. Once the request is issued then it should not file next image capture request in onFailure() callback because next request will be issued after onImageAvailable(). For example, if failure happen on "preTakePicture()", then it needs to file next request. if failure happen on "postTakePicture", then it shouldn't file next request. It depends on capture request issued or not. One thought is to define a flag in TakePictureState and set the flag after capture request issued. Then it can depend on the flag to issue next request or not.
is EnvVars thread safe? There are multiple threads accessing this code, so you risk them overwriting eachother.
Optional: Should it be "The endTime should be greater than startTime.". Better: retrieve all msg from a property file so that we can change without modifying code.
Code style
Yep, would really like to find another way then breaking out Transformer and SerializationHandler from internal JVM packages. Looks like you are using this to quickly implement an encoding?
Let's introduce an interface to avoid all of those instanceof checks.
Probably set this down by where the sha1 is set for the object, for consistency.
This is not the right place to add the filter to the chain. It must be added the same way the other fillers are added in DefaultFilterChainManagerConfigurer and AbstractStormpathWebMvcConfiguration (the former is for Servlet, the latter is for Spring and Spring Boot)
Did you mean to write "else if" here?
Method is too complicate to understand, pls split on different methods.
Why aren't you using 'createNic(..);
This is a style/opinion thing, but I would rather see a class/interface here instead of a Triple; otherwise it's hard to know which File is which.
seems out of alignment to me.. this would fail checkstyle apparently.
and since this assertion is pretty popular, I guess you could refactor it in its own method. Doing assertThat(passiveMessageHandler.getTrackerClients().count()).is(x)
You don't need to change this method signature. I would leave this method private.
This function already calls findByReferenceId as it's return value so you don't need to call dataAccessRequestService.findByReferenceId() again
I think this can be truststorePasswordAlias instead of the string?
No need to check for null, releaseConnection already does that
I'm not sure what you mean. I'm not too concerned about whether we have lots of small, fine-grained tests, or a smaller number of tests that test a more complete scenario, but we should, somewhere, be testing that all child attributes that the mapper creates are in fact created correctly. That includes testing all attributes when we have multiple jobs with the same name; I can imagine a bug where only some attributes come from the correct job.
Why adding unneeded braces?
Just my personal preference, but I'd switch the operands because of readability reasons (i.e. event.getPropertyName().equals("location"))
Any chance ":where_clause:" ends up being a valid token in the request? Would be best to ensure that it gets removed in the sqlview definition before merging in the query instead of after building a query with bits coming from the user. Many things can happen, the filter encoding which is different by DBMS, custom functions and their encoding, this being a base class for many databases... while ":where_clause:" is pretty specific, the changes of conflicts are non zero. Also, if you remove in the sql_view expansion, there is less need to sprinkle around calls to "removeWherePlaceholder". Idea, get the filter, pass it to encodeTableName (or pass the full query to encodeTableName) and handle the removal there instead. Mind joins, not sure what goes on there... actually, make that happen in VirtualTable.expandParameters for better effect. Or, to avoid changing the existing API, one option could be to add the removal of the placeholder as a hint.
Hmm, what is this? What is a java template?
Do we need to clear the repository ? We're doing it at tear down already in clearRepo
will this cause busy-loop?
Do you expect this switch to grow new cases? Otherwise a simple if ("json".equalsIgnoreCase(srcExt)) is simpler.
nit: should we keep 2 tabs alignment for everything?
What will happen if there will be a deadlocked delete task? If I read the code correctly we will be spinning here forever? Is there any way to avoid this?
Since this adds a new listener, should we clear the listeners before adding the new listener? I know setupContent is called only once right now, so it won't make a difference, but it wouldn't hurt to be defensive about a potential change. What do you think?
This logging is not related to this PR, so please remove them all. If you want to add the loggings, please create another issue.
maybe define a const for "/organizations/" also, we can call only one time path.indexOf wdyt ?
simply call scheduler.schedule(new PollingRunnable(), 0, POLLING_FREQUENCY)
These are weird casts... could we maybe use an explicit type parameter on the singletonMap method call.
might not need the sleep if the persistor.write() call is moved to after the cancel
s/checkState/verify/, also add a message in case it ever fails.
Can we use a better exception?
start
change to sexGenotypeDataList.isEmpty()
Let's name this based on what the map actually does: namespacesExhibitingViolations or something like this.
I thought we want to pass the current line number (lineCount) here, not the starting line.
Should we log case when this if is false?
@bharatviswa504 I think we can skip this one as throughout this class we are following this approach of using auditSuccess, mostly for code readability/correctness. I think we can discuss with @anuengineer on this. If he is onboard with this change then we can change it across OM, SCM, DN for audit log. Since that will be a big enough change, we can do that in separate jira. Does that sound good?
or java Matchers.<Config>is(anotherConfig))
I would move this directly to the variable declaration to make the constructor less complex.
How will this be cleaned up?
all 3s?
if (!meta.equals(metadataCache.get(file)) {
all caps?
remove this variable and call inline
isEmpty is not in Java 1.5
Also (I know I keep repeating this but it's important), don't explain what the code does, that's not very useful. Instead explain why you do it. In this case does it mean there's some JS executed in between? If you wan't write a proper explanation to why then it means you don't understand what you're doing! At least mention that so that others will not think you knew what you were doing ;) But best is to not put stuff you don't understand and thus always explain the why.
I wonder why we need this bogus file here?
not sure why we need isWaiting. notify can be called as long as it is synchronized on the object.
.isEmpty(), .size()
Shouldn't that be in a specialized derived class? It might not be relevant for R4E no?
You can easily coalesce the null-check and the switch into a single if (header == SET_COOKIE). How about SET_COOKIE2 (I'm ok to not consider it, just raising the issue of whether we want to explicitly not consider it).
![MAJOR](<LINK_1> 'Severity: MAJOR') Provide multiple methods instead of using "refreshMeasures" to determine which action to take. [![rule](<LINK_2>](<LINK_0>
Ticks don't line up. The if branch consumes up to 2 ticks. Consider using an unconditional call to subMonitor.setWorkRemaining(7) here.
These should use the separated constructor, not hardcode the colon.
Why "model.getStorage()" instead of just "storage"?
Can you change "2abcd" to something which describes what's happening? Something like "CAUSE-A-FAILURE-DURING-RETRIEVAL"?
This isn't actually asynchronous. We're blocking here. We probably want to use a specialized callback for each call that aggregates responses, and calls the users callback if it's the last one.
use callback style instead
The product is never null, code can be simplified here
Should we rather just not update the descriptions if they are empty, instead of creating a new object ?
please remove warning suppress and the unnecessary casting
To keep consistency with all the operations, the beginning of the URL should be got from client.getBaseUrl() , not from a saved member. The responsability for server-wide data is in the WebdavClient object, not in the individual operations.
don't set the chatsate for the entire conversations. set the chatstate for the user only
Typo: Try use inputFormat -> Try using inputSource
Why not MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Collections.singletonList(range1));
Same question here - can't we find a way to not rely on naming convention?
The numbers used in this method seem to be something meaningful. Would you explain if they are?
Does this mean that we won't allow any idle connections, even when not using Tor? I'm not sure that's desirable for normal usage of the app...
In this method, JDT also makes sure that the hyperlink is on a method/function. This allows it to prevent showing the "Step Into" hyperlink option for non-methods. Can we do the same?
Rethink if you need so many &&
can we add enableTcpConnectionEndpointRediscovery value here too. would be helpful for troubleshooting.
remove please
I'm wondering if it couldn't be more relevant to avoid having array in a single String, at least to follow what've been done for the MongoDB repository. Please have a look to <LINK_0> What do you think?
Can/should we warn if there are config options in the map that were not recognized?
It should be better to use List interface instead of concrete implementation.
Should be METRICS_METADATA_NAME.
I think debug is enough since it is not some crucial state transition.
I think this if..else could be shortened to a ternary statement, but it's not critical. :)
Optional: since we already have NullChecker class, should we utilize to use some method(isNotNullishIgnoreSpace) in there? or using StringUtil from apache package?
What happens if somebody mutates the value while it's being written out?
If I understand correctly, the purpose of introducing the internalInvokeAction() methods is to be able to get back the status of the run, that we don't have in Runnable. Instead, why not consider refactoring createRunnable to be a createCallable that returns a Callable. Seems cleaner, and the asych vs sync will just invoke directly on the callable...like so: if (isAsyncExecution) { .... submit( createCallable(...) ); } .... else { ... IActionInvokeStatus status = createCallable(...).call(); }
Won't this print the error message every time we find a mismatch? For example if we have 4 authenticator classes, this will print 3 times.
no blocker in any case but does the current user ('cloud'?) have the rights on any system (think rbac). Doing get tempdir syscall would be better.
Would swtich make it cleaner?
This change is not related to the PR. Is this fixing something else that you just witnessed? Would be better to create another PR just for fixing this issue.
This check is no longer necessary since you verified it in the calling method. (ie. Retry.getNextRetryInterval)
Discussed offline: This is ok as long as we make sure internal server doesn't say that it is fully ready until this has completed for all clients.
I think this is the line of code that cause the issue in the mail-list
these messages should be self-explanatory (i.e. make it clear what are the strings)
Maybe we don't want to log this, but is this interrupt() really needed? Or harmful?
Maybe external @NonNull annotation?
Where is there no space after the comma? It would make the annotations more readable.
This check fails in the case of split editors, since the target parent is the MCompositePart. I guess the more general algorithm should be to search up the target context parents to see if one is the perspective context?
IIRC, this needs to be changed to three!=null&& three.sameBounds != null
you seem to be deliberately not mapping over Optionals - is there a reason for this? This bit would be fine as  return epdqGatewayResponse.getBaseResponse() .map(EpdqQueryResponse::toChargeQueryResponse) .orElseThrow(() -> new WebApplicationException("Things went wrong"));  wouldn't it?
copy-paste bug, should be frame.toImmutable()
Could use method ref.
avoid guava
If already decided to refactor it,it would be great if it can be refactor to four different methods. It might be useful later on. BTW Consider adding the getIntegerConfig and other method types to the Config class maybe, its much more cleaner then Config.<Integer> GetValue, and could clean our code in many places
I would use serverAddressDeclaration.getText().toString() instead.
Not anymore indeed. I used it with the first version of the test
There is problem with the precision. When I tested it value was 1410354493.260164474 but fValueTimestamp resulted to a TmfNanoTimesatmp with fValue=1410354493260164608 and scale -9. So, my compare filter for equal will never find the exact timestamp because of this.
Is it safe if value is empty?
Change Object to String
What happened to the null check?
maybe better to use a logger here instead of System.out?
This might be called periodInMilliseconds
nit: might want to rename it to processDiagnostic or something to imply that this method handles diagnostic related queries?
HttpHeaders.LOCATION
Check that you have the expected number of keys and bundles?
isAdvanced(false) is default for ChannelGroupTypeBuilder. We can skip this one.
I think we need this check because when workspace state is different to STARTING / RUNNING we will update its attributes and try to stop it.
Why not make the port property an int in the first place?
I think it is better to keep the node source logging semantic [nodesourceName] etc
nickListeners is not synchronized although it should be
stack isn't closed
That's one of the two changes, that are outside of test code. The change here looks correct. However, I don't know, which Charset GroovyLexer is using or expecting... So, I'd rather use the constructor, that takes a Reader: GroovyLexer lexer = new GroovyLexer(new StringReader(buffer.toString()));
you can move this to the class level and mark as private static final.
Seems like the required version should be a property of the application (UI) instead. This is also a bit verbose. Maybe we could drop some of the prefixes for the local variables (which are less likely to be ambiguous)?
@wezell is the uuid stuff required yet?
How about defining the life cycle for file watcher like start, stop etc. and also define the state of the file watcher like starting, running, not started and stopping etc. The locking is not required if we define the states. The clients can leverage these states if there are any tasks depending on file watcher state
new ActionResult<ItemStack> -> new ActionResult<>
Is this necessary to special handling? following constructTrie logic will not handle the root sharding key?
Causes NPE in line 151 (connectionHandler.connect(accountToConnect, failSilently);) when account is null and default account is not set? (NPE in [ConnectionHandler.connectXMPPInternal](<LINK_0> Also NPE in [l.117](<LINK_1> if account is null (if I am not mistaken).
We can do this in try() - finally block to ensure outputstream is always closed.
I find it nicer to override getGraphicalViewer and cast their. Similar as we do it with most getModel methods in the editparts
It looks like this is non-trivial and it will be executed on every sign-in, which could be a lot. Would it be better to move this to verify channel, which is most likely only executed once? (Similarly with channelSignIn())
u return false here, but u already updated _oldDisk with garbage before
It's not clear that the exception is warranted here -- is it strange and inconsistent for FUNC_VOLT_REGEXP_POSITION to define an extra nodes[] element and set it to null vs. just defining one fewer element? In other words, this fix works, but is there a cleaner fix?
Magic number 10?
exactRef
try-with-resources while getting connection to avoid connection leaks
java throw new RuntimeException(e); // so we will see the cause...
Is this an error condition? Should get logged at a minimum i think
Defining two arrays is not very apparent of their mapping. May be a map of server error code to router error code will be very intuitive.
Now, if there is no trace opened, the viewer has no columns. Should we create the default columns at construction and add the analysis-provided ones later?
I think when we are here, this if clause can be moved out of the catch and implemented as follow (classForName already throws ClassNotFoundException): java if (className.indexOf('.') == -1) { result = Class.forName("java.lang." + className); classes.put("java.lang." + className, result); } else { classes.put(className, Class.forName(className)); }  then result and additional check for null is not needed.
Should probably rename the above to htmlStream to advertise that its not a string
two options... 1. this url is only for interactive - then we can use both extensions types. 2. this url serves both interactive and non interactive, and the mode is determined by the url of phase0, for example: if you access /login -> interactive, if you access /get-ticket -> non interactive. then we need to pass the mode into the chain of phases, when we reach here we know what mode we are either by query parameter or session variable.
the deleted field of the entity is not checked
This pattern was needed for the partition strategy and column mappings because we wanted to provide backward-compatibility for existing HBC schemas. Since properties are an addition to the SchemaManager, I don't think we need to worry about them being embedded in Schemas. I think that removes quite a bit of code!
Swallowing stacktrace ;-) I would be in favour of:  LOG.error("Error while playing command", e);
I would consider abstracting this useful goodie into SwtTestUtil.java as it's likely to be used in other places also.
I don't believe anything related to ManagementRemotingServices is required unless http-upgrade is turned on.
it's easier to read if you do:  if (type != Schema.Type.String)) { throw new ... } //logic here  as it removes one layer of indentation. In any case, I'm not sure if you even need the check. Isn't this validated at configure time?
not Dimension.USED_JAVA_HEAP ?
please use here getBackendCollection(Class<T> clz, VdcQueryType query, VdcQueryParametersBase queryParams) method instead of manual query invocation.
You can put the Gtk version check into the 'if (settings !=0)' block like so if (settings != 0 && OS.GTK.... As otherwise the buffer is instantiated for no reason for Gtk3.10+, such waste of memory and cpu power there :-/. Lols, I'm picky yes.
My original code here was also inconsistent with the reference manual. We allow a string if it can be coerced to a number. You could either fix or open an issue for that and assign it to me if you like.
I think this one should also get called for 1.3.0? In which case the method on EJB3RemoteResourceDefinition could be renamed
Better keep that as a field as new instantiations are expensive.
IMHO such a difficult for understanding and potentially error-prone statement. I don't understand it. Please consider rewriting it in a simpler way. Currently, If I understand statement correctly: the environment won't be validated in advance if it is not a sidecar based workspace while it should be. Am I wrong?
Does not look to be enough, because currentSessions.entrySet() iterator below may still collide with recordRequest(). I recommend synchronizing the entire block
s/-//'
does Arrays.equals internally have a short-circuit for a==b? if not, given that i think the majority of use cases they'll be ==, we invert this and do: if (a == b || Arrays.equals(a, b)) { createFromCxtor } else { createGettingCxtor }
quick question: do we have blob authorization succeeded tests for delete and get operations?
As above, the client needs to be closed
I don't know how it works for you, but for me it fails: > incompatible types: List<Object> cannot be converted to Collection<? extends Message<?>> > return new SimpleMessageGroup((Collection<? extends Message<?>>) allMessages, groupId);
Any reason why this is 26 instead of 25?
I'm not sure that we need to have loader here.
This method should have some logging. Especially in the case where the file type is invalid
why don't you call refresh?
remove new line
I'm not sure if this is really an error... rather a warn. It's not that an answer is always required
If fields can be null, more null checks elsewhere might be needed. In this case, I would suggest not to use so many lines for the comparison, but use something like: Objects.equals(this.calendarName, other.calendarName); If fields cannot be null, don't go null-checking in equals and hashCode.
Minor optimization. If this one pattern is going to be used often you could make it static as part of the class.
Extra line can be removed to match constructor
Can you put brackets after the type instead of the variable? This is form is valid but [discouraged](<LINK_0> This occurs a couple different times in the PR.
can you protect this against a new Severity level?
Hmmm, might be more efficient to just invalidate the cache when a user's limits are changed rather than checking each time. <LINK_0>
was this PR build using maven before pushing? seams that it was not because maven would fix the formatting
The whole test is PageStore-only. It should not be disabled, especially in such way. I sent a possible fix in #1123.
How about collecting all active sessions and then looping over them once (avoid duplicating the counting code)
Since this is the same behavior on each side of the branch, perhaps put it after the branch?
Readability might be improved by using the Schema.ofFields(name1, type1, name2, type2, ...) factory method.
I don't see a 'equals' implementation in both AuthenticationToken and the Token class itself. If I'm correct this means that it checks for object equality (similar to ==) which will always throw false if comparing two repo results.
I would rather throw IllegalArgumentException here.
These actually should not be error messages. They were only printing out to err so they would display faster. I actually think we should get rid of these log messages
I'd guess the @SuppressWarnings("unchecked") above this wont be needed anymore.
Don't have to use this.
Can't request be null at this point, if the request parsing failed?
Leave inline and do TaskTags.markInessential( Effectors.invocation(...) )
You can use &apos; if you prefer (the numeric entity seems out of place otherwise). You may have previously seen people say that it was nonstandard, but (a) every browser supports it regardless, and (b) it's part of HTML5 anyway.
Implementing XorCardinality at the container level is an improvement that sounds promising to me...
does it has unit test? it should check diff scenarios
We should probably also do: fixitResourceMap.remove(delta.getResource())
just disable the button instead ?
change to VISIBLE not just present :)
The form below is used elsewhere:  Event name length (%s) is longer than the maximum authorized (%s). '%s' was provided.
executeCall should delegate to adjustParameters and adjustResult methods, to make it easier to understand/maintain what is going on.
Better to add exceptions to method signature.
might be nice to move emails_json to a constant somewhere that can be referenced by all uses across the app.
Is the retry handler doing something with the payload? If not, I'd just remove the finally block to avoid buffering it in memory unnecessarily.
Talked about at <LINK_0> . null was still left in. This field shouldn't be null IMO unless you can point to a specific reason that we can't remove null.
It was discussed in the code review to use instance of because Event may get extended in future
java if (StringUtils.isNotEmpty(rc.getClient())) { Map<String, String> parameters = cc.getParameters(); if(parameters == null) { parameters = new HashMap<>(); cc.setParameters(parameters); } parameters.putIfAbsent(CLIENT_KEY, rc.getClient()); }  maybe it's better
Why you add option SkipClassIndexingIfLowMemory? If alwaysIndex ==true and no free memory left jadx will just hang and GC will eat all CPU. What the purpose of this option?
unbind JNDI? remove datasources?
I thought it was not that easy to parse a CSV . What happens if we have : 35, 1456, "mytext", 89000, "other,text", 45 I mean the text encloser " " should allow to have the DELIMITER inside the text ?
Collections.singletonList already returns a list. Why are you wrapping it in another ArrayList?
These lines shouldn't be here?
req: Could you please rename StreamsMetricsImpl metrics to StreamsMetricsImpl streamsMetrics and then format the code like this  final StreamsMetricsImpl streamsMetrics = new StreamsMetricsImpl(metrics, "test", StreamsConfig.METRICS_LATEST);
The Presto way to do this appears to be requireNonNull(schemaName, "schemaName is null");
Maybe we could only propose branches for the remote we have started the wizard from?
This should be MISSING_CATALOG, which is causing the test to fail.
Please add braces here to create a scope since you're defining new variables inside the case
Business logic should be in a service
instanceof would be more suitable
InvalidPathException is not handled here. I recommend using Util#fileToPath() instead. <LINK_0> suggestion Path path = Files.move(rootDir.toPath(), Util.fileToPath(), StandardCopyOption.ATOMIC_MOVE);
The close calls will not be executed if an exception is thrown. Shouldn't they be placed in a finally clause instead?
most places in druid just use objectMapper.readValue(persistFile, new TypeReference<List<LookupBean>>(){})
the replacement could be done just once outside the while loop as it will be the same for all the values
If the widget is turned into a label and the member to an EntityModel, these lines should be replaced by setEntity().
The main bug was that the element of id constSumOption_Option--1 is hidden so there **must** be an assertion check for that. So add the most important assertion check, which is to see if constSumOption_Option--1 is visible or not.
I suggest adding "removeAsync" to the API and wait only for the last future here, this will speed up this method.
yes, I forgot this
I know it sounds picky but please store calculated threshold in fields (like regular HashMap does).
throw if there are externs explicitly passed and skipParseExterns is true (or set at all)?
How are the changes within this file related to the PR? I would not have expected any changes needed in the UI layer for this.
By using FailoverPriority, this will be simplified, you won't need the if() conditions anymore you will just have to do: .failoverPriority(failoverPriority.toString())
What about removing the birds object and just iterating over docIds?  for (String bird : docIds) { ... }
return this;
Are we forcing Spark side execution here? Why is that?
While doing snapshot transfer, all message has the same snapshottimestamp. May check the metadata's seqNum + 1 = ack's seqNum.
The spacing style isn't following the existing conventions. Can you reformat this patch to match what exists?
personally I prefer to inline the instantiation of columns directly in the call to table.addColumn (as in line 72) since it makes the code more compact and easier to add/remove/move around the columns - especially when you don't need to reference the individual column instances for some additional tweaks. But if you strongly prefer this style, I'm OK with it.
Should you be closing the socket when the received message code is unexpected? Not clear what the proper behavior should be here.
Check if _metadata file exist inside table dump path.
try using java 8 stream api somthing like : selectedLabels = allLabels.stream().filter(label->label.gethosts().contains(getHostId()))
propose: "Request to terminate work. All unique combination of <Endpoint,Query> were executed"
We should use keyService here, intention is to cache key temporary so under heavy load we don't download keys all the time.
How is this check different from the one on line 426?
Is this more important than debug?
I would either add IfPresent to the method name or move if outside of the method.
What happens if the parser fails? Does it throw an exception? Is jsonnull? Both cases do not seem to be handled here.
new StringBuilder(EMPTY_STR) is equivalent to new StringBuilder()
Please check error message and HTTP code using [RestJmsSharedBaseIntegrationTest.assertClientException()](<LINK_0> method .
This doesn't make sense to me. If the thread is stuck and we are trying to join() it, we are stuck, too.
these two if can be merged.
Throw the exception and somewhere at the top of the call stack, fail with a helpful error message.
as("legacy impl can unlock a lock taken by conjure impl")
Is there really that much of a performance gain in this case between byte orders?
How often is this called and logged?
2500 is a magic number
Perhaps have AndroidFxAccount have an adder that takes a bundle?
Better name for the main file of a definition please.
use of remaining() is exactly what got us into the OOM scenario. Even with more selectivity, this will result in OOM if there is a lot of distance between the lastAddress and the tail.
Nit, long line? Maybe split it into two strings concatenation?
formatting
toUpperCase() useless as it is done in "WorkspaceImageFigure.isSvgImage(resourceExtension)"
should we catch a numberformatexception?
Google style is not to use abbreviations like sb. Perhaps url?
This method is long and has 3 nested levels. Can you break it up into smaller methods. The file is getting very long. Can you refactor that functionality into new classes so that we stop growing this file, ideally shrink it ;).
Maybe redundant? You're providing 'Action' to fenceNode(); the method can check for itself if [action!=FenceActionType.STATUS] (no need to provide it as another parameter).
change==null test is pointless, line 39 above NPE'd if change was null when getting the current patch set
declare namespace doesn't work yet?
This seems to be an instanceof implementation because the old UsageSearchEvent can contain multiple queries (which is weird). I would recommend to use UsageSearchEvent instead, remove the instanceof and fix UsageSearchEvent to contain a single query
I think it would be more appropriate to use DaoFacade.getAvailableMerit() here but perhaps not super important
Nit: I usually find it more helpful to just say: "Finish calculateAssignment(). Took: {} ms.". Just to make it consistent with other logs.
Could version specific values cause regression or bug?
Those if could be merged.
would be better to use logger here
Checkstyle violations. There must be spaces around the braces. Please check the tests
Where does the gameID come from ? Couldn't resolve gameId. And the first parameter in the API, should be only 'activity'.
Instread of String.getBytes(), use SafeEncoder.encode(String). Alternate idea, keep SafeEncoder.encode(message) in variable and use it wherever you want.
Is this if statement really necessary ?
Why not a simple null-check?
before doing this, you need to check that record.getSchema().getField(keyField) is not null. If it is, the key field does not exist in the input record.
You can delete both of these try/catch blocks. If an exception is thrown it'll fail the test.
no need to create variable functionHandle; just return.
Isn't the above the same as this (i.e. converting from TIMESTAMP directly to DECIMAL)?  PDataType.DECIMAL.toObject(ptr, columnModifier, PDataType.TIMESTAMP);
Somehow this was dropped from my review.
Shouldn't it be ancestorRef instead of parentId? (in which case parentId would become useless)
Any reason why we removed the type?
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java .put(TESTER_NAMES, testnames.stream() .map(ProjectTesterImpl::maybeQuote) .collect(Collectors.joining(",")));
this won't turn text from null to empty, if that's what you wanted you need to do: text = Strings.nullToEmpty(text)
can we modularize this as this code block is repeated.
Can't this cause a class cast exception? When entity is of type BusinessEntity<T> where T doesn't extend Guid. The casting will be alright because type erasure, but then T will be returned here which isn't of type Guid. I think you'll still have to extract the entity's ID, and only return it if it's of type Guid (same as before). I wouldn't do this using the other getEntityGuid (it might work due to type erasure but is wrong), I would instead cast explicitly to BusinessEntity<?> and call getId().
same as above: use a constant for 'debug'
Make this as a log.error statement. And needs to have space after the ","
Again is this time sensitive (so a 20ms delay in thread 2 waking up to add "2" to messages will cause it to be out-of-order?
Please consider moving this in a setUp() method.
[java.lang.String#matches(java.lang.String)](<LINK_0> -> nameToCheck.matches(key)
The log is a lie :)
probably need to make this code smarter, if user will create vm from api, without specifying sound card, and engine choose to add it and then fail, it will be... fail... we have similar issue with engine picking spice if display is missing, and spice is not supported on ppc: <LINK_0> probably calling the new isSoundDeviceEnabled() method can be good but need to check cluster is not null first
do not abbreviate: Slice encodedDecimal = Decimals.encodeScaledValue(bigDecimal);
won't it be useful to print messages before and after here (just like the connect)
when can this be null?
please use FeatureSupported class
While this was already a problem, should we switch to passing objects rather than building the string here? This serializes the schema every time the function runs.
I would much prefer that we used service.Id to build the set than the service itself. We don't really guarantee that the thing that implements service has a well implemented hashCode and equals method. Looking at the current implementation, it compares each field on the object. That is actually much more than we need or want. You could use a map like Map<Long, Service> to rely on keys being unique and then use map.values() to get the services at the end.
Not much you can do here, but equality isn't well defined for types. For example, String.class == String.class, but String[].class _isn't_ equal to the parameter of Set<String[]>. There are similar problems for primitives (int.class != Integer.class).
Set<Map<String, Integer>> no?
Just catch all exceptions here
I dont think we should set the count here. I think we should have an increment cound instead.
nit: same here regarding HashSet instantiation
you can join the 2 conditions in a single expression.
Why not log the exception? By doing e.getMessage() we don't get the stack trace.
We can use getDefaultSearchString(): getHostList().setSearchString(getHostList().getDefaultSearchString()); getVmList().setSearchString(getVmList().getDefaultSearchString()); getUserList().setSearchString(getUserList().getDefaultSearchString());
Seems nicer to me to throw here an IOException instead, after all this probably happens because of io issues.
fetch uses upload on the remote side
Is this the only reason the IOException could occur?
initializeYoutubePlayerFragment needs refactor to initializeYoutubePlayer.
if (trace) missing?
I think for a test like this it would be good to use the core-service=platform-mbean stuff to validate the actual system property in the server VM. org.jboss.as.test.deployment.trivial.ServiceActivatorDeploymentUtil has some utility code related to reading system properties that way.
I would prefer to use variable names like releasesFromDatabase or sw360Releases to have a differential between the sw360 thrift objects and rest objects.
Please also fix the typo in advanedListener
The same thing as I already mentioned. Don't use untyped Maps for results. Specify proper types for the API. Otherwise, every decimal can lose precise value information until it gets to BigDecimal.
please remove TODO and .printStackTrace() and add proper logging instead
I would write it like this, it does away with the try-catch:  java errors.checkThat(file.getPath(), content, is(equalTo(reference)));
I generally prefer Boolean.TRUE.equals, but that's just a matter of taste I guess.
This prefix is the same in all 3 cases. Extract it to a constant?
replaceAll is costly, it this needed or can it be done differently?
rename to requiredBundles and then just use required in foreach look var
missing something here ?
Should we extract this to a method? The two ifs are doing the same if I am seeing it right.
Personally I like seeing these log messages in the log. As an admin, there is a sense of comfort when I see these ;)
Should this be in init() or start()? All initialization happens in init() and processing threads start in start()
what's actually updating this.reportStats? when reportedCounter is incremented, does reportedStats also update, due to the shared MetricName ?
Looks like these two are the only two test cases testing the IMap methods with maxIdle support. Shouldn't be more here? Also, these are unrelated to this PR though: - testGetAll_whenMapEmpty is missing @Test annotation - many tests declare thrown exceptions while no invoked method is throwing checked exceptions
Replace with retVal = wish1.getIndex().compareTo(wish2.getIndex());
Redundant semicolons.
nit, remove extra ;
Move Feature Layer instantiation and operation layers to before the try block. The xmlquery is only relevant to the populate call (and therefore the feature query result future too).
Non-informative info log
RandomUtil return a Thread local random?
It seems like this can compute a negative lag for a partition because latestOffsetsFromKafka might have stale latest offsets and highestCurrentOffsets will always have updated information before the lag is computed. Wouldn't it be problematic ?
Yep, it should be backward compatible. In fact i believe that your existing tests will/should pass without changes. Cheers
You might want to use non-thread safe class StringBuilder instead of StringBuffer.
you can check only exp instanceof NamespaceAware because "null instanceof NamespaceAware" is returning false
I think that it would be more clear if the if/else code was extracted in a separate method called: addOnlyPositiveAccountingEntriesForPDPProcessing
This is exactly the same as 'extendedElement' a few lines above. It's not clear why we have two variables 'extendedElement' and 'baseElement'. Is it just to distinguish changes to the extension ends of a stereotype from changes to its other properties? (implying a different kind of notification being sent out)
finally?
Can we rename this variable so that it is intuitive. Eg:- boolean hasMoreRows = false.
this should be moved after the check for whether the subtree root is present
I wonder if we need here a similar converter mechanism as for serializing into the database: <LINK_0>
No need for the offensive language :)
it looks like it also has to take care of casts
getIdAsString ?
What happens if fastpass/bin/fastpass doesn't exist? For instance, what if I use this plugin in any other repo? Should we return an empty optional if the file doesn't exist?
Use getNonNullRequestParamValue
1) The getSystemMenuItemByName() function itself returns the MenuItem on which you can call setVisible(). You don't have to call findItem() on it again. 2) getSystemMenuItemByName() can actually return null. Some older API versions don't support the discovery of these menu items by name. So, we need to check for null before calling setVisible().
Sounds like an error suppression. Could you please explain this change a bit?
FWIW you could have put the Project.NameKey into a SectionMatcher. Its an internal hidden implementation detail of the server. This would clean up some of the Map usage and maybe make the code a bit more clear here and in PermissionCollection.
Wrong indentation, it should be in line with the Assert above. Note: we use 2 spaces for indentation. You can verify whether your code conforms to Flume's code formatting guidelines by running checkstyle on it: mvn clean verify -DskipTests -Drat.skip, please run it, there are a couple of other warnings too.
It seems to me this whole block could be added to MavenStructuredPomEditorPageFactory
This still seems like an odd place for these methods. Shouldn't these be in SqlGraph?
please use final StringReader sr
Since we are only looking for 0 or 1 results, it seems like queryForObject might make more sense here.
This is network-incompatible change. Either make it network-compatible, or set the right required remote versions. And make sure to test it with non-dev builds, both when trying to join on older client, and when trying to join older server.
I think we should create a defensive copy of the Map
add standard soft assertions to the mix
Let's rollback to the first version. We can keep this as a future possible improvement.
@shivtej1505 These values are used in each test so maybe we should make them constants ? If yest then apply change and feel free to merge :)
I think you missed this out during refactoring? i.e. if (questionId != null && selectedSection != null)
Please move port number to a constant
couldn't we extract all those checks and navigations to a method #getLaunchConfiguration(DebugEvent event)? This would shorten these rather lenghty checks and extractions (event -> source -> process -> launch -> launchConfiguration and would improve readability I believe.
This warning message is not clear to me. Can you provide a sample?
might be good to explicitly call out the since4pass icon type instead of using an else. in case they ever add another icon, we won't show the since4pass instead
Lost original code. Use MultiStatus to store both full original status and a new code.
Nice catch, this is indeed possible.
Can we be sure this bean hasn't been created yet?
JenkinsRule.waitUntilNoActivity would be easier. That is how I normally test triggers. [example](<LINK_0>
Nit-pick: just use an ArrayList because this list should only ever be appended (and saves creation of ephemeral list-node objects)
Not sure why it says student here :laughing: maybe we could open an issue to change this to instructor instead if there's a need to change it.
If the bridgeHandler is null you set the thing to ONLINE?
I agree.
Remove Policy.endOpWork constant and all references to it. Change Policy.opWork from 99 to 100.
please log the error before returning the Exception.
I'm a bit lost on this change.. so is this now iterating twice? why the check during iteration was not good?
More usual to have "} else if (...) {"
Possibly this deserves a localized message
s/failedToBeRemoved/failedRemoving/
update is done in wrong place, look down domain is updated at line 167
this means that you must push all of the patchset as once, else you'll break the build. So either do so, or move this line to its proper commit.
Is this line too noisy? I think its helpful to see it
Seems we'd wait 1 hour before attempting to resolve again if there was no records found. That'll happen from time to time in prod due to infra breakage. How about a special case where we retry earlier when no records were found?
Isn't this wrong? The list before the replaceAtHead was: [1, 11], and the replace was ([1], [111]), so the result should be [111, 11], right? So when iterator in reverse order you'll see [11] then [111]. Or am I getting confused?
You can remove first condition and make second condition vise versa so null is handled automatically
Remove this if you make the postdraw for entries
Same reason here. > Actually, I think it is not the method's responsibility to verify the instructor privilege here. As long as the pre-condition for getInstructorOfCourseFromRequest is fulfilled, it should executed. - The login check should be only verified at L110 (where you delete the old code) - The caller method should verify that the entity is instructor (I think already is as checkAccessControlForInstructorFeedbackSubmission).
Logging this every time it fails will lead to a lot of log bloat. Could you keep track of whether this warning has been emitted before and only warn the first time?
nit, the assertion hasSize(1) already says there should be one group, what is not said though is why?
Check formatting..
This is a bit brittle, but I don't really see a way to waitFor() the end of the rebalance (as opposed to waiting for some time, hoping that the rebalance will be finished)
Looks like throws Exception is not needed.
No reason we should do this more eagerly than "feed.sla.statusCheck.frequency.seconds". Can use the same, but, start with a delay, so this runs a little after Pending Instances is populated.
Could we unify this between BroadcastStateTransformationTranslator and TwoInputTransformationTranslator? The entire method is identical in the two classes (minus checking for keySelector in a single input, but the version from TwoInputTransformationTranslator should work as well.) We did a similar thing with AbstractOneInputTransformationTranslator.
maybe if collectChangedFiles returns an empty list, simply continue?
colorList  will never be null, widget#getLabelColor and widget#getValueColor always return a list instance.
This statement does not need the conversion, it's just checking that there's at least one row selected.
Let's rename these to addShaderProgram(string).
nit: .filter(SingleColumn.class::isInstance)
Would be better to log here I think.
find available port helper method?
nit: we wrap at 100 columns
Why can't you use writeCharSequence(...) ?
please review code format
NIT: Instead of Observable.just(Long.valueOf(0L)) you can take advantage of auto-boxing and write Observable.just(0L).
it's a little confusing to use a local variable of the same name as a class variable. Perhaps you can call it keepThisConnectionAlive?
What about duplicates? Maybe better use to toMap() variant that overrides entries instead of throwing an exception.
please do not perform validation based on method call side effects, if you need to validate number of properties just do that
it might be worth factoring this out to a hasError function
Because of JIT optimizations, the iterator form of for is [faster](<LINK_0>
Typo in the log message. Should be _have been_. Can you place this message in a resources file? Did UX sign off on this message?
we should pass partition key to CosmosItemRequestOption here. The intention of this benchmark is to measure perf when pk is passed as request options.
Should inline
getHostStatus(host) should not be called anymore, so do you still need the when()? removing this catches the case where it is called unexpectedly
You need to get rid of the forward slashes here too
It looks like it's possible to get this value while checking "frequency" java entrySet() .stream() .filter(e -> e.getValue().equals(envValue)) .findAny() .orElse(null) // should never happens .getKey()
- remove IF NOT EXISTS - move this statement outside of try block; otherwise, if CREATE TABLE fails, DROP TABLE in finally block will fail as well
can we log the exception?
what happens if the optional is empty?
See #1307
Really minor, but I would call this method "retryIfNeeded" or "retryIfConcurrentUpdate"
not sure it's needed, you just registered the 3 events.
remove
Not quite sure why do we pass real log provider here. For example situation: during migration from 3.2 to 3.3 we need to do only count store migration. As result, we do not do any store copy so the first invocation to rebuildCountsFromScratch will fail since the store is not there and then again we will try to migrate count store and the user will see format exceptions still?
We should remove the cookies before sending the loginMsgToRegenerateAntiCsrfToken, otherwise the session might not be correctly updated.
code style. Might be helpful to highlight code you've written and do a Ctrl+Alt+L (Reformat code).
Why create and fill(0)? zeros is enough.
java // Function expressions without names have a NAME node containing an empty string.
why can't we put this logic within the other filter?
@jomarko Hi. I think @danielezonca is creating a specific class to hold the string constants used throughout the code, so probably that # should be replaced. Beside that, I think we are also going to have two different "expression" identifier, one for value creation (the one used in all this tests, I think) and one for method invocation. This latter case seems not covered- even if I am not sure on how to test it. @danielezonca ?
I understand that you actually don't need the full result, but isn't this operation rather limiting? If you don't want to instantiate the result into some list, you could define an interface within the Queryable feature with size() and list() methods and wrap the CacheQuery inside.
This will also list the contents of the system config. So maybe we must not deprecate the open variants? Also note that list() loads the config.
if writeFileInfoCache#remove returns true we will miss to check readFileInfoCache#remove (the 'or' will not evaluate the second operand)
Can you break lines so that it can fit 80 chars?
Move them to an alter util? Or maybe a AlterTable, and have two implementation: ObjectAlterTable and PropertiesAlterTable.
isUnauthorized 403
![MAJOR](<LINK_1> Reduce the total number of break and continue statements in this loop to use at most one. [![rule](<LINK_2>](<LINK_0>
rename to source
Why add the extra variable?
Use ResourceUtils.closeOrLog() instead
Should probably throw an Error(e) in this case...
we'll need to hash-compare against tags too won't we? rename cat to dog but a note already has Dog as a tag I think we'll still get a duplicate java String thisHash = getSimperiumKey();   List<String> tags = new ArrayList<String>(note.getTags()); List<String> tagHashes = new ArrayList<String>(); Set<String> tagSet = new HashSet<String>(); for (String tag : tags) { String hash = TagUtils.hashTag(tag); tagHashes.add(hash); tagSet.add(hash); } List<String> newTags = new ArrayList<String>(); for (int i = 0; i < tags.size(); i++) { if (thisHash.equals(tagHashes[i]) && !tagSet.contains(tagHashes[i])) { newTags.add(newTag); } else { newTags.add(tags[i]); } }
I see that you're using the compatibility-version in the template, but what if the template doesn't have custom compatibility-version and its cluster is being changed?
I think you should have this loop also after the start time array puts. Or else you have a smaller header than what is calculated in getSpecificHeaderSize()
don't use kaltura.com:1935 in the pattern, since this will break everybody that uses different hostname (like QA or developers). search just from /kLive/....
Try-finally, please?
Add card hints to inform user about useful data: ![shot_200608_040615](<LINK_0>
Remove this COMMIT since it is in finally
listFiles() can return null if the threadDir doesn't exist (e.g., process terminated before you called this function) so you need to do a null check before iterating below.
I thought that we did not need to have this mapping in the compute engine
prefer renaming the method to handleExpiredRequest since there is no longer distinction within this method on which expired request should be handled.
Now that DynamicItem is safe in master (I merged the WebSession work from Martin and Jonathan) this should use the same model and have exactly one item contributed from a plugin that automatically overrides the default one supplied by Gerrit.
what for is this empty if statement?
Restore formatting.
Small typo for the param placeholder.
you should be able to do AssetExtension assetExtension = (AssetExtension) asset.getExtension() you'll want to check for null, and create a new instance of AssetExtension as needed. If you need to create a new AssetExtension object, you'll want to call asset.setExtension(). doing a business object save of asset should save both the asset and asset extension.
Express this more directly: if (mHasWifi) { mInitialWifiState = mWifiManager.isWifiEnabled(); } Note that there should be a space between "if" and the parentheses
nit: remove the 'currently' in parentheses to shorten the message a little.
Do this in a finally block
Use @Mock, see e.g. MolgenisLocaleResolverTest
Did you mean "setting"?
Why this needs to be created for every android module even if config option doesn't exist in buck config? addAndroidCompilerOutputPath is called later at the end of this method which means it would called twice. Is this by design?
remove
why read the "weight" parameters here? seems not need, because we can read in AutoMapper also.
Knock this down to protected (no need to define public api here) - this will also provide a chance for subclasses to be smarter (for example WKTStratagy could start recogning the geometry column). Aside this method is really ugly/confusing :)
Minor suggestion to improve the readability of the code below: use mappedSlice as a prefix for these variables.
please explain whey this thread sleep is required.
There is definitely a need for a centralized toast generator.
Why not model.getLocalizedTooltip()?
Why aren't we calling createChecker?
If you'll follow my suggestion in line 444, this method can be removed.
You could create a constant for the singleton locks, no real need to create new instances, same for the read_write below
(nit + local, premature optimization) The first check about isResourceRequest could be moved up to the first if, after the instanceof, to reduce computation.
Don't think you need this if - it's doing the same thing in the if and the else.
those 2 lines should be in the if clause as well.
why the string declaration for SSL_FACTORY? If you do this, do for all strings in property. If not, remove the variable. It is not wrong but the implementation is varies in style and it's not something professional
Since the events are never removed from the list, this creates a memory leak. The notifier keeps a reference to all events, the events have a reference to the players and games, those have further references, preventing all these objects from being garbage collected. I'm not sure why this was added; since each event is only fired exactly once, the contains() check should always return false. What happens if we just remove eventList?
Feels like the button text should just live in a layout?
In the happy case where we continue to receive acks for each event delivered, always the ack-notifier thread will be draining the queue. Publisher thread will continue to do only the fetch part. I think this conflicts a bit with the design of this class and the purpose of the publisher thread.
Why don't we change the ConnectorMetadata#getTableLayouts to ConnectorMetadata#getTableLayout that returns a single ConnectorTableLayoutResult?
- this.ascent and this.descent are in Pixels so autoScaleDown to be applied after deciding the value from Math.max
suggestion logger.info("'--interval' specified [{}] is lower than the minimum allowed [10].", this.getInterval());
Better use inner constant here.
Doesn't the output FS also need to be registered if not present? Or is the assumption that it will be same as input fs?
This should be a private static final String at class level.
Failed to resolve Remote Artifact Why Remote ? It's hosted repository.
Here is a lot of staff happening in the constructor, maybe move it to init method, or a lazy loading? There is a situation when, a can add a filed in object and it will throw an exception during construction
lets use StringBuilder for str as we are changing it within the loop multiple times.
Not your code originally but the filtering and mapping seems pretty pointless: java assertThat(activeMessageHandler.getRecordedMessages().collect(toList())).hasSize(1);
You could simplify this to "groupid = props.getProperty(..." and then drop the else case. Not a review blocker though.
I know it is easier to work with the static cluster map for such things, but since we have moved to Helix and static cluster map is deprecated, can we not build in these dependencies and use Helix instead?
to avoid NPEs use; MLConstants.DEEPLEARNING.equalsIgnoreCase(model.getAlgorithmClass())
and maybe even nested functionality as well.
What if clientSpan is null? (i.e. the client span is not found) Copying all binary annotations from the client span may be an issue, as could be misleading for the resulting server span. However only alternative may be to 'set' the URL on the server span (i.e. override any value that it potentially derived).
Should this be something like "Creating LocalCacheManager with {} existing pages" ?
leftover?
I'm good with b, but I've noticed a lot of reviewers prefer to see binding, which is more idiomatic java.
Tempted to do it before breakfast :)
I think we should export this as a constant also - it's used in two places already. In the future we may supply the user name by configuration.
We should use the OR operator here instead of AND. If the first part of the condition is true, meaning that the list of lines of credit is empty, then there is no reason to check whether the first item ( .get(0)) of the collection is null or not. On the other hand, if the collection is not empty, the first element might be null. Therefore, I suggest to transform the condition into something like clientLoCs.isEmpty() || clientLoCs.get(0) == null.
i see that in CSV case where fieldsToRead is null, we get fields to read in the RecordReader. Versus, in the JSON/AVRO case we used to make that decision inside the RecordExtractor. Is it possible to keep these consistent and always let the RecordExtractor make this decision?
Shouldn't this be something like "Press \"Merge entries\" to resolve the merge conflict." ?
No need for a mock.
Indentation is all over the place here.
To me it feels like an error-prone situation when we return results for lower number of partitions than requested. It's unclear what such situations indicate: we skipped/forgot some partitions entirely or we processed them without results. We already had such problematic cases recently, EPs were skipping partitions silently and it was really hard to diagnose/debug this. Not sure what we should do, at least some kind of a logging here and in FirstAttemptExecutionCallback.onResponse would be really helpful; a more safe option is to completely disallow such situations by reporting an exceptional result to the future.
Its good that isAggregate was removed, but we should still verify that the primaryResource is a Work. That just boils down to a primaryResource.hasProperty call I believe
It is good to assign conditions like this to a local variable so that it can be given an explanatory name.
There are six themes now. Dark / light in 3 different font sizes. There is a class util/ThemeHelper to do the settings to theme id conversion.
Probably don't need DEBUG but should we add TRACE logging for these conditions?
Might worth adding a separator before this one and before the scope button, as they have opposite behaviour.
put the log after the send
I guess you need to change the parameter type to List.class:  java }).when(nodeDiscovery, NOTIFY_DEVICE_DISCOVERED, Mockito.any(List.class), (RemoteXBeeDevice) Mockito.any());
I think "I" is not a good name. Maybe change to "interface"
nit: flatten nested else { if {} } to else if {}?
I would consider re-using org.ovirt.engine.core.dao.NetworkDAODbFacadeImpl.NetworkRowMapper since that's the main entity in question, and not changing the field names in the view (otherwise it wouldn't work) -or- using some different approach to reuse the bulk of code.
@Namiii possible to allow configuration of the implementation to use so that we can add app engine support in the future?
Wouldn't it be better to remove duplicate logic and just invoke the version taking a Run? It seems like a lot of this could be condensed.
We should use named not positional arguments. I believe both are supported by EBean.
Doesn't c.isOwner imply user.isAdministrator ?
Don't use default shell. Dialog has one.
Shouldn't catch Throwable as it can be any sort of JVM error. Probably shouldn't catch blanket Exception either unless you wan't some special handling. Exceptions thrown out to jersey should result in a 50x error by default. Also seems like web specific exceptions should be thrown by the remote/resource class.
replace with Guid.isNullOrEmpty(..) I'm not entirely sure that we want to return false here and not keep the current behavior (which is equivalent to retun ture) , if operations that depend on the connect operation fail "later" in the calling flows..it will be the same as before. what do you think? have you checked that it's safe to return false in that case as used by all the callers? it may fail certain flows.
can this be put into a method?
should we consider having a single impl for both readVarInt() and readVarInteger()?
I think we should be putting more values here, to ensure that every bucket has at least one key. Buckets are not fully created until data is put into them, so with only two keys, the system is not in a very realistic state.
firstNonNull() is useless because of single parameter.
this is against naming convention - variable with CONSTANT like name.
@balamurugana I think the issue is config.toString() which is not returning XML here
This part could go into AzureUtils.
suggestion LOGGER.log(Level.SEVERE, "Email configuration properties were not provided correctly.", e);
Please close this defaultAccessor at the end of the test to prevent a ZkClient leak.
needs a NULL check otherwise the phone_number column will always be an empty string instead of NULL. Assuming this is your intention...
Don't know that this is correct. If the item isn't found, you are "pretending" all is OK and returning the map anyway. Isn't the correct thing to throw the exception? Minimally, shouldn't either the exception be logged, or a warning to the log that something is amiss?
Do we want to add more checks on the size of the array itself?
These can go in a single try
Do we need this here since we already set the mSearchMenuItem in onCreateOptionsMenu?
Remove this line
Code style: please keep line lengths <= 100 chars. Github's web UI doesn't even show the full text.
Can you please assert on the exception, that it is with timeout error message?
most of us use throw Exceptions.propagate(e) to skip needing to include a non-reachable return null; the throw never gets run of course but it is misleading in a good way :)
Please remove this, I fixed the cause in a432e377a8d4e7dd04f2267bc59b1e66ea6d6656
since w/out the '/' it is already set, no need to reset, no? I'd just do:  if (!pushConfiguration.getServerUrl().endsWith("/")) { pushConfiguration.setServerUrl(pushConfiguration.getServerUrl() + '/'); }
Cosmetic: Would you mind using static import statements for these assertion methods? Thanks! :)
Was this config prop removed on purpose?
I think it must be possible to skip subtrees also for non TreeIterators.
Do you think it would be better if we kept the data null and instead check for this outside of if (data != null) statement? I don't think we care about the data, and someone might accidentally remove the new Intent() since it "looks" kind of pointless here. It's not a big deal but it also uses extra memory (a tiny bit, that is :P )
Create map with expect size would reduce memory, just like this:  Map<String, String> srcParams = getParameters(); Map<String, String> newMap = new HashMap<>((int)((srcParams.size() + parameters.size) / 0.75 + 1)); newMap.putAll(srcParams); newMap.putAll(parameters);
we should ensure semanticModeland symbol are not null before using it, or alternatively only run the rule when semantic is available and ensure verifyNoIssueWithoutSemantic
Please label these reporting.parameter.onOrAfter and reporting.parameter.onOrBefore
I was curious what you were going to do with the 'readonly' field here. :) When you open a remote file with the media server...you can open it either in read mode or write mode; but not both at the same time (although the MediaServer could be extended to support such a case easily by opening a RandomAccessFile and getting the channel from there rather than a FileOuptutStream object in the openWriteFile method). The way this is currently done; any calls to the write method in here will fail because the files are being opened in read mode on the server always. Since you've got all the other work in here...I'd say just change MediaServer to use a RandomAccessFile's channel instead of FileOutputStream (the uploadStream field); then make this use OPENWRITEW instead of OPENW if readonly is set to false (and prior to that, request the upload key from the server so it'll grant you write access). That _should_ have no performance implications.
usually update to non-operational status is done by SetNonOperationalVdsCommand for rhv hosts. we don't have to use it here, since the kubevirt node status isn't expected to change outside of this context. I wonder if we should include the reasoning here (just an error message in the log or audit log event) explaining why the host status is non-operational. Also, if there are known issues with the node, we can include them into the log.
Missing final
This will effectively embed the value as String, why not embed the value as JS boolean instead? With this change, GWT host page will contain: var displaySupportedBrowserWarning = { value: "true" }; But with snippet below, it could be simply: var displaySupportedBrowserWarning = true; Java servlet code snippet: request.setAttribute(ATTR_DISPLAY_SUPPORTED_BROWSER_WARNING, getDisplaySupportedBrowserWarning() ? BooleanNode.TRUE : BooleanNode.FALSE);
Can you please simplify this a bit? Something like this should work:  Stream<ChannelShim> videoChannels = channelShims.stream().filter(c -> MediaType.VIDEO.equals(c.getMediaType())); List<SourcePacketExtension> sources = videoChannels.map(ChannelShim::getSources).filter(Objects::nonNull) .flatMap(s -> s.stream()).collect(Collectors.toList());
Minor: consider View.NO_ID and @ResId annotation.
Why do we always compare as double? In one of my tests the fValueNumber is Long. If we compare as double it might not give us the expected result because of the loss of precission.
Is .json correct here? This is in the xml type descriptor?
I believe we want this too protected
If we extend EntityCollectionTransceiver instead, it will take care of the view-mapping and apply the "last modified date" logic too. We'll just need to adapt it to the Timestamped interface as with EntityTransceiver.
Not required, but you can use |= here.
Since you only added a log statement to this file you should just remove it from the pull request.
This won't replicate FITS extracts since it only applies to original_files, you may need to break replication into a separate route from the original binary processing. I'd suggest kicking it off after indexing and before enhancements. I'm also realizing that MODS files may get processed as an original file... trying to decide if that's an issue. Doesn't need to be addressed right now though.
@micnice This won't work as the factory is not fetching the bloodTest entity from the repo. We need that entity so that we can get the category, the BloodTestBackingForm could only contain the id. @jmuzinda is busy working on making those changes, please chat with him.
dataSource instanceof StreamingOnRequestDataSource is redundant since it is already checked above in line 185.
I find it surprising that we always set a diff's state to MERGED in this method: If we merge right to left, and the diff was from the left, then it's been rejected, so it should be marked as DISCARDED, shouldn't it? Except maybe for pseudo-conflicting diffs, which we can consider as MERGED in any case?
This is not your code, but is just a preference of mine, so feel free to ignore... but... I think the code would read better if this checked that the type == null and threw the BadRequestException that is in the else clause. That would remove the else clause and move the new code left.  if (dto.getType() == null) { throw new BadRequestException(i18n.tr("Unit type must be specified.")); } ConsumerType ctype = this.consumerTypeCurator.lookupByLabel(dto.getType().getLabel()); if (ctype == null) { throw new BadRequestException(i18n.tr("Invalid unit type: {0}", dto.getType().getLabel())); } consumer.setType(ctype);
Could you not use reflection? I know it's a pain to list all methods, but this is faster and doesn't lead to error/weird case for non existing properties.
The default selection for the RadioGroup can be changed via the layout resource [here](<LINK_0> You can also rearrange the sequence (if you want rename before replace) and if you want to change the default visibility of the inputLayout there as well.
This used to be an AtomicInteger but is now a regular int. Are you sure it's safe? Is all the code that uses it required to be run in the same thread, according the the Appenderator contract? If not then please beef up the contract.
suggestion LOG.warn("Error while handling response for RPC module: {}. Response string: {}", rpcModule.getId(), message, e);
please add this property to telemetry, it's good to know why we get AUTH_TOKEN_NOT_RETURNED (access token isn't returned or it prompt was required)
should this be perhaps something generic, and used for other results as well ?
I really hope the format changes for the final spec. :)
Is this related to the rest of the PR?
Path has strange and subtle differences between different constructors. The original code specified the constructor was the one that took a String explicitly. This code would work if the type was changed to URI, instead of String, but I'm not sure the behavior would be identical. The original version protects against subtle differences like that. For this reason, I'm not a big fan of method references for constructors, unless the type is *very* stable and well-known (like ArrayList::new). The change you've made here is probably fine... but I'm not sure if we want to protect against possible subtle changes in this code by keeping the explicit String type declaration.
We should add some assert to make sure that varArgsType is not null.
Definitely good to move this to a ViewModel
This would look logically clearer:  java if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); }
Please use ConfigUtils.getDefaultProfile() instead of hardcoded "full" profile name.
Yes, please revert. Create a separate PR if you like.
I don't know if this is an issue but deserialization will not be backward compatible.
Also this toast. It's really annoying.
Be careful with this comparison here. If we're caring about the UUID (which we don't at all in this case -- it's a one-to-one comparison for differences in content), then we need to compare the UUIDs for identification, falling back to the ID only when the UUID is not present. Also, keep in mind we don't return non-String CharSequences from any of our methods (on account of the immutability is pretty handy), so we don't need to use contentEquals over "normal" equals. In any event, I would drop both instances here. This isn't the same type of operation we're doing in the DTO branch (identification before comparison), the ID check is already done in the nested isChangedBy call, and the UUID check will break the version comparison bits that currently rely on ignoring the UUID when checking for data changes.
Put an empty line after this.
The duration variable should be qualified with the this keyword.
I am not very comfortable in the way we go about constructing container w/ new fields and once it is serialized and deserialized, it resets some of the fields to defaults. Can we set the defaults in the constructor itself. Sorry to drag this patch more. But I feel like most of the tests for now tests V2 container and not V1.
--allow-duplicates is a better name, but now "f" is not a good short name. Maybe "a" or "d", or no short name.
Please change this to use a leading capital Unable. Also is it worth continuing here? If getAuthority() fails and requestDomain is null shouldn't we just return?
Why VARCHAR? Shouldn't it be a GEOMETRY_TYPE?
The fetchablePartitions method used below is probably another nice opportunity to use something like forEachAssignedPartition.
The assert condition is the same as the if condition so if seems useless
... + Pattern.quote(upperPropertyName) + ...
KualiDecimal has a constructor that accepts a String as input, so you don't need to parse the String value with NumberFormat explicitly.
Seems like public is a better default, though. The point of a getter or setter is to expose the variable through the class interface, isn't it?
allVmDevices.forEach(getCompensationContext()::snapshotEntityUpdated)
I prefer the code style using the space between the if and the parenthesis, which is the standard code convention: <LINK_0> But no offense taken if you prefer this style.
Ok I think that answers my question before, makes sense! Thanks Jose
I think this would be better if it polled for a shutdown server. I've seen times when jboss-as takes longer than 5 seconds to shutdown.
you would need to use subMap and remove this and subsequent lines below.
Did you forget a ! here?
![BLOCKER](<LINK_1> Close this "FileOutputStream". [![rule](<LINK_0>](<LINK_2>
The idea with the filtered buffer is that it only allows items to go into the "main" inventory if the item matches what is in the blueprint inventory. You can also extract from the filtered buffer's main inventory.
add a check that the first argument is identifier
Would it work to change OverlordActionBasedUsedSegmentLister to take a TaskToolbox instead of a TaskToolboxFactory, and do: DatasourcePathSpec.setUsedSegmentLister(new OverlordActionBasedUsedSegmentLister(toolbox)); And avoid the global injector?
Same here: should be BuildConfig.DEBUG
@Januson modelTranslator never used in this code. Any specific reason for this null check?
Did you intend to log and then print stack trace?
Shouldn't this be a finally instead of a catch?
Set "vertebrates" right here
This line means the trace token that is passed through might not be what the caller provided.
final XPathEvaluator xpathEvaluator = new XPathEvaluator(Configuration.newConfiguration()); final XPathExpression xpathExpression = xpathEvaluator.createExpression(query);  can we make this execution to be done ones for whole Checkstyle execution ? for example in "setQuery".
How about the operands are empty ?
Debug statement should be removed
i guess it should be text/plain.
Rather than having a trailing space at the end of missingMethods, use a StringJoiner.
The actual delete should happen at the end as WIndows can be very picky about files being logged. So the remove would need to happen first.
I'm not sure anymore what the point of supporting preview features is, if we're going to drop support for them between any minor version. So either 1. instability is to be expected, and we should clearly advertise that preview feature support may be broken anytime (and display a warning) 2. we should not support preview features at all 3. we should continue supporting each preview version until at least the next major release. I think I side with the last option here. It's not very complex to continue supporting Java 12 preview. Besides, we haven't advertised dropping Java 12 preview support and this seems kind of sudden. If we continue supporting preview features, it would make sense to have separate language versions for preview versions, because: * Rules written for preview features may not apply to the non-preview version. For example, we could write a rule to detect string concatenation that may be replaced with a text block - but this would be irrelevant without preview enabled. This is exactly the problem our LanguageVersions are supposed to tackle. * Without a language version, we can't determine whether we're running in preview mode without *seeing* a preview feature being used, making the warning of option 1 unreliable
I am not positive but I believe it would make sense to copy the item here (or in getExtractedStack before extracting), just so that if a crafting implementer queries what remaining items are for a recipe there are no side effects of the container being drained just because of the getter being called to say see if an automated crafter has room to also store the remaining stacks.
I know we talked about this, but just to verify, I am guessing  .to( "file://" + getStartingDir() + "?fileName=${in.headers." + TEMPLATED_STRING_HEADER_RTE_PROP + "}&delete=true");  didn't work
if we're concerning ourselves with time elapsed, be explicit about what the start time is.
take out to a function
Wrong code -- must be else.
Needs a permission check here.
use getExceptionCode to check exception code.
A field in the class?
@cvrebert please leave Tv.THREE here
Maybe, if the member is not found, 'res' is better to remain model.getDeployProject()?
Could use List.of(...)
Debug/Trace statements here would be very useful.
I've added ArrayUtils.removeDuplicate method to hide the ugliness.
nit: Maps.immutableEntry() would be a bit cleaner here.
Not sure if you're still working on this PR, but I think this TODO is part of it. range should probably be a property of Entity.
why is this here? the join is not processed inside the SemaphoreCompletionService
The if statement checks for event.getNewValue() == null but then we do a event.getNewValue().toString(). Seems like a risk for an NPE...
How about renaming this to particleEmitterDrawables? I know it's verbose, but I kinda like that over peDrawables.. I'm not sure about this one though.
Why not compare size first?
can't you properly support stream here?
Is there a unit test for this as well?
null?
You have this lastRun which is ended in dispose. Are there cases where lastRun could be non-null here before it is set to run? In that case, should the non-null last run be ended?
I propose to explicitly add the mention of flow-build-info.json: "... prepare-frontend Maven goal which generates 'flow-build-info.json' file prior to deploying ..."
Please change the old names of variables "userSetMatcher" and "userRemoveMatcher". Thank you.
Why not do this at the start of the method - we know this before doing a directory listing
Comparator should be customized.
Seems we might use LOG.infof("Found %d objects within testsuite-suite polygon.", cnt ) as well.
Just to make sure i understand .. this is getting the list of DAM Asset "folder" paths, and then traversing their sub-trees, collecting all the folders under them, which (the folder list) is used later to collect all the assets? WDYT about forgoing this collection and just walk the resource tree from this list of root folders? <LINK_1> <LINK_0>
This won't ever trigger since getRedis returns null already. The memory cache will also never contain a deleted key by construction.
This entire class will conflict with #3428.
What is the error when you do: fields[1] = (userId == null)?"":userId; and don't do anything more.
if (message != null && !message.trim().isEmpty()) { ... No need for those extra parentheses that only make the code difficult to read, and no need for "" either.
maybe Util.getShortObjectId() instead of putting 7 here?
@cuenyad use enum in TermId
Why systables is needed in this query?
fix =
Why is this removed? The user could still specify a malformed url in the config screen, and now the error will be harder to find.
I think this should be a reject rather than a conversion.
result = units.bytes.multiply(new BigInteger(numberString))  Or?
Assuming you create a temp user object with just an id, you should be able to use makeURLWithObject or something like that and then pass in the user object.
Do we need this?
Why is this neccessary? The processes are already returned in a sorted list, as indicated by the SORT_ID constant passed as the third parameter to loadData in the previous line, aren't they? If you just want to reverse the order and start with the lowest ID, you should use SortOrder.ASCENDING instead of DESCENDING, I guess.
rename 'listeners'
It would be stronger to add assertion on comparison of studyDetails.getContacts().get(0) to the user details retrieved from workbench users table.
...and use the (old signature) getVoxelScreenSize here to avoid the Arrays.stream(...).max().getAsDouble()
I don't see where this is throwing ServerOperationException. It throws its superclass, ServerConnectivityException.
@amisevsk might be more relevant to throw OpenShiftException now ?
you forgot to update metrics. metrics.updateNodeResponseMetric......
Should we log channel information as well?
What is the purpose of collecting to a list while streaming? If this is required then please add a note to the source code.
Exception will be logged twice.
this method need to sum the disks per domain, otherwise, if i have 1 domain and 5 disks, but space for only 1 snapshot, the check will pass.
A dir picker seems good to me
use getLunDao() instead of DbFacade.getInstance().getLunDao(). Also, why use an empty string and not just null?
Are you sure the object comparison is the same as primitive value comparison?
This should be false. Is this a typo?
These two updates is useless, the flow runs in transaction, the changes are not seen until transaction is committed, what is a reason to perform unneeded operation? These makes code inefficient and unreadable.
while (!replayComplete) is better if it does not break the logic (as I can see it does not)
I though only the number of nodes in the cluster would originate ISPN-8134
Is there a way to check whether a variable is *effectively* final? Because I'd like this to work with locals and locals are rarely explicitly defined as final.
Why is this check ?
What's the different between this and testConstraintSolverForceBacktrack
Could you move the "2f" into a constant?
child
Can we have a similar asc ii graph for this test case as well? Thanks a lot in advance!
Whenever you switch an assert from testNG to Jupiter, you need to make sure the "expected" and "actual" variables are swapped. Otherwise the error messages will be wrong when the tests fail.
I can't understand why this exists. Please check if it can be removed.
I would argue that we don't want to start with an invalid configuration. Maybe catching these exceptions is not needed?
I believe you don't actually need to instantiate a new SessionModel here - it can just be SessionModel sessionModel;, or just declare it as part of line 410 SessionModel sessionModel = (SessionModel) session.....
How can this work? Don't they all have the same name (i.e. the category name)?
This conditional in the else clause is probably not needed since we're already in the else case, right?
Why we are choosing INT? Wouldn't it confuse users?
rename to propName maybe switch with 'fullKey', i.e. rename fullKey->propName and this here to key then
There is no reason to have this isOptional variable - it only complicates reading.
Don't worry about it, but I think this whole method is indented one _tab_ too far
Any reason this doesn't use addAll as well?
the extension could be even something else even it is minor thing, i have seen it for some rare cases ;)
Just thinking and maybe a good improvement is to make StudyInstance in middleware retrieve a boolean indicating if the instance has a fieldmap created or not, so you avoid querying this info many times. Not to be tackled now but to have it in mind
Add a message here?
expected 2 nodes but was:  + nodes?
extract this to a dedicated method.
I think line 121 should change <= to < for comparison. suppose max-solr-results = 10, and numFound = 61, so results will show in 7 pages. when pageNumber=5 (it is index starting with 0), then listStartNumber = 5*10+1=51 (it is index starting with 1), then isLastPage = (61 <= 51+10) = true, but there is one more page after this one.
Please double check. I am not sure(!), but stored.equals(share) may be what you are looking for. This compares references.
Also, this should be consolidated into the same validation: new StoragePooLValidator(getStoragePoolForVds()).isUp() // Also checks existance :-)
these 2 calculation won't change during the lifecycle of the class, I think these could be moved to constructor and the value stored as fields
Image and title can be done in the parent class
req: After this deletion, REBALANCE_PROTOCOL defined on line 66 is not used anymore and can be deleted, too.
does it make more sense to use GB instead of US here since payment initiation is more of a GB product?
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 27 to at most 20. [![rule](<LINK_2>](<LINK_0>
For example the thread came to this if block and the same moment another thread will acquire connection for that same slot. The node exists in the ZK but not in the ACQUIRED_SLOTS . Do you think it is gonna be a problem?
interruption to authentication
perhaps sledgehammer to fly, but we could have content-type contract on the server, which is disabled for prod. Ex. Retrofit-BodyType: com.foo.MyClass
formatter
keep its own check
call equals on constant
to loop var also other occurances below
Also, a test-case which proves the problem would be very helpful.
PUT and POST should have different behaviours: POST will return CONFLICT if the entity with the same name already exists, while PUT will replace the entity. Take a look at how the CacheResource handles both methods: <LINK_0> We should either discern between the two verbs, or support just the PUT
Add checking for null here. You can pass null as debugConfiguration.
I'd prefer to see more specific assertions for these block types. Consider having two separate tests, one for unsupported block types that result in an UnsupportedBlockStrategy, and one for block types that result in NoOpBlockStrategy.
This should be outside the loop I think
move this
assertTrue(pce.getMessage().contains("bla bla bla"))
Could you, please, explain, why verification the command palette had been removed?
Ugh, this is gross. Can the unit test just set the property accordingly so you don't have to couple the product code to the tests?
Is this method called at another location too? I'm just asking because you didn't remove another call to updateLibrary
This is a nice fix and makes sense to me. But I'm missing why you had to pass the ZookeeperClient to this class to accomplish that?
please make the error message more explicit.
we're updating the selected route while the method claims to update the collection of available routes. I'd rather move this down to #updateRoute or get both methods unified for added code clarity (ex. I'd try to fix an issue with the selected route, would dig into updateRoute() and then unexpectely find out that the route is also set in #updateRoutes. Not ideal imho.
suggestion String[] splitThread = channels.split(":", 2);
Same here, how passed canDoaACtion().validateInputs() ?
Again should be able to use resources loading instead of a full path?
class name escaping
If you touch this class+method anyway would you mind modifying the underlying design in a way not to return null value? It would be quite error prone e.g. in case of TableDefWriter if the FileLayout is Parquet and by any mistake the type of a given column is not mapped then the execution path would not end up in "not supported" exception, but TableDefWriter would try to create the table with "NULL" datatype. IMHO this would be a great improvement here. I would also standardize it in a way not to throw IOException (e.g. getHiveColumnTypeForTextTable) and RuntimeException for the same problem, but go only with RuntimeException.
oh wait, based off the convo, shouldn't this message change?
clusteringDependentLogic == null is always false since clusteringDependentLogic is never null
Id doesn't make sense to validate the existence of host.id or host.name right after you checked it in the 'if' statement. You don't need this validation.
You should pass a more meaningful name for the orchestrator. Something like "Elasticsearch query orchestrator for backend " + name.
I guess I think a . before left and right would be a bit more readable.
i think expectedValue is second argument. If "3" is placed in proper place, there is not much requirement on putting custom message for this assertion, since the default one will be self explanatory
Another instance of the predicate discussed previously
I find the old way makes this easier to read.
Overall the code is more compat but less straightforward and more obscure. The recurrent use of the form: x = y == z ? a:b ... makes the method hard to read :-( Previous form was possibly longer but with more "self-describing" function names. Never sacrify the readbility for a more compact code.
style nit: we don't use braces around single line blocks
@vilchik-elena LinkedList is not my default choice for a list.
log deviceIdentification and deviceLifecycleStatus as well
Ugh. If the underlying stream isn't a BufferedReader, this won't be efficient. With a BufferedReader you should be able to mark(), read a char[], scan that for \n, copy into StringBuilder the range you scanned, then reset and skip on the BufferedReader or whatever to advance it. But that is probably overkill with BufferedReader. It depends on how its used and the frequency we are calling it. I suspect the single character read is fine so long as its a BufferedReader.
These should be the same triggered ability, which I know is an annoying thing to do. I'm actually wondering if there should be a combined triggered ability class for this sort of thing.
How does this line work? It looks like it's a loop that doesn't do anything
Ditto. The string can be defined as a constant variable.
I suggest to put (i / HALF) (i.e. for all i < HALF it will be 0, for all i >= HALF it will be 1) into "feat1" instead of random value, because otherwise your check  assertTrue(kmdl.predict(VectorUtils.num2Vec(0.0)) == 0.0); can fail.
Should go into @After method to make sure it clears authorizations even if an assert statement fails.
This is the same as in JiraUpdateWriter. I suggest to put Reject Exception creation to validateRequestBody() method. Here, you may leave only a call to validateRequestBody(json);
Ha. Can you actually change all these to assertEquals(1, expected.getErrorMessages().size()) ? ... not sure why I didn't do that in the first place.
why not to inject this one as a dependency of the class ? (same as DBSchedulerUtilQuartzImpl)
Why this separate block for SchemaProjectorException? Isn't that just a CopycatException that could be handled by the existing block? Or are you throwing the exception because this is effectively unrecoverable?
This should be capped at max, so: byte[] nb = new byte[Math.min(buf.length * 2, max)];
Could also "copy" the attributeValueFilterPattern, it's immutable.
better use .isEmpty()
Does this part actually do anything? It looks like you're assigning a new PageTitle to a local variable, but this doesn't replace the actual list item with the new title, so this assignment is lost. And anyway, it seems like this isn't really necessary, either.
Looks like you will need to add ability search person on server
This should fixed in master
what if host already in non-operational status? shouldn't we check it and move to unknown in this scenario?
To be consistent with the previous behavior, I think you should use Files.createDirectories (since you are replacing mkdirs). This will create any parent directories that don't exist.
It doesn't seem like you do anything with the remaining typeIds.
Do we have to always create v2 clients even if I am using only v3 ?
newChild
Perhaps it would be better to just connect the jschSession within the lock above (and add a catch); then the connect within SftpSession would be a no-op for shared sessions and we'd avoid this extra lock() and the try/finally for cases when a shared session is not being used.
Is debug the appropriate log level for these? All apps I've seen deployed have everything is set to info or higher.
Can we move startup of the native protocol for until after we've finished setting up traces and finished startup? This should always be the last step.
There are some concurrency issues: you may observe overshadowedSegments from a previous run. I think it would be easier to add isOvershadowed field to DataSegment directly in this PR because that's the plan anyway and that would allow avoiding concurrency issues.
I _think_ that should be ok too. Should it skip the sequence limit entirely if limit is the default Long.MAX_VALUE?
Debugging println that should be removed?
here it should be "perform", no?
Unless I'm missing something, this doesn't look like it properly handles HBase's bizarre "last append wins" behavior
A safe rule of thumb while starting any activity is to first check using PackageManager and Intent.resolveActivity() whether some activity exists to handle that intent. I think instead of try-catch, you should have used if (activity exists) {start activity} else {show message}. What do you say @therajanmaurya ? It's quite rare though that Settings activity is not found or modded somehow in a way that the usual approach would lead to crash!
Add newline before return.
Just writeBytes(content.array()) Back to my original, somewhat broken version ;)
Why is this?
tooltips -> useToolTips
Should this be pulled out into a separate PR?
you can just do  evalSuccess = instance.comparison.equals(IS_NOT);
Would it be easier to read like this: java if (!config.isLocal() && config.shouldAuthenticate() && config.isStartPageAbsoluteUrl()) { return new BootConfigValidationResult(false, "Cannot authenticate using an absolute URL for start page."); } if (!config.isLocal() && !config.shouldAuthenticate() && !config.isStartPageAbsoluteUrl()) { return new BootConfigValidationResult(false, "Cannot configure relative URL start page with deferred authentication."); }
Makes sense to use fAssociatedValue instead of getAssociatedNumericalValue() since it makes the code more explicit.
please remove useless whitespaces.
Why filtering out case variables?
Why is this code copy-pasted? Since the 2 classes inherit from the same base class, it can be put there in a method.
Does a list of futures always be completed in the order they are added?
inline with ifPresent to emphasize there isn't any complex if logic in this method:  searchFrom(plan).where(ApplyNode.class::isInstance) .findFirst() .ifPresent(applyNode -> { throw error(....); });
Explicitly set the Encoding ?
Should we close the reader here? Or it will be used for InputChannels later?
@sebing this line doesn't compile
\r.getBytes(Charsets.UTF_8)[0] is a really expensive call. It goes through the charset codecs. Just do a bytes[offset + numBytes -1] == '\r'.
Shouldn't stripFormat be used since stripEssentialsFormat does untranslated color codes afaik? suggestion final String strippedNick = FormatUtil.stripFormat(user.getNickname());
Let's use underscore so it's consistent with session properties
Why did you not use a Objects.isNull(amNotNull) here like on other places and changes?
why this change?
Collections.sort(ops, Comparator.comparing(OperationInfo::getId))
this returns a boolean - you need to check if the file was actually created.
That said, I have no objections to this PR.
This should first read the value, remember it and re-set - either on teardown or in the finally block. Otherwise the test may change the environment.
Move the if (id == null) before defining isFactory to avoid getting it if not needed
Make it final
Maybe don't have to copy if AffinityConfig.affinity is a Map<String, Set<String>>?
Null parameter checks should always use "Assert.checkNotNullParam" if possible.
(nit) Move the declaration into the for look for better readability
Two map creations + putAll. I believe the code should pay more attention to that ... even if it means using the map in a side effect way as an argument.
How about a LinkedHashSet to keep the order stable?
There is no ifPresent and orElse code here. - Can't we use int and -1? - This would be closer to the data model of linkedFiles.
I think it makes more sense if the extra parameter was read from an FVClassifier rather than required at any OFSwitchAcceptor. It would also make the feature more like other config options than the classifier already supports.
Can you double check whether partCount==1 case is handled fine here?
In the case where properties == null shouldn't you retrieve the existing application properties and use those?
Can we update method isAuthzClient, add getOnDemand logic in method isAuthzClient?
Obviously just a nit: I think this can be L.e(caught) or L.e("foo", caught); Since this is a test should we just fail?
Just in case you intended to have immutable class java.util.Data is mutable class. You can check it here: <LINK_0>
in general the updated() method is meant to be used for static system configuration like ip addresses of gateways and stuff. The creation of concrete readers should only be done when items do really refer to a specific meter. Otherwise there could be many dangling Reader instances reading content but cannot forward the state to any item.
So, here's the big problem I see with this approach. You've chopped the request for clearing status into many requests and for each of these requests, you load the complete projects repository. That means, to display the projects page for one user, we send N/10+1 requests for all of the projects to the DB instead of just two. Given that the number of project is only going to increase, I believe this approach has no future. Remember how we recently had to limit the number of components loaded for display on the main page to improve performance? When we have to do this for projects, it will only make the +1 part faster. N/10 calls for clearing status will still be loading all projects. Same applies to the sticky filtering by Group, which is already being used. I'm afraid that there is no acceptable way of loading deep project tree structures on the fly. I think we will have to compute this information in some background jobs and load it from the DB cache when necessary. Case in point: my dev system contains 1099 projects. It took 2:25 min for the projects page to completely load, including clearing statuses. Let's discuss.
@wangqiaoshi if else logic looks redundant. Is it possible that we just move projectLoader.uploadProjectProperty(project, prop) outside of if else logics ?
Unless I'm mistaken, this isn't strictly correct. The equivalent behavior would be achieved on legacy slaves if we discarded when initial-load is 100, and rejected otherwise.
change to IStructuredSelection
Null Parameters is a runtime problem and I believe it should be KuraRuntimeException. You can use Preconditions static factory methods container class for such conditions.
This omits the critical functionality in #9: allowing scripts to interpret results themselves.
LEGACY_ACCOUNT_ID and LEGACY_CONTAINER_ID are also defined in BlobProperties. Lets have the declaration in one place only and let others use the same.
Suggest having a second network - one with TRANSPORT_WIFI - on top of the VPN you already have.
will it be possible to extract this into method and cover with unit test + doc (the logic is not transparent IMO)
nit: I'd prefer to push the spans into a collection and verify after. As written this will pass if the acquireLimiter span is created twice (also true of the previous implementation).
I don't think we should use getContext() we should use getActivity(). what do you say @droidchef
I think these calculations can be simplified like this: java double pitchRadians = Math.toRadians(location.getPitch()); double yawRadians = Math.toRadians(location.getYaw()); double verticalMultiplier = cos(pitchRadians); double x = verticalMultiplier * sin(-yawRadians); double z = verticalMultiplier * cos(yawRadians); double y = sin(-(Math.toRadians(location.getPitch() - pitchOffset));
values("A")
Do you need to lock on both calls? I would try to extract locking in a helper method so it would interfere with MySql startup.
nit: could combine into (taskConfig.getCommand() == null != jobConfig.getCommand() == null) and say "Command must exist in either job or task, not both".
You don't need to remove() since it would be replaced in the following put().
this is a check of the argument. Annotate with @NonNull and let static code-analysis handle this
Just make getLatestLayout return a Layout, if its null then return a dummy layout with -1 epoch. Then in fetchLayout you can wrap this with a future and return.
Too much duplication with the previous method.
Reusing FContext in the other examples still.
rename to launch
Can we use NotFound error code?
I'm not sure this is needed. Why do we need to commit to the indexing service here? We don't seem to need to do this when deleting any other type of Group (see other delete methods in this same Builder). If it's unnecessary, I'd recommend removing it
This check is not only adding but also removing problem from / to nodes. Returning true leads to a prune of the child-tree branch beneath that node. I'm not sure whether this "rule" (skipping already once visited nodes) can be applied to all node types e.g. ExecTCs are e.g. if their parent is re-used in different contexts, occurring multiple times within a traversing run which might be relevant to the problem cleanup or new problem creation.
Related?
To enforce naming convention, should we put composing and parsing containers' names to a separated class?
again, no default please.
Why not directly call a canDeleteInstance(input) ?
Great, thanks again.
Same thing: Missing table name in error message. 1) It is not clear what is missing 2) It is not clear why it is missing. Assert message should better be like "\"check_table\" should be contained in the exception message because ...". Note: the assertion **hides** the original message, thus it makes analysis hard. So you should either use assertThat(..., message, contains("...")) or add message to the message parameter.
On phone so can't expand this file to see below but if it's duping the next line, commet instead is fine
else if (newLeast.compareTo(oldLeast) == 0) {...} else { issueError(... (symmetric to the other Direction)
This can just be a plain Map.
I wonder if the mediaUrl could be abused here (with infos coming from the server) and if we should escape it (same for other calls to execJavaScriptFromString with a mediaUrl)
Shouldn't we protect ourselves against wrong context type?
java protected String entityToJson(Object entity) { String newEntityJson = ""; // TODO: Throw an auditing exception here // Drop data on consumer we do not want serialized, Jackson doesn't // seem to care about XmlTransient annotations when used here: try { newEntityJson = mapper.writeValueAsString(entity); } catch (Exception e) { log.warn("Unable to jsonify: " + entity); log.error("jsonification failed!", e); } return newEntityJson; }  is what should be getting run by entityToJson. I don't see why any side effects would happen in that code.
I would split that up, it's a bit hard to read. if (includedInFeature) return false; if (showProducts && includedInProduct) return false;
Should we really have a different formatting for newly added files? Why not simply sb.append("+") .append(info.lines_inserted()) ? This formatting would be more consistent.
add final to Exceptions
Using valueOf to get the constant instead of using noneOf definitely seems better to me.
Maybe we need to create constant field with value data just to know were exactly it's used. I've found only EventTypeValidation#wrapSchemaInData, and it will be hard for me to understand where else it could happen.
Rather than having this check and two different code paths, let's make it so that version is final and always non-null with a default of $2y
fInt? Just f looks better.
Would it make sense to also make sure that the string is not blank?
when do we validate the config file?
suggestion if (vungleBanner != null) { if (vungleBanner.getParent() != null) { ((ViewGroup) vungleBanner.getParent()).removeView(vungleBanner); } Log.d(TAG, "Vungle banner adapter cleanUp: destroyAd # " + vungleBanner.hashCode()); vungleBanner.destroyAd(); vungleBanner = null; }
shouldn't the datastreams be identical if it's the same request? Why only check owner (and effectively datastream name)?
This lack of braces doesn't follow our style guide.
Looking at this test as a whole, the public interface is tested more thoroughly if raw string values are used here instead of the internal constants representing the manifest keys. In the case that a typo ends up in MF_AUTO_CAPTURE_SESSIONS, this test wouldn't catch it at all.
nit: addr seems useless? no need to assign to addr anymore?
where could python console log re-directed? It is better to redirect console log to Java console and shifu.log.
I would prefer updating Avatica to add another MetaResultSet.create that has updateCount parameter, instead of adding a subclass.
Is this the right logic? We care only about bulk PUT. We want to add the filter for every request besides bulk put. So we should invert this logic.
this is maybe what ConfigMemorySize.toBytes should throw for out of range
currentProgress is always >0. So first condition can be removed
BarcodePrintAssister should be private final member instead of new anonymous class per request. Same in all other ControllerHelperServices
not clear what to do
Here we should just use the CategoryDeleteCommand and I don't know why the code that you copied used a category ;-)
Could just use a method reference, here: .map(UMLTProtocolMessage::toReceiveEvent) It's not only a bit easier to read but, unless the compiler is very clever, saves on creating a .class file for the function. :-)
should be new UdpMatcher(config) ...
Added a controller view so that you can send commands straight to the Arduino?
use constant EntityModels
I find this more difficult to read and would prefer the original version here.
Use BrowserUtil. The handler in tasks.ui should handle the URL.
Is there any way around it or is an optimization to no copy not really worth it?
nit: use else to be clearer
can we add an upperbound here (liek 20 ro somethign) and throw an exception if it tries too many times
Would it be much of change in tests to change VersionedEventStore#putAll to take LockWatchEvents?
@jwass @findepi @arhimondr GeometryType enum lists types used for serialization. Envelope type is used to efficiently serialize trivial polygons and enable further optimizations by preserving the fact that the polygon is a rectangle aligned with coordinate axes across ser-de (see #10327). Andrii pointed out that it would be clearer to rename GeometryType to GeometrySerializationType . If we do that, we could then add getStandardName method to the enum to return the type name that ST_GeometryType expects. This way when new serialization type is added, it will be obvious that standard name needs to be provided for it. ST_GeometryType must return ST_Polygon for envelopes.
tags can also be null (default value)
might as well compress it... let's not introduce kryo / chill deps, too much churn for such a low-level lib
This is still missing tests for FOO from both the folder and the project.
And the variable name systemWeighting?
You need to handle the case where mli is null.
Why do we mark Integer.MAX_VALUE? If we call reset after this the read position of the stream will be Integer.MAX_VALUE.
modify it as it was implemented in ENG-10264
Considering the implementation details, I wouldn't make this method available even to its package. Let's discuss.
just call this value
going to remove as the refreshing of the prefs shouldn't be on this code path. Should be taken care of the process that instantiates the object (see AbstractKeyValueService#constructor)
You should probably make a variable at the beginning of the loop for getMainHandLocation so it isn't run 3 times
Can you rework this to just:  assertEquals( expectedHighLevelObject, actualHighLevelObject );  which will compare the two via .equals() on the objects. This assumed that AnalyticsEvent has a sensible equals() implementation. Which, it may not, actually...
Does adb output contain different line separators based on OS?
I think += should just be =. This will at least double the value every time, not just multiply it by the modifer.
code is a little bit cleaner if stream is mapped before the filtering  locks.stream().map(LockInfo::getAcquired) .filter(Objects::nonNull) .filter(date -> date.isBefore(limitForAcquired)) .count()
extract to local variable?
Hm, I think it's better to use nextOffsets.get() now that it has been set rather than repeatedly calling consumer.position() here and the line below, since we don't really know the cost of calling consumer.position() but we control nextOffsets.
might be like this: java arraySupport = PrimitiveArraySupport.getArraySupport(array) if (arraySupport != null) { fieldString = arraySupport.toArrayString(array) }  The static PrimitiveArraySupport.arrayToString() method can be removed then.
add spacing for readability
String.length() != []byte.length. We would need to convert string into UTF8 encoded byte array.
When are these clients closed? When the perf test is completed, eventHubProducer*Client.close() should be called.
I still don't really undestand why this change became necessary within this PR? That interval cannot be stored isn't new. Did randomType change in some unrelated way?
nit: extra parenthesis
Can you add location too to enumerate api.
remove final
Shall we combine two if conditions and also save errorHandlerAttr.getAttributeValue() to a value and re use
Done. This is OK to share one instance of the progress monitor, because it is basically empty.
Could use Execs.multiThreaded()
These three lines should be moved further down, the PlayerProfile caches the armor too, so you can directly access the item that way and save a ton of performance too.
I think we will still get NPE, no ? We might move get out of for and run for if output of get is not null at both places.
What does this lastCall suggest?
Swap the equals condition.
I think this check should be done in internalGetOffset() instead? The scaling could make a valid offset_s overflow and vice-versa. And the offset could make the total offset overflow.
duplicated check with the ones inside executeOperation
nit: again, error text
I mentioned this in the commcare-core PR, but I think we should be setting the arguments by setting them as XPath variables on the evaluation context, since that will naturally and robustly substitute them in as needed as the stack ops are calculated.
Instead of asking the user to enter additional constants, why can't we do DOWNSAMPLE(<time_series>]*,#downsampler#) DOWNSAMPLE_QUERYTIME(<time_series>]*,#downsampler#)
Haven't dug into this, but just want to check that a named location really will give the name in the locationFlags map. As opposed to it being embedded in the spec.
please also add checks to validate that Dimension has positive height/width
there's too many parens here making this tricky to read. i think this would be much simpler to read as:  if (nameIdFromSubject != null || baseIdFromSubject != null) {
Something like this should work but i have to think about the implementation of equals on the Node and wether we are doing the right thing. PublisherPush pp = current.get() if (pp != null && pp.getPushId().equals(pushId)) { current = new ForwardingNode(current); return true; } Node next = current; for (int i = marked.size() - 1; i >= 0; i--) { Node n = marked.get(i); if (n.equals(current)) continue; next = new LinkNode(n, next); if (n matches push id) { current = new ForwardingNode(next); return true; } } return false
Could we invert this? So if it exists, we return true, then outside the block we can do all the rest.
Android Studio suggests to use ! isEmpty() instead. It's up to you :wink: If you do so, please update everywhere
BTW I don't see this in TreeColumn. Usually Tree/Table code is identical, maybe something was missing in the fix for bug 97863.
can MAX_FILE_PER_WINDOW be a configuration? and why is it needed?
Why not request(2) once in this request()? I.e.,  java public void request(long n) { if (n > 0 && once.compareAndSet(false, true)) { parent.requestMore(2); } }
I wonder if we should not make this a method for time selection: select(SWTBotTimeGraphEntry entry, long t1, long t2, int mouseButton). When we do time selection we don't normally go up or down. Then when we use the mouse to pan the view, we're usually concerned only with coordinates and not time (e.g. I'm going to pan 1/4 page up&right, then I would see pan(int x1, int y1, int x2, int y2). And that's either middle button or Ctrl+left button. Probably good enough to assume it's middle button. Maybe pan() could be in SWTBotTimeGraph() and select(t1, t2, button) could be in SWTBotTimeGraphEntry?
Once you set primary type, you can just init properties based on mapping table. Take a look at this code <LINK_0>
close streams
I think the exception should be Could not delete
What's the purpose of this change?
Must be inside the try-catch, otherwise the lock will never be released.
out of curiosity how long does this new check take?
Should we not simply create a temp variable of type Path at the beginning with that exact logic and use that variable everywhere as opposed to duplicating it in X places? This would reduce the complexity of the method.
Can you leave Exception for catch possible NPE :)
throw a badrequest exception if only the container name is set.
why not use addMessageHandler ?
I think we can split them into 2 parallel Threads to speed up job execution.
What is this addition for? -- I also see reconstructions of HashMaps throughout this PR
Is there a reason why you are using a Set instead of an ImmutableSet?
No need to keep a blank lines in the beginning and end of method bodies
Eli, we almost missed it - look at runThread - the value parameter is set by the result of executor.Fence - how is it returned to the rest of the flow? same with succeeded. This should be handled differently.
Why are you expecting this? Why expect some sections? Why expect 2 sections? What are you testing?
Should this change be integrated in 2.0.x ? (I mean even if we don't integrate this PR?)
that call to getReferenceSequenceDictionary() is going to be done a lot of times. Can you call once and reuse? Wont save much (collect dominates, that's for sure) but it's a simple change
Just curious: why not write the loop as links.stream().filter(Objects::nonNull).forEach(action);?
final
Like with the attribute access item check, this compares the DTOs to themselves, instead of to the value objects from methodAccessItemList.
Can this loop be simplified with something like ArrayList.indexOf?
I don't think anybody wants System.out being used in the productive code?
Just because it's done that way in the other tests...move function to just before the comparison?
If you're going to fix the indentation here, remember that we use four spaces per indent.
If this can't keep using GenericTypes.resolveType() then this is a breaking change.
<= and >= maybe?
avoid increasing visibility?!
If the test is measuring the scalability of read operations, we can persist data once and not touch them again unless the data needs to change. That means writing data should not be part of the test, but a separate script that is run manually whenever we need. For measuring scalability of write operations, we can need to separate the _primary_ objects whose write are being measured from _supplementary_ objects that simply need to be there for the write to succeed. e.g. The session object needs to be in the datastore for an operation of writing responses to succeed. After that, the supplementary object can be written once using a script, similar to the case above.
This log is likely a duplicate of the one that we have in the initialize. Should we log this for every login?
Not clear from reading sources without an IDE handy what item is going to be here. Is there a reason this cannot stay as name?
KV type is only used in High Level API after the transformer. It essentially contains (ime.key(), ime.message()). You can remove this check completely. ime should also not be null.
I think you should get the visible status from model and set the visibility of the warning, Otherwise if you open and close the add bricks dialog box in create volume scenario, warnings will not be shown.
Could you define this color in **colors.xml** file and use getColor() instead?
deploymentName should have quotes around it, otherwise spaces are lost and it becomes "WARMODULENAME.war" in standalone.xml.
This should probably be 4.2, no?
Make these variables static final, so you don't have to initialize them every time
should be assertTrue
TreeSet might be better (can remove duplicate and automatically sort). But since timestep won't be many so this is fine.
minor: it looks like the method modifier can be changed with "private"?
Just noticed getCaseAuditEvent*Listner* typo when going over N&N :)
Suggestion for future work: This should really work if we just deleted the body of this if statement and replaced it with a single call to layoutBar.requestLayout()... but it probably won't actually work because of the way CoolBar relies on an explicit setSize call to determine its CoolItem sizes. If we could fix CoolBar's layout to make it use the computed sizes of its children directly, it would really simplify this code.
Probably I haven't understood the problem....but, was not the goal of the ticket to provide a sort on the tags in the CSV file generated ? where are we checking that the content of the CSV file is following that ?
What happens if you just add without checking for empty list? Still the same result?
switch this and other getQuery.andUuid calls below to atsServer.getArtifactByUuid(uuid)
Nit: should not have trailing space here, as this will result in an extra space
The keySet method is not blocking already. Maybe the worry is the iterator hasNext method instead?
Should use parameterized logging instead of string concatenation.
I am thinking it would be better to have this an IntStream instead. Stream<Integer> case segments is null we have to box N values and unbox N values in the forEach consumer segments is not null we have to unbox N values in the forEach consumer IntStream case segments is non null we have 0 unboxing segment is not null we have N unboxing in a call to mapToInt In either case it should be better or the same.
I think this (and subsequent occurrences) would be better as something like: assertTrue("The countdown should reach zero", latch.await(1, TimeUnit.MINUTES)); That way at least if we end up on a failure path we aren't waiting indefinitely or relying on a global test timeout that could abort a build.
Why do you need the varDeclaration.getContainingClass() == haxeclass here? Doesn't the fact that varDeclaration was found as a direct child of the body imply that?
s/any(List.class)/anyList/
Don't swallow interrupts! <LINK_0>
can we propagate e please?
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
Could verify here that workpid was not committed, aka doesn't exist outside of the transaction. Then after the parent closes you could check that the work does exist. And maybe do something with the folder you created to verify that stuff happened with it? Sounds like you could make a helper for this and the other tests that makes a non-tx client and fails the test if a get returns the wrong status code
Why two separate try-catch blocks?
NPE if data does not contain repoObject.getBucketName(). (Looks like a few other methods have that problem too.)
meh, was easy to fix. added now.
You should use <plural> here to take care of this. This is better for localisation. You should use: - One - Two - Few - Many - Other While English will be easy since two, few, many and other will be the same but this is not the case in every language.
IMHO we should extract this ugly code in a dedicated private method getLocale() local variable should be named locale
could you specify List<PartitionId>?
java final List<AttributeValue> values = Lists.newArrayList( new AttributeValue().withS(rangeKey1), new AttributeValue().withS(rangeKey2) );
i suppose it's not a field mapper anymore? It kinda still is though .. i dunno random thought.
Static import of Assertions.assertThat() would be more readable (if there is no conflict with another assertion framework).
I am not sure what does line 92 to line 96 do. why they are different?
This could be a method, assertValidLicense (final String schemeId) { if (!SYSTEM_WORKFLOW_ID.equals(workflowAction.getSchemeId()) && !hasValidLicense() && !this.getFriendClass().isFriend()) { throw ...
Do we want this setting to apply it to all operators or only the Writer? I think that it seems more relevant for the writer only as that is what the user "sees", but I am not 100% sure.
sorry i'm a little bit confused, what are we doing here?
Is the plan to merge this to develop or keep it in a separate branch until it's ready? If it gets merged to develop, then these command line options will be available, perhaps before they should be. If it works today, then never mind.
inline slice variable: return serialize(serializationBuffer.slice(), page.getPositionCount());
I might consider making a helper method simply to make all these statements occupy a single line.
We can use foreach here
it's better to use different names for user and repo ... it would be less confusing
please make this more deterministic rather than just sleeping
extract
Use doc.getACP(), and ACP not ACPImpl.
if (element instanceof FieldMetadata || element instanceof ComplexTypeMetadata) { impactSort.get(Impact.MEDIUM).add(removeAction); }
duplication of !directory.canExecute()?
nit: use i++ to start the loop so it looks less like we declared a new i here. Also wrap the body in {}
Can we replace this method override with additional parameter in CodePanel constructor?
same if statement twice?
perhaps put try catch around interpreterGroup.close();? it looks to me like other calls inside should not fail in most cases. if close() is expensive or could fail, then a try catch just around it could let other groups a chance to get clean up, instead of skipping all of the rest this is doing now.
Please review if logger.error will handle String arrays appropriately. This looks like it should be  logger.error("Fail to execute rule '{}': {}", ruleUID, t.getMessage(), t);  On a second look, since the throwable is also logged we might drop the redundant message and do logger.error("Fail to execute rule '{}'.", ruleUID, t); instead. wdyt?
typo: "during update registration"
I think it is better to return an empty collection instead of null.
I am not sure if this is really a problem. Because you can always take all members from synchronized group and add them to the different group by union. What do you think?
Just curious if we can avoid converting the MarshalledEntry to an InternalCacheEntry before checking expiration. Could MarshalledEntry.getMetadata() help here?
what you log is the unqualified version plus the qualifier, actually, not just qualifier.
Unknown Column Type
Minor nit, but ClassMethodCache is a slight misnomer, since we are only caching no-arg methods
Juan, I prefer a single exit point on multiple points. Do you mind defining Integer exitCode = 0 in the method beginning, and a single System.exit(exitCode) at the method's end? Then you simply need to set this value once in the catch block to 1.
can we remove this check since we already do this check inside the initializeRunId()
Can let fall-through.
Maybe we should assign the error message to a proper String variable and pass it for logging as well as into the instance of "Message".
why ignore case?
Instead of creating objects for each method, for logger and property object, can move it up to a method with @Before annotation to call it before the actual test methods are called?
Info or warn..?
Unnecessary if check. Why not just: qi.maxRepoSize = qs.getMaxRepoSize(); ?
relevant non-logging code change here ^^^
This should be: java // Prepare first users rights on all subgroups of groups where user is GroupAdmin and add them to AuthzRoles of the user AuthzRoles authzRoles = addAllSubgroupsToAuthzRoles(sess, authzResolverImpl.getRoles(sess.getPerunPrincipal().getUser()));  like in init(sess) method.
fields = Collections.nCopies(columnHandles.size(), null);
Remove handling of PercentType because it is a subtype of DecimalType and both are converted in the same way.
hostname resolution is case-insensitive so LOCALHOST is a valid hostname for 127.0.0.1 (had the same issue in netty hosts file resolver) hostname.toLowerCase(Locale.ENGLISH).equals("localhost");
lock is missing
There's probably a maxint const somehwere
Why are we having space prefix here?
:) I know, I saw the test. If you want to improve the original test too, that would be great. If you find out that these tests differ just by (not)calling the checkPrometheusMetrics(), could be worth also reduce the duplication by introducing a new private method containing logic of the test. If you find it too complicated, feel free to focus just on the tests related to Prometheus and let me know - I will file a Jira about the test refactoring. Thanks!
Is the Syso here needed? Maybe try to either use log function or just remove it.
To keep our arrival/departure labeling consistent with the normal arrival times lists, let's construct an instance of ArrivalInfo here from the ObaArrivalInfo, and then call arrivalInfo.isArrival() to determine if it's an arrival or departure. This is actually a little more complicated than I was originally thinking, though, as previously we were always using arrival time for the reminder - technically I think we should probably be reminding users with the departure times for departures, and arrival time for arrivals. I think we could use arrivalInfo.getEta() for this (internally we already calculate ETA from arrival or departure appropriately), but the resolution for getEta() is currently in seconds, and this method expects to return milliseconds. Maybe we add another method that returns ETA in milliseconds.
This does not accept limiter functions like findMetrics?
Mark the method with @Nullable or factory doesn't follow _everything is not-null by default_ pattern ?
This should be sorted for efficiency
Please add logging to make it easier to debug when XML_FILE_PARAM key doesn't exist.
Perhaps boundary should be partBoundary as basicBoundry isn't that expressive?
This should be a singleton.
Optional.empty() ? :)
Can we sort the label names (by name) to have the columns always in the same order? I think it is confusing if the order may change.
Do we really need to log anything here in the method, if we don't log any details about error? I think that logging should be done inside upper level method which tries to deal with gluster service status?
Instead of using String comparison you should use CDIProxies.isCDIProxy method to check if the class is a proxy.
Double full stop.
should this be startsWith?
no null check for defaultKeysource
This is a very good test, big coverage!
The ControllerListener is the deprecated way to get these events, and ControllerStatusListener is the new version to get it. Did you switch to this method for performance reasons?
Please use "something <operator> null" convention
could use incr util
you to defer setting this value too, otherwise it breaks when: focus in text box delete everything then click check box
This should be disabled by default in Elide 4. However, turn it on for testing so the tests below work.
Nit, but either the spacing should be fixed or use String.format
This could possibly be a Batch (and ops.batch). Not required, but some commands to that and the error behavior is a bit nicer.
avoid access direct to view, use presenter instead.
I think this doesn't allow executing tasks because you ignore r.
Refactor idea: replace lines 191-194 with: java ipv6 = "false".equals(System.getProperty("java.net.preferIPv4Stack", null)) || "true".equals(System.getProperty("java.net.preferIPv6Addresses", null))
this method (checkForPendingAppHealthActions) triggers any time we get back to the home screen, not just any time the app starts up for the first time, right? I think that means that failures to sync will keep forcing the user to keep trying to sync after , say, every form, even if they can't currently sync. I think this needs some way to identify that the user has attempted to sync already in the current login, and only force a sync if one hasn't already happened, so we can trigger the right behavior (sync before update), but only once per session (or once per update attempt. If the user restarts the update and it's blocked on sync it should reset that flag back to force a sync)
This line also seems to be redundant.
no need for unmapped check since already check and returned above.
Maybe we need a contentlet.getBaseType() method that looks up against the contentType if set or the map if not?
Stream instance "one" -> "two"
No else needed , exception stops the method code
space before {
RE? you mean MI?
Move this before the // Change the feedback path... line. Also, make this edit: ... ~~for~~ **while editing** question...
ping
nit: avoid private fields dependencies in the constructor is preferred. new HashMap<>(instanceCapacity); Or just assign instanceCapacity to _remainingCapacity.
Is the text still escaped when stored? It needs to be unescaped before storing, otherwise if someone submits an XML file, it won't be an actual XML file that is stored, which would be bad for reusability purposes.
How bad is this state? Is it alert worthy?
xl should be called xi for an int. Ditto throughout.
this is unrelated to the main change and also increases scope of the variable. There is no performance improvement if you meant that.
Initialize should likely go to setPolicy
Last thing, promise. Just check that Kernel32.INSTANCE.GetLastError() is INVALID_HANDLE or something like that. This would fail on a non-US-English system.
Should the charset parameter be set for the Content-Type header?  java this.addHeader(CONTENT_TYPE, "application/x-www-form-urlencoded; charset=" + getCharset());
Why is this so slow?
rs -> resultSet please
The NoCurrentCaseException should be in a separate catch so the error can be logged as SEVERE.
Strictly speaking, not needed as shard() must be from 0 to 255 right?
shouldn't we check for owner != null here too?
Is this correct? According to the [API docs](<LINK_0>, this should be 406, but the docs have been known to be wrong.
Replace with UserUtils.validateUsername(String)
For a very short time, the interval is out of the queue and returning from the method but not written to the volatile variable yet. I have reproduced the exception with this patch.
magic numbers
it looks wrong.. this one is always true: !isHotsetField(srcFld.getName()) || (isHotsetField(srcFld.getName()) so I think it should be: !isHotsetField(srcFld.getName()) || !hotsetEnabled right?
these lines could be moved into the if/else block above
What if Content-Length is 500_000_000? Will you really create a buffer with that size?
the original setEvent is necessary to keep, so we will end up with two setEvent methods: java void setEvent(bool); void setEvent(String);
My understanding here is that the proposal is to only cache the result of postMatch(null, null), which is quite a common scenario. If that's the case, shouldn't this be if (cachedPostMatch == null && declaring == null && target == null) ? Or maybe I'm not understanding what you're trying to do?
I don't like this because you are turning every exception into a walk up the tree. Even if the dashboard is defined in a project, but its object files are corrupt and cannot be read you walk up the tree looking for another dashboard of the same name.
Please use AssertJ
Inline?
Question: why are you first setting HomeAsUpEnabled to false and then to true?
If the hostname is already trusted you no longer need to check for the URL. I suggest you to remove this line from here, then to add an if statement right below the try/catch to verify whether trustedHostName is true or not, if it is false then you can call trustedUrl = webBrowserConfig.isUrlTrusted(url);. It's better for performance since it prevents you to iterate in both lists when you do not need it.
could be maybe a bit more elegant to use the Stream API to do that? :)
This does not surface the exception and is a silent failure. It should throw.
scene.getPopup() should be accessed in a static way.  At least, that's what Eclipse says. And I think the same. (this is not the only line this warning is generated) <review,logic
I think it was better with the old static imports.
Nit: Capital 'G' for start of sentence. Also, Redis should be capitalized.
This is still showing up with no indication of what the actual error is. I think we need to display all available diagnostic info in the console to make it easier for engineers (and me) to debug their build failures.
This is not needed.
I am not to fond of this type of code as it could result in a NPE, I would want some checks here to protect us.
space around +
Name will always be null before save
@rnveach we shouldn't ignore any exceptions unless absolutely necessary. What are cases when absolute path works but canonical path fails?
Just to double check, is it safe to assume number of executors is same as number of tasks? If there's safe way to get the value it would be better to apply that, otherwise 0 (even -1) might make less confusion.
Check args ?
I think we can and should move to using guava's Files etc as much as possible for this kind of thing. But for now, you could use something like:  File tempFile = ResourceUtils.writeToTempFile(src, "sshcopy", "data"); try { finalSrc = new FileInputStream(tempFile); } catch (IOException e) { throw Throwables.propagate(e); }
Extraneous final
Just a clarification: the WD_FILE location is now somewhat hard coded in the implementation. But it is still modifiable in the service preferences. There is still a reference to the getWatchdogDevice in the private method writeWatchdogDevice. Could this take to some sort of inconsistencies? What happens if the user changes that value in the service preferences?
It looks like you left this in by mistake. Either remove the line or change the text description.
Do we need this since we already have a log by the thing status update with the same message?
Shouldn't we do the same thing than above in the code (ie: using Objects.equals)?
extra space
thread is needed only inside if block
entityManager shoudl be closed after each query. We should put this in a try block so we don't leak it: java try ( EntityManager entityManager = emf.createEntityManager()) { //do stuff } java
It's hard to get what 6 actually means. Recommend to use OrientPermission - there is method to get combined flag as int.
please remove the added exceptions
ditto about "indeterminate" in error messages.
Refactor this to a reusable (injectable) function that transforms a Docker state to a jclouds node Status?
The only thing I can think that _might_ be a problem is that any argument implementations that depend on e.g. statement.isWrapperFor() or statement.unwrap() to unwrap a vendor-specific prepared statement might error with @DefineNamedBindings where otherwise it might behave fine.
too many indents in this method, I would extract this part to another method.
I smell a C++ coder here. Please use a for-each loop so my eyes don't bleed. :)  for (Element button : releseContainer.select("li a")){ }  Magic.
Why "auth_type_email" string? Enum or integers and no magic numbers.
Yeah, I agree it's likely not winning us any time, just complicates the code path. I'm in favour of dropping them
lets call this trainingPollOperationResponse indicating that it will return a poller instance.
It is not clear to me why we need to suppress this exception.
Minor: Validate that hive-site.xml exists and print a warning if it doesn't? Looks like this can be a common mistake.
This will find all of the columns with that name in any table in any schema in any database, right? And won't it be possible to return more than one result? After seeing this code, this seems pretty brittle.
what if several clusters? we should at least TODO or jira
extract?
What if it's an integer, or short, or ... whatever? Can it check Number.class.isAssignableFrom(...) instead?
for-each here  for (JsonElement jsonEle : jsonArray) { // stuff }
This is probably unnecessary now -- all of the resolution is done by the population of the entity from the DTO.
I guess it should be account not amount.
I think maybe here print the size of the buffers queue? validate that it is > 0
assertTrue?
Fix condition.
Same on local variable.
We should check that getAllPendingJobs is not returning null. In API21 there is no notNull annotation for that method.
I think Expression.getValue() with return type variant to Boolean.class does the trick for us. As far as the conversion service is in charge the in SpEL.
what is the semantic of these different config strategies? You are using environment variables and a config file. Would it be possible to use just one mechanism? I think this would simplify the bootstrap of the DC and its runtime management. Wdyt?
Actually can you revert this, and also put the call to buildFontList back into getFontList? You removed it but that's a behaviour change I didn't notice, it means if someone adds new fonts or whatever they won't actually show up until the app is restarted - and the user probably isn't going to realise that.
Please define the new key names in the Constant class. This will make them easier to discover.
Nothing happens here, I think the entire addJobChangeListener should be removed like others.
unboxing will happen in the comparison in the if branch anyways, so probably better to do it early declaring the type long here.
CoreException is much wider than ResourceException, which is the one you want to ignore. Wouldn't explicitlyt checking whether the resource exists be more precise?
I like this cleanup.
Shall we remove these, test println()?
This may be a very heavy operation, if it's called for many items, it can be a serious performance hog. I think we should avoid relying on regexp as much as possible, and if we do rely on them, we need to use the Pattern and invoke Pattern.compile only once. IIRC, matches will Pattern.compile() every time.
Can the setter calls on the builder be chained? Probably look nicer that way.
As this if-else if-else if-else getting longer, let's use switch case?
Does it make sense to constantly create threads in packs of 10? Why not to use single CachedThreadPool for this service?
You can make this more readable by introducing local variables. Having a multi-line expression is not ideal.
Determining if we require a prediction model should happen in the scheduler
Consider using the positive checking, which should mean you have 5 positive BranchState checks since 6 negative checks are done now.
You should test hasNext each time (before calling the 1st next until after calling the last next.
use %s placeholder instead of {}
Just pointing this out in case you dont want it commit this app id
Use getConstantsConfig().getGroupScope().equalsIgnoreCase(scope) to avoid NPE's
Please favor immutable collections. val response = ImmutableList.<MultipartUpload>builder() here.
When the default value for the timeout is being used, instead of hard-coding the value like here, it would be better to use a reference to the DEFAULT_SERVER_CONNECTION_TIMEOUT defined in PoolFactory.java.
Same here, just for clarifying: Build.VERSION_CODES.JELLY_BEAN_MR2
minor: is it possible to have this try-catch wrap just whatever line is potentially throwing it?
Something seems wrong with the name mapping. When I select a file (executable or text file), the whole trace entry gets duplicated.
modelProvider.getModel() could be inlined here.
end variable is used only once, hence, it is better to inline it: qualifyingSet.setEnd(qualifyingSet.getEnd()); However, inlining shows that the variable and the statement that's using it are not necessary. Let's remove these.
Can we check this is in an assert?
Consider using String.format() here
you can you atStartOfDay() or something like that.
Remove the extra newline.
We should combine the list with the deferred adapters. Maybe give a deferred adapter a name?
Second parameter of Status is the pluginId. Why to pass path here?
This condition could be put in a new method to factorize code and improve readability.
this change seems to be incorrect. The original code was supposed to calculate the size needed for all the volumes (when performing collapse), while this one seems to take into consideration only one volume.
the apply method should only return false if a not expected situation happens. So if the player guesses the card name wrong, it should return true and not false, because this is a normal situation. At least nothing special happens depending the return code. Only if false is returned, there is a info message to the log to be able to recognize logical problems of an effects apply method.
nit: it's a bummer that checkstyle doesn't run for tests, but (regardless) you will need a space before { as in:  Exception {
And this should go away i.e the if clause
why this method is called scheduleAll ?
Why checking only the expression of the MemberSelectExpression ?
Unnecessary parentheses.
checkedCast()
Ultimately, the whole section here is to find the Set&lt;String&gt; processorNames. I would suggest to fold all this into a single method getProcessorNames() and pass that to the grouper's constructor.
No sure, but isn't it possible to use a "try with resources" here?
:ant: Also deserves a test.
We're on Java 8, so now you can do String solved = data?.getStatus();
I know it was like that in DimensionPredicateFilter but should 'no predicate' mean 'matches all'?
if ( jsonld.contains("\"_:foo\"") )
Why not just use domainDataDir.toPath()?
Please check the messages for validation errors (post validations). Since we add errors on the agent config object and throw the GoConfigInvalidException, we must show 422 (unprocessable entity) instead of 500 (internal server error)
Let's give that variable a better name, what about config?
feature check would be enough
Use StringUtils.isBlank
do we need the check block on line 219 if this validation code runs over things first?
duplicate
Obviously this text needs to be externalized.
do we really need to synchronize here? I tend to think no, but yet again, here is where the race condition was.
This should go inside of synchronized block. Since metrics may be added to _metrics after you've instantiated sizeJVMMetrics.
You may also return early here to avoid one level of nesting.  if (!doi.isPresent()) { entriesWithIncompleteMetadata.add(entry); LOGGER.info("skipping reference with citation key \"" + citationKey + "\", since it does not have a DOI"); return false; }
I wonder if a helper method would be better here? Something like isClientCredentialsGrantType(authorizedClient)
is this. required?
Chain?
typo: require_s_ a_n_. Same below.
It should be future.channel().close()
It looks like this will update its presence with every new transcription result. Or am I missing something? I would expect it to update its presence when the status changes (when it starts and when it stops).
AFAIK you should not use string concatenation in debug traces.
should this be completionFuture.completeExceptionally(t) ?
I think this would be more readable when you merge the if branches of both ifs and maybe extract them into a private method.
I would only use the try-catch block for beanManager.resolve() to make it clearer.
the formatting is a bit broken here
I think that this logic would be a bit easier to follow if we combined these two checks and used !==. That way it's clear that pack types can only be changed to other pack types with the same value for testSampleProduced.
the standard one here is "attr"
No need to use Preconditions.checkNotNull() here, .withParam("token", token, true) will throw a exception if token is null or empty.
perhaps this should be false, so you can selectively enable it - at least initially?
For null values, we just do not supply those properties in the autoGenerationOption
Add missing braces here
We may want to consider crashing the app in debug to follow the Fail Fast principle and showing a snackbar so the users know something went wrong, wdyt?
When touching the line above I would have done an s/Hudson/Jenkins/
Could you help to rename logger to LOGGER ? It is our convention for naming static variables.
Why is this variable mutable? Another way is to extract it to a separate method (e.g., getNumRunningWorkers()). WDYT?
If it's a time-consuming operation, there may be a benefit to run them in parallel ?
looks to me like the only way creationOrder.subList(0,1) would fail is if their creation times are identical (ie to nearest millisecond). i don't think there are issues with "older" one being deleted in that situation. but maybe so that we can have _both_ checks (the new time one, and the original subList one) we should stick a Time.sleep(Duration.millis(1)) before the resize(2) ?
Hm. I think we should actually be concerned if we ever get to here -- I'm not sure the TaskMigratedException made sense either. Trying to add records to a closed task would imply that we closed the task due to shutting down or because we no longer own it, both cases which should also involves trimming its topic(s) from the consumer's assignment, but were still returned records for said topic(s). Unless, the consumer may still return already-fetched records from partitions no longer in its assignment during poll? I thought we would trim those records out and only return from the actual assignment
I think you can use the interface here -- "Cell" instead of "AbstractCell". It's a little more proper to do that in Java. Other than that, looks good.
Can you use busy waiting, event or latch here? In the current implementation, this test lasts for six seconds, even if it is not necessary. Unfortunately, the tests are already slow = (
I think we should use a larger number for the maximum batch size, e.g. 2 * deleteBatchSize as we discussed before. The partitioning code will return batches that have at least deleteBatchSize (cell, ts) pairs, and we don't want each batch to be broken down into several delete() calls.
suggestion
We can omit check on PERUNADMIN role here, since any of the check will be true for such user. Check on PERUNOBSERVER stays of course.
put in two lines.
Currently this will fail because the operators throw an exception. So for now we may have to simply return an empty list and open another JIRA as a reminder, to enable retry when the operators allow it. The other option would be to have a flag like supportsRetry, that is always false for now and in the future we enable it.
As a safeguard regarding null, I suggest to replace the condition by if (Objects.equals(l.getComponentId(), component.getUuid())).
Why did we make this change?
whynot just this.ssl = sslContext != null
You can do it in a single line new ArrayList<>(types.getMixins().keySet()) which also improves memory usage.
No need for this, you've already checked that it's null. Direct == should be fine.
What should happen if d == -1? (E.g. if the suffix should be the entire basename in that case then this should set 'd = s'.)
I believe the algorithm here is "findMarker" or "findMarkerByTitle". Consider methodizing this so it's perfectly clear.
this is ok, for example group is SuperUser, so user can login even if not in database, the id should be random uuid or something similar, you already took care of that in the past.
category
I meant a . after " but the field is of type %s " since the next statement is a new sentence and starts with a capital letter. lgtm otherwise.
why container.isEncrypted() is not passed in as last arg for constructing the BlobProperties.
Cosmetic: Could you please rename this to futureNumericDate?
doing it in the constructor is fine
Why do we have a keystoreResource and a keystorePath?
not yet committed
Won't this go into an infinite loop? Presumably we want to only retry some sane amount of times.
[nit] This looks like a restatement (or slightly stronger version of) the previous line?
Please add a space after the ,
I would only execute this try if overflow is not already set. Given the way this code is currently written, I'm concerned about repeated throws in a tight loop.
BashCommands.ifExecutableElse0("apt-get", BashCommands.chainGroup(...))
this can throw IOException if I recall correctly, and should be handled properly so that deleteDirectory is cleaned up regardless.
This seems too fragile. It wouldn't be an odd thing if this took > 1 second. I think it's valid to loop for quite a long time (say 20 secs) intermittently testing for reload completion. The RuntimeException at L103 tells you the reload has progressed, so AIUI it's not relevant to this test how long it takes from there to complete.
If the config format is busted, I wonder if we should throw an IllegalStateException here.
why's stripe count is saved as String?
Maybe write a mock rule (similar to MockJoin) to simulate the Project + Aggregate split that you want to test? I had a hard time to understand why AggregateReduceFunctionsRule will trigger what expects be tested. Another benefit is this test will be stable even if when changes are made on AggregateReduceFunctionsRule.
NotebookService is usually for external call (such as websocket or rest api). Because only websocket & rest api needs callback. Here we can directly call notebook() to get Note and check permission.
As the data will be accessed through MemoryStore, we don't need to have data be a class variable; Instead, let's change it to local variable, and also the data loaded from MemoryStore (the values of workloadMap in L253)
The follow menu item should be disabled in this case since you won't know whether running it will follow or unfollow.
It isn't type safe. Are you sure that all objects are _MetadataType_?
Can simply use isEmpty.
HostMessenger has a helper function getHostGroupsFromZK(), maybe you can get it from there.
Static import
just change "" to null
How would this affect the memory footprint of each event? Also, is a soft copy okay here? I guess if soft copy is okay, then it won't be too much overhead because this would just be two more references.
you might replace this for user.isAdmin
getDate is deprecated. Is there a non-deprecated method you can call with the same result?
Try to avoid one level of indentation using (!MOOD_NODE .
To make this more bulletproof, can we wait for the file to exist and be not empty in a loop? If the file never gets created, the test would eventually time out as I described above.
Curious about why you needed to add this here and above?
could this be a log warning? the metadata is still malformed.
would probably be simpler to just to String.format(UPSTREAM_FORMAT, entry.getKey(), upstream)
Do we need this variable, given the member variable you added?
Should we just wrap all the code below(until updating fileOffsets) inside this if block? It gets rid of the scenario where changelogSSP can be null but still we try fetching offsets for it. It also gets rid of potential NPEs.
The new one is not more readable than the original. See if there is a better alternative.
why use qualified name?
You could have used Arrays.equals()
Why are you printing the frame layout? btw, it looks like this: android.widget.FrameLayout{b3fe67c V.E...... ......I. 0,0-0,0}
Empty collection should be returned instead of null
A couple of questions regarding this method: - I guess it can be called concurrently (otherwise there would not be any need for this CAS loop. Is this right? - What's the reason that we check for state == State.BLOCKED and then later do scheduled.compareAndSet(state, State.BLOCKED)? - If it's called concurrently, can it happen that: ThreadA detects that priorityWriteQueue is not empty and changes state to SCHEDULED ThreadB enters CAS loop and changes state to BLOCKED ThreadA calls owner().addTaskAndWakeup(this); In this case, I guess ThreadB will eventually call owner().addTaskAndWakeup(this); again. But the first call to addTaskAndWakeup will be with a BLOCKED pipeline. I guess this is not a problem. Can you confirm?
Does it make sense? Wouldn't it be enough to use AtomicReference ?
Shouldn't we be coalescing the left.getDoc() with right.getDoc()?
shouldn't be called left anymore
Don't concat strings in log statements, use the param support  logger.info ("I have a {} to eat.", object);
Again, findBugs doesn't like it. See above.
It's one-time. Then you handle only one response. You can detect only one server.
I think this could be a race condition between tableExists and getTableInfo. Maybe we could remove tableExists and wrap getTableInfo into a try/catch block?
Can we please mock the Future?
I don't think the intention was to change the isJavaFxInClasspath in classpath. In my world it would e kept as is. Then, if it returns true, use the LoadClass privileged action (which is used under the hood for isJavaFxInClasspath) to load JavaFXPropertyValueUnwrapper.
Maybe this can be moved to the declaration?
erm. padding ; are we?
Should null be handled here ?
Should the context also be cleaned up or doesn't it matter because it's failing anyways?
what about covering this use-case?
This can be avoided as it is a number input already.
Could we get a correct pythonJarFile for Yarn perjob/application mode here? It seems that we do not ship the $FLINK_HOME/opt directory and set the FLINK_OPT_DIR environment. Maybe it is out of the scope of this PR.
Can we have global constant for '*' ?
Use of this.getClass().getName
AdColonyAppOptions options = AdColonyMediationAdapter.getAppOptions(); if (options == null) { optiions = new AdColonyAppOptions(); }
Please do not use Java **assert** keyword. Java Assertions are disabled by default in maven-surefire. I am pretty sure that your test will pass even with assert(false). Use JUnit method assertTrue instead.
I'd either make this more symmetrical to the entry == null branch, or check for CACHE_MODE_LOCAL first.
Don't need to escape '\' in the string, though it might add readability?
For reference, string(Text.of(longFlag)).parse(source, args, context); became args.next();
Traditionally we use UnfillfilledRequrements as a signal for a configuration resource which is currently invalid but the user could make valid through some action (IE: "You need to update CommCare before proceeding"). I think "InvalidStructureException" is the more appropriate error here, which means "The config file that was requested for processing isn't created correctly, and needs to be changed before it will ever worlk.
Consider adding a separate timeout value here.
Hi @boaks , LOW: it would be nice to separate serializeHeader to a new method :) rather than duplicating it in both cases
can you replace this check with event-loop thread instead of not being the junit thread ?
Confusing variable names of target and targetName. I'd prefer webserver and webservers or some such to avoid confusion.
'() ->' won't work when backporting to 3.6
We shouldn't do both log and throw.. Let's remove logging here.
Can baseUrl be the empty string?
For this test, you don't need to set the activation key anyways, because if the user has no activation key set then whatever value is provided is definitely incorrect
Maybe switch the condition to <pre>intervals == null || (r.getReadUnmappedFlag() && r.getAlignmentStart() == SAMRecord.NO_ALIGNMENT_START)</pre>? Then the check below could be slightly simplified but the benefit would be to completely skip interval checking for unmapped reads.
put this declaration 8 lines lower
Can we use Guava style map creation?
It looks like a collection of two OGCMultiPoints will incorrectly return true.
if association is using default version, ver=null. So, this comparison is wrong. if(ver==null), then add this to deferred loads, so you can load it later.
The class is generic, would be there a way to have the contract more abstract. Somehow to remove any "gitHub" specific stuff
Continuing the ArgumentsAndResult discussion, I think here we should be robust and even don't expose arguments until the invocation.proceed() returns. Anyway there should be some hook to expect an Exception\- try...catch around invocation.proceed().
Please verify afterwards that the attribute foo = bar has not been set and please delete the Business Service afterwards.
Better moved to the if block that returns a value.
I'd add .notConvertingParticipant() here so that no update strategy text -> model is being attached.
<LINK_0> just got merged, rebase using this syntax for DomainList
What is this doing? I do not understand it.
what about using type File instead of Object you then dont need to cast multiple times later on. or maybe use a list: List<File> filesList = (List<File>) FileUtils.listFiles(destinationFolder, null, true);
This is not needed, you already set everything in the constructor above
is DELIM needed here?
The initial size of list is _2_..?
seems like if check has been made twice by mistake
Another one! Any reason you're using these over the lighter-weight ArrayList?
Throw exception from here as well.
spelling, one L: trailing
same cleanup issue here I think
rename to p or prop
Hm... two thoughts here: (a) reshape isn't always a no-copy op. Not sure, but we might end up returning a copy in some cases with this approach? (b) if we do use reshape, I'd be more comfortable with a .reshape(input.ordering(), indexes)
Correlation Id cannot be parsed or "Wrong format of the correlation ID". You should also log the actual value that the server returned, so that we can see it in the logs.
I don't think I like a branch here. This is too into the weeds for a configuration item. If you're going to log something, pick the one that works and be done.
I would add an emptySpace after file: ".. migrate file "
inline targe: partitionData[i].flush(outputBuffer);
why do we need this? can't we support specifying an implementation as the type and then detect whether it is a concrete class and construct the instance and proxy appropriately (taking all interfaces as the proxy)? feels like it's painful even suggesting that someone coming from YAML should supply both type and impl.
why final variable? :-)
hardcoding "/" may not work in windows environment. Shall we use File.seperator ?
why on <strike>Earth</strike> any planet! we will gonna have a method on Neo4jMatchers! that does index creation!
Minor, but we can break the loop as soon as we found first RENTING partition, no need to keep iteration.
break if we found it?
I'm worried this will get noisy in production, as if you have 100K items to index, you are going to see this message 100K times.
try/catch this so logging doesn't affect normal operations
Why not just make this the next statement after the for loop?
Why * 100? Wouldn't simply projects.size() and then newChild(1) below be clearer?
I see this here and on line 631. should this be pulled into a common routine? perhaps a name like loadNeededTestLibraries() how many places do we have the library name.
nit: we don't use '!' anywhere else, lets replace with a '.'
Remove magic number - should not have impact for performance as big as it was worth to provide specified number
Is there a special reason why you use String.format and not simply use parameterized logging?
@cvrebert rename this to branch
Another one would be to do #instantiation with credentials.
I think it might be better to use trace for such messages?
When partition is negative, it also encodes the number of total partitions. Can we just pass the number of total partitions in constructor so it doesn't have to be encoded in partition?
It would be even better to just return here, wouldn't it? Then you don't need the if statement on line 99 and can define the consoleAppender variable on the same line where you initialize it (currently on line 100).
I thought this method was only java 9?
can be return csv.headers().stream().anyMatch(header -> knownReference(header));
This should be a label, not part of a metric name.
Combine this with the variable declaration above. suggestion CacheEntry cb = cache.getBlockNoStats(_lookup);
shouldn't this be moved into the if() clause for maximal memory savings?
Servlet path tests are fragile: - The service could be a workspace specific one, not 100% sure to do the various wrappers, but at this point you might see "workspace/ogc" as the servlet path - The OGC services might end up being moved to another position before upgrade (not sure) - Other plugins in the future might be using json-ld (e.g., dunno, GetFeatureInfo, a WPS process) but not based on this plugin It seems safer to me, to use "WFS".equalsIgnoreCase(request.getService()) to test for WFS, along with the output format type.
As above; Consider using getClass().getSimpleName() instead of this
add log statement to else block DEBUG level
Do the same check that you did for account_id below since user_id will eventually be phased out.
invert it
I think we should disable cache for the poller. If you look at privous corfustore stream or our DCN, they both disabled cache to avoid polluting addressSpaceView cache, which could cause a lot of NoRollbackException.
Returning null causes entry removal from dataSources Map, it didn't happen before
Shouldn't you pass the called url as a parameter, so that the form can actually redirect back once the user authenticated successfully?
tritto
Few questions about this change: 1. What happens if the value is null? You probably need a null check here. 2. What happens if you get a list of Features from a GeoPackage store? Will they be converted back to Booleans? 3. Is it possible for there to be GeoPackage files written by GeoTools before this fix that contain boolean values, and does GeoTools still read these correctly? 4. Does this affect the GeoServer GeoPackage output format; does this bug show up there?
Do we want this to equals or just match?
Where is this used?
@Randgalt Can we move this to a constant now that we're no longer supporting 3.4?
Looks like you forgot a !. Should be (path -> !path.isEmpty()
ImmutableList -> List
IBM-specific without that dash?
I find it better to: * keep check in the while condition * Remove if above * remove the null check on line 300 (which is already covered by the condition in the while, and conditions are better than break.
checkNotNull
style-nit: You can chain this call: Repository git = new FileRepositoryBuilder() .setMustExist(true) .setFS(getFS()) .setGitDir(submoduleGitDir) .build(); try { head = git.resolve(Constants.HEAD); } finally { git.close(); }
Use the CommandWithArg<Boolean> variant here so that the output repopulation happens even if the package versions aren't sufficient.
minor typo in variable name here
What is the reasoning for disallowing a zero tenor? Given period doesn't disallow, we may have code (possibly tests) that make use of it
what about something like this ? logsToCompact.sort(Comparator.comparing(EntryLogMetadata::getUsage)
Formatting, please adhere to our code style guidelines, there should be a space after the if and before the curly bracket {
We'll need to redesign the toggle actions not to use the status text, since the new grid items only support a single line of text due to their reduced size.
This need to be error message. But don't log and throw. Either log or throw.
I don't think we should try to dispose this image. Just caching them would would probably be sufficient and would provide better performances for people often dealing with colors.
because then we need to fetch the user twice here and in candoaction. this is not user visible command anyway, it is only used by batch, engine.log is the interface.
This method means that whole oxauth can process only one single CIBA request per given period of time. Imagine we code Authorization Code Flow in this way. We will get 1 request per second instead of hundreds. Yes, it's stable 1 req/s but we should handle many concurrently. (Between, can you correct code formatter in your IDE to code that we already have? It would be easier to read and you will get less merging conflicts.)
remove from here an update of DB, the following method should only convert info retrieved from host
Typo "exisist"
It's a good consideration to check presence of the field, but actually it's not needed. getPropertyNode() in the node builder API doesn't mandate that the given property actually exists, it's intended to pass "fake fields", e.g. for map keys. So we shouldn't enforce this here.
I know you love streams and lambdas very much :) but... we are trying to avoid them when there is no clear benefit as there is a cost to it. In this case, I think a bunch of for loops would be more readable, especially since the return will serve as a break.
Suggestion - could rename this to mergedServiceStatusMap and the pairResult in the loop below to serviceStatusMap to follow this code better.
This can be private, right?
ditto (compare size)
validateDate also check if date is not null and if it is not in the past and it should be done before checkNumberOfPatients
You need to get the folder from Jenkins again. Otherwise this always pass.
Is this equivalent and a bit clearer: java if (anno1 != null && anno2 != null) { AnnotationMirror glb = qualifierHierarchy.greatestLowerBound(anno1, anno2); lubLowerBound.replaceAnnotation(glb); }  As anno1 and anno2 are from the same hierarchy, their glb must exist. The two ifs are confusing the logic for me.
nit: can we call this variable detectedPrimaryLanguage
hierarchy is misspelled.
If printing the stacktraces is not very useful and annoying, Adding e.getMessage() just to tell us what type of exception has happened is better?
Add "0x"?
Why not in the try block?
No space betweeen } and finally
ValueProvider interface has an isAccessible method. You should implement that interface & in isAccessible return logical and of all the components' isAccessible
removed
here also, a traditonal for loop is better
Please try to avoid using Horizontal/Vertical panels if it is at least a bit possible. They are rendered as tables and unless it is really hard to style the content using divs (FlowPanels) than we try to avoid using them.
shouldn't the store be invoked when add() is successful?
can the resulting message end up having a -1,-1 location if currentToken result in a null value?
Should we make "pig.dump.hadoopCounter" a const ?
In general, when adding to a map, please ensure that the key is not an empty string by using StringUtils.isNotBlank(...) to avoid stuff like this: json "servers" : [ { "url" : "", "description" : "", "variables" : { "" : { "description" : "" } } } ]
Looks, like we need the same test for CCSMatrix.
or can you change the test to be more patient to see an expected value? Do you know how often these values are currently being updated?
No need for the brackets here, if you want to keep them then put the close bracket after the 0.
This is a LOT of chaining...
How is this related to the subject of this PR and/or OveruseEstimator? @champtar, could I please ask you to keep PRs to a single, standalone subject? If you need to work on two dependent subjects, you can still create two PRs and state in one of them that it depends on the other and paste a link to it.
i know you've just used the same pattern as used before but could you please remove System.out and use log.warn instead? It would be great if you could also enhance the error message (by at least using e.getErrorMessage())
That condition seems redundant.
Why don't you use the Java 8 java.time.* APIs here?
Agreed on this statement. The catch could still result in an exception being thrown and unsubscribe having happened because it is a race. So we likely need a check inside the catch as well.
This entire method is redundant. What you should do is implement updarteAllInBatch(Collection<T>) in MassOperationGenericDAO in a similar fashion to updateAll(Collection<T>) and then call it from there. There's no point in having this type of method in all the DAOs.
What is this semicolon doing?
I feel like a String.format would be better used in situations like this.
Just curious, why does this method change to initial range first then full range?
@ljacomet : I forgot to update this part in my previous PR. Now, since calls to register() can be delayed we need to use completable futures to delegate the refreshing and push of the notification, in case platform does not send us the entity creation event fast. Is it possible to change to something like this:  if (managementRegistry != null) { LOGGER.trace("init({})", storeIdentifier); ServerSideServerStore serverStore = ehcacheStateService.getStore(storeIdentifier); ServerStoreBinding serverStoreBinding = new ServerStoreBinding(storeIdentifier, serverStore); CompletableFuture<?> r1 = managementRegistry.register(serverStoreBinding); ServerSideConfiguration.Pool pool = ehcacheStateService.getDedicatedResourcePool(storeIdentifier); CompletableFuture<?> r2; if (pool != null) { r2 = managementRegistry.register(new PoolBinding(storeIdentifier, pool, PoolBinding.AllocationType.DEDICATED)); } else { r2 = CompletableFuture.completedFuture(null); } CompletableFuture.allOf(r1, r2) .thenRun(() -> managementRegistry.refresh() .thenRun(() -> managementRegistry.pushServerEntityNotification(serverStoreBinding, EHCACHE_SERVER_STORE_CREATED.name()))); }
Probably should be on the data Center level, same as we do for ImportStorageDomain
don't want to define a constant for this? ^
The LockClient can be in any state when calling deregisterInterest() and LEASE_EXPIRED event can only be received in HAS_LEASE state. I see we set the state correctly in discoveryService but I think there should be validation here as well
Should this ever happen or is this an invalid state?
pull this out into common method.
I _think_ this is equivalent to writing one line at the beginning when(clientSupplier.get()).thenReturn(client).thenThrow(new ISE("bad"));. This could help us avoid having to do numberOfExecutions - 1 calls in line 98, which requires looking backwards to figure out why there's a - 1 there.
Hello @mcimbora , not sure if this code here is trying to "limit" the "delete field operation" only to fields that are generated by the data modeler? But this is something we can't do, since the data modeller must eventually edit and manage dataobjects that were eventually generated by external tools.
nit: consider simplify this: java for (boolean firstTry = true, int rawCnt = nonVolatileRawCnt();; firstTry = false, rawCnt = refCntUpdater.get(this)) { if ((rawCnt & 1) != 0) { throw new IllegalReferenceCountException(0, -decrement); } int realCnt = rawCnt >>> 1; if (decrement == realCnt) { // most likely case if (refCntUpdater.compareAndSet(this, rawCnt, 1)) { // any odd number deallocate(); return true; } } else if (decrement < realCnt) { // all changes to the raw count are 2x the "real" change if (refCntUpdater.compareAndSet(this, rawCnt, rawCnt - (decrement << 1))) { return false; } } else if (!firstTry) { throw new IllegalReferenceCountException(realCnt, -decrement); } if (!firstTry) { // this benefits throughput under high contention Thread.yield(); } rawCnt = refCntUpdater.get(this); }
These all use CREDIT, perhaps you could use a mix of values for a little greater coverage?
I don't see why you can't have an overall precision/scale, calculated using the same logic you've already written, but just as a loop instead of just with the lhs and rhs. It seems better in the case you mentioned if col1 + col2 + col3 doesn't fail if the overall result fits into the overall precision. Were not driving off a spec that says that's not ok. The alternative would be to create arithmetic expressions with only 2 children, instead of n. I just don't see an advantage to failing the expression evaluation in the case you mention. Would Oracle fail it? If Oracle and Postgres and Derby all fail in this case, then let's move to having only 2 children expressions. Otherwise, let's do the above.
Instead of a list should this be a Pair (keypair) of string, and rename the method as getUserKeyPair() ?
I think that you should pass result._source as the new role content. Or better yet, the content argument of this method, since updateRole really performs a replace.
Should we save the configuration without the repository before disposing of that repository?
I would have this function just return an array of column indexes - rather than the specifiers. Later on when we add more support we can do it there, rather than down on line 86/ with another for loop.
cant you change this to null as well?
as far as I remember there path separator used to be defined in reg constants .
Isn't there a test case missing? The original issue is about the case where the embedded list is empty? Why is it "2" btw.? Seems some parts of the original PR got lost?
You don't need to allocate a new set here: BookmarksInsertionManager copies the contents.
Indentation (consider using the Eclipse IDE to auto-format code). Also, please import java.sql.Timestamp and use here without package qualifier.
Would expect 200000 - possibly source data needs converting to microseconds?
could you make this log message specific to glue? error messages are ideally unique in each class
If siteOid is null, you should not set any values at all. Leave them as nulls
Don't allocate a new ByfeBuffer like that. Let's just use cloneBufferArray() here as well for consistency.
Might want to be smarter about this list of fields to return. We could look at the fetch hints and choose only the fields we need. Bringing back in, out, and label when we aren't going to use them might be slow.
I'm surprised that getRequestHeader does not return an optional :)
You can probably make this shorter - it's effectively string concat, right? It could probably be pulled out into a variable and reused, too.
please use assertThat from hamcrest instead
consider responding to the event with this error message as well so the user knows why they're not receiving headlines
Please precise permission required : "Delete a non-main branch of a project.<br/>" + "Requires the project administration permission"
This test should also check that the commit revision mentioned in the message is as expected.
Here you are taking default visualizer. Technically it's not good: you should first use visualizer defined on the property and if it's returning null for filter - get filter from default visualizer.
It's a good point. We realize that context is very overloaded right now and we're planning on refactoring in the future.
variants of this uri building are repeated in this class. could you centralize this logic into a shared method or member? During initialization of this class it seems we could replace set kubernetesURI as "[kubernetesURI]/api/v1/namespaces/default/pods" which would help.
if you invert this if and throw, you can save one indentation level for the rest of the method
I'm not getting this bit, unless getState somehow causes the instance to change its launch time. This should not affect anything. The change is still harmless though.
So in case of error: * We're returning to the workspace list anyways * The error message appears there? However in case of workspace save error or service panel save error, then an exception shows up in the page instead (there is no exception management there). I'd try to keep things uniform if at all possible, if the saving error can only happen under oddball conditions, getting a full page exception is fine IMHO (and uniform with the rest of the GeoServer UI). However in case a service panel fails, then an exception appears in the UI? Also, the accessDataPanel field can be null if another security subsystem is setup, so I'd at least check if it's null or not before attempting a save.
Using a for does not make any sense to me. With that code it's impossible to have several parameters, like Map<String, Integer> for example.
please use StringUtils.isBlank here to avoid NPE
Either use assert ctx.isOriginLocal() : "There's ..." or throw new IllegalStateException(...)
Why not? I did it.
What would happen if some of the ids are found and others are not, would it still work and returns the ones that were actually found or throw an exception?
why not suggestion for (allele : alleles) {
Check formatting Couldn't you use AttributeUtil for this?
Can be written as DRepresentationDescriptor.class::cast.
Do we need to worry about the in clause limit here?
I've noticed a lot of small formatting errors like this. Instead of nitpicking over each one, I think letting your IDE auto-format the classes you've created should cover most of them.
The test should check for existence of a metadata-related user-friendly message.
Same here, why do we need this?
please reverse contract change.
minor: not sure if this needs to be a function of its own
Not sure, should we try to emit onFetchResponseReceived before those return statements?
Obtain through object graph, which would eliminate the need for a null check.
This should equal the subcommand used to normally invoke this program, e.g. label create.
Root could be handled the same way as any other GraphQLContainer - then you wouldn't need instanceof here - and you could commonize the logic to determine if pageTotals was requested.
How about making the interval configurable via a system property?
Don't we need to destroy connectionFactory and template in the end of the test as well?
Use a static precompiled pattern here.
Ah... we should not add suffix to static library. But I looked at the code and found no good way to only apply linkedArtifactNameSuffix to dynamic library in CcLinkingHelper. Looks like we still have to have an additional attribute for this. They we can apply the DLL suffix based on the linkTargetType. Sorry about the back and forth.
If the attributes types are null for both, i would compare other fields of the attribute then
unSubscribe should be realized only from onDestroy on fragment
Is there a risk of there being more than one source with the requestedSourceId? Should this case be handled (e.g. log something)?
This shouldn't throw an exception - that will completely interrupt the kickall. Instead, onlinePlayer.kickPlayer(kickReason) should only be called if the player does *not* have the essentials.kickall.exempt permission.
formatting. And what is wrong with using getLoadedCube? It's shorter, and more readable.
You might also want to look at Wenhung's recent changes that were merged for chaining Futures. It could make this code a little easier to read.
must write "length" bytes, like this.buffer.writeTo(this.outputStream, 0, length); Packet max size is set in variable maxPacketSize (server option max_allowed_packet). if sending more than this size, database will close socket.
Calls to restartCommCare shouldn't be delegated through an instance (like _()) because it is a static method.
I agree.
CustomFileDownloader
Instead of setting mPrivateDnsRouteSet even if the operation failed, you should probably do: try { InetAddress inetAddress = InetAddress.getByName(addrString); if (DBG) Log.d(TAG, " adding " + addrString); if (NetworkUtils.addHostRoute(mInterfaceName, inetAddress) == 0) { mPrivateDnsRouteSet = true; } }
If by 'res' you mean 'result', why don't you just put this name directly?
This doesn't check any invariants.
nit: this is always true.
Is it normal to ask for an AuditLogger and cast it to an AuditBackend?
isn't there a static final variable somewhere that corresponds to that tolerance?
Could you not write over method params and create separate variables instead?
How/when is refresh handled?
s.o.
I've always been a fan of if (o == null || getClass() != o.getClass()) for this. Every equals implementation is ugly, but at least mine bails early if the subtypes don't line up.
Do not use printStackTrace() - use logger mechanism.
<LINK_3> will work as well
This can be done once, before calling doWith() rather than for each method.
Why not just return false here?
What does LanguageBatchInput.toString() look like?
Final (or maybe consider dumping the variable completely)
what is the difference if otherSecret is null ?
final
RPC/Core API is not consistent with opposite method sponsorMember().  sponsorMember(userId,userId) removeSponsor(memberId,userId)  @licehammer do we really want it that way ? When params are named the same (sponsored/sponsor) ?
@ThejanW what if users want to point to API hosted elsewhere than http://localhost:8764 ?
< -> <=
lets avoid the context switch and locking. either we 1. totally remove the synchronized - and go to VDSM if don't have the answer, taking into account that a mass run vm could result some redundant getIsoPrefix queries 2. go into the synchronised only as long as the cache is missed. 3. take 1 and add eager initialization when the pool has active iso in another patch I vote for 3
Again rename variables & error logs here. "owningCommunity" should be "parentCommunity"
Like above, line too long
why call getEndpointSuffix again?
update logging format.
equalsIgnoreCase
OK, I got it. Yes, it look like it's obsolete in the meantime.
I know we have been inconsistent, but usually use IllegalArgumentException on parsing as State is something that could resolve, and this won't.
There seems to be a bunch of unneccessary manual work (Decoding the WKT, creating the projection file, etc.) going on here. Can't you just copy all the test data to the temp folder?
I don't see this brickId getting used below. Can "HashSet<GeoRepSessionStatus> statusValues" be formed here itself?
ERROR->NOT_FOUND.
so , here it is expected that limits are pushed only when pushDownSort is explicitly set by the user in the request.. while in RowBasedGrouperHelper it will happen automatically if limit was non-negative and ordering columns were subset of dimensions, wouldn't this produce wrong results if user did not enable pushDown but it was automatic.... am i missing something? also, "whether limit is pushed down or not" code can be refactored into a common place and is used here and RowBasedGrouperHelper so that no disparity can happen.
can't we just do a "break" here instead of using the label?
check if null if not raising exception?
nit: EnumSet.of
Instead of using a separate e.printStackTrace(), I would add the exception to the logging statement, so it all comes together as one: suggestion log.warn("exception in finally block - this may be a follow-up exception of an exception thrown in the try block.", e);  Then, one could get rid of the line below.
I really don't like this. There has got to be a better way to resolve this issue.
What about the case when there is a single call that is active and this hangup method is called? In this case, we will call hangupForegroundResumeBackground instead of hangupForegroundResumeBackground. In fact, when a call is hung up it is usually hung up through hangup(Connection), not hangup(Call) (a little confusing).
it seems like this method never returns false.
Extract variables for targets.target(targetRange.from) and targets.target(targetRange.to - 1). You could name them firstTarget and lastTarget, for example.
- Why postSetUp isn't called from applyInlineDeployments - should we use pushInlineDeployments here ? - Use of deployContrib with a test bundle
This is just crazy :-D I thought that ++i is used only on tech interviews to confuse candidates
As you've mentioned, this changes the default behavior for all images >= 26 to force SRGB instead of leaving inPreferredColorSpace at the default null value. However, this change also means that with this API it would not be possible to set inPreferredColorSpace=null. I'm not sure if somebody would ever want to have this behavior but if we think that somebody might want this, it would be possible to just set the default ColorSpace in ImageDecodeOptions to SRGB and developers can then override it to null, which would enable the inPreferredColorSpace=null mode. Existing calls that currently pass in null / false since they don't support color spaces could be changed to also pass in SRGB to be consistent. I can't really think of a good example where this might be needed though, so this version here should be fine as well. What do you think?
What's happening here? Weren't all the dependencies already copied to HDFS?
You should be able to move iPart and jPart up in to their respective loops and avoid a bunch of extra calls.
I don't think you need to declare the variable here. Either move it to be a class variable or move it inside the if statement.
I think we should sort outside the loop since then we only have to do it once
Shall we just remove this line-218 ? Since MongoRules.isItem indicates that it only works for ITEM
It's recommended to use builder pattern for the sake of readability. i.e.  new AlertDialog.Builder(...) .setTitle(...) .setMessage(...) ... ;
Do you mean !mIsRoaming && !mForceLowBandwidthIfRoaming here instead? Since mForceLowBandwidthIfRoaming will always start out as false, right?
I guess that instead of null == deletedOnSecondary && deletedOnSecondary the it should be null == deletedOnPrimary && deletedOnSecondary, right? Or deletedOnSecondary != null && deletedOnSecondary.
There's a lot of logic in this method which will make it hard to debug in the future... why wouldn't the following below work? And have any management of currentWork, or emitting the next work in a single place, inside the drainQueue method. java @Override protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); }
I don't think we should send a message here, if the FoodLevelChangeEvent was cancelled, then we should simply not consume any hunger points. The wind staff itself did not fail, if the event was cancelled, this is most likely because that server doesn't use the hunger system...
Not necessary.
do we need logging in tests if we don't actually check the values?
Only after paragraph run ~ -> "Only after running the paragraph, we can see the new output ~"
externalize string
I think it's slightly clearer to use Utils.containsNoNull here
I'd reconsider the WithResponse calls. I thought we added this to encompass all use-cases, but I don't expect usual devs to care about the HTTP response.
please use UserTrade.Builder here
this should be computed outside of for loop just once.
We may need to remove OzoneBucket#addAcls API as it is the legacy impl based on BucketManager#SetProperty. When we switch it to use setAcls(), the existing acls are not preserved correctly. We could either rename this API to setAcls or remove it.
Pass the access token, and the use the id in the callee.
Isn't this test supposed to test the behavior of the ShardConsumer on failures when executorservice is not able to handle the submissions of runnables? Testing multithreaded behavior in unit tests is generally not recommended. Would mocking the executorservice not work in this scenario?
NIT: can we add the mount id, and maybe the mount path in this message?
probably should have renamed the variable to "idOrUuid" to make the code more readable
java8-isation [forEach][optional][flatmap]
Change to false? (Or not set it?)
@dankraw I remember that you wondered about concurrency of this task. Imo we should try to parallel this stream because when we have 500 topics and each metadata download takes 100ms (max is 500ms) then we will wait here 50 seconds which is not short amount of time in startup phase.
Please turn these into constants and reuse these constants in the rest of the test.
![BLOCKER](<LINK_0> 'Severity: BLOCKER') Close this "BufferedReader" in a "finally" clause. [![rule](<LINK_1>](<LINK_2>
can this be false? if so, should we retry this check for it to be started
We should probably make the "3" into a constant, since we are using it in multiple places.
nit: missing space between if and (
Good candidates to use builders?
What is the problem that your addressing here? Should this instead check for null _theAction, since the below _theAction.equals(txControl) check already handles the null txControl case: else if (_theAction == null) return false;
duplicate load of the file?
Maybe a LinkedHashSet to preserve order.
This formula assumes no correlation between partitioned-by columns, right?
bad variable name getVdsCertificateSubjectResult
Maybe there are other tests in that vein? The basic idea is to try to trick the planner into producing an invalid plan. I'm also curious about several levels of nested queries:  SQL select * from (select * from (select * from (select * from t)))  In this case, since we optimize from the most deeply nested up, will should be able to convert this into:  SQL select * from t;  Is that right?
This stub will be called multiple times per table as it is invoked by several methods in InjectableBehaviourObjectStore. Need to increment the count only if encounter a new table.
is there a better method to get the header without leaving an open file handle?
Can use ObjectDoublePair here and similar methods for better performance (one less object boxing).
use log.error or warn
getRefs skips dangling symrefs, so r.getObjectId() should never be null. This could error out: ObjectId id = r.getObjectId(); if (id == null) { throw new AssertionError( String.format("getRefs returned unresolved ref %s", r)); } outw.println(id.name());
isn't it exactly the same as #836?
@qqmyers I don't think we talked about this updateIdentifierStatus method. Was it simply unused?
add a partition with a later time, that doesn't get deleted.
suggestion for (final InfoItem item : relatedItems) {
@vmaletta replace 8264 by TermId.SEED_AMOUNT_G in all tests
How about logging a warning to use the new name instead of the old one?
Looking at the original implementation, it appears like operatorContext may be null (if (operatorContext != null) below). I assume this code will crash with NPE in such a case. If it turns out operatorContext is guaranteed to be non-null, can you add rquireNonNull to operatorContext?
should this go into the "mutliAspect" ? aspects that resolve to null will String to "null", is that the expected behavior?
I looked up many web pages/blogs which discuss "removing an element from HashMap while iterating over it". All of them suggest one common method i.e. using an iterator. I saw using ArrayList somewhere, but that's not a common suggestion. If the keySet() doesn't return all the keys at once to create the ArrayList at once, which it shouldn't ideally, we may be removing a key which the iterator is scanning, thus causing an exception. Since at the end we will remove all the elements, one possible solution is to close all the connections first by iterating over the Map and then call clear() on the Map. This will still require us to refactor close() method as suggested earlier.
Successfully wrote header
Just put all this part in if (action.isSetRegistrationConfiguration()) block and save repeating this condition in each method again
@lautarobock let's assign new Opt.Empty statement into an else block instead of initializing the variable here. That way we can a) declare valid as final, and b) avoid instantiating Opt.Empty if unnecessary.
final
I would prefer doing all the onPollReady() on operation arrival in OperationController and passing in the readyForPollCallback only when required (i.e. GetBlobOperation and ChunkFiller).
Why do we need to apply transactions for SELECT statements?
use joinUrl instead of confirmationUrl ?
We should probably only catch the thrown exceptions and not all Throwables here.
Should the default value of timestamp be -1, to be consistent with the KeyValue class?
i normally static import the Assert classes for improved readability, is there a reason you didn't do this here?
Same here with the TZ check
This can return null
block1.getSize() < status.getCurrentSize()  If the blocksize is changed only at the begin, I guess, these checks will have the same result as the above test. If the blocksize should be changed within the transfer, I'm not sure, when this test should fail and why.
assertEquals(excpected, actual)
ditto about exception or letting checkpoint coordinator know, that this checkpoint was declined. Otherwise, aren't we risking a situation where this checkpoint will complete, despite this operator not participating in it? Also it might be better to move this if check much higher, somewhere to the top of checkpointState method?
can we flatten this into an &&
Any reason you want to traverse thru the actions here rather than thru the Map's entrySet. That way you can also just traverse thru the actions just once, lookup the view once and move setActionPerformer to inside the loop, avoiding going thru the actions twice.
When converting cursors one should be able to convert any timeline, not just active ones
Could you use failed() here?
Shall we print something such as "Default close method is invoked! No operation is executed." That can give user some hints.
Switches?
I agree, looks like it is meant to be the child.
nitpick: You don't need the profileStr.length() here. To take substring from given index till the end, just use [String#substring(int)](<LINK_0>
check for non-null?
Generally the logic looks ok, but it's a bit complicated. If I were you, I would: 1. Use Collectors.partitioningBy to create two lists out of allDiskAndSnapshots - one with DiskImage objects and another with the rest. 2. Use Collectors.partitioningBy to create two lists out of the DiskImage objects list - active and non active disks. 3. Go over the non active ones and add them as snapshots to the appropriate disk. 4. Add all the active disks to the non DiskImage disks from section 1 and return this list. That way you can separate into more than one method and make it, IMHO, easier to understand and maintain.
Why do we need this part?
are we sure about this? what if termination is triggered during backup?
what about reading in parallel? I don't know if that would optimise things since kafka consumer already pre-fetches data, so that when calling poll the data is already available. What do you think?
This should only be set up once, in the activity. (both lines)
Suggestion: Maybe add a stored procedure or change the getAllForVm to also filter disks by storageType
...**if** one or more...
I think this method would be more readable if it checked for instanceof LockRequestForNewSegment first and then !dataSource.equals(request.getDataSource() as separate checks that return false (i.e., the cases that will never conflict), before going to the TimeChunkLockRequest and SpecificSegmentLockRequest blocks
Enclose if-else blocks within { } even for single statements
Date now = new Date() might be better name for it.
Merge if statement: if (path != null && !XmlUtils.exportXmlFile(selectionXml, path).isOK())
Mention the reason here, why catching inflation exception is necessary here.
Should we be logging here?
This should escape the column names if they contain illegal sql identifier characters.
Not the most informative debug message.
please keep as field, easier to find there (maybe just for me :wink: )
(nit) trailing whitespace [and likewise below]
Why do we throw IOException here?
The check is correct- but I think that the error message is too specific (covers just the case of templates)
You don't have to throw InternalErrorException in any of these methods :)
the checkout already nulls the inode
Not before I exhaust my command of SOQL. :)
I would inline count
case 409: exception = new IllegalStateException(exception.getMessage(), exception); break;
Should we really use such a high number? If I understand correctly, hbase's own system tables use 200, so I don't think we should go above that.
I don't think we need this here, only in UrlParamBuilder.
Is the first part of the test required? "if (!olf.RAFClosed" It sits below an assert that in order to pass must be true.
could be discover a better word but not sure.. Apart from that, why are we trying to query 10 times if we are able to get an answer from k8s api?. It is because we want to discover at least one other member to form the cluster?
Why is this second condition necessary?
throw new IllegalArgumentException("When filtering with regular expressions, " + "the path must be a directory and leverage glob syntax. Usually " + "the folder path needs to end with '/*'.");
I believe this was a class-loader hack that we needed for Kafka, it may not be necessary here.
should be f
repated, too many bases
File a good first issue?
setCommit takes a capital-B Boolean, so no need for this check, if it's null it'll just set to null.
Not only that, but I think there is something wrong further down: java subject = restRequest.getSubject(); authorization = restRequest.getAuthorizationHeader(); restRequest.setSubject(subject);  I think the setSubject can be removed
Create this file in the maven build dir "target"
This seems to be a non-trivial wasteful computation in case node.kind is neither AND nor OR
Lines 124-127 seem difficult to understand, is there any way to write it to be easily understandable? And are not to standards (always use brackets in if or else, except for the else in else if).
I think you can do an "exists" call here instead. That will avoid throwing/logging an error, which will look suspicious to a new developer. I think logging at the info level is warranted in both cases - if the Manage server exists, log a message confirming it, and if it doesn't exist, log a message stating that a Manage server will be created in group (name).
scaleIn a task is awkawrd. I think finding the min task should be implemented within scaleInManager.scaleIn
You should use entityType instead of topicName for your comparison
You mentioned "KafkaMirrorMakerConnectorTask.createKafkaConsumer(), the properties are copied over to yet another object, causing the defaults to no longer be accessible." Guess it would be helpful to extend the test to make sure config reaches all the way to its final destination? Doesn't have to be this check in, another check in would work too.
This layer only understands ILogData can you move this conversion to StreamViewSMRAdapter which actually maps ILogData to SMREntry
Indent this, so that the code checks for mUseAutoScale???Restriction ONLY if mCustomAxisMin is true, that way it uses the same mAxisMinum variable, but it two different possible ways.
Is there someone we can yank these 30 or so lines to a separate method or, even better, a separate class? Ideally, we probably want it to look something like this: java GatewayResponse<WorldpayOrderStatusResponse> response = worldpayAuthoriseHandler.authoriseWithPossibleExemption(request); if (worldpayExemptionResponseFigurerOuterer.isSoftDecline()) { // Some logging stuff here? response = worldpayAuthoriseHandler.authoriseWithoutExemption(request); } return response;
If you're already using the early return pattern, might as well use it throughout the code: if (!canAddVm(...)) { return false; }
In the getServerTemplateId() above you work with the possibility of serverTemplate being null. Here you're calling serverTemplate.getId() directly without null check - possible NPE here? The same for hashCode below..
No need to check in here since maxNumBackup value will always > 0 based on the caller logic
minor:  if (sendZeroSizedLastChunk && random.nextInt(2) % 2 == 0) { sendZeroAndWait(); }
Nit: An explicit call to super() is not needed.
This if can be removed. You already have it above.
voidPromise() is not allowed for ch.close(...). Just call ch.close().
Add Log level check, so toString only gets invoked if log level is trace. (Couple more times in this file)
Calling the hook here only creates a draft-published event when the first patch-set of a change was uploaded as draft and then gets published, so that the change status switches from DRAFT to NEW. However if a new draft patch set is uploaded for a change that is already in review and then this patch set gets published, no event is fired (since the change is not any more in DRAFT state and we do not enter the if in line 88). I believe you should also ensure that the event is fired if a draft patch set on a change in review is published.
Unless the docs explicitly say a method will never return null you should check it, or be in a try/catch that's going to handle an NPE.
I think there's a Jetty util for cleaning the exceptions floating around somewhere
Would it be better to sort by status (order: true > null > false), noteRequired (false > true) and description (A > Z)?
This change doesn't seem to reflect the description, and shouldn't be necessary, correct? Only moving the inputStream initialization is necessary?
nit: expected is first
nit: extra spaces
isAnyValueEqual
ImmutableMap.of(
Consider declaring these variables as class-scoped constants. I see them being repeatedly declared/used on other methods.
float this up above permissions methods
These logic about clear outdated state are missing in the latest PR.
![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
maybe make this bigger, just to be safe, say 25...
One question, since we do verification in topology builder, is there any validation code in later stage that could be removed?
Using names such as compressedBuf, compressed and uncompressed, instead of temp, temp2 and copyBuf would make the more readable.
else if? or switch?
A check for null is required here as expression is an optional value and can be null
this local is only scoped to the finally block. declare it within the finally block.
Haven't we lost fail-fast abilities by moving this here?
Requires a check for AbsListView now. Or remove the check altogether.
This piece of code java Profiler.INSTANCE.getApplicationStateManager().getLastState() == ApplicationState.OFFLINE  is copy-pasted everywhere (sometimes in a method, sometimes not). Can you factorize in a single method somewhere in Profiler.INSTANCE or in ApplicationStateManager? I guess what you are actually looking for is the flag ApplicationStateManager#online
Can you please add className to error message?
This code should continue to read as one-liners. It's intended as an extensibility point and should be terse. Prefer:  java modules.add(new DOM(new AndroidDOMProviderFactory()));
Try to use the better alternative assertJ.
This already happens in the AnimationTimer and should be removed. <organisation
![MAJOR](<LINK_0> 'Severity: MAJOR') Method has 7 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
There should be a dedicated test rather than replacing this one.
Not strictly part of this pull request, but let's see if this can be changed to boolean.
More weird union() usage for setting the min-max values. You should use the min-max constructor. suggestion BlockRegion region = new BlockRegion(mins.get(i), max.get(i));
Maybe just give the real type be here in the exception ? And for before method too
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
Is there a more elegant way to do this? A Callback and background thread seems super hacky.
Better message: "Hashing a column of type " + column.getType() + " is unsupported"
rename to type
Have to create it each time? Can we not just create once and then put it in place before evaluate?
When logging an exception, pass also the exception as param to the method, so that the stack trace is available in the log file.
This message is a bit off since the full Request is being used to pick a handler now.
@filfreire better use SolidList instead
suggestion LOGGER.log(Level.WARNING, "please report to the respective component", e);
Is there any way to check this without two loops? If each one has x memberships, then the loop want to go for x*x times to find it.
Why add empty string?
A space is missing
IT failed due to this, SYSCS_PERFORM_MAJOR_COMPACTION_ON_SCHEMA calls this function with tableName set to null. We could perform the validate here and move all the logic into a separate function that gets called both by SYSCS_PERFORM_MAJOR_COMPACTION_ON_TABLE and SYSCS_PERFORM_MAJOR_COMPACTION_ON_SCHEMA
How about using accessor methods instead of field access? That way, we can entirely omit any kind of proxy handling.
-->finally
@zeemanhe This IF/ELSE IF/ELSE is hard to read. Can we do something like: if (startAction == StartAction.JOIN) { } else if (startAction.doesRejoin()) { } else { ... }
I don't think we should filter the parameters, as capabilities are parameters, too. An we should keep the link to the rfc for further reference to there parameter types, if there are any.
@odockal this could be moved also in labels class
These will get overwritten on each iteration of the loop, so you'll need to use keys like "key_"+i and "value_"+i. Also, you can use it when you create the object like  Object key = Variables.register("key_"+i, Random.getObject());
- we don't use final for local variables - constants need to be defined as private static final member variables and names should be all caps with underscore separators, e.g. private static final int LOWEST_SCORE = 10; - in this case though, I think it is better to inline these values.  private static int scoreFilter(Map<Subfield, TupleDomainFilter> filters) { checkArgument(!filters.isEmpty()); if (filters.size() > 1){ // Complex type column. Complex types are expensive! return 1000; } Map.Entry<Subfield, TupleDomainFilter> filterEntry = Iterables.getOnlyElement(filters.entrySet()); if (!filterEntry.getKey().getPath().isEmpty()){ // Complex type column. Complex types are expensive! return 1000; } TupleDomainFilter filter = filterEntry.getValue(); if(filter instanceof BigintRange) { if(((BigintRange) filter).isSingleValue()){ // Integer equality. Generally cheap. return 10; } return 50; } if(filter instanceof BigintValues || filter instanceof BigintMultiRange) { return 50; } return 100; }
Not needed
EventType that we put to publishEvent method, should be constructed similar to its API counterpart: resourceType.actionType. Example: service.update. So instead of eventType.toString(), we should use objectManager.getType(resource) + "." + eventType.toString()
We've just created this, no need to clear it (probably a leftover from a previous version).
shouldn't all apply*Filter() methods be private?
Why putting this in the else? Also, this filter can never match because a field cannot be both TIME and DATE_TIME
why doesn't this also subtract the AND of the inList predicates like with OR? (relevant e.g. if you specify duplicate values)
Same here for out: use the [try-with-resources-statement](<LINK_0>
Could I recommend extracting a VIEW_TYPE_MESSAGE_OTHER_USERS maybe? :) Also a VIEW_TYPE_MESSAGE_THIS_USER and use it here (else if it), so you have an else that can throw
what is 2? make final
I get it that the JRE is optimized for small short-lived allocations. But I still don't feel absolutely at piece with allocating a new RawPacket just to pass it to a util and then leave it to the garbage collector... In my mind, having an overloaded Utils.isKeyFrame which takes byte[],int,int (in addition to the existing one which takes RawPacket) is OK. Anyway, I don't want you to do anything and I merely wanted to share what's on my mind.
rename to occurrence
suggestion for (final Node node : graph.nodes()) {
(nit) outgoingGranularitySpec will never be null because it will return incoming spec if outgoing is not set
logging
Add a log message to help debug issues.
It won't be closed on exceptional paths. Please also use Util.closeAndLogFailures() instead, because we want to report the issue in logs at least
The path is Linux specific?
this logic resides in the DiskMapper, you should be mapping new DiskImage from the disk and using unregisteredDisk as a template. by using mapper you make sure that all properties defined by user eventually get in to the unregisteredDisk that will be send to the backend.
I think we should remove this shuffling at all. CC: @sopel39
I think we are hitting the limits of genericity. Please consider extracting a class that will replace Pair<List<Statement>, List<Statement>>. This should 1) help with reading the code, maybe move a few methods directly onto this type?
Unfortunately this won't quite work - FastTESR is fast because forge has a global VertexBuffer (in TileEntityRenderBuffer). This method is only called by non-fast TESR stuffs.
Delete blank line
Rename aadJwtBearerTokenAuthenticationConverter to converter.
Are you gonna allow null for messages or not? In [L56](<LINK_1>, it assumes that messages can be null. But [L69 in ComputationCallable.java](<LINK_0>, you handle it not to pass null value. Please make them consistent.
fix this and all other places
minor-XXS: maybe rename "someBlobs" to "batchofBlobs"
please use one line per declaration as we do normally in netty
Any reason not to compare the cigars directly? Or the cigar-strings if that doesn't work?
Could be if (mergedDictionary.add(key))
please change the method name to 'initialiseCache'
typo Excpeted
Don't we at least need to call replay on the mocks? And, since we're not actually expecting any behaviour, create nice mocks instead?
These two for loops look like they can be condensed into one.
operatorId.getAndIncrement() is called twice producing different values for operatorId and sourceId; is this intentional?
Would you mind naming the variable aggregatedFieldsQueryBuilder instead of builder?
Typo...
can you make 383 a constant ?
need a comma before partitionid
Why is this the initialDispute? Shouldn't we be checking the updatedDispute?
NOT a fan of this
add explicit condition, and throw exception if not matching the current options
Could just use indexOf() and check if it returns != -1
Shouldn't this be: hasMutable |= Once we hit a row that has mutable conditions the decision cannot be cached even if that row decided to abstain for this particular permission check.
we need to add to this message that we reached the max number of retries
nit: use type inference suggestion Map<String, String> challengeMap = new HashMap<>();
Isn't this assertion redundant with the 2 previous ones?
It looks like you're overriding this just below with newDIskCacheExecutor() always? same for newSourceExecutor above.
Don't log anything at info level during query execution, there will be too many logs. debug or trace is preferred.
you can use: new HashSet<String>(Arrays.asList("eth4",  ));
AtomicBoolean.get() returns a boolean, you don't have to compare against false. Or was this done to improve readability? suggestion while (!isLifeCycleStopped.get() && !isTimeout.get()) {
Isn't it more common to put the != null condition first?
See the aQute.libg.cryptography package for classes to compute MD5, SHA1, SHA256. They provide a nice asHex method to return the digest value as a hex string.
Could you use extract constant here? why it is 64 seconds?
It's unlikely you want the toString method here, since toString is volatile and not suitable for outputting on the API. What value are you after?
get rid of this variable and use getCallback.subResource?
The same thing would happen with this empty catch block as well. Since the outer try/catch block already catches Exception, this inner try/catch block could just be removed.
This here is wrong. What it's really doing is checking whether the given string exists as a Gestalt asset. When it's anything but a ship it causes issues down the line. I know it wasn't your code, just pointing out the issue. :+1:
we should either use setReinit or remove it
we can use strigutils.isempty()
Why do you throw out exception handling here (DateTimeParseException will be thrown)? The gcviewer.imp.ParseException contains the whole text line, where the problem occurs and usually helps much in understanding, why the exception occurred.
when possible this should narrow to the most specific exception type. this goes for all caught Exceptions listed in this PR.
I assume that this should be printed with a logger not just to stdout
please add a defensive != null check (ideally inside a else if). Indeed, if binding == null, toString() will result in a NPE
Please, take care about SmartLifecycle here too:  IntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, IntegrationNamespaceUtils.AUTO_STARTUP); IntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, IntegrationNamespaceUtils.PHASE);
functionality question: is this allowed to be none? After EAR is implemented, there will still be a situation where something is not encrypted?
to be on the safe side use Guid.isNullOrEmpty()
Did you intend to leave this in?
compareRpmParts .. the s is missing
minor: may want to rename emphasizing these records for an outputstream, like recordsForEachStream or some other better name.
no need for the intermediate String object. use sb.append(buffer, offset, curIndex - offset)
We might want to ask Github support about this. Can you provide some details about the exact issue?
Why did you remove this?
LOG.debug?
can you describe this usecase?
Calling toString and throwing away the result looks odd. Presumably this is to consume the errorStream. Out of interest does findbugs warn about discarding return values?
Do we have any tests for this method?
Change this to a warning instead of error since we just log the exception.
person.getDeathdateEstimated()
Let's fix typo: caschedParams -> cachedParams
better to remove this Override since OnClickListener is an interface.
I think we should get rid of this generic catch block. The only method that might throw an unchecked exception here is extractPayload(), but it already has a generic catch block (which should probably also be converted to catching only JsonSyntaxException).
Just for readability replace with else if(Intent.ACTION_MEDIA_SCANNER_STARTED)
i18n; string to Messages
This is an odd way to pass data for initialization, cc @Major-, we need to look at setting up player "pre-init" code.
why Lists.<Object> ?
Why not unconditionally use ChecksumPolicy.IGNORE? Not a big deal, but extra remote request for SHA1/MD5 files that almost certainly will not be there and do not add much even if they are, seems pointless.
Move this line one up and we do not need to change to the main thread in case the filter does apply.
It could use a lambda, less code and indentation.
I think here you can use a method based filter, for example: .filter(JbpmKieServerExtension::isValidPersistenceKey) so it can be reused other places if needed
what about treating this use-case?
Should we trim these values?
This skips the last line of the method that seems unrelated to the drawer. My suggestion is to extract the drawer-related code to a separate method and do the null check there.
this could be null
Not to be too picky, but this is unsafe cast. Consider adding assertion to ensure that AC is an instance of ConfigurableApplicationContext. It may be safe within our whole bootstrap but it is public class after all.
Maybe write it into some log?
unnecessary empty line
I suppose you meant, different in the message ?
anyMatch might be more suitable than filter+findFirst
How can null ever be a useful value here? If the AD allows undefined, since no one ever populates RuntimeCap's dynamic optional requirements, this will just result in registering a strange requirement.
This will prolong the time the test takes in normal execution, because we rely on heartbeat timeout to detect missing member (see the assertClusterSizeEventually in line 873 below). The test failure in #15710 failed in the first assert of cluster size (line 862 - just waiting for a cluster of 3 members to be formed during test setup). If there is evidence of long hiccups in the test failure logs, then I think we can close the issue without merging any change to the test itself.
I think it might be preferable to randomly drop some requests instead of all them. e.g. find a formula that would translate the load into a % of requests to drop.
the msg string above here should say String.format("%s. Only one array field per index allowed", msg)
Collections.emptyMap() could be used here
log full exception
Create an issue to fix this hack
is it really isPlugged? Does parameter action mean, that something is plugged or rather that something should be plugged? Seems the latter to me ...
nit: for (int i = offset; i < offset + length; ++i)
Perhaps viewBot.show() before selecting the tree item would be enough? At this point it is possible that the view is not created yet (it could be a view reference for a background tab).
Can we refactor this to avoid so much code duplication in these two, very similar, conditions?
do we need this anymore ? and the method getHTTPStatusCodeFamily ?
use "%s" substitution
No, this method should not throw interrupted exceptions.
It looks like we will have to add this kind of logic for every resource type. Maybe this is something that we can ask from jason.
I must be missing something. Is that whole try/catch block even useful?
Should this be ANY_ENTITY_TOKEN?
I think using string concatenation is faster and cheaper here than using the string format.
This is a remote method call, I don't think the exception is actually fired. I expect it will be wrapped and just invoked getErrorCallback in case of error
Method name should be something like getResourceResult.
This is possible because DAnalysisSessionImpl extends DAnalysisSessionEObjectImpl, but that is actually an internal implementation detail, and it should not really be considered as a proper part of the session.
Misses the separator use elsewhere
Maybe your test can't trigger the issue because of this (which was causing the leak). Why was it dropped?
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
final
I would convert this to a warning, i.e. Logger.warn("Creating a track without sample entry");
I suppose this will not be needed when <LINK_0> is resolved.
remove finally {
Better to add a function to return properties of a cluster, as what you did for location and interface.
Is this in meters/feet? Hmm... I'm not sure what to do suggest regarding the change in precision.
We can initialize fileContents with DEFAULT_FILE_CONTENTS, and use if (configFileHelper.exists()) instead for the else case.
Throwing an IllegalArgumentException here is not really an improvement over a NullPointerException I think.
Rename to isoStats - will not have to change again
Arg may not always have a shape. We might have some place holder logic we want to put in here. At least checking for null shapes before you do this would be good.
Step Verifier should be used... I'm not sure why you don't use Mockito to mock an HttpResponse and instead.
You could skip all the lines up till setLabelStyle() if fill is null here? That way it would be more clear that setFillPattern() is not called. Though didn't check if style.setFillColor() does something with null param. optInt() returns 0 for null but since color will be null the setFillPattern() is not called. If the lines are just skipped anyone reading this code in the future wouldn't need to check what optInt() and parseColors() do for nulls to figure out what is actually set for the style here.
Is this required? When will this be true?
Why aren't you adding all planks directly instead of this weird placeholder?
consider using assertj assertThat(list.get(0)).isEqualTo(2)
this should still be done at the top of visualizeNetworks (where it was before). If there is not network, the rest of the code does not have to be executed.
you don't need that line, verifyTitleUrl is already checking that. See point1
Can you please have a look how the other getUrl*** methods handle the exception handling. I think they are allowed to simply throw them and the performSearch method then converts it to a FetcherException.
nit-pick: An empty line would be nice here or break out the "else" into a method too
I am not quite clear what is this test motivation for. When the dispatcher throws exception, it would terminate the internal thread inside ChannelStateWriteRequestExecutorImpl. And when the worker#close, it should throw exception actually, i think we should verify the exception is same with testException
I think that this is a change of behavior. To keep backward-compatibility what about referencing system tags in both tags and systemTags ?
Why was this removed ?
I would recommend exposing 10000 as a configuration, i.e max result queue size
possible NPE if default cluster is not set
Add an assertion to check the hardwre id.
I would add braces around the first else block to improve readability
Drop logging line
Recommend using a new error message instead of borrowing from sync menu.
I tried verifying this patch. But vdsUpEvent was not at all called. Looks like it will be called only when the host status is UP. But host status will not be up until glusterd service is started. I have to move this logic to ActivcateVdsCommand.
You most probably will have to create a method to get the inputStream so this method can be testable as such by creating an object instance and calling this method while providing your inputStream.
pass the exception as the second parameter to LOGGER.warn rather than printing
Is the new method needed to get default-to-false? Couldn't you just use isEnabled and change the default on the property?
.first(Audience.class) -> .getAudience()
Or ClassCastException I suppose, theoretically. Maybe just catch Exception already.
Use assertTrue instead?
@NielsCharlier is this a resource leak? Could it be fixed by a try-with-resources block?
Replace by Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size());
Maybe we should have a static Set of invalid error codes and make this line if (INVALID_CODES.conatins(errorCodeName)) {
should be InitializationType.CloudInit no?
should be Math.min
nit: use vararg constructor. A couple below as well
This adds a discouraged access warning. Maybe use public API?
Extract this timeout into a constant to be shared among the verify calls and initialization.
You set the edge quark with the given edge, then the line after, you sort of close that edge with a null value 1ns after? Most definitely not how this should work...
You can use Arrays.fill() if each element is the same and doesn't depend on the index. Also, why is the colour set first, then retrieved using getSymbolColor() ? I think this loop can be simplified a bit, I'll push an update.
When you call register() from both these place, whats happen differently between the calls. Inside the method, both these calls seem to be doing the same thing. If there is no difference, can you call register() only in the constructor of Tracker?
We can't change options that we've published, it could break something downstream.
As we are removing Map support, shall we also remove complexTypes?
Maybe we can have the getString() contains the logic of checking InvokeSource to reduce the repeated app.language().getAppLanguageLocalizedName(app.language().getAppLanguageCodes().get(1)
I think this code can be simplified by getting SSLHandler.handshakeFuture() and adding a listener to it, instead of registering an action with the ConnectionLifecycleHandler
posargs.addAll(items)
Should this be final CbclData ...?
why a long timeout on this one but not on pingWithArgumentWhileSubscribed?
Please give a better name.
Can we have the header check?
Can this NPE if groupId does not exist?
Can stringToEncode.getBytes(StandardCharsets.UTF_8) be used here? What is the point of .name()?
Why don't we wait on jobMasterLeaderElectionService.getStartFuture instead of doing busy polling?
ImmutableMap.of()
Exists
it's not a problem if it configured not to manage, so message is not need here
for the case we set system preference to disable the autobuild on .settings change, we should have second test that verifies the opposite (no changes at all if property is set)
Can you explain this? It always has been strange for me to synchronize on the local variable. But here it is more suspicious because the whole method is synchronized. As well as many other methods here which deal with the same this.pendingConfirms.get(listener)
Add .disableAutoComplete() By default autoComplete is enabled, this means this SDK will internally complete the message for you and user do not need to call messageContext.complete() . But since we want to show how user can disable this feature by calling disableAutoComplete and complete it manually (like you do in processMessage Consumer). We had this bug in readme and it was left over, since you are touching this specific part, you can fix this also. Thank You
use java.util.Objects
This is hard to read over and over. Can we add static methods on MemoryPolicy with nice semantic names? I want MemoryPolicy.shouldReadFromCache and MemoryPolicy.shouldWriteToCache (or whatever names you think fit).
Do you still need these (here and below) throws changes?
I'm actually not sure why it wasn't doing getNotebook().getNote(note id) before @jongyoul @zjffdu ?
Can't we just change the catch clause to catch TTransportException? Then we don't need to rethrow other exceptions ourselves.
We have to trigger some logs, in a case when app receiving invalid/not implemented screen_name (e.g app receive pro screen name instated of profile)
Add this into ConnectionPoolConfig constructor (line 82). connectionPoolSocketResetOnError = verifiableProperties.getBoolean("connectionpool.socket.reset.on.error", true);
This can also be nested. No need to check debug if info isn't enabled.
why does this test remove the first container? is it because container 1 has the 4 spouts being removed and if so, how did we make that the case? We should clarify since it's not clear why that's the case by reading the code.
In case of a deleted file, getNewPath returns /dev/null, which causes a garbage path. Could you add a check with getChange(), and disable it in case of DELETE?
suggestion logger.write(Instant.now().toString().getBytes(StandardCharsets.US_ASCII));
please make sure we don't run into an NPE here
I don't think this is the right place to call child interceptors. This would mean child interceptors are invoked, even when the command handler is declared on the parent entity (?). I would expect the interceptor invocation to happen in the ChildForwardingCommandMessageHandlingMember.
Is this generating a warning? There are a number of renderers in Terasology and unless strictly necessary I'd like to keep this variable as worldRenderer, for the time being.
in Utils.preAllocateFileIfNeeded(), the following code is used  if (System.getProperty("os.name").toLowerCase().startsWith("linux")) { ... }  Do you know if one is better than the other?
is there a unit test we could write to reproduce the NPE?
autoboxing? long == Long in java
change inboundRequest to qpi and make it constant.
nit: we can inline the threadId in the suppressionEmitSensor call.
we should also consider the fact that there could me more than 1 colon in the tags. To do so, let's simply do split(":", 2)
try to move these as close to where they're used. so first check if the job id exists. If so handle one way. otherwise send the error response. it's confusing that the response is initialized so high up.
why logger debug here ?
Does it mean we need this property (credentials_type) from selfservice ?
should be replaced with '==' since this field is of type 'int'
This method allocates a new empty array on each invocation if types are not enumerations. It's cheap enough, but actually it's not designed to be used if higher order is not Value.ENUM. The following code is used everywhere: Java if (t2 == Value.ENUM) { String[] enumerators = ValueEnum.getEnumeratorsForBinaryOperation(a, b); a = a.convertToEnum(enumerators); b = b.convertToEnum(enumerators); } else { a = a.conventTo(t2, -1, mode) b = b.convertTo(t2, -1, mode); }  (May be we need a specialized convertTo() with an additional argument with the second operand to use enumerators from it if type is not ENUM and target type is ENUM to avoid all these ugly patterns.)
I have not studied the issue in any detail but just looking at the code changes I don't think you need to synchronize on the whole method, maybe just on the bit that writes to the socket. In fact, if you assemble the data and do a single write I would expect OutputStream to write it out in a single go - ie I don't think you need any synchronization at all.
Hmm, not sure, but it might be good to call finish() here, otherwise I suspect it just hang with a blank screen.
Similarly, this makes me nervous (and its impact does not seem to be limited to z/OS): we expect the status file to be in EBCDIC if on z/OS, and in ASCII on any other platform. So if the JVM on z/OS fails to report its default charset as EBCDIC (why??), then we would just need to hard-code that value here.
looks like a candidate to be factored out. Should have some tests
Please add exception message.
Variable name should be similar to its type.
Should be InternalErrorException
You can use UnsetObject.instance (from oep.infra.widgets). Using a singleton instance makes it easier to test the nature of the object: if (value == UnsetObject.instance){ //Nothing selected }
Seems like we could avoid extra nesting (and make the diff smaller) by making the bailout condition return early.
You should prepend the path to the file name. Now I get a NoSuchFileException with a file containing only the file name.
These changes are fine, but, since there is an API exposed for the FeedSLA, we'll need to extend that API and add/modify corresponding methods to return process SLA misses.
Let's actually remove this part and instead come up with a proper solution to deal with the staging and cache.
I would change this slightly to, "Hawkular Metrics schema is up to date at version %s"
Although it is a PATCH, this could be true/false which avoids deriving forcePatchBackfill
Should this get logged here?
use extracted method createLegacyFile from above
Can these be set to a constant somewhere to limit the capacity for typos?
shouldn't the publication state be updated?
Can you merge these two if's?
Not obvious at all which corner cases are being tested. I'll update from what I see in the merge method. You'll have to verify though to make sure I didn't forget anything. I certainly did a good job of it since my tests found a bug in your copy method ;-)
Not needed to make the test pass.
Why to compute dpi & imageSelectorIndex in this method?
- Name the thread with ZAP- prefix to be easier to know that's a ZAP thread (e.g. ZAP-GraphQL-Parser). - The thread was not started in the importUrl, better extract a method that does this to avoid duplicating in each of them.
Small note: User quux is not used in this test and can be removed.
I think that works. If the only difference between two of these is that one code is NO_CODE but the other isn't, equals() says false but hashCode() is the same. That's OK in the contract.
Is it intentional to deal with RemoteOpMsg same as RemoveOpResultMsg? If then, shouldn't we rename the method onRemoteOpResultMsg?
Have you considered writing a simple FileFilter implementation, passing it into listFiles() here and below? That would give us one copy of the test, instead of two that must be updated together if our filtering requirements change.
I think you wanted StringBuilder here.
You can put RuntimeException.class.getName(), "VSM" directly here, no need for an intermediate variable.
Replace this with a constant
@Nullable public
I would invert this condition to say there is a metric whose aggregator list is empty i.e. java metricsQuery.getMetrics().stream().anyMatch(metric -> metric.getAggregators().isEmpty())  I think it makes intent clearer by removing a ! and the comparison
might be better to validate against a regex.
Maybe we can phrase this a bit more user-friendly "Updates are only allowed on individual records, identified by gr_id" or something like that. Referring to a select item is at least a bit of an internal detail to the user.
Instead of doing this you could pass FileFilterUtils.suffixFileFilter(".jar") at line 86
We're likely to never supporting something else here. I'd suggest to create and register 2 dedicated inner classes instead which are just implementing the required concrete code.
I would imagine that maxStringTruncateAtFirstReplacementCharacter and minStringTruncateAtFirstReplacementCharacter should also apply to ORIGINAL.
I probably am not understanding this -- is the configurable property name really getMaximumErrorReportingRetries, or is it actually something like MaximumErrorReportingRetries?
shouldn't address.length() > 108 be good enough ?
suggeset to use assertEquals()
It'll always succeed (we bail out if the hashmap doesn't contain the chunk ID a few lines above).
Is this method still used in this class? It is now duplicated.
add message
splitAggregations? createIntermediateAggregations?
doesn't okHttpClient.newBuilder inherit parent's hostnameVerifier?
suggestion SmartQuery<SQLBlob> query = oma.select(SQLBlob.class)
Unused?
Should we abort the server?
I don't think having a class for this buys you anything. I'd make them all (possibly static) methods of the enclosing class.
Its better to return a new list instead of modifying the passed values directly.
You don't need to preserve all this info. These were only around because before the health checks mixed and health and metric responsibilities which we shouldn't be doing anyway
This does not handle properly the case where you have a return in finally (and where you have not a return in the finally in fact)
You do not need to call Integer.parseInt(getUuid()) more than once in a method
![MAJOR](<LINK_1> Replace this usage of System.out or System.err by a logger. [![rule](<LINK_2>](<LINK_0>
This code block is duplicated within the test, it can be extracted to a separate method.
Same here. JsonReader is closeable so using a try-with-resources statement for closing the object is maybe a good idea.
No need for 'formItems' variable - simply call 'formBuilder.addFormItem' on each new FormItem.
This needs to use the merged new value, not the new value from the manipulator.
I would prefer we ensure that on entry we're not already JITed or so (Main.isInterpreted should be an invariant in the beginning). Nicolas, do we have any good infrastructure to do that?
CAn you also check that LogUnitServer TRIM_MARK_REQUEST gives you correct/expected trim mark address
Consider using AssertJ for these kinds of asserts, and all other asserts (but we can do that later.)
sorry, I meant: key: username@sftp://sftpHostname:sftpPort
Cleanup: Remove all **throws MiddlewareQueryException** clauses
I'd suggest to change this to  logger.debug("Unregistering service {} at {}:{} ({})", description.serviceType, instance.getInetAddress().getHostAddress(), description.servicePort, instance.getName());
I'm not sure if this is a valid case. Actually, I think request should not be called before subscribe.
suggestion String key = map.get("binarytext"); if (fulltextDescriptor.getFulltextStoredInBlob() && key != null) {
We do not need to print out the stack trace here because the exception was expected?
found -> find
I'm confused about a couple things. First, if a subscription changes while we are in the middle of a rebalance, do we need to call onJoinPrepare again? With the old semantics, we probably didn't need to because we revoked everything, but with "cooperative" rebalancing, perhaps we should? cc @guozhangwang The second thing is that it seems surprising that we raise auth errors from the "group subscription." If consumer 1 has subscribed to "A" and consumer 2 has subscribed to "B," I probably wouldn't expect to get any auth errors for topic "B" from consumer 1. So maybe we should be ignoring auth errors not part of subscription()? Not sure if that is straightforward or if there are any additional implications.
Actually I wonder why this method is needed at all. Why not just call asyncExec when we don't want to block and syncExec when we do?
I think here you can avoid the persistenceEntry variable declaration, just adding the instance on result.add since the reference is not being used on any other places.
minor formatting, no spaces between the parens and spaces between the conditional. if (fDomain == null && fWorkstation == null)
nit: Maps.immutableEntry()?
Why not represent as an actual List and use Joiner to render it to a String?
Why did you make this package-private?
Hmm, explanation is optional in the protobuf. This means the better way would be to not set the explanation at all rather than set it to the empty string.
pls remove whitespaces after opening and before closing parenthesis. We mostly follow regular [Java coding conventions](<LINK_0> (with just a few changes)
Spacing is a little off here. Two spaces after the return and extra space in front of the ImmutableSet.copyOf
Can't we have something like talendStudioVersion.compareTo("7.3.1") < 0 so that this is compatible with future versions also ?
Message should be corrected as "Batch window should have.. not Length batch....
let's get rid of these "anonymous assert" strings
There's a risk here that whether or not the Exemption Engine is enabled may change between when we record in the database and when we build the request. Can we avoid this? Perhaps we could calculate whether or not the Exemption Engine is enabled once and then pass it to WorldpayAuthoriseHandler and then down to WorldpayOrderRequestBuilder, which would respect that rather than doing its own check to see if the Exemption Engine is enabled.
Still this asserts can use assertEquals method? Please use them all places.
Is the hiddenPowerType check necessary?
(GlusterVolumeEntity)getSelectedItem() can be assigned to a local fields, so that avoid casting it again and again
The interpolated/monthly flag should be added in the convention fields. Not hard-coded here.
I think usage of String concatenation here is an issue. Could you fix it?
why duplicate this line?
Btw even if we keep the try catch, this is dead code, because fail internally throw an exception
Is it the case where we start a fresh new block2 transfer ? If yes I think we face the same kind of question than with block1, what should we do if we already have a running block2 transfer for the same resource/endpoint.
you can probably just do fileListView.getItems().addAll(file) rather than loop over the list. Also, since you have a list of files, you probably want to rename the list to files rather than the singular file
If you're going to go to the trouble of extracting and extension, I think it makes more sense to use a switch block. That, or don't bother and just do filename.endsWith(".xlsx").
That should be: java logger.error("Cannot publish topic: {}", topic, e);
What is the purpose of s_count > 3 condition? Lets not use [magic numbers](<LINK_0> in code.
warn?
Can we do this in the OperatorImpl#init?
This function always returns true?
Were we always throwing in this condition?
please switch this to new Runnable(... and revert the compile source change
that;s just a lambda expression, you should be able to go es.submit(() -> { touch(filename); return null; }
For FieldUtils there is this jira issue: <LINK_0> "FieldUtils methods leak accessible flags" with requests that the visibility of a field should be restored after the field is written. Maybe the visibility of the method should also be restored after it is invoked? What do think?
<code>password.isEmpty()</code> is an excessive check. ## WHY? If password is not <code>null</code> then client have already sent it so "Password required" is not correct message, but <i>"Password should contain at least 8 characters"</i> is! So you should not check password length twice.
You might want to have some buffer time in here, maybe up to a minute. If the token is one second away from expiring here, it's possible that it might expire by the time it is used in an API. We observed some calls taking 10 seconds from the UI, so I generously rounded up to 1 minute as a suggestion -- maybe that's too much.
In the Clean-Codian spirit, a couple of convenience methods for isRestBaseEnabled() and (especially) getPageLanguage() might improve readability here.
what if we want to add new patient identifier ?
I don't think it's necessary to log this, maybe at a debug or trace level but definitely not info
can you make this method private and the others that are only used in this file as well
Let's rename dirfrac to dirFrac, shall we? (i realize you did not introduce this variable in the first place, but it never hurts to sprinkle some code-quality-dust over areas that you visit)
Iterable is not a list, the cast is unsafe
Could this be fromString?
Can remove this from the above two lines.
It can be changed to "{}: {}" instead of wrapping to String.format(). And \n may not be needed.
I would suggest not to use conditional binding. We are usually complaining such solutions. Instead of that you can use technique that was used in Che 5 <LINK_0>
this should be the last missing piece of the puzzle to connect it all the way through. The SingularityPendingRequest is the object that will carry the envOverrides from the RunNowRequest to the pending task. In RequestResource.scheduleImmediately we create a SingularityPendingRequest from the provided SingularityRunNowRequest. That pending request will need to take in the environment overrides, so that we can later use them on this line to put them on the pending task. The RequestResource calls checkRunNowRequest on the SingularityValidator, which is what actually constructs the object actually running some checks. That is where the envOverrides will need to be put on the SingularityPendingRequest
I don't quite understand this. I thought HypercubeShuffle was supposed to send a tuple to all cells with coordinates equal to hashes of mapped attributes in the tuple, duplicated across all dimensions not mapped to attributes in the tuple? But this logic only sends a given tuple to a single cell, right?
Since getView() can be null, it's possible that getView().findViewById can throw a NullPointerException. Should we add a if (getView() != null) check?
ConversionUtils :)
You really want to return here? I think you mean continue.
Maybe not now, but I think in the future we should consider a 'receiver quality policy' to handle this: basically we'd have a policy to prefer quality or number of participants viewed. Preferring quality would mean that we go through the list of endpoints and pick the maximum quality that can fit for each one until we run out of 'room' Preferring number of participants viewed would iterate over all the endpoints and get them in their lowest quality, then iterate again to try and improve quality for each one until we ran out of room. 'Stage view' would be the first policy (maximize quality of active speaker), 'tile view' would be the second (maximize the number of participants seen).
computeIfAbsent is apparently not as performant as it could be in java 7. Could be worth manually checking if present first since we potentially do this on every request.
![MINOR](<LINK_2> 'Severity: MINOR') Reorder the modifiers to comply with the Java Language Specification. [![rule](<LINK_1>](<LINK_0>
I'd extract these two lines into a method, since it's duplicated on the tests: createJSONSerialization(JSonSerializer...adapters)
in order to make this cleaner and more robust, I would suggest to put the try/catch statement outside the if(logger.isInfoEnabled()). You can do it this way: ScriptResult res; try { res = future.get() } catch (Exception e) { logger.warn("blabla") }
Please use double, not Double. It adds overhead (boxing/unboxing). Also, no cast would be needed.
We may have some cases where the resource exist but is not loaded
If you fight for performance, maybe you want to replace this call by the String formatting
Same here. No such method defined in interface Node
I think we should strictly reject null-names right away as they will cause a rather cryptic exception message further down (I am not even sure the String expansion will work properly).
I love to use static imports, but it is up to u
Do you think it's safe to instantiate the class? In Kafka I compared the packages as String.
this is a protocol mandated string, it should be a string constant in code.
Use assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());
I think that the log message should be "because it hasn't been signed by" rather than "since it's not approved by". @mattihjelm, any thoughts?
We need to test this code with a large survey (200+) questions... I would guess that this process of deleting related data will take more than 60 secs, and therefore, we need to delete it in a _Task_.
please add getMessage. : {}:\n{}
The switch could be substituted via a static final hashmap that has been statically prefilled during classloadinig (basically implementing a lookup table) but I leave this idea up for @davivel's vote :smiley_cat:
If this is performance-sensitive, could try getItem(branchName) first optimistically.
Enclose in if (log.isDebugEnabled())
Should we move this to a config action as well?
I suggest to use monotonic time which is exposed by <LINK_0> It would make the code resilient to system clock changes.
All other methods use trace(), this one debug(). Is that done on purpose?
typo in maxrety
Very minor, but I am missing some spaces after the commas :-)
I can't see where is the index added.
please extract to ImagesHandler -> e.g. getLeafImages
this is a race.. what is the status immediately changes?
make it evident that the count is number of repos
space required
I wonder if this is the right place for the fix. Shouldn't we make sure that red/green/blue is not negative and not above 1? At least the later is already checked in lines 108-120 so you would only need to check for negative numbers.
Define a constant instead of duplicating this literal "FAVOURITES" 4 times.
appended ? you might want to rephrase this.
This variable is unnecessary now.
methodName is not used or?
What is the point in storing the previous solution recorder ?
Why does it need to be sorted two times? Please also remove the space between Order and (
Use explicit blocks even for one-liners. I was also wondering why this behavior is preferable to returning an empty list. At least for me it breaks the [Principle of Least Astonishment](<LINK_0> "we don't know what to do so we do everything" vs. "we don't know what to do so we do nothing".
nit: perhaps extract a method "replayTerm(toCyrillic)" that does all this? it could be reused in the toLatin case
I think removeAll will return an empty list rather than null. Let's add a size check here as well
This can potentially crash the app on startup, since it can fire a network call (refreshStreamConfigs) before everything else is initialized. This should probably be the last thing to be initialized in this sequence.
@erenavsarogullari - instead of forward slash - can you use Java Path class - to keep it more generic?
This may be cleaner. It also doesn't allocate a new object for each iteration of the loop:  java Iterator<?> myIter = value.iterator(); for (int index=0; myIter.hasNext(); ++index) { flatNestedMap.put(String.format("%s[%s], key, index), myIter.next()); }  Both are correct, so feel free to #ignore.
same here, fromMessage->principal would make more sense maybe
Useless because containsExactly will check it too and has probably a better error message when it fails.
If file not found exception is thrown (when file not exists, correct status), Internal Error Exception is thrown and everything fail. In this case we need to set perunNamespaces map to empty one and continue.
You can use lambda here
there is a mess here.. honestly, without deeper investigation I'm not able to come with a convincing explanation for why, but I think the same treatment you added in removeVmsFromCache should be in the last 'else' block as well (that 'stable' field confuses me, we must refactor this class..)
If the code is not necessary, let's remove it.
new append
assert return value
You should stay away from java 1.4 ideoms and use java 1.5 for each loop instead, imho.
if the connection is already made at this point, the log line should really be "_Connected_ to helios-solo watchdog at ..."
Why not:  for (String [] line: lines.subList(1, lines.size() -1)) { ... }
There are a ton of calls (and casts) to getActivity(). Probably better to just save a reference onAttach so you only have to cast once.
Perhaps change the condition to: java return cigar.getCigarElement(0).getOperator() == CigarOperator.S && (cigar.getCigarElement(0).getLength() == readLength || readLength == 0) && cigar.getCigarElement(1).getOperator() == CigarOperator.N;
Couldn't this be put inside the if (!wasAdapterNull), too?
space after decl
similar thought here about merging the catches
I've noticed that you seem to have a strange habit of explicitly doing error checks and then not handling the error properly. Here, obviously you need to return false if pfd == null, which according to the docs can happen for some unspecified reason. It's a really weird mistake for me to see come up multiple times, because the if (pfd != null) part that you added shows that you were conscious that it can be null, and yet still didn't handle that case correctly... You might want to try keeping this in mind when coding, and should explicitly watch out for it in your self-reviews.
There's a method already for this on AbstractInfinispanTest#eventually, could it be used here?
Can we put this check in the outer loop (i.e. between line 66 and 67) and only log once for each plugin that has an invalid name? for (String pluginName : pluginCapabilities.plugins()) { if (!isPluginNameSane(pluginName)) { log.warn("..."); continue; } for (Map.Entry<String, Provider<CapabilityDefinition>> entry : ... { } } Or do we need to keep it here and log every capability that is being dropped?
I think it would be good here to check that the CLabels are there. I.e: fBot.clabel("Message matches \"F\""); fBot.clabel("Timestamp matches \"2\"");
Why not orElse(Duration.seconds(5))?
Could you add an assertion that the contents of file0 are "modified file0" (for working directory)?
why toLowerCase? Can you make changes to Bean to handle for the same so that all consumers are not worried about the same?
please remove every redundant line from this test
why 1? can't it be on a different position?
'true' is the default value, no need to set it explicitly
The infinite loop that @danielb987 saw in CI goes through here. Line 1909 of TrackSegment view in getCentreSeg does a setCoordsCenter call, which goes through getBounds, which in line 574 calls getCentreSeg again. Not sure whether the underlying problem is here or in line 1909 (why is a get call _setting_ something?), but this is the new code.
In the JUnit integration we actually only check if testResult.hasException() {throw Exception}.. If the test is skipped the JUnit specific exception AssumptionViolatedException is caught from JUnit and rethrown.. We would need to update the JUnit integration as well to check for the State==skipped and recreate a AssumptionViolatedException
Is there any rational on why 2000 as the sleep time? I was thinking if it would be interesting to have a "retry strategy" for async assertions. So we could keep running the assertions until it passed **or** a certain timeout was reached. Wdyt?
I think there should be a more explicit check for the exact path to the META-INF/maven/plungin.xml, because... what will happen, if, say, there is coincidentally some other plugin.xml file...?
Should this print to the user or throw an exception. I am concerned we are printing to the user while it should be logged or throw an exception.
Rename gone wild? This isn't a Supplier.
could use writeLong(Double.doubleToLongBits(v)) to avoid code duplication
This protocol works only if cluster is in-memory and baseline-autoadjust is enabled. How it works when persistence is enabled and with/without baseline autoadjust is enabled?
I think this should be setSelected not setEnabled
See if you can exceptions instead of booleans to indicate exceptional situations.
This line could be moved inside the upper if block to save an additional log level check in the non logging case.
Get out the .count() call out in a variable so that it's clearer
I think in this else case we need to fail the promise, so that we can notify that the write completed badly.
size -> count
I think there is an equals test helper, something similar might be nice for compareTo.
At first, I didn't like that this because it replaced the whole Set - if you'd called get() first then this the set would get re-initialized when it already had keys in it. But I suppose that's not really a problem. If you don't do that then you have to check if the Set was initialized or not and if not new one up:  java if (keys == Collections.emptySet()) keys = new HashSet<>(); client.submitAsync(msg).get().all().get().forEach(r -> keys.add(r.getString())  A tad nicer because it gets rid of stream()....i dunno either way is fine i guess.
I would imagine that removeAddress and the call to PersonAddress.setPerson are technically mutually exclusive, so this should probably be an if-else clause or you should call continue after removing it. I know the ConceptSaveHandler code for descriptions has this same issue, i will fix it
Can't we mention the actual type where the No-Arg Constructor couldn't be found? That would help the developer.
Do you know the scenario where the connection is null? are you sure it's impossible in the first branch?
you should return here, and remove the unneeded boolean
Let's use java8 lambda here.
An assertion message for the fail()'s would be nice.
may be move this to a private method called setUpTest()
would be clearer if this said storageDomainFunction (it serves as a data domain, it is of type fcp)
why these verifications have been removed ?
latch
nit: we should use ConsumerConfig.DEFAULT_API_TIMEOUT_MS_CONFIG instead of a hard-coded string -- in case we ever deprecate the config we would figure out that we might want to update this log statement
You can just use bitwise operators (bitwise AND) to check for flags.
Please follow parameters order in CTOR and assignments order inside CTOR -> move below yaxisMaximum.
add a LIQUID_BREAK or keep the previous LIQUID_FLOW? Nothing is mixing here
This is nice, but running init to upgrade only helps if the expected schema version (eVer) is higher than the current schema version (sVer.versionNbr). If somebody runs an old Gerrit version against a newer test site, it's a downgrade which is simply not supported. I think we should differentiate these two cases and give dedicated error messages.
Since you already checked the sequence number prior to this line this check may not be correct and may cause StateSequenceException. Should it be replaced by this: if (sequence != ringbuffer.tailSequence() + 1)
These saved state keys should be defined as constants.
What do you think about keeping the naming of Connect instead of adding Connection? Besides just consistency, I think that the former is more accurate given that it's a verb (like read), and the timeout is the maximum time allowed as that action is being taken.
The not-ok and the ok sysout have been interchanged it seems
So real-only fragments are still being replicated?
Zlog.logException(e) can be used here.
This could be MetadataSchema.DeletesSection.decodeDeleteRow(entry.getKey().getRow()) or similar.
you're inconsistent here. I think it would be most readable if you keep currentGuid as first argument i.e. !currentGuid.equals(imageTemplate) &&
This is something that maybe doesn't make sense anymore. Here we can see that event type is coupled to the kafka topic name. But since this relation is made through a timeline now, it seems that the proper way to get this topic is through event type + cursors from the timelines.
you should also support visitMethodDeclaration
should we check if default path is not encrypted ..then only store it against NO_ENCRYPTION?
should state and country also be logged?
Not completely sure, but I think this could also be written as java states.merge(stateName, 1L, Long::sum);
Method allJobsWithEveryAnnotation has 29 lines of code (exceeds 25 allowed). Consider refactoring.
I don't think you need to return newSession each time you call a set* method.
remoteGetAll() could return a CompletableFutures.completedNull(), and then you wouldn't need the if.
unnecessary line, drop this
In theory getVisibleFor could return a SplitPackageBinding, so this would break the invariant that declaredPackages doesn't contain them. But the surrounding packageBinding.isDeclaredIn(this) ensures that this doesn't happen (assuming the bug in SPB.getVisibleFor is fixed). But to make it obvious, packageBinding.getIncarnation(this) could be used here instead, which never returns a SBP and always returns a non-null result because of surrounding if(...)
What case does this cover that wasn't covered previously?
This can be replaced with assertThatThrownBy(() -> message.doLocalPutAll(partitionedRegion, mock(InternalDistributedMember.class), 1)).isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
isNullOrEmpty
All these flags can be combined with firstBytes since we have enough room there.
nit: Stream.of(spilt)
I don't understand the purpose of this. Why would we need to create a dedicated Reportable for unmapped request ? I would prefer to make use of the Metrics object for which we are setting a dummy api-id (as we are doing for an unknown application (id = 1)). WDYT ?
The Exception is never thrown.
Don't need to cast to a float here or below
since all exceptions are handled the same way, you can use only one clause: } catch (URISyntaxException | IOException | TmfTraceException e) { throw new IllegalStateException(e); } (don't use RuntimeException directly, IllegalStateException is basically the same thing and keeps Sonar happy ;) )
let me note a pattern here, Personally I do not like cases that fall through to the default case.
I don't see getDueRequesters doing anything about the order of the requesters it receives, and I think here we want to min across all requesters. I would also add a method that just iterates and returns the minimum as an int to avoid creating a list every time.
To make SWT.NO_MOVE + SWT.TITLE style combination work on Windows as well, please add below line @2099 if((style & SWT.NO_MOVE) != 0 && msg == OS.WM_NCLBUTTONDOWN && wParam == OS.HTCAPTION) return 0;
lowerVersionHosts , lowCpuHosts and incompatibleEmulatedMachineHosts is going to have an extra "," at the end, it should be removed.
Lets just initialize new installations with the default abbreviation of CR.
I got a bit confused trying to work out exactly what SAR was :). In any case, looking at what this does, it feels like it would be simpler if Cue were to instead have the following field:  /** * The bitmap height as a fraction of the of the viewport size, or -1 if the bitmap should be * displayed at its natural height given for its specified {@link #size}. */ public final float bitmapHeight;  Then here you can do:  int height = cueBitmapHeight != -1 ? Math.round(parentWidth * cueBitmapHeight) : [what-was-here-before];
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
You removed the domain requirement type. Why?
Nit: This adds mAnimatorListener once per registered callback? We probably shouldn't assume that AnimatorSet will check for duplicated listeners. I'd move this 2 lines up, inside the null check.
Let's rename it to blobUploadConflictCount because there is a same name metric in vcrMetrics.blobUploadSkippedCount. They indicate different things.
Instead of using SelectionListener and have an empty defaultSelected method, you can use a SelectionAdapter. fImportButton.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { importAnalysis(); } });
ScheduleResolverBackedScheduleQueryExecutor means nothing to 99% of people who will read that error message
There is some point showing some inconsistency In this testEquals():  lock1 = registry1.obtain("foo"); lock2 = registry2.obtain("foo"); assertNotEquals(lock1, lock2); lock1.lock(); assertFalse(lock2.tryLock());  Since we can't lock lock2, they must be equal. I'm developing now HazelcastLockRegistry and it shows me that lock from different registries for the same key are equal :smile: .
hmm, but this parse will work only for version-zero cursors. For version one that will fail as offset is not a number.
before creating the guid we should check that the operation succeded
Please check code formatting for all classes
Simplify the method
IMO there's no need to check all filters, one is enough to filter a message. That is more useful in the UI/API to show the user which filters would apply to a message.
is it possible that the interrupt status of the thread is not cleared by this task if it wasn't blocked waiting on something. in that case same thread with interrupt status set would pick a new task ?
compiler.getCodingConvention()? In multiple places.
You could use the try-with-resources syntax here.
Is there a reason the try-with-resources was replaced a finally? Not a big deal, just seems unnecessary.
Why is this not using HDSFileReader seek/next instead?
Use LogHelper
Can this be parameterized?
Shouldn't this check and throw an error if the value is larger than [Float.MAX_VALUE](<LINK_0> or smaller than Float.MIN_VALUE?
Double negation is hard. And I wonder about what Test means in this context (if you are talking about the equality test, then it is rather confusing). Moreover, declairation of the method is on line 180 whereas its usages are on line 79 and 88. I would rename the method to isFieldInitialized.
Let's add the type to the error message.
condInvert is missing
My latest commit has changed the way compareTo is implemented for datanode. You can use replicaId.getDataNodeId().compareTo(dataNodeId.getHostName()) == 0
I guess this is to avoid a spurious empty cell at the beginning of the row, but it prevents to have empty cells in the table e.g.: |=== |one|two|three |lorem||ipsum |=== should result in an empty cell in row 2, col 2
This three lines seem to be useless. It will be added at line 230 anyway.
You can use local-variable type inference here (var)
This isn't really a JSON parse exception, is it? It sounds like the JSON is valid, just that we can't actually do anything with null.
Also, you should catch IllegalArgumentException which can be thrown by Enum.valueOf, no? Since the XML could be corrupt and we should not explode.
Avoid using execute() directly
Is a plain "else" block needed here to at least log the cases where no PaymentWorks processing is needed?
This seems too broad to me. I don't think that a spring.xml.ignore property should have an effect on whether or not .groovy bean definitions can be loaded.
I would extract a method getTranslator() since you only use context to initialize it.
String
check .isEmpty() as well?
seems well suited to factor into a map
Seriously, we don't need to warn on every write. The data loss happens when you're yanking storage/OS out from under the software -- most applications aren't expected to behave in that scenario.
please use null instead of Guid.Empty, as would happen if using AddDiskCommand with vmId=null.
Can we add some log message, in case we got className with null value?
Please add a separator.
Hmm, if you make ViewHolder a non-static class, then it could have access to all these fields directly (and shouldn't need to be passed this click handling Runnable).
This could be created once before the for loop (or moved to a constant, or just compare the types).
also ignore margin col
this looks strange: we already registered export of registry in the init and here again during reporting we can potentially register some other set of events? how is that possible?
it could be more readable to use assertEquals instead
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
I think you should catch InterruptedException and shouldn't schedule any more tasks on it.
prefer to use the constant TIME_BETWEEN_RETRIES_MS
from line 228 to line 237, you removed the conditional debug logs and add info log, not very sure this is better and necessary.
It does not look right as we do only "return acceptBit" at the end.
These lines seem duplicated this.connectFuture = null; this.handshakeFuture = null;
Why don't you use while(true)?
Use the {} placeholders
Shouldn't we use the Display.getDefault() only if we cannot obtain it from PlatformUI.getWorkbench()?
Use DateTimeUtils.dateToLong
This equals implementation should include attributes from the Command super class.
fix
Syntax is off here
Confused here, why can't we use new SortByImple(property.getName()) directly?
Isn't this.readOnly = "on".equals(transaction_read_only); enough?
need to add mtu to parcel/unparcel
why don't you simply refer to "command" in your sendCommand method? Like "sendCommand(itemName, command)?
spelling
I think there is no need to fire this event. There is only one listener to this event which is this ProjectListPopup class itself. So instead of firing and catching the event, you could immdiately here do what is done in the event handler and then remove the custom handler and event for on move pointer.
There's no need to download this to an OutputStream then convert to an InputStream. Instead you can just call executeMediaAsInputStream() to directly generate in InputStream and return that.
@inverno we can return true
this is a breaking change. Should we consider adding another one and keeping this one for use object implementations?
Should we add getChRoot here as the value for zkPath field for kafka component ?
This has confusing output when running a single test method and is not required anyhow. IDEs and Maven show which classes and methods are tested, no need to duplicate that functionality.
Please move this line to the end of this method.
This id will be the one of the vnmapper resource, instead of the id of a network resource the capability is expecting. If I am right, then the resource that will arrive to the capability will not be a network, and code will throw a CapabilityException("Resource id does not belong to a network resource."). Can we check that before merging this pull request?
Isn't it better if you also merge the the old newConfigurationMap.get(stringMapEntry.getKey()) with stringMapEntry.getValue()
rename to simple
This DateFormat object never changes. Maybe make it static final in the class scope and save a bit of performance?
Checkstyle conflict. Need braces.
Redundant
minor: don't use acronym for NFC? e.g. "The path %s is still cached as not found for repository %s."
Use a schedule executor. Instead of sleeping threads blocking and using up a thread
Either one should be enough. Actually could you change revertRpcManager() to call stopBlocking() first, and then stopBlocking() to call assertEquals(emptyList(), queuedRequests) instead of logging an error message (which doesn't even get printed on the console)?
you don't need MetricNameDto.Origin.SESSION_SCOPE_TG here
you might want to use the guava lib for this
initial commit was already created in setUp() method
cool :)
Shouldn't there be 'hosts.stream().collect(Collectors.joining(","))' instead of just 'hosts'?
@zumbrunnen You can merge getString(int) and String.format(String, Object...) by using [getString(int, Object...)](<LINK_0>, java.lang.Object...%29).
ByteArrayInputStream certificate is accessed after it is closed. Better to use try whit resources to ensure that this is not required.
on the value that equals the current *default* we can (and I think should) remove the repo specific key/value completely from the prefs via unsetProjectSpecificFirstParentPreference
update log to mention ${project.artifactId}-${project.version} or just "Tokens are not replaced".
toLowerCase(Locale.ENGLISH)
Style: no brackets around single lines
Initialization with an empty string is not necessary. The consuming code should gracefully handle the unset preference.
One other thing I thought of: we should factor these strings out into variables like CQUERY_ID and CLANGD_ID, and reuse them in CPPLanguageServerPreferencePage
When running it from Eclipse I noticed that job.getThread() can return null. You should a null check for that.
Why are you removing this check? This can cause issues with how we read packet id's.
Please move this piece of code before switch-case block, you can refer to the style in OracleSqlDialect.
suggestion throw new IllegalArgumentException("JAR does not look like a plugin, there is no Short-Name manifest attribute");
This is a recursive call .. which is a little scary in a constructor. If somebody tries to copy a node which is a descendent of itself in any way, we are headed for a stack overflow. If we want safety from this possibility, we could do a cycle dependency check/detection ... searching if any descendant paths comes back to the current object, and if so, refusing to copy children or using a special value which represents a logical failure. Another issue here is that every node in the cache will have multiple copies --- one for itself, plus one for every ancestor node. With a maximum tree depth of 10 the most we will have is 10 times as much memory usage as necessary. (or maybe this constructor function is only used for return values passed out of services? (rather than the cache initialization code) If that is the case, maybe this function should not be a constructor but a "cloneTumorTypeValue()" function. The constructor could do the shallow copy (re-using the children). Since we have an addChild member function, I would suggest doing the cycle detection for deep cloning. (This could be done in future PR).
can we catch something a little more descriptive like IllegalArgumentException
I think no need to add filter here, since the tRedshiftConnection component handle the db connection, rather than the tRedshiftInput component.
Okay what is this logic trying to do? Is there a bug report? There is a bunch of color converters that cover these cases, would be good to avoid duplication. Okay updated the description with details from #1648
minor but the array is not necessary here.
do you want all Throwables or this is wide enough.
So I just did a little bit of hunting around on Stack Overflow because I was surprised at how much work it took just to customize the icon, and found this suggestion: <LINK_0> (just read the "UPDATE" line at the top, not the rest of the post). I just confirmed locally that his/her suggestion works; do you have any opposition to switching to that?
I think you do not need to explicitly call the toString method.
Why Hashtable over HashMap?
It should be child.add(...).
Does carrier want to hide *all* APN fields, or just user and password? If it's just user and password, then make a change in DataProfile to just obscure those fields. Many of the other fields are still very useful for debugging, even on user builds.
For your information,  if (!blockToSubKeyRangesMap.containsKey(blockId)) { blockToSubKeyRangesMap.put(blockId, new LinkedList<>()); }  can be written equivalently as:  blockToSubKeyRangesMap.putIfAbsent(blockId, new LinkedList<>());  But either way is okay to me.
suggestion log.error("Public key is not RSA");
I expected this code to be moved to start(). Now it is in duplicate
In IntelliJ I usually just write fail( and hit ALT + ENTER to apply static import, IntellIJ applies it for whole file then
Are you guys really using inheritance everywhere? You *really* want to subclass all of these? Why not just pass in functionals that can create the plan? Then your SessionFactory (I assume you already subclass SessionFactory, Session, etc) can simply pass in a different one. I mean, feel free to keep subclassing everything, but personally I'd be trying to minimize what I need to subclass
This message looks misleading. Will tags be considered at this point as well?
Does this also swallow InterruptedException?
Should we only add filters which are defaultSelected? Then you may have to build a temporary list with the filters to be added...
Extract this check to the StorageDomainValidator and replace the call here and in UpdateStorageDomainCommand with it
Maybe we should hold a reference to the listener and limit the requests to one at a time. Pressing it twice in succession can lead to contradictory toast messages. I'm assuming the same could happen on a slow connection.
can you call ts "taskStateData" ?
this seems like a bad idea. better list exceptions explicitly
- It should be initialised with the value from the ScannerParam. - The undoable edits should be discarded after setting the value.
do not remove curly braces around the else
Is this not the same as to say: if (!user.isIdentifiedUser()) { throw new AuthException("Authentication required"); } ? And else branch is never hit?
suggestion Utils.closeQuietly(retryWithToleranceOperator, "retry operator");
Use AppUtils <LINK_0>
This looks like a copy of setIncludedPaths, just with different types. Change the argument type of setIncludedPaths to Set<? extends IResource> and remove this.
Ah, I see. Edit: Actually, upon closer inspection, it appears that I had got the order mixed up. Looks like all things are accounted for. That was my mistake.
What's the unit for these numbers?
I think it may be worth factoring parts of this out. The 403 credentials_expired checks are very specific to Cloudant I think and it is probably not worth doing all the JSON extraction etc for 403 in IAM cases. As there is still a decent amount of common functionality that makes it frustrating to override an entire checkResponse method we can probably break this out into something like getRenewalStatusCodes (which can default to 401) and performAdditionalChecks() which can default to a no-op or whatever fits.
Better to use List instead of ArrayList  java public List<RemoteXBeeDevice> getDevices() {
Should be a MojoFailureException because this is a configuration error. MojoExecutionException should only be used for internal errors.
NOT_FOUND again.
spell out eocd
I assume the whole formula can be extracted into a separate method, for example: java private static long getPerformanceDiff(long expectedMs, Runnable m) { return abs(expectedMs - getBenchmark(m)); }
spelling
These can be changed to RegionVersionVector<?> to prevent "rawtypes" warnings.
this is dangerous  given the example: java public class Outer { private static final int FOO = Inner.BAR; public static class Inner { private static final int BAR = new Random().nextInt(); } }  As Inner.BAR hasn't been resolved yet, it will default to saying it's a constant, which it's not. A first step could be: if it's a literal say it's constant, otherwise say it's not. We will have some false positives, but they will still be far less than we have now. I'd rather have the false positives than the false negative. And we can probably improve upon that with symbol table on a second PR.
consider a helper method that replaces Objects.equals().
I'd extract this code into a separate method: private void syncRefreshRate() { Configurator conf = (Configurator) TypeResolver.getInstance().resolve(Configurator.class); conf.updateRefreshRate(); int interval = conf.getPollingTimerInterval(); if (interval != normalInterval) { setRefreshRate(interval); } }
Is 5000ms as headroom for job scheduling enough? Should we make this configurable somehow?
@bhhari What was the problem? Was it that getReadPositions returned junk? If so, shouldn't if branch also populate outputPositions? Also, outputPositions = positions needs to be followed by outputPositionsReadOnly = true;
why is this line still necessary?
I don't think we need to initialize this here right? We can do that in the only method that uses it.
This can be changed now with the ActiveMQHeaders settters.
Random aside.. shouldn't this sample be in.. samples? I'm a bit confused.
Don't you want to test that PredefinedScopeConfigurationImpl#initializeLocales() works correctly?
Is this correct? Shouldn't this be "%s/plugins/%s"
Can simply check that the normal interface to implementation class is registered already.
Not convinced we should just synchronize on this map, without knowing anything about it. That feels dangerous and ad hoc. We can presumably rely on the map's put method to be synchronized if the map really needs to be synchronized. What do we expect this map (returned by target.get(this)) to be?
Partially correct. Also move the instantiation of the array outside the evaluate. You can used pointables.clear() inside evaluate.
Why pass in the executor as a parameter when we have access to the field?
@CustomBrutauthRules({ModeratorOnlyRule.class})
that is the easy fix, the better fix would be to check if carried by raildroid or by player..
invert
style nit: we don't use braces around single line blocks
this is duplicate code and should be extracted into a method.
asserting default values does not make sense. If Eclipse decide to change it later, it will fail on this place but it is not a bug in our code, only tests are not robust enough. Instead of it, I would obtain default values and try to change them to a different one and assert that change has been done.
perhaps bit nicer with assertThatThrownBy
I dont know about this but we use I'd say in all of the tests the Assert.assert ... so you better change your Idea settings or redo the whole test style so it goes only one way.
You may want to add spaces around "=="
Is this operation being removed the correct thing to do?
You can drop the ***.
perhaps add a "bytes/second" metric here indicating how fast we work through the file. That also gives us an idea of how much slower than the raw "read a file" speed offered by the underlying filesystem we're at. all of these are still 'wall time' and don't tell us just how much of the CPU we might have used to do the processing. I'm interested in that, but do not know best how to measure it at this point, especially with extractors and codecs doing a bunch of their work in a separate process. Put that on the list of things to look at later.
probably a NPE exception is thrown here.
Minor: seems like we can return right away when pools/poolIds is empty
how did you pick which of these parameters are passed to the constructor, and which to the method? stuff like helper, downloader and controller seem more like constructor injected parameters, while folderName and listeners sound more suited as method parameters to me.
Can do touch %s %s %s %s as a single command.
This needs to be improved. If somebody has this and then opens the workspace with an Eclipse that has an older Egit version, he'll get an InvalidObjectIdException. Add the new caret position at the end. Then old Egit can read state saved by new EGit (it'll simply ignore the caret position).
Nit: It would make sense to check that queries.size() == classes.size()
Just make the test throws Exception
We should add support (and have it on by default) for ensuring the value is not null. For example, right now if the ClientRegistration is not found it returns null. This means consumers need to perform null checks on the arguments passed into their controller.
Might as well do %s and Column.TIME_COLUMN_NAME here since you went to the trouble of doing it in the if check.
fragment.getContext()
I think the null check that was at L1015 before may be necessary. Unlike the Resource tree, we don't do a copy-on-write/publish-on-commit deal when an op changes the MRR tree (yet). So a read op that calls this can have an MRR disappear underneath it.
I'd just move this to before the for-loop begins.
Maybe I'm missing something, but I'm not fully sure we need this here since we unregister the dispatcher in onPause, does it make sense? wdyt?
ObjectUtils.toString() will return an empty string if obj is null. Is this really what you want to do?
b == null
Why was this necessary? The only thing that changed is the addition of the label image, does that screw up the layout?
We might want to prefix the message with something like this, incase you're catching an error that doesn't have a nice message.  "Topology {0} submitted successfully", topology.getName()
You don't need .toMap() here. keySet() is a method on DBObject
Some of engine-config values are quite large, wouldn't it be better to show difference on multiple lines? Something like: Option name: SOME_OPTION Current value: 'A value set by user' Default value: 'Default value of the option'
can we check whether prevStatus!=Unassigned here and declare the dynamicFromDb field inside the else block instead?
It is usually better to pass the exception as an argument to the logger so the stack trace gets logged too
Does doing synchronized (this) in inner class will not stop its outer class. So I think this is wrong.
I think you can use RedDeer implementation of this dialog: <LINK_0> WDYT?
please statically import assertThat and hasItems
This isn't a complete fix as the Binary value may contain a subsequence of some other array value possibly a slice from another buffer owned by someone else so you need to copy this if the Binary has an array offset or relative length value that doesn't match the underlying array otherwise you end up with a value on the other side that doesn't match the original scoped array contents.
extractData()
If you select the options "Gear" icon on a menu the audio upload widget should be right there: ![screen shot 2017-09-06 at 3 13 35 pm](<LINK_0>
I am not sure if we need the isNoteReadyToBeSaved logic here. Since we are in the createReasonNote function, and it looks like populateIdentifierOnNoteAndExtension takes care of the condition that caused the root problem of this Jira. When would we not want to save the note here?
I'd just do if (tasksQueued.add(localPath))
Could you please extract these capabilities change (except Rewind and FF) into a separate commit? Or even remove from this PR.
@original-brownbear can't we use pure java 7 feature java.nio.file.Files.write()?
I guess that is supposed to compensate the removal of the code that resided in validateBootSequence? that is not equal, if the user set the boot sequence as DC (disk and then cd-rom) and the iso domain is null, run vm used to succeed before and now we'll fail - did you intend to change this behavior?
Handlers shouldn't know about specific writers - we shouldn't blind cast here.
No point using a StreamRawData and writing to a temporary file as well. Perhaps leave it as FileRawData for the moment.
nit why CLog.e?
Do we want to keep this log?
minor: "client termination"? ("terminate" sounds a bit odd as a noun).
I guess keeping this line same as the previous one if (settings.getRequestedCameraId() == Camera.CameraInfo.CAMERA_FACING_BACK)  would be more appropriate although it would be functionally the same thing.
agentBuidler -> agentBuilder
Are you sure that error message should contain \n?
@inverno How about extracting the body of this lambda into a separate method? This method findRootBranchingBlocks would be more readable and more homogeneous.
Needs defaults
Maybe Throwable?
Most (if not all) enumerable operators include a static factory method which takes into account deducing collation and distribution. Shouldn't we include one?
Use a StringBuffer, Guava or write a custom utility method that does String Join
I'd also rename the variable to linesOfText.
Is the getFileSystem call thread safe ? Previously this was in a synchronized block, now it is out of the synchronization block
Can we get this map from options object using getImpersonationServiceAccounts() method instead?
indexArtifact and BlackboardException are depreicated
Why are you saving existing classLoader? I think you can remove it
Need Outcome.Untap like code below?
!isempty if list
please use a constant (static final)
Looks like this run on an already altered db. We could put it in the previous state and run the upgrade task to actually test it did the modification.
I think these check is good candidate for canDoaction error message
This is playing dirty. We shouldn't dig around in the DOM looking for the first child of anything. Please rework this using GWT widgets or more direct references to elements based on UiBinder annotations.
Should we describe that these messages are also autocompleted?
Is it really the delete method you want to invoke here?
I think having a single code path might be better here, i.e. have only the fallback? Otherwise could be surprised by different behaviour in some edge cases.
java ItemStack s = ItemHandlerHelper.copyStackWithSize(stack, maxStackSize);
We don't need to explicitly create the system here. Just do it behind the scene if needed.
suggestion fields.add(new Field(this, path, outputsIterator.next()));  The relation of a Field must point to the relation who owns the field, which in this case here is the AnalyzedInsertStatement.
no clue why
for loop?
keep in mind that the transaction is doing closeAndCommit but it must be just commit, you might be closing twice
Bit of a nitpick, but could we also log an error so that the exception is not completely silent when JMXFetch's stderr is not redirected to a log? Something like LOGGER.error("Unable to compute common bean scope, querying all beans as a fallback")
I don't think that this loop is doing anything, you're just starting the producerTemplate over and over without sending any messages. Change this test to use a timer or something so that you can invoke the HTTP route multiple times.
You can use following instead: List<Attribute> attrs = this.getAttributes(sess, resource, group); You don't need to addAll to existing collection and clear it up right away - it's confusing.
Instead of having multiple exit points from this method (the two returns), create an empty 'results' before the if, set it in the if, and then return it after.
Do we need deleteSmsOnRuim and deleteSmsOnSim maybe we could pass a parameter instead.
we are usually using StringUtils from apache.commons, this class is already imported here so I think you should use this
This availableLocation should be refactored to its own method, as the same lines are used in several places.
Please move this clearProperty call to @After to guarantee cleanup even if the test fails.
Should be IllegalArgumentException too
so we are trying ten time and logging an error for each time. Than when done we return null if we failed! I think we should improve this.
Redundant String.format()
As mentioned before, we could also have in general a handler function that takes the action to perform and that always logs at the end, instead of having to call each time logWithContext.
How about this.systemUserList = Arrays.asList(accessControlSecurityConfiguration.getSystemUserAttributeValue().split(",")); and not initializing it at the top instead of creating a temporary list just to add it to another
What's the point of this change?
!isEmpty
If you are going to use message with pattern and {} placeholder and parameters after comma, let's use it for each logging
I would use "get" directly without checking with "containsKey", there is no reason generate hashCode twice and search in the map. Then you can check "if null" and return empty list ...... But this is matter of style.
All IS_NULL_OVERHEAD multiplications seems to deserve a separate commit
outputDirectoryPath is already a String
why not directly int i = 0?
Should we also allow overriding to false? Making this:  java if (enableStackTrace != null)  The same thing applies to enableTrace, but that one seems less straightforward. Does it make sense to have enableTrace=true on a parent span and enableTrace=false on a child span?
For instance.. there' s nothing the client CLI can do with a inVM acceptor. that's only valid for embedded cases, which is definitely not the case for the CLI.
duplicate code, could use a method
assertTrue(queues.isEmpty(), "Expecting empty queues but was %s", queues)?
Looks like a great way to validate the onRemove event (tricky to do otherwise).
Assigning actualArray to expected as well
With any messages going to the logger where you need to drop a variable, use the replacement syntax. This will save us some unnecessary string concatenation in the cases where the message won't be output.  log.debug("Processing {} as a containing object node.", this.fieldName);  Note that I won't be calling this out every place, so give your branch a once-over to try to catch all of these.
Why don't we keep termination here? Since we wait for the safe state, the cluster should have already been balanced before the next instance's termination.
Ewald @ewaldgrusk, update is a better way to update one cell of a matrix. And now it should work fine. Could you please change all the get/set pairw with update like this:  java copy.update(k, j, Matrices.asDivFunction(d));
The change here causes a regression in legacy switch type clusters. I those clusters the default profile should be one of the management network profiles.
is the test function really available on windows platforms?
If you're supplying a filename then the disposition should be attachment I think.
why cast twice to JSONArray?
What happens in this scenario, where maxLength = 100 but strLen is set to 110? My question is are these two mutually exclusive? Also what happens if equals is set too?
I think append("/") has no effect here. project.getLocation().append(selectedRepo) should work.
Did you forget to use interactive param? Otherwise it seems like YAGNI.
change
nit: unnecessary optimization, else's code would cover that
Just noticed this one. Please unwrap it.
nit: perhaps, inline this variable
Please use a proper formatting for this if condition.
With only one argument, Collections.singletonList(entity) is more efficient.
please also check the exception message!
please avoid the usage of raw types. From the looks of this code it seems that 'provider' will always be of type Provider<VmwareVmProviderProperties> (maybe also the 'providers' field?) In case this cannot be guaranteed, use Provider<?> to make this explicit.
try/catch
In light of the following policy, please revert this change. ---- Please refrain from modifying classes under org.springframework.asm, org.springframework.cglib, and org.springframework.objenesis. Those include repackaged forks of the third-party libraries ASM, CGLIB, and Objenesis. Any refactoring to those classes should take place upstream in the originating repository. The Spring Framework will then pick up the changes when syncing with official updates of the forked third-party libraries.
@Vojtech, Would doing an @UiHandler make sense here??
Add a log when there's a malformed url. It helps in debugging issues.
Why we are retrieving jobs from DB here ? Why not same transaction ?
At this point, it's not clear if all bytes from src have been read. So, it might be useful to loop through the writes to sslEngine until flush() can't write all bytes to sockets and then return. This can potentially avoid the caller from re-populating the same bytes from fileChannel again.
might want to rename this to "getCRSExtent()"
Should you also call addToBackStack() here?
nit: can we use CacheKeyBuilder here?
Add  @SuppressWarnings("unused") // Used by jelly @Restricted(DoNotUse.class) // Used by jelly
nit, I believe the latest style file has changed exception throws to non-wrapping. Please update your local style configuration.
Put it on a separate line with a message like "getPartitionStatistics() returned null".
Looking at the code below line 289, I think this should be if (!TextUtils.isEmpty(customOtpApiUrl))?
Null check.
Please move this to the isLoginValid method instead of removing it
Not sure I'm following what you're doing here. Can you elaborate?
Why are changes in this class included in this PR? They seem unrelated.
create an intent to move on course dates.
Use FileUtils.mkdirs
i guess you should update this field always (even if secure is false)
This is not the same semantics as the original handling of null pathParameterValues with provided a default path if one wasn't specified. As a matter of style, I don't like this approach. The code is converting a null to an empty value with no reasoning other than to prevent a null pointer exception further down the stack. If a null pathParameterValues is valid coming into resolvePathParameters, then it should be valid all the way down to where it is actually used, and not require this conversion from null to empty value in the middle.
Give a Duration timeout argument to blockUntilEnded just in case something goes wrong.
good catchm this is not a "path". I wonder if we can somehow preserve the "message" I see that KeeperException has a bad way of dealing with the "exception message". Maybe we should clean up it. Is is so bad to keep errMsg here ? and clean up this stuff in a separate commit ?
I think the else block needs to be one level out.
fyi, there is a convenience constructor for VoltTable that takes a variable number (one or more) ColumnInfo arguments instead of an explicit array. It makes these kinds of changes a little easier.
Did you consider using paging for that?
This should probably be info at this point?
Would you please factor the common logic to assertBigDecimalLiteral(String inputText, String expectedOutputText)? That would make test much more readable (it won't include repeated builder.makeExactLiteral...), and the failure message would be much easier to understand. Thanks.
Why the change? Standard syntax would be <player> for required values. Typically [player] indicates optional values.
remove "this."
Would be more readable to call the variable readyPingMsec too
boolean isTheFirstPage = startPage * pageLimit == 0
Why don't we just pass in fileSystemContext, transactionId, etc into DeltaShardRewriter? Having these two functions is really hard to understand from the interface.
Consider injecting the discoverClient into the method
m -> messageMonitor? u -> unitOfWork?
For quay.io and DockerHub I'd like to see a test where 1) A tool has tags with existing records for checksums 2) We do a refresh, but quay.io/DockerHub are slow and/or non-responsive 3) Verify that we just keep the existing checksums
this is 'quark', then you don't need the try-catch.
getLocalService -> getService
'null' must be first operande
suggestion throw new TableException("Pandas UDAF and non-Pandas UDAF cannot be used together.");
why not do adbHostValue.len() > 0?
Imagine we catched an InterruptedException and reached this line. The we still would return true. Is that correct? Shouldn't we return false here?
Nit: Remove debug logging
Actually, the last else is unnecessary, and the last condition i == 100 can be the else clause, because if i < 100 and i > 100 are both violated, it must be i == 100.
Since len isn't used outside of this for loop, you can put it in the initialization. for (int i = 0, len = params.length; i < len; i++) {}
in case of holes, Tx stream's tail will not be above the stream tail, right? It will be the other way round
You could replace this line with hasSenderAnnotation=false. Then you can extract Line 90 to 102 to a method hasSenderAnnotation Inside this method the hasSenderAnnotation can be replaced with return statements. Then this should be good to go
We can always use CreateSnapshot, just change it to accept the InitialSize.
The old code also opens websites, which leads to problems with this new code. I think a isLink check at the appropiate place suffices.
s/Sharable/Shareable
should be: java helper.waitForRegistrationAtServerSide(1);
This seems to be redundant - if we reach this point, the lease has been created already, right? so we should not issue another call to add the lease
It could be List.of (master only).
getParamNames and getArgs is only called once. Maybe we can refactor this to a getParamArguments method
shall we make '_' a constant? I suppose 'HYPHEN' can be used for that? That way, if we change the replacement character one day, we'll just need to change it in one place.
suggestion if ((qualityMod > 0) && (null != tech) && tech.getOptions().booleanOption(PersonnelOptions.TECH_FIXER)) {
Consider breaking the lambda into a helper function.
Updating physics flows water. So this would be a duplicate action.
random could be a member variable of this class instead of constructed in various methods
Wouldn't return null instead of this exception enough for the method contract? As you see in the NioFileLocker, you just suppress such an exception any way. So, let's make a return null; here, add a @Nullable for method return and so on!
Accessing preferences directly from the parser code is not allowed since IBM uses this code in a headless environment that doesn't support Eclipse preferences. You can propagate additional preferences by adding them to ExtendedScannerInfo class similar to how it was done for include export patterns (see getIncludeExportPatterns and setIncludeExportPatterns methods).
Please use parenthesis for for statements.
Whitespace
Could add a check here that ImageName.getRegistry() returns indeed docker.jolokia.org ? (i doubt that)
Please review after our conversation
No null check for zone here?
final Boolean disallowDoctypeDecl = JSFResourceDefinition.DISALLOW_DOCTYPE_DECL.resolveModelAttribute(context, model).asBooleanOrNull();
log?
This types is used only to count them ? And then writeObject + convertToLegacy again? surely a mistake
See above - refactor!
expected value comes first so assertEquals(4096, connection.getChunkLength());
Whitespace formatting - could you please remove this extra line?
This should be a Log entry.
@fanifieiev It's more it to check if two Requests are equals, right?
Problematic... should first check if the service is a WFS or a features API, that the request is a GetFeature or its equivalent in features API, and that the chosen output format is the JSON-LD one. I'd check the request object (mind it will be different for the WFS and OGC Features API case).
Unused arg
Not sure we should use any public IP even for mock data. Replace with private network IP please
Please have test for null value of targetId.
Is there an enum of the existing valid Disk types?
Maybe have a for() loop that iterates over a number of iterations and waits e.g. 10ms per loop so that the total time bounded by this test is say, 1s? That way, if it never passes it doesn't hang for ever. for(int i=0;i++;i<100 && !threadFinished.get()) { Thread.sleep(10); }
According the method name, shouldn't be the error message more like: "No path of modelName with modelNamespace found" Maybe also it is more about illegal argument or illegal state than about unsupported operation?
@pynicolas why there is no test for truthiness?
@hustodemon : please update. Here is still the '+' sign missing. Correct would be:  kopts = kopts + " self_update=0 pt.options=+self_update";
The key is offlineTableName instead of rawTableName. Also, no need to do check and remove here, directly remove should be good enough suggestion _tableUpdaterLockMap.remove(offlineTableName);
try to keep the case consistent with every other endpoint, let's use camelCase suggestion species, assembly, response)).toUri().toString(), "coreVariant");
I don't really understand your calculation here, can you elaborate? BTW, I think some simple function like  long rtt = 1000 / request.get() - hostSleepTime; hostSleepTime -= rrt  might just do
Does getJenkinsHome() always return a valid jenkinsHome here? Just asking, to make sure it does; you know best.
Shouldn't it be "decryption OF security keys..."?
need to verify that 'getSanStorageModelBase' is not null, as we set it only for block domains
This logic appears to be duplicated three times, any chance this could be abstracted? Possibly a method that takes Flux<ByteBuffer> and returns Mono<Tuple2<ContentType, Flux<ByteBuffer>>.
is riding?
For undeploy, Do we need to retrieve any info
We should use the string variant of function for simplicity: suggestion .value("user", function("fromJson", literal(alice, USER_CODEC)))  The examples already do for everything else (table name, bind marker, etc).
shouldn't log and skip. Just let the exception propagate, it should be handled by mapreduce.
I think I agree with you do not shift the this.sendToPipe(rawBuffer); to new Thread, because we block the current Thread with latch.await(this.pipeTimeout , TimeUnit.MILLISECONDS) just after submition anyway.
same as above, An explanation for some exception will be useful
add message "renewer in " + ids
@raphaelln minor: usually we use Matchers.is
Why "next"?
Also reject query for field name **id** which is a reserved keyword for all id fields.
indices, not indeces
Please implement toString() to provide debugging state information for debugging purposes.
can be removed as expectAssertionError already checks that
methinks this should be false not true
We miss an assertion that the retrieved node name is "replacement"
you can remove the leavingServers variable and pass null here. Same in the other test
Why change the default SQL type for DateTime items in this PR?
ohh interesting. is it not mandatory in the swagger? or what changed? a regression?
Whats the urlclasspath definition for file archive? In the past we had .zip accepted. Years ago but would check against the urlclassloader.
It looks like this is impossible, based on the implementation. If so, this should be AssertionError, which represents the programmer's assertion of it not being possible, on the assumption that the code is written correctly.
This line should not contain any whitespace symbols.
What are some examples of these task names that should be ignored? Contains "idea" (any capitalization) seems like it could match unintended stuff, like "semidead" or "mideast" :-)
Use a logger or remove this.
This line/var is unused.
You're using this pattern a lot. Versioning.getVersionOrdinal() is going to possibly create an unknown version object and then getKnownVersion() is going to throw it away. Is there a way to do this w/o creating an object? Maybe Versioning.getKnownVersion(short, default)?
mapping could not be null at that time anyway since it is used one line above
something fishy here - the 'reinitialize' field is redundant?
.map(this::splitToFileNameAndOvf)
Is this method being called often? Should we surround with if (logger.isDebugEnabled())?
should probably be Integer.valueOf(100) purely for consistency reasons.
start < end is verified pre-condition already?
you can use assertThat(array).hasSameSizeAs
seems we can specify ArrayList size in constructor above to avoid performance and memory overhead, though not a big deal.
nit: as a matter of style, I think it's better to either always include braces on each branch of an if-else, or to never include them. (Otherwise it's easy to miss things in a refactor)
Not good; this blocks the UI thread. No point running the operation in a background job then.
I think we should create a defensive copy of the Map
Same here - remove the catch block.
What is the purpose of passing it as an http URL here? I believe there are parsers already in Geode for splitting host:port.
could you clarify how does this change help?
I have some doubts about variable name. Checkstyle should shout about it.
Could you replace this if by  Optional.ofNullable( this.states.get( source ).meshManagerProperty().get() ).ifPresent( MeshManager::removeAllNeurons );  Maybe in the future we will have MeshManagers for non-label sources.
suggestion final Map<SlotRequestId, SlotExecutionVertexAssignment> slotExecutionVertexAssignments = createSlotExecutionVertexAssignments(executionVertexSchedulingRequirements); final Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = slotExecutionVertexAssignments .entrySet() .stream() .collect(Collectors.toMap(e -> e.getValue().getExecutionVertexId(), Map.Entry::getKey)); final List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures = createPhysicalSlotRequestFutures( executionVertexSchedulingRequirements, executionVertexSlotRequestIds); allocateSlotsForAssignments( physicalSlotRequestFutures, slotExecutionVertexAssignments); return new ArrayList<>(slotExecutionVertexAssignments.values());  This seems to be a bit less indexing... It also implies some simplification of the called private methods.
It is a bad practice to catch Throwable (can cause maintenance issues if api changes to have new caught exceptions, or later you want a caught exception to bubble up). You should catch RuntimeException and other specific exceptions.
no need space before new line can we avoid new line in this case?
Can just use new Runnable() {...} so don't need a return.
It could be more optimized to following function.  @Nullable private static Uri getFileUriFromMediaStoreUri(@NonNull Context context, @NonNull Uri photoUri) { final Cursor cursor = context.getContentResolver().query(photoUri, new String[]{MediaStore.Images.ImageColumns.DATA}, null, null, null); if (null == cursor) { return null; } try { if (cursor.moveToFirst()) { final String data = cursor.getString(0); if (TextUtils.isEmpty(data)) { return null; } return Uri.fromFile(new File(data)); } } finally { cursor.close(); } return null; }
Again, might not be public
Is there a case that the firstKey is null and the rest are not?
Is TimeoutException possible? I noticed the Pool is Busy exception is a ConnectionException.
Use the config from the HBTU? Maybe new Configuration(TEST_UTIL.getConfiguration())
Let's use setPositiveButton here instead. There's no special motivation for it, but I think Google styles the positive one with the primary colors
Spotbugs is flagging this line:  [ERROR] Dead store to worker in org.apache.druid.indexing.overlord.RemoteTaskRunner.streamTaskReports(String) [org.apache.druid.indexing.overlord.RemoteTaskRunner] At RemoteTaskRunner.java:[line 651] DLS_DEAD_LOCAL_STORE
Can we initialize the new ArrayList<>() with same size as list 'metrics'. This will save on resizing cost which includes Array copy operation.
can we have final variables for 80 and 443 ? the variable should have a clear name that indicates that these are the default ports.
Pretty sure this is only used during the setup wizard, so doesn't need the permission check changed.
Since userDirectory is known outside the for loop, you could get the canonical path and store it in variable for comparison in the if statement. Also, having an empty if statement is odd. Shouldn't you put a ! around the whole thing and do the FileUtils.forceDelete(f); inside the if and get rid of the else?
Again, initial capacity should be specified. Or use LinkedList
We should turn the auth system back on after creating the test data.
:+1: using CoderResult looks good approach to me.
Same here - duplicated code.
Make this if the other way round. Check for the positive condition and have the negative one in the else. It makes it more readable
You can not put person via storIOSQLite.put() because it will be recursive, so you need to use storIOSQLite.internal(), but you can use storIOSQLite.put() to put cars.
some logic is repeated in the if-elseif-else. Can be simplified as  if (!isShutdown.get() && connection.isUsable()) { ... } else { ... }
why do you need this.?
Could you add something like "for patchSetId: " + psId.toString() to this message, and any other pertinent detailed info to the other messages if appropriate?
value size, instead of key size in a message
Can we use default builder by default and hide this argument?
Name of the template should be more explicit.
You could instead use:  addEnricher(Enrichers.builder() .propagating(RedisStore.HOSTNAME, RedisStore.ADDRESS, RedisStore.SUBNET_HOSTNAME, RedisStore.SUBNET_ADDRESS, RedisStore.REDIS_PORT) .from(master) .build());
null check?
These two methods should be the same name with the exception of prev/next suffix.
is this try necesasary to test the casting, im not sure i like the construct i would prefer to use instanceof
How is this happening?
java // TODO Java 7+ use chained exceptions
The value should still be read from the activeConfig instance, to allow for per-world overrides.
@gmandnepr indentation still needs to be fixed here
No need to use UriBuilder
The default for the managed param is true, so you can just miss that out I think.
Same as above, a bit hard to read
Please, fix
I prefer:  java if (GenericUtils.length(owner) > 0) { continue; }  I don't think "empty" owner are expected, and even if they are IMO they are the same as "no user".
Wouldn't make more sense to push this down into RetryingReadRowsOperation so that we don't have to duplicate this for callback api?
Shouldn't a similar check be implemented for Byte, Short, Integer, etc? This isn't a special case, just range check.
Pass nfe as the cause (third param) to RestClientException
Could you please use window.getShell().getDisplay() instead of Display.getCurrent()?
This is going to break when the menu changes in future. May be write a function that can find an item and click it irrespective of menu content? e.g. clickMenu(String... items) and call it clickMenu("Boards","Auto-create","Work distribution") Note the use of variable length argument lists.
formatting
passwords should usually better not appear in log files - and it also makes no sense to have it as a warning. I'd suggest to either remove it or reduce to DEBUG level.
Let's check that a snapshot was created with provided name.
.orElse("failed")
In that case I'm definitely need to use AllureMain.class.getClassLoader(). The resource that I need to unpack is located in allure-bundle.jar, and available from ClassLoader that loaded AllureMain
getIndexDiffCacheEntry() can return null
Tapping enter on an empty checkbox line removes the checkbox as expected and moves the cursor to the next line, which I wasn't expecting at first. I thought the cursor would remain on same line, but then I noticed the cursor moves to the next line when tapping enter on an empty bullet list as well. Should we move to the next line or stay on the same line? I noticed some really awesome apps (e.g. WordPress for Android/iOS) and some stock apps (e.g. Notes for iOS) stay on the same line.
Extract try and catch blocks into separate methods? As a rule of thumb, try to keep constructors simple. Similarly, see if this if statement can be extracted out.
Can you use Matcher.appendReplacement() to simplify this? <LINK_0>
throwing these two exceptions on their own line like this is a bit neater to read than wrapping like above
I'm obviously missing something, but it seems to me to always be a Map?
Any specific reason to enforce the fairness?
If there's an exception being thrown, we should be at least logging information about the exception. Otherwise, there's no way to troubleshoot what's happening without attaching a debugger.
Consider extracting this into its own function called addBuyOrderToOrderBook or perhaps just addBuyOrder
Here it breaks the format.
As already noted in other commits, looks like NPE?
is there a better place to hold this code or can we introduce one, now that this code becomes much longer?
use simple for loop instead of foreach
old code looked ok, I think druid codebase style is to keep parenthesis on the same line except for class/method opening.
Attach the GeoElement to the Callout. This will allow for the callout leader position to follow the symbol offset above: java // set the leader position and show the callout Point calloutLocation = graphic.computeCalloutLocation(graphic.getGeometry().getExtent().getCenter(), mMapView); mCallout.setGeoElement(graphic, calloutLocation);  ![attach](<LINK_0>
I'm missing an else here. Is there a situation where this condition is _not_ going to be true? If there is, the fl switch doesn't work? If so, maybe we should at least say that it's not going to work.
duringActivities()
maybe extract Thread.currentThread().getName()? then you can use a format string (and avoid string cat when debug isn't on)
I am not sure should we care about the scenario here, where in case of exception while executing _invoker.invoke(invocation)_ , should we remove TIMEOUT_FILTER_START_TIME from attacchment ? I think this piece of code should take care of removing TIMEOUT_FILTER_START_TIME even in case of exception. What do you say?
This should be a method in PKI. Depending on the intermediate CA the chain file name "ca-chain.cert.pem" might differ
Looks like previously created InternalEnvironment should be used instead of the creation of the new one.
delete
this logic should be within EngineSSHClient
there have been quite a few formatting changes where the formatting isn't necessary, when you go back to using wrappedSerializableTxManager I'd expect all of these to disappear
call byteBuf.release() and also add assertFalse(ch.finish());
There won't be any remote keys in the common case; therefore this array should not be allocated ahead.
Potential null pointer exception since we have remove the value != null check. We should check valid string values using StringUtils.isNotBlank method.
Avoid using null as much as possible.
I would prefer you'd use a named constant instead of putting true in there. So what I am suggesting is adding a private static final Boolean REFIRE_IMMEDIATELY = true, which you'd use here i.o. just true.
These method have to much arguments already: Just give it an IValueMap and write all out to the tag.
And will spare this null check.
please dont remove explicit initialization
This isn't correct. If fail() throws AssertionError, you'll get a stack trace but the test will pass. It's OK to declare the test method "throws Exception" - this will result in any uncaught exception propagating back to JUnit and failing the test.
Could we verify there are no constraints instead of removing this row?
...the base ChoiceCallback might be used by a mechanism and should be tested for; furthermore, there are other subclasses of ChoiceCallback (like RealmChoiceCallback) which might interfere with correct operation of realm selection if there is no type-based check involved.
local variable should be camelCase not fCamelCase
Instead of setting styles on the element like this I suggest you use css classes. For instance create a .css under src/main/resources/org/ovirt/engine/ui/common/css lets say 'Validation.css'. In the css file do something like this: .validationError { border: 1px solid red; } Then in EntityModelCellTable class define the resource and the associated style like this: public interface ValidationCss extends CssResource { String validationError(); } public interface EntityModelCellTableResources extends ClientBundle { @Source("org/ovirt/engine/ui/common/css/Validation.css") ValidationCss validationCss(); } private static final EntityModelCellTableResources ENTITY_MODEL_CELL_TABLE_RESOURCES = GWT.create(EntityModelCellTableResources.class); private final ValidationCss style; In the constructor: style = ENTITY_MODEL_CELL_TABLE_RESOURCES.validationCss(); style.ensureInjected(); And finally in validate you can now do the following: if (!valid) { element.addClassName(style.validationError()); } else { element.removeClassName(style.validationError()); } This is a lot of work, but this will make it much easier later to change the style in the .css file without having to alter code. It will also make it very easy to externalize the style class, so we can brand it at a later time.
You can express it in pattern argument of extend.
are you hiding an issue?
This construct causes "createHeadToken" to be called upon each call of "createTokenAt". That may be an expensive operation. Please use orElseGet(this::createHeadToken) instead.
Is this an outside case or are we using exceptions as control statements?
will existing code handle this RuntimeException properly ? what about throwing a IOException ?
Please test this value not by metric registry, but by JMX
This doesn't check accepts anywhere which could cause strange problems
I guess pattern can be shared as public static final field with other classes/tests to prevent copy/pasting and possible issues in the future.
nit, pass the periodicTriggerInterval to initRefreshTask() and do the branch inside. That makes this code cleaner.
Did you need to check to make sure the invalid part didn't make it in?
Generics: Iterable<Object>
pls. use a separate method for this or rename this one to indicate that it is doing this, too
Does the querying stuff generate caches which have no configuration?
These look like testing remnants. :)
You can avoid one lookup like this: String path = pathCache.get(key); if (path == null) { ... } return path;
could we make this a subclass of RuntimeException so that if folks want to catch it for whatever reason they needn't parse the message. alternatively, maybe we should add an accessor for hasRolledOver in case a user need to know if things have rolled over, but doesn't want to consider it an error?
LOGGER.warn()?
All the same stuff applies here. Note that you could separate the loading out into its own function.
Probably this Iterables.getOnlyElement(ll) needs to be (MachineLocation)machine.get()?
Another opportunity for a nice stream pipeline.
I note below that this is a hack. This is an unnecessary data conversion which will create performance issues on large files.
Can be simplified streamName = getPhysicalName().orElse(getStreamId());
call super.hasMailAuth()
As @calixtus said, it would be nice if you could add a logging statement here: Add private static final Logger LOGGER = LoggerFactory.getLogger(Linux.class); at the top of the class and then here LOGGER.debug("Received output: " + line).
Yes, didn't mean to imply your implementation was wrong, I just wish to avoid potential trouble later on :p.
Shouldn't JabRefPreferences be replaced by MainStage ? (As this does not print the values stored in the preferences)
Shouldn't there be a null check here before calling close() on the response. Kind of similar to the what we do in the catch block above?
If modelId is only used if thingUID != null && thingTypeUID != null I would move the variable definition and initialization into this branch.
weren't you going to actually increase the size of this buffer to reduce the error rate?
just a question about ascii, is that ok?
'null' must be the first operande
1. Any way around not having to execute axe for each webelement ? Concerned about the perf implications here - since axe would be injected into the page for each time etc. 2. Would it be possible to convert the webelements into CSS selectors and use it along with the include option ?
you can probably use the same trick, if wasChildChecked you don't need to call isActive() and you can't uncheck the element.
this already exists as 'AstroBindingConstants.THING_TYPE_SUN'
We should sanity check whether handle is already in a transaction here and throw an exception, before changing the state of didTxnRollback.
I guess this could go in a common class somewhere, so that it's also available for commercial edition and extension developers .
You don't need these "//" at the end of these lines.
Check on primaryPublicGithubEmails.size() > 0 to avoid **NullPointerException**.
How about raw types? Will they fail later?
camel case: vlanVm - for entire patch.
If flash copy widgets are disabled in the user's preferences you will show the text "Copy Search Results" with no way for the user to do that. The flash movie is not created and the copyable label has no other widget to focus on.
int channel
you probably dont even need this, just send the value of _withSLA_ always?
Readlock looks useless here. Anyway, you'll finish the future in few lines below.
Nitpick, but this could be an ImmutableMap (or at least coded to interface). Super nitpick, but other similar snippets should be coded to interface as well.
How about to append the unit for each metric?  PS Elapsed Time: {0} s
HTTPClient to allow use of AEM-configured proxy.
When ready to consider the PR final you might want to either remove or set debug logging to the debug level :-)
if you move the save next to the fetch, they might be moved out together and handled together. Also you might save some if condition regarding checking if it's CCMv1 or v2
Can we avoid hardcoding the proposal text here? We should reference to the original WTP proposal text if possible.
You can remove the else clause above (but keep the code block) and remove one level of nesting.
since VmGuestContainerListModel is no longer generic we don't need to use TypeLiteral anymore. A simple bind(VmGuestContainerListModel.class).in(Singleton.class) is sufficient.
Might want to put this back to something sensible.
suggestion LOGGER.finer(() -> "Checking EC2 Connection on: " + ec2_cloud.getDisplayName());  Lazy logging message construction for lower log levels.
Nit: Let's move isCurrentUser() check out a level so we don't have to do it twice
The error message is not correct as instructor can call the method to access moderated/preview person. Actually, I think it is not the method's responsibility to verify the login privilege here. As long as the pre-condition for getStudentOfCourseFromRequest is fulfilled, it should executed. i.e. - The login check should be only verified at orElseGet - Other login privilege check should be in checkAccessControlForStudentFeedbackSubmission (e.g., to verify it is logged in when access as preview person)
just call serialize(event, getCurrentTraceToken(), jsonGenerator) here to avoid duplicated code between the two flavors of serialize().
suggestion  It's unused.
This update should not have been done in another commit, ie "Set built-in QG as default of organization, where you have set the ORG#DEFAULT_QG column as nullable
Looks like this is the first attempt, this should fail if you include on the first attempt
It should be new TajoRuntimeException(new UnsupportedDataType(...).
Usually we will put this line before the try block.
All the other stores have their registration done in their provider... why is this one different?
I think you can replace it with just MDC.put(IDENTITY_ID_MDC_KEY, subject.getUserId());
use the method to set the values of scheduled page
Unlike in perun-core, there is no possibility to provide null for destinationGroup, since it always retrieve group by provided ID. Please make destinationGroup param optional (check it's presence) to allow moving groups to top-level.
just use UndertowLogger.ROOT_LOGGER.debug("....");
What is the serialVersionUID for? IIUC, Jenkins uses XStream to serialize/deserialize data, not Java serialization. is this required?
and also fix indentation in this file
Deserializing the data twice.
Can you set message Id in assertion and verify the message Id exists?
could you explain why 5
We need this check (it should arguably have been there before...) because you're casting to (byte) below, yet writing the full strArray without truncating. The check could be moved to the constructor though. And the Illegal*Argument*Exception would make even more sense!
Can you use a StringBuilder instead? I guess that there can be many lines, doing string concat this way can have an effect on performance.
why do you need to override getCustomValues() instead of just adding the custom values here? with the override it will affect also command inheriting from this command.
assert that convertedOriginal.states.size == stored.states.size
move it to new test
I think that in this case the code would be more understandable if you replaced the condition by if (nextConfigurationChanged(vm) && !nextRunFields.contains("customCpuName") instead of creating separate method (with not so clear name).
Please add empty line to indicate the above belongs together.
assertEquals(2, actualScores.size())
use debug rather than info for logging.
With line break maybe?
partially **built** mapping?
Missing all() or explicit setLimit call.
Ultimately we probably want to ignore provides for files that were not explicitly passed in, e.g. stuff from the transitive closure like base.js but also other libraries. Probably to early to do that, but maybe leave a TODO here?
Cannot render interstitial ad. -> Cannot render rewarded ad. Also, create a single String variable to use in these 2 places.
What's the purpose of removing objectMapper == null from this if statement and instead setting it to null on line 41? What is the value of objectMapper when afterPropertiesSet() is called?
messInitRepo > initRepoMessage
I think it should be located after note.run
It wasn't clear to me at first where the assertions are. Consider keeping the util function just as a helper to create projects but not do assertions.
This call and the one above make a logical group, duplicated elsewhere - extract method
This should probably not be changed, judging from the test code here around
Can you encapsulate this into a "simple" AffinityGroup method that will just be called from here?
this should be the first line, well before the dotConnect
I'm not sure this exception is related to "if (parameterNames.length != totalLength)". I think we can have more context somewhere.
Recent Infinispan versions bring JCacheProvider for both embedded and remote, and since there can (and should!) be both of them on classpath, you should add property for selection of the provider.
I think assumeTrue is unnecessary. Such test is supposed to be performed when all DCs are specified.
So I generally think of deleting in-place like this (while still using an iterator) as being a dangerous operation, and would assume we'd need to make a "todelete" list and then apply the deletions afterwards. Am I incorrect about that WRT our iterators?
no need for else at positive flow
Why not use the char array approach as before?
The correct way to look up a target translation is by id. We should not be building the path manually. e.g. AppContext.getTranslator().getTargetTranslation(targetTranslationId).
fix variable naming and same goes here
Code style
This leads to a regression. In master the app is now showing also the files, not just the folders. The if sentence should be removed.
NIT remove on line
Should put the path as well in the audit log too  logAuditEvent(success, "listSnapshots", snapshotRoot);
Should this be onErrorMap? This logic looks to be more of an error mapping than an alternate resume from an exception given this will propagate an error.
Can we move the "drawableId", "titleId", etc strings to private static final String...?
naming, removeFromNetworkLink (and addToNetworkLink)
Shouldn't you explicitly use a CharSet to read from the stream (using the InputStreamReader ctor with CharSet) instead of using the system default CharSet? You might be able to determine the correct encoding by using getContentEncoding() before actually reading the content.
does apiToken need a null check someplace before this?
Line count will not be incremented if exception is thrown.
This won't work on EAP6, please to use this: [WildflyCompatibilityUtils.parseCLIStyleAddress](<LINK_0> WildflyCompatibilityUtils.parseCLIStyleAddress("/subsystem=hawkular-wildfly-agent/")
please check that the bitstreamformat is still here
why is it saing wizardPageList ? bad copy/paste ?
My understanding is that these API's are java 7 APIs. Right now we're still supporting java 6 in the project. This isn't a hard stop, I'd like to deprecate and remove 6 and 7 support now that the older hadoop versions are removed, but that would have to happen on master before these API's can be used.
fBot =
Might make sense for helper methods like getPrefix and getLocal. The local processing is a bit involved for one line.
Here for each project which gets selected a new row is appended to the SelectedItemsTable. This means that the projects in the SelectedItemsTable are sorted in the order in which they have been selected. I would find it more convinient if they were sorted by name.
Please add this to the 1.7.4 block, so all updates for one version are in one location.
if there aren't plans to ultimately use this check in many other places in the future, why not lose this boolean and just use site instanceof JournalSite instead as you do elsewhere?
Once .xsd is updated, this and the below string should also be updated of course.
Need to handle this exception
simply return tid?
I usually prefer to use formatter, as it keep the message easily readable when reviewing: java String.format("Split this %d characters long line (which is greater than %d authorized).", length, maximumLineLength)
You must use players in range, not all players: game.getState().getPlayersInRange(controller.getId(), game)
I can see this URL mangling is ugly but necessary. Maybe string.format instead?
Can we use a try-with-resource pattern here?
What is the purpose of this test? It doesn't seem like a test at all. Maybe if you asserted that the signatures of the provider methods are correct, that would make it a useful test.
Is there a more specific exception, i.e., QuotaViolatedException, that you can unwrap from the DNRIOE? Would be good to assert on its presence.
I think it's mostly fine. If you want, the message could be updated to: > Queried for a buffer before requesting a subpartition
Do we need to reset this to false once we actually manage to trigger repartitioning on cluster state change?
StringUtils.isnotempty
An automation handler is recreated on configuration change. Please extract configuration in the contructor.
Perhaps inspect the operation instead of relying on this class field
I think you meant suggestion return loadSpecificationFallback(swaggerParser, uriAsString, e);
try reusing 'initVmTemplate()' method from: <LINK_0>
We don't need this check
With the lines above this looks like the RuntimeException is thrown on purpose here. @sobimibos can you clarify here what we can do alternatively? Thanks.
Magic
With this break we will just loop once, is that intended? Why do you need a while loop then, you can just pick the first element.
This should not be removed. A negative period makes no sense.
import BytesValues
should this also be moved into if (sendable && !backingOff) { ? for example, if the batch is not full, it's unnecessary to put tp to readyNodes.
path -> "key"
hlen is not a very descriptive name. Could you please rename it?
when queue is full exception out of this method looks unhandled
These changes should not make it in - they were for debug purpose.
no need for times(1). I think it's the default behavior.
ah, it's just moved code. Ok...
Can you use 4 spaces for indentation here? It is the style that we use in the rest of the project.
Another fake LRO?
since this is debug logging provide an e.getMessage() instead and re-add the placeholder.
would it make sense to define two functions parseInts and parseFloats to avoid this boilerplate?
Add braces.
can be refactore to a method  setValue(getInvocationReturnType(returnTypes,in)); private Object getInvocationReturnType(Type[] returnType,ObjectInput in) { if(returnType == null || returnType.length == 0) { return in.readObject(); } if( returnType.length ==1 ) { return in.readObject((Class<?>) returnType[0]; } return in.readObject((Class<?>) returnType[0], returnType[1]); }  What do you say? As this code I have done without editor so there might some braces or syntactical error so plz excuse me for that.
I don't think it's safe to reuse nowMs here since we may have blocked on free.allocate.
abort twice?
no need of type on RHS
Remove first element from ArrayList is a bit inefficient operation. Can we use LinkedList here or perhaps remove the last element?
redundant?
this and previous can be a single line
What happens when someone visits the page this component is on with an id that is invalid?
Exception#printStackTrace goes to stderr by default.
Maybe this code can be extracted into a separate method, to reduce code duplication
can JobType be passed so that it can be logged accordingly?
Can we let the type be inferred on these, for easier reading? on(ExportProgressEvent.class, event -> {
null might be a valid value for the field but you also get null if some exception happens. I would not handle exceptions at all.
Rename to gatewayServerFuture
Can this be limited to SocketTimeoutException, as in the original?
Not so sure about this part of the change. The ssh fencer is logging in to a unix user, so probably the unix username is more important than the kerberos username for the daemon.
a const please
PLease invert operande
this should be checkBasicAPIs(strings, deserialized, true);
Code formatting
@neonailol I think it's better to make this pattern private static final, because it produces immutable Pattern object (like a constant) and it will degrade performance if it called too often from outside.
Cannot be empty but anyway: StringUtil.isEmpty checks both conditions.
Maybe split this widget creation to separate method to make this big callback more readable.. Also I'd prefer functional style to forEach, but I might be FP freak :P  projectWidgetsByName = projects.stream() .collect(Collectors.toMap(Function.identity() , this::createProjectWidget) ); private TileWidget createProjectWidget(ExampleProject project) { TileWidget tileWidget = tileWidgets.get(); tileWidget.init(project.getName(), project.getDescription(), null, null, selectCommand(tileWidget)); return tileWidget; }
This setup is a straight copy of the one in ActivityCategoryServiceIntegrationTest. Can't you put it somewhere where it can be shared? Common base class?
You can discard 1 card if you only have 1 card in hand.
Calling "updateCredential" during every authentication could mean lots of unecessary DB writes. I wonder that update is needed just when counters are used, which is not always? Not a blocker for this PR - we can create follow-up JIRA to doublecheck and we can be eventually improve later IMO.
Is the above any different to:  java if (env != null) { tool = tool.forEnvironment(env); } else if (node != null) { tool = tool.forNode(node, listener); }  Aside from the fact that the above only flows through one leg of the if and (imo) more clearly shows that env takes precedence over node.
not -> does not .
final
this allocation seems wasteful, couldnt we just inline the allthreads call and directly check them?
s/"Inventory"/NbtDataUtil.INVENTORY or something thereof.
I think it would be better for the client to pass in a simple callback interface. This way you can avoid a weird dependency on Fragments (and their crazy lifecycle!).
Order of the above logic should be swapped. You need to look for the selectedDevices first. If no devices selected, then look for all the devices.
The IDE warnings for these lines can be removed by using Region.Entry<Object,Object> entry1 = uncheckedCast(mock(Region.Entry.class)); Region.Entry<Object,Object> entry2 = uncheckedCast(mock(Region.Entry.class)); Region.Entry<Object,Object> entry3 = uncheckedCast(mock(Region.Entry.class));
suggestion "Hadoop in your classpath. For more information refer to the " +  same as above, also mention HADOOP_CLASSPATH
We need to consider handling two exceptions that consumer.position may throw: KafkaException -> should be a fatal one; TimeoutException -> in this case we cannot commit, probably have to treat as fatal..
Can we use CollectionUtils.isNotEmpty from apache commons here?
instead you can use something like: com.facebook.presto.sql.planner.TestLogicalPlanner#assertPlanContainsNoApplyOrAnyJoin to see if there is no filter node
the label "outer" is a bit confusing here since this for loop is actually itself nested in another for loop
What you want to use here is Collections.singleton()
If we're going to include commons-codec as a dependency, then I think you should just replace the whole block of code above with this:  generatedPassword = DigestUtils.sha256Hex(password);
I'd move the fundamental type constraints into the implementation of ElasticsearchPersistentProperty to fail faster.
technically speaking installationLocation can be null based on implementation, so in this case can we log error and avoid doing anything in the provision method?
The implementation of this callback seems correct, but feels a bit messy. That's kind of why I generally prefer separating the events if possible. A bit of a better organization of the code could help here as well, but not required. Just leaving my general feedback about it here.
if header is null, showHeader must be true
I wonder if "whitespace" handling should be incorporated to the call site of parseReturningKeyword and other parseXYZKeyword. By the way: tab, newline would trigger defeat query[offset - 1] == ' ' kind of check.
Add context specific message without using e.getMessage().
Here the _Object reference_ to capabilities is copied. So capabilities and tempCapabilities, refer to the same object. Thus, this change is not really fixing the Avoid reassigning parameters such as 'capabilities' condition. In this particular case, the approach should be  java DesiredCapabilties newCapabilities = SelendroidCapabilities.android(); // Note: SelendroidCapabilities.android() returns a new DesiredCapabilties object. So,now that the original capabilities _Object reference_ and values are lost. newCapabilities.merge(capabilities); // I suspect the fact that we don't merge the pre-existing values is a bug we have today. See IOSDriverCapabilitiesBuilder -- it calls merge(), for example // the rest of the changes
I don't think we need to say anything when the index is present, and the error message isn't going to tell a user what's going on. Something like "Index file [path to file] not found. An index is required for sharded export." for example
nit: is it necessary?
I was wonder if You could move something like this to VEContent.java in ContentPatterns package. We did something similar with Palantir javascripts and put them into one PalantirContent class.
I believe stringUtils.isEmpty returns true for null string. So the first check condition can be skipped
Nit: the name of the variable no longer matches the name of the config parameter, but I don't think this is a blocker.
When there is no delay we won't attempt retries? Would we want this instead? java return Retry.max(options.getMaxRetries());
If I understand it right, this variable should be named sortOrder rather than value which is confusing,
that's a neat pattern I've never seen before :)
AbstractRpcClient does not seem to be best place for this static method. _batchSize looks a bit strange in java. AbstractRpcClient.parseBatchSize(clientProps) call in AbstractRpcSink too. I would consider to move the method to a utility class (or maybe to RpcClient).
we could even make printPar final
Can be done less expensively (and perhaps more simply) by using built-ins:  Map<StackId, Set<String>> mpackServices = topology.getComponents().collect( groupingBy(ResolvedComponent::stackId, mapping(comp -> comp.serviceInfo().getName(), toSet())));
hey @pefernan , found several like this one... is it a typo?
shouldn't we overwrite newtree only when it was checked that is was not explicitly set? If somebody sets newTree but not oldTree then we would ignore his newTree.
what is the purpose of this synchronization? the corresponding reads (from get methods) are not synchronized. Is the concern trying to handle concurrent calls to setTypeMap on the same PgConnection?
Call assertThat(request.getHeaders(EXPECT).isEmpty()).
java .subscribe(new Action1<ResultType> { });
If we provide an ExistsPredicate with a specified IndexOrder we need to fail if we cannot serve it?
Your questions of the prev PR: - We do not have an in-place swap. This is not possible for Tuple2 because of the generic types T1 != T2 (wlog) - Lets implement it as iterator with a boolean switch = !switch state to avoid new Tuple instances:  java Iterator<Gen<T>> iter = new Java.util.Iterator<>() { boolean switch = false; hasNext() = true next() = { gen = switch ? ... : ...; seitch = !switch; return gen; } } return rnd -> iter.next().apply(rnd);
Can you use the static import for Mockito.when here?
this is asuuming that both upper and lower are non-null
Is returning the object type Boolean necessary? I think it is just fine to use the primitive type (boolean). Using the object would unnecessarily cause boxing and unboxing and sometimes cause subtle bugs.
If no listener, still need to watch? Why?
I'd switch the + to a , so we get a stack trace here in the logs.
No need to wrap into CodeSystemURI here.
Didn't we agree to change it to something like follows? requestSent = sendConnectionRequestToSession();
is.available() is not going to be reliable. You want Content-Length header (if present) and if it's not present you can wrap the InputStream and count the bytes.
this. for all of these
Looks like this field is added always. What happens if rhs-version is not available ?
anyway to find an unused port? This could hit something like 8080 that is occupied.
How react the notification system ? Should you not compute the current list of label format, then compare to the existing one and replace it (clear and addAll) at this moment. Instead of calling clear() and then add values one by one.
(optional) likewise
This is wrong, the DECLARED_NAMESPACES_MAP shoudl already contain all necessary namespaces no? So why adding all the namespaces? IMHO the behavior now should be, is a simple feature? business as usual. Is a complex feature? then we get the necessary namespaces from the complex type and we add them, makes sense? It should no matter if they come from a local workspaces or not.
Wouldn't this cause the exportProperties array to be computed each time we send out a metrics message? That would be very inefficient, as the list doesn't change between refresh operations. That was the main reason why it's been done once via onApplicationEvent - based on the discussion that @jvalkeal and I had, that seems to have some race condition issue, but we should probably make sure that this is cached rather than computed every time.
in your case you should use createRepository instead of createRepositoryWithArtifacts because the artifact will be deployed within test.
I think we can do the same here as just pass db in
nit: this if condition is duplicated in the else part. Please refactor it by extracting common parts and executing specific Array related logic when if clause passes.
@vilchik-elena Why is nowdoc outside of STRING_LITERAL()?
Duplicate check. Line 180 is excess. 181-182 checks are enough
very close, let's add an actual alias on workflow before waitForRefresh so it shows up here
Try replacing executor with a SerialScheduledExecutorService and call its elapseTime() method to advance time.
log would be nice here
What if courseId does not exist?
extract InfiniumVcfFields.GENOTYPE_VALUES.values().length to a static constant
rrbc->rrbs (x3)
The parser is a throw away, but the configuration is shareable, please move it to a class field. (or at least, it should be, in GeoServer most configurations are Spring singletons)
Try to have only one exit point per function, returning here can be hard to follow.
The category.xml file is usually not part of the output repository. Trye removing this line.
looks like you are checking for recursion, can we have a java doc just to say what true and false mean?
IMO you don't need to append exception message to you log again. Just adding the exception object would be enough
Please use StringBuffer for better performance.
Even though this class is using DefaultDataBuffer, which does not require releasing, I still think it would be a good idea to release them here anyway, especially if we make the data buffer factory configurable. I think the release can be implemented as the ContentChunk callback (I am assuming that the callback would be called after the data has been written, not sure about that). I see that below you said that releasing in the callback does not work for the response, but perhaps it does for the request?
in all the guava functions like Preconditions, it is more efficient to write them as follows:  java Preconditions.checkState(colType == Type.STRING_TYPE, "Column to split \"%s\" (%s) must have type STRING_TYPE", columnName, colType);  This avoids unnecessary string construction, in the case that the check passes, and it is also easier to read.
The defer isn't needed here.
Can we change v to something like exp?
for each ?
Probably culpritIds should be computed before returning, no? Potentially it could change while we are iterating.
coundn' t we use mongo.delete().eq....eq...().executeFor(...) here?
This seems like something that was for testing and should be removed
Can you use log4j2 ?
This no longer needs an initial value.
This is causing GruntLaunch to always run the default task. However if there is a selection and that selection is an ITask, I think it would be better to pass that to the GruntLaunch
rewrite scenario: Feature: As a grid operator I want to be able to perform SmartMeteringInstallation operations on a device Background: Given an organisation with OrganisationID "LianderNetManagement" @SLIM-218 Scenario: Add a new device "E0026000059790003" Given a device with DeviceID "E0026000059790003" When the add device request with "E0026000059790003" is received Then the device request response should be ok And the device "E0026000059790003" should be added in the core database And the device "E0026000059790003" should be added in the dlms database @SLIM-218 Scenario: Add a new device "G00XX561204926013" Given a device with DeviceID "G00XX561204926013" When the add device request with "G00XX561204926013" is received Then the device request response should be ok And the device "G00XX561204926013" should be added in the core database And the device "G00XX561204926013" should be added in the dlms database this way the device id is part of the scenario name; you can retrieve it by using scenario.getName()
Previously, this was also done when no new job was started. Was that unnecessary, or should the new code also do this in that case?
technically speaking this service requires a key and a secret..
why is this done on init (called from onLoad()) rather than in readResolve?
do you need the log text box to be scrollable?
This is probably quite useful for now, but lets make sure we remove it if we don't need it for the final sample
This is wrong IMO, if I create a subclass of Number, this method will always return false even if my Number's intValue() returns 0.
Not really needed here (see remark in BranchOperationUI)
Does this test fail with the old solution?
If it's possible, you could use Collections.singletonMap(key, value) here.
You can merge these two if conditions into one
I think flush is not needed here. Because it will flush every byte, isn't it? Try with resources will auto close your streams. Which will execute flush as well
You get major bonus points for writing a testcase! I'm curious why store the result of getProcessID() in a variable unless you want to test against it... why not just store os.getProcessId() two lines up and then use it twice? (Or just not use a temp variable and only use os.getProcessId().)
pass Style as parameter to above 2 methods
I wonder if we should add a preProcessing(...) method to initialize some variables. I don't like too much that the validation method is also responsible for the initialization of the fields
There are a lot of other cases that need to be covered.
nit: make these 100_000 and 1_000_000 for readability
missed deltaUuid
is**R**hsNull
This implicit behavior updating global state seems a little weird but I haven't put a lot of thought into it - I'd expect it doesn't really cause any issues in practice but it does smell a little weird. I think it's the right thing to do but seems like maybe the wrong place to do it
Remove this.
You shouldn't be checking reference equality for objects. Please use Objects.equals instead.
can we use lessThan instead of compare() < 0?
It looks suspicious that the method is eating the exception just so it can be called as a function. That also raises the question: what if the mysql instance is down during the whole report run - will the report complete successfully even though every sql update failed and logged an error?
Why do we need to execute these create and drop table statements?
List.contains
If selected resource is non-workspace, then you'll get first path element from getProject() method, and finally getMapping will return null. With change I929c3c32e getMapping for non-workspace files will return proper RepositoryMapping.
I think it's preferable to take all logic out of the TableWriter, so that you calculate false positives here and not inside composeLine. This may require creating another nested class called eg FalsePositiveRecord that is basically a struct of the filename and snp and indel counts, but t's worth it.
I imagine it's going to be super useful to have a single line log with op : user [path]
We can use the cache here for a read: AccountState s = rsrc.getUser().state(); if (s.getUserName() == null) { throw new ResourceNotFoundException(); } String p = s.getPassword(s.getUserName()); if (p == null) { throw new ResourceNotFoundException(); }
are this changes related to xsite?
A bit of a renaming, since this effectively comes down to a permission issue suggestion ______TS("Instructor attempts to edit student's response with appropriate permission, should be accessible");
Rather than hard-coding the texts here, they should be defined in a .properties file so that they can be translated.
See how this is done for entities. Does BasicBrooklynCatalog.loadClassByType load policies as well as entity classes? See BrooklynAssemblyTemplateInstantiator.loadEntityType, for a policy equivalent.
suggestion } else if (value instanceof FloatSet) {
The test probably has been set to null.
What if the interface and/or service is null? Won't we run into the same problem?
I look forward to seeing this in logs.
Can this logic moved into 'vdcExc.getMessage()' ?
Why this Iterables.size instead of a simple inputPaths.size() ? Both choices are not "null protected"
Could this code be tested with non segmented logs? Perhaps just put the test of swap segments within if (isLogSegmented)
@joshuajplagonera @ericleich I belive it's important to call  mVungleManager.removeActiveBannerAd(placementId, vungleBannerAd); everywhere, except for cleanLeakedBannerAdapters() when we know that it should be destroyed in any case. The reason is that previously there was only one VungleBannerAdapter for placementId and the call was safe. Now several VungleBannerAdapters can ask for mVungleManager.removeActiveBannerAd(placementId); on some callback delayed delivering in different cases. We have observer it on refresh when old adapter instance get onDestroy() call later and that was the reason for setLayout() call and 'if (adView == mAdLayout.get()) {' check.
URL in hashset?
Should not catch to just re-throw.
We have the ability to parameterize some classes per upgrade pack. Do we need to consider the case where an UP defines an Ambari class with properties? Should open a jira if you think this is something we need to allow.
Minor suggestion: Instead of needing to check the size and each individual entry, could you build the expected config map and then do an equals check?
I have tested on a YARN cluster, it could not take effect here. When i cancel the Flink job, the application status is still FAILED.
Not sure where the conventions are from, but this should be made consistent with the other places as:  if (data == null) { throw new NullPointerException("data == null"); }
tracing() is never null. If tracing is disable, then cr.tracing().isEnabled() returns false. I would remove the condition and always configure tracing. Conditionality should happen on a different level.
This looks identical to the code on line 88. It would be better to have this as a method since the code is repeated. Also, if this is a separate method, it will be more easily unit testable (though unit tests are not required)
please restore single node verification to use ==, it is more concise and shorter and performance is better.
Code style
shouldn't we return immediately if we know this fails.
I think this can't be null.
Can we discuss this part when you get into the office, for me to get a better understanding of this patch?
What's this change for? Refer to #54, please.
strange place for a linebreak here
The {style} (without capital) is missing ... See table 32 in the WMTS specifications.
Should it be Resteasy with Eclipse Vert.x here?
Does this have to be synchronized? Why not do the post-check after the submission and remove token+message pair?
It seems that you don't have to write a new separate method and call it.
I'm not clear on whether the reference here can be null, which should likely be protected so we don't obfuscate the runtime expresson. I think "toString()" is an implicit, here so it may not be necessary anyway.
<LINK_0> Since they are more methods than variables, should we base it on MethodDefHandler instead?
Since this is DEBUG, I don't know if it would make sense to log the full, unsafe map in addition to / in place of the map with unsafe keys replaced by the placeholder. I'm thinking that if we actually wanted to look at what's going on, the world might well be on fire. (Definitely non-blocking though!)
If waitTimeout is what I'm understanding, i.e. the maximum time to wait for the request to be returned, this code doesn't do as expected. It doesn't count the time spent on doing real request, wait & process the response. It only accumulates the pollingInterval which is sleeping time between requests.
return DataTransactionBuilder.failNoData(); it is a kind of fail because they tried to remove something that is not there
would this provide better readability? java public List<InputSplit> getSplits(JobContext job) throws IOException { List<InputSplit> fileSplits = super.getSplits(job); Configuration hConf = job.getConfiguration(); boolean copyHeader = hConf.getBoolean(PathTrackingInputFormat.COPY_HEADER, false); List<InputSplit> splits = new ArrayList<>(fileSplits.size()); String header = null; for (InputSplit split : fileSplits) { CombineFileSplit combineFileSplit = (CombineFileSplit) split; if (copyHeader && header == null) { header = getHeader(hConf, header, combineFileSplit); } splits.add(new CombineHeaderFileSplit(combineFileSplit, header)); } return splits; }
Is this right? We want to call getTimestamp for both TIMESTAMP and DATE meta types?
Could you give MessageInfo a toString method and use that here?
There are no email clients installed. Move this in strings.xml.
Add a check here to verify that the broadcastSerialDataReceived method was not called.
no need check for null, task will be usually created, if it is not we have a bug and these should be solved
Add more information in the log message, like backup attempt failed for which snapshot, how many attempts left for retry etc.
It is totally useless
The break without the label would also terminate the for-loop not the while-loop. Why is this label necessary?
Response is not closed if code below throws
Please mock :D
You have slf4j logger defined up there
Could use Strings.isNullOrEmpty
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
maybe invert here so that true = success and false = failure?
not a good idea. you're introducing un-obvious coupling here. I should remember that blah here means the same as blah 8 lines above. If in the future I want to change it here, I should find the place above, in order to make this test still valid. use a variable instead. the same for other methods and constants
Which exceptions is this try/catch trying to catch?
return is not needed here and creates a lint warning
Why UNAUTHORIZED?
Navigating again?
I think the error message should be more meaningful like non-exclusive subscriber received messages. WDYT?
No, this method should not throw interrupted exceptions.
Whitespaces after colons.
May be it makes sense to leave this check if it's not too heavy? Or leave it here by default and add a flag to skip the check as soon as it is not needed?
Do we need a lock? Could we use an optimistic "update where" & react appropriately if the update fails to update any rows?
It is better to :  java Pool bonusPool = getBonusPool(existingPools); if(bonusPool == null) { //create bonus pool } else { //update pool if needed }  this way we: - iterate through pools only once - get to clean up the hasBonusPool method
extract in method formatIgnoredConditions
This shouldn't be correct, we want the main artifact AND the classified one...
how many? should we limit these more?
I think this message should change, we could get a NullStage even for a wrong stage counter.
1. "refs/notes/" could also be excluded 2. Would it make more sense to check the opposite: if (!refName.startsWith("refs/heads/") && !refName.startsWith("refs/tags/")) { continue; } I guess it is more likely that in Gerrit we will introduce a new "refs/xyz" namespace which will require change here to add this exception than that Git will introduce a new namespace for branches or tags. Alternatively, instead of using getAllRefs() and then filtering out what is not necessary, we could use getRefs(Constants.R_HEADS) and getRefs(Constants.R_TAGS) to fetch exactly the (sub)set of references we are interested into.
will this work on a cluster with namespaces enabled?
Could use Collections.singletonList()?
I was looking at this and thinking about how to eliminate the duplication of readString("object-id[@pub-id-type=\"doi\"]", assetNode) and would like to suggest:  java if (GRAPHIC_NODE_PARENTS.contains(nodeName)) { doi = readString("object-id[@pub-id-type=\"doi\"]", assetNode); if (doi == null && nodeName.equals(DISP_FORMULA)) { doi = readHrefAttribute(assetNode); } } else if (ASSET_NODE_NAMES.contains(nodeName)) { doi = readHrefAttribute(assetNode); } else ...  Also cuts down one more top-level else-if, which is nice.
Please check if it is actually filtered (just to be sure)
nit: can use variable "image". (so does following 3 places)
It seems that expected is always the same as observed? If so, why do we have 3 parameters instead of 2?
Concern of localisation as before
Above calculation will always be 1, suggest to put some description why will it be 1 always.
Again, don't you think the checking the internalDriveMapping and put it in the hashcode is relevant here?
Local DynamoDB now supports Booleans, I updated it in the DynamoDBLocal repo
it's matter of taste, but instead enrichmentTagItem != null just true in this situation would be more understandable
To make sure that the try always throws an exception and hits this case, you should call Assert.fail at the end of the try. Right now, this test will pass if script.launch succeeds (it shouldn't since you corrupted the cache) _or_ if it throws the specific kind of exception you are looking for.
Isn't there an option to convert the specific value to its desired unit from the values map and then call the ExecutionMessageDirector.resolveStepMessage(stepType, values) instead of resolving the message first and then parse and replace part of it ?
Maybe you could use the new BranchEmail.getMessageClass() method to simplify this error handling (or something like it)? I hate to see this much code for an error message.
0? -1 doesn't make sense.
May be check for size>0 and log a severe message?
Same as above, please use the file name in the response ?
These is wrong, if you want to prevent hot plug you should add appropriate check to hot plug command - SnapshotsValidator.vmNotDuringSnapshot(), lock is used for other purposes.
It is good to have this condition to be checked only when ByteBuffer has any bytes to be read. So, It is better to leave where it is currently. It seems newly added conditional checks follow what InputStream#(byte b[], int off, int len) does but the above suggestions are valid for this scenario.
Does currentPlan.removeRebaseInteractivePlanChangeListener(this); need to be done here in case it's not null? (Or rather, should the lines below that do this be moved before this if.)
Please change the initial capacity of basicParameterClassList to 15.
(nit): not sure if this is any clearer that 1 (and 0) above.
My preference is to use org.eclipse.core.runtime.Platform.getWS() and getOS()
why not java for (int i = position + 1; position < arrayLength; i++) {  ditto for other implementations
Don't call ts.getParameter(key, ERROR) twice, put it in a local variable.
should build rather an immutable collection rather than using foreach to add to a mutable container
Shouldn't there be a null check here? clearSelection() does set the map to null after all.
This is also valid, but it looks not a good convention
I think the bounded case should have explicitly no checkpointing enabled, so that we have recovery that re-executes the fully (goes back to the beginning).
inet6Adsreess -> inet6Addresses
I'm starting to think we need more than just a backport... * We could get a SuspectException here, if one of the nodes crashes during execution * We could also get an IllegalLifecycleStateException in the callable if the cache is shutting down and the cache manager isn't (yet).
nit: maybe simpler to read (and no need for 'return') with if (!annotationList.isEmpty()) { call.addMarker(new InlineMarker(target)); }
I would apply the same logic to the Expires header
Perhaps word this a bit differently, Successfully loaded path %s after %d attempts? Also, is it possible for this to become spammy if a large number of files is to be loaded?
This is not a good practice to make a fragment static and reaching it with classname. You should use object oriented approaches instead. Otherwise it will cause leaks.
Not sure that we are testing all the possible situations there. On my side I also tested with the following cases, without encountering any issues:  ComplexNestedGenericClass v1 = new ComplexNestedGenericClass(new java.util.ArrayList<Object>()); ComplexNestedGenericClass<U> v2 = new ComplexNestedGenericClass<U>(myU); ComplexNestedGenericClass<? extends List<Object>> v3 = new ComplexNestedGenericClass<List<Object>>(new java.util.ArrayList<Object>());
It looks like indentation is too large here and below.
Use ButterKnife to annotate contributorName field, and these findViewById lines could be removed.
This could be "int" instead of Integer here, to avoid an unneeded boxing/unboxing (since it's only used below as an int).
String repos = group.getRepositoryDirectories().stream() .map(File::toString) .collect(Collectors.joining(SEPARATOR)); preferences.put(PREFS_GROUP_PREFIX + groupId, repos);
If the tree viewer's trace is null, it should have an empty input and no elements, why would it send any CheckStateChangedEvent?
any particular reason not to reuse the offsetVector?
We typically use IllegalArgumentException for these kinds of checks.
replace break with return?
suggestion List<RestEntry> entries = new ArrayList<>();
I think this layout should be called button_and_answer or something. I don't like suggesting that it's the "default" answer view.
The way I'm reading it is that the logic here flows as follows  if (requested resources fit entirely into available resources) remove the requested resources form the available resources reduce the total available resources by the requested resources reserve the requested resources so that we can use them return the reserved resources else if (there are still available resources, but not all requested resources are available) add an "empty" resource to the list of available resources for this reservation type reduce the total available resources by the amount of resources we are using here reserve the available resource so that we can use them later  I'm not positive I understand why we wouldn't just remove the entire resource by calling availableResource.remove(new ScalarResourceEntry(availableResourceValue)) (as is similar to what is done in the if) and why the else if requires that we pay special attention to the reservationType (where the if seems to ignore the reservationType until it goes to reserve the resources).
This bit shouldn't be required. If UnixSHACryptPassword extends AbstractPasswordImpl (as it should), then the method to convert it to a key spec should be right on that class.
Wrong indentation, code in condition might be mistaken for the code inside it. It should be: java if (uidIter != null && uidIter.term() != null && uidIter.term().bytesEquals(buid)) {
This code is not rebased on latest version...
Do we need to test the older API here, is it enough to just test the new revision has the correct attachments?
there is an extra ',' in the end here
This seems like an invalid state to me. You should be allowed to be in the same cohort twice, but not with overlapping dates. E.g. you'd need to end membershipAOne before starting membershipATwo.
I have some doubts that we need to update labels for the namespace where che server is running. Maybe it's the job of the operator or another deployment tool.
all getTaskState methods actually use the "getJobState" permission. If a user has the permission to read the state of a given job, then he can read the state of any of its tasks.
Rather than having this somewhat redundant single-use static method, I think it would be cleaner to remove it, and instead factor out the common initialization code from the constructor it's delegating to, and call that method from both constructors (this method would no longer delegate to the other one).
Again, not sure we should have ServletExceptions in the DSpace API module.
Why did you not use a Objects.nonNull(title) here like on other places and changes?
why change to , ?
wouldn't you want to see if the Router is still working properly?
The capture of metrics and some assertions can probably be factorized and not duplicated.
Space should be before the opening parenthesis, not after.
Asma, do we still need this code after edit policy change?
Please remove if not req'd
Shouldn't this be "memory" instead of "mamory" ?
you need to pass Statement.RETURN_GENERATED_KEYS as second argument (check line 55 on previous code)
UnchangedCommitMessage
Revert this formatting
Maybe add an assertion message: assertNotNull("message must not be null", message);
Not sure but I think it should be really the last one in the list, or?
This is a query in loop again. For large lists, this could be a performance problem. We should see if we can use the breedingMethodMap we already have available in this method instead.
This seems like a lot of work to basically always return new StringDimensionHandler(dimensionName, multiValueHandling), but I assume it's meant to be fleshed out a bit later.
If we are performance concerned, I would recommend adding  if (w.checkError()) { return; }  as no sense continuing if PrintWriter has already suppressed the IOE
spaces between expressions please: (startIdx >= 0) ? (startIdx + 1) : startIdx; here and below.
AppLog.e already logs the stack trace, so e.printStackTrace() isn't necessary here.
what's the reason to need to change this?
this if can be combined with the if starting on line 162.
Replace the 1 with a constant that describes what actually that value is?
We shouldn't care about source in this context. If resolvedOafObject is not null we are fine.
please rename to match the action: activate/deactivate
I think you can move the message into the IllegalArgumentException exception. The log statement is optional.
nit: acquire the a new lock
Formatting issue. Extra space before ==
The list of hardware profiles should also include the cpu. I see two things to improve here: - Provide more cpu/ram combinations (otherwise is not enough flexible), such as providers like CloudSigma do (those also have hardcoded hardware profiles). - Create a Supplier<Hardware>, qualified with something like @Default to avoid collisions with the jclouds hardware supplier, to let people bind their own hardware profiles if they need different ones.
This would mean, all access to WindowCache started *before* the job runs will use *not* the settings from current workspace. In worst case this can lead to crashes on Linux / Windows, where mmap access could be configured differently as expected.
Can move this block above
This is quite different from how the blog title is set in [refreshBlogDetails](<LINK_0>
My fault again - these do need deleteOnExit, or better yet unset INDEX_ON_THE_FLY except in one test specifically for the index case.
if we have this mergeConfig() method, then all the BuildConfig fields should be Optional<> to make merging easier
Missed this before: inject an ObjectMapper here rather than creating one.
there is no need to create a geometry factory for every request, i can be a static final field
This effectively overrides GWTP TabContainerPresenter#setInSlot(IsSlot<T>, T) method, which looks like this: ... try { Presenter<?, ?> presenter = (Presenter<?, ?>) child; TabContentProxy<?> proxy = (TabContentProxy<?>) presenter.getProxy(); getView().setActiveTab(proxy.getTab()); } catch (Exception e) { // We can't cast, no worry, we just won't highlight a tab } ... The try/catch block will also catch java.lang.ClassCastException so the instanceof check is actually redundant here, so I'd recommend to keep the code as before. The typecast will fail only if a non-tab Presenter is revealed into this (tab container) Presenter, which indicates a coding mistake.
nit: please pick more descriptive variable rather than r
Here we should return the SUMMARY_ORGANIZATION profile rather than the SUMMARY_STATION profile.
I feel a lookup table is justified here. We can generate the lookup in a static constructor and populate it with the sine and cosine values for 0-360 degrees. Seems like a simple optimization that prevents a lot of heavy math.
nit: previously this function always returned a string; now it's returning null? Might be safer to just change the usages of .charAt() here.
just nic instead of nicRef ?
nit: is there a reason we can't use e?
Just "true" or Boolean.TRUE would be better here.
Since there are two key sizes, there should be two algorithms: "sha-256-crypt" and "sha-512-crypt" look like sensible names.
The default in TableMetadata is RETRY_ON_WRITE_WRITE, is this intentionally different?
assertTrue
As we also pass the response object around, is it possible to get the content size from the response object instead of passing contentSize?
Use setClass method if possbile
JSON supports int and float as number types, so could leave the conversion to strings away. This would result in "statusCode": 1 instead of "statusCode": "1". But maybe a matter of taste?
bad rebase
insert a checkArgument(ttlTimeProvider != null, "ttlTimeProvider" ) here
equals(), not ==
int enbale = 1;
Minor: the three logging statements in this method use three different conventions when referring to interfaces: "does not implement ..." vs "does not implement an interface with name ..." vs "does not implement the expected interface ..." What about unifying this?
This should be the same functionality (do we have a test covering a change like this?)
If you have more than one thread waiting in take() or blockingPeek(), this will wake up only one of them. Shouldn't it be signalAll() ?
I don't really like this. The goal of these samples is to stand alone. Any alternatives?
Seems like this method would be good to have protected and non-static, so people could override the combination algo.
Nit: can it be moved to the first place? In case it needs to skip action, it will save some some time to look up the table descriptor.
Why there is no interface for BlobStoreCompactor? Even if this is tied to the BlobStore Implementation, we can think of people wanting to have their own implementation for compaction. For eg: please take a look at how hbase has an abstract base class for Compactor and they have different types of Compactors implementing different types of compaction. May be writing a single page impl design doc upfront would have been nice.
Do we want to check for possible null values in sl.getIdentifier() and sl.getDisplayName() and fallback to empty string ""?
destination.getParent() return the same thing but is more readable in this context I think
warn ?
Let's move this above any other work
ideal candidate for a method ex. addRealmParameters?
As with other places, skip fields and don't add to map if empty strings.
Instead of Character.valueOf(char).toString(), just use String.valueOf(char)
Hi! This is the duplicate code
no need for the or, is has multiple arity.
this isn't right. Enabling autofixes disables the cache even if the file has no violations / no violations that are actually autofixable. We are reprocessing all files for no reason
Invalid reference to output of SELECT clause from grouping() expression in ORDER BY or something like it.
Please have static factory methods for calendars that take 2, 3, and 4 arguments. Consider placing them into a class Calendars that in the same package with Tests.
Consider changing the default pattern "\\s+"
same here with notebook instance
let's stream the topics and use a collector in the end.
I think you improve that now :-) ## Chico Sokol On Mon, Nov 3, 2014 at 3:59 PM, monitorjbl notifications@github.com wrote: > In src/main/java/org/mamute/search/SolrQuestionIndex.java: > > > - String answer = null; > > - List<String> responses = new ArrayList<>(); > > - for (Answer a : q.getAnswers()) { > > - if (a.isSolution()) { > > - answer = a.getDescription(); > > - } else { > > - responses.add(a.getDescription()); > > - } > > - } > > + > > - if (answer != null) { > > - doc.addField("answer", answer); > > - } > > - if (responses.size() > 0) { > > - doc.addField("responses", responses.toString().replace("[", "").replace("]", "")); > > - } > > Sure, there's a Guava utility that joins collections. I was just keeping > to the original implementation, but I don't mind switching one bit. > > - > Reply to this email directly or view it on GitHub > <LINK_0>
Shall we use java 8 streams here?
Can we write Line 395-440 with one simple stream().filter? Nothing wrong with code itself but just a thought.
seems like getVm() can't be null here....it's checked within canDoAction
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
you can put the profile within the UserProfile class... you already had it no? and fail if no (return null from translateUser).
I think it might be better to use another exception specific to this case, something like LocalTargetUrlProxyException.
type can be encoded as a number instead of string, you can probably use ValueType.XXX.ordinal() as encoding. io.druid.segment.column.ValueType is an enum defined with the types.
perhaps export the length to a constant
Thanks for breaking this down into smaller chunks!
minor: We could decide this outside of the factory method to avoid "on-call/on-demand" instanceof checks
what about more meaningful variable name, instead of br, browser or currentBrowser?
Could move this line above line 232.
You can drop this logging here.
Just in case, I think you can search and replace to use your previously created enum SourceControl. I doubt we'll change the prefix, but just in case.
it's really hard to guess why oldDefault and newDefault are called like this
I'd like to see this refactored, it's a really long method atm.
I think this is a better way of handling the situation, compared to throwing the exception. Shall we remove the exception instead? If you do, revise Ui tests accordingly.
Might as well make a constant out of this
I would declare this variable inside the try / catch block too.
This is the place where the filtering should be moved to
This can be simplified using incompatiblePluginMap.computeIfAbsent.
I think this method should de-register the actor in the future and thus this would help explain the difference between contexts like this where the actor should not resurrect and sudden/unexpected suicides where it should. I'm advocating (perhaps not very clearly) that the former should call the method and the latter should be an unhandled exception. Also, in a future revision please make this method name clear; e.g. killAndDeregisterSelf.
get shell from control of current element, i.e. getControl().getShell()
This can go in the while() loop now and become final.
@vilchik-elena I would prefer avoiding a field (statements) for that.
separate this chunk out into a helper function
I was a bit confused at first, just because the root node isn't the usual jsRoot (the parent of all input files). Can we add a Preconditions check that root must be a SCRIPT node?
Is this block checked by automated test? How safe is the update here?
if the cookie doesn't contain '=', then it looks like an ArrayOutOfBoundsException will occur here.
It's more conventional to return 1 on failure.
How can you get here RunTimeException? if you can, isn't it better to set retValue to false here.
Sounds great. But what you think to change throwIfNotValidationException to receive only e.getCause and instantiate a ApplicationLogicException only in the 122 line? <LINK_0> Because this catch and the subsequent catch have the same logic.
add {} to avoid future bugs.
Yes indeed, my mistake
is it worth extracting this stream processing into a separate method and giving it a meaningful name?
You need to do the setTitle() on R.id.switch_logs.
I would prefer constant there.
use elements.iterator() (of type java.util.Iterator) instead of List.ofAll(). this will save cycles and memory
should you adhere to http policy? What if it is https?
How about something like this instead:  .split(this.clients, "iterator")  ?
Is it feasible to include the ResultSet in the try so it is closed via AutoCloseable?
Any risk in using !connection.isOpen() ?
typo
Also, perhaps the new setting should be mentioned in the commit message.
Error message should read:  Could not import "$class", class not found.
setField is meant for api fields. We don't want this as an api field, we want it as a internal flag. Instead use DataAccessor.fromDataFieldOf(v).withKey(VolumeConstants.FIELD_LAST_ALLOCATED_HOST_ID).set(newHost)
suggestion  I think we to make doRunWithObjectSafepoints private and the finally clause of doRun already does this. What do you think?
A bit hard to follow, but does make the following tests really easy
Please don't introduce such useless and unrelated constructs in patches.
IDE says that MalformedURLException is never thrown, so can be removed. Going further I'd replace listing all exceptions with one top level Exception.
Does that work without Kotlin on the classpath? Or is that class never even used then? Because otherwise it won't be able to be loaded, wouldn't it?
HBaseTestingUtility has some nice waitFor() methods which simplify this kind of logic
Locale currentLocale = getCurrentLocale(); here
This would be a good place to use a try-with-resources block: java try (ZContext ctx = new ZContext()) { Socket push = ctx.createSocket(SocketType.PUSH); assertThat(push, notNullValue()); }
BranchOperation locks resources and thus should not execute in UI thread.
nit: You may want to inline this method as it is just logging with log.error(errMessage, ex)
Just curious why you departed from using setField(... ?
Use 2 spaces instead of a tab character.
Weak test, content negotiation in OGC API services can also be done via "accept" headers.
We shouldn't do all of this ourselves. You can use class Properties, that does exactly the same, in one line "load(InputStream is)"
this if/else block is replicated below modulo a log statement. Private method?
Everything from here down MUST be in a try/finally block so that we cannot possibly leak that database connection. Right now if the patch set comes back as null (missing in the database) we'd leak the connection, creating an easy DOS attack.
As this class is abstract, I think this should remain protected.
These error message constants should be updated to say "constructor or static factory method" instead of just "constructor."
in this case it is more appropriate to return immediately (the item is an inprogress submission so to discover the right collection you should queries the workspace and workflow tables)
I'm wondering if we really need to recheck so soon - seems like we could recheck in a few seconds and still provide a good experience.
Rolling back this suggestion assertValidAudienceClaim(jwt.getAudience(), (List<String>) entry.getValue());
The exception shouldn't be silenced here?
Why not just log the duration?
need default case?
I would simplify the constructor - if the user has supplied an 'otherStatus', you don't need them to supply an operation status, you can automatically make that OTHER.
CloseableHttpResponse implement AutoCloseable. Replace finally with try-with-resources.
nit: spaces around /
revert this, as it's been fixed by Emi's changes for running equiv on full publisher
Maybe create a method isWindows() containing: System.getProperty("os.name").startsWith( "Windows" ) to avoid writing the same code many times
@danielezonca Pls check for null in e.getMessage; if null, provide a meaningful substitution
Is it safe to assume that this list is non-empty? If it's empty, then accountToUse will remain null.
Style-nit: Useless catch/throw. Just don't declare the catch, and it'll throw on its own to the caller.
This was in your original code, but puzzling nonetheless. What is gained by shifting the elements of the permuted list by 1 position before assigning them into the array? Why not a more straightforward element by element assignment at the same position? Is this known to somehow compensate for some known skew to the Collections.shuffle output? It seems arbitrary.
unnecessary brackets here ;)
Perhaps we should assert here that the size of keys does not exceed the IsStandard limits (15, I think?)
Reformat the code. There are two spaces here.
nit: IllegalArgumentException, Unsupported spatial join type:
Given that everything is in memory, a 1MB buffer seems large. Maybe something like 32k?... not sure this matters either way
attributes is deprecated. It's attributesToRetrieve now. Instead of manually mingling with the attributes, I would create a Query, call setAttributesToRetrieve() then build() and boom! here you go: simpler, more reliable.
WSO2
s/for/to a/
How do these pass Semaphore, which is running without campus VPN?
are you changing the field from non-required to required?
Do we really want to catch all exceptions here rather than just SecurityException?
This null check seems redundant.
take the if before try
I would use instead entity.getParent() instanceOf AmbariServer ? ((AmbariServer) entity.getParent()).getFqdn() : null;
In the main method, you used this without checking null?
Wouldn't it make sense to test first for value != null? That way you wouldn't compute that line all the time but only if necessary.
Shouldn't this be a constant somewhere
Need to retrieve cert's subject name instead of issuer. Here is sample code certification.getSubjectX500Principal().getName()
i think there is something missing here (or when you're building the queries). in gnocchi, if you dont' specify a granularity (<LINK_0>, it will return back all granularities associated with metric. if you're using 'low' archive policy, this is only one granularity and you're fine. but if you're using 'medium', 'high', and presumably any custom policy, it will have multiple granularities returned and if you ignore it or don't specify it, you'll be effectively squashing multiple series into one.
Can this go in RequestActionSupport
Why not call it map like in other uses?
How about extracting this lambda into a separate method? Then we could replace the lambda with a method handle to the extracted method. Let's discuss this separately.
bare in mind that, even if non-conventional, people may simply write @org.junit.Ruletoo
Reducto this duplicate line
I think technically this check is not necessary, since the remove() method says it removes a key if it exists and does nothing if not.
checkState?
This can just be named notesBucket.
because of compensation in this command its better to have this call in the second transaction below, otherwise handling will need to be added in case there is a failure later on
We probably need to have a getLastDescriptors.
Can be final.
I think we can just leave this additional fix in this PR.
Extra semicolon
This should at least be "Privileges required", but it might be better to do this in a localisable way as you did for the other ticket.
use {}
Still want this to happen with ops and indexing. It will be significantly faster. Have you looked at the put(INDArrayIndex[])?
Convert to switch for consistency?
It might be simpler to just do Set equality between provided argument names and the required argument names. If the sets are not equal - throw an exception.
Not sure whether we need to consider the precision of double comparison here. Generally speaking, when comparing double numbers, epsilon is usually used. <LINK_0>
Should we be reading the time from the scheduling block here?
superfluous newline
here's the fallback to not use SASI on duration (when we can't due to version). Since indexes are in a separate file, we should be able to more easily maintain them than the manually created indexes of the old implementation.
Can we shift all these methods (related to finding possible givers/recipients) into a new class?
The ResourceManager is a singleton, so storing a command specific state in it could cause a race condition. The same state will be visible to multiple instances of this command at the same time. The state can be stored in the command parameters. They are serialized to the DB, and they should contain the same data when one of the async methods is called, endWithFailure() or endSuccessfully().
Why have another level method redirection if nothing else is in it?
I don't think this is correct. Are you sure every available geocoder use the same key?
Can we throw a specific exception throw new NoSuchTemplateException(templateName); as we do for invalid agent <LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "add" method. [![rule](<LINK_1>](<LINK_2>
for (int i=0; i< bricks.size() ; i=i+volume.getReplicaCount()) { List<BrickProperties> set = new ArrayList<>(); int replicaCounter = 0; while (replicaCounter <volume.getReplicaCount()) { if (!brick.isArbiter) { set.add(bricks.get(i+replicaCounter)) } replicaCounter++; } replicaSets.add(set.stream().map(field)); }
Should be || ?
Is there any reason that we need to expose the sortCacheTable in Definition with a getter? If not, what about only providing methods to put/get key/value of the cache table and do synchronization inside those methods?
It will be better to combine the 3 asserts above? I still don't see a compelling reason of using asserts at runtime? Do these asserts have the same semantics as the asserts in test frameworks? In that case you wouldn't want to halt execution and instead do exception handling.
action.isSetHost()
should it be wrapped with the ConditionChecker and wait for it for some time? (I think it works in an async way)
This is a confusing noop since reportInternalServerErrorOverSideband() doesn't use it. Maybe complete the change here and replace reportInternalServerErrorOverSideband() with errOut.write()?
Shall we make this private as discussed?
I think it's better to log it through OpenShiftIOUIActivator
i think this collection contains the set of results to return to the client, but we are actually interested in the number of cells that were filtered out (I guess postFilteredCells is kind of an ambiguous name here).
Utils.validateArg
suggestion return tx.run("CREATE (v:VersionedThingWithAssignedId {id:1})").consume();
Is this the same list of extra components for the bookie?
space
Up server check is already done in superclass. Can remove from here.
if (".".equals(dot.getText()) is definitely more readable than reaching out to the Objects class.
You can also use 'runInternalMultipleActions'
Is it worth discussing this case for **?
Both client and response should be inside try-with-resource.
This does not work. It returns something like ClipData{...}.
Is this a Java Future? It is much less powerful than a CompletableFuture or a NettyFuture.
Can we rewrite this statement to make it more readable:  (nop || (!cacheRegistered && !(op instanceof SchemaAddQueryEntityOperation)))  We want to say here: Complete the future if 1. There is no operation OR 2. Cache not registered AND operation is not SchemaAddQueryEntityOperation
It seems silly to collect into a list, only to use it to stream() right below again. Can we combine those two collects?
rename ruleInfo2
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
The test case is ok, but I'd fix this differently, since root path usage is only one case where this breaks. Maybe  Integer sqlType = null; if (path != null) { ColumnMetadata metadata = ColumnMetadata.getColumnMetadata(path); if (metadata.hasJdbcType()) { jdbcType = metadata.getJdbcType(); } }
why not assertEquals(classpathExpected, classpath1);?
Again, the repeated put statements.
change it to debug level
declaration and assignment can be combined
Why remove the sort?
Needs a return statement?
open files?
suggestion topology.addVertex(nodeVertex);
The invocation needs a mod instance, I think
Magic number?
Declare as Set
If these print lines are still needed, please add them to the logger
Table commonCourts has three elements, but here you only use two.
It'd be better if an early return that checks if the method [XmlPullParser.isEmptyElementTag](<LINK_0> is true so that the intent is clearer.
Is there an extra newline here?
We can probably declare only Exception as thrown here.
I just saw that we seemed to forgot to convert that old swing dialog here. Could you please fix this as well? dialogService.showErrorDialog or so should work Thanks!
I would go with stream iteration here java titleList.stream() .filter(x -> fieldApprover.approve(x.getDataInfo())) .findFirst() .ifPresent(x -> metaBuilder.setTitle(x.getValue()));
If we can't omit /costumize validate() either at store() nor at flush() I suggest adding the following to the beggining of AbstractDiskModel#forceCreationWarning(): if (getConfirmWindow() != null) { return; } This will prevent creating two different confirmation windows without using the new outside variable.
If the text is used as part of the message for an exception being thrown it will follow "An exception occurred ". The way it is formulated now, that won't give a clean exception message. Something like "replacing keys on the device" looks more in line with how this text is treated in other places where throwExceptionIfResultNotOk is called.
Permission is only required starting in O, hence the check. That aside I'm perfectly fine with removing it altogether since I don't think the serial gives us any valuable insight.
Typically, we check for <applicationname>-<profile>, <applicationname>, application-<profile> and application. Those with <profile> we check each profile from a comma separated list. Does this do that?
When we list the participants, the ones without a name should be listed with IDs. Perhaps we can handle this by modifying Participant#getName, or handle it here?
Iterables.getFirst
This is going to be hard to trace in multi-user environment. Compiled model for what SQL? Which FD?
Why rechecking?
foundService or existingClusterService?
Could you make this more consistent? Currently one stringifier is in a local variable, while the other is referenced directly.
nit: This doesn't feel necessary - is there a reason why you can't just pass in local and remote (mapping away the WithExecutor) into the constructor at the end?
Could you please add asserts for remained avro types?
This will cancel the entire worker, not just the recursive action. If one uses a scheduler for general scheduling tasks (instead of an Executor) this will disrupt the worker. This is one step better, but for the 100% correct version, a new subscription type is required.  java public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) { final long periodInNanos = unit.toNanos(period); final long startInNanos = TimeUnit.MILLISECONDS.toNanos(now()) + unit.toNanos(initialDelay); final MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription(); final Action0 recursiveAction = new Action0() { long count = 0; @Override public void call() { if (!mas.isUnsubscribed()) { action.call(); long nextTick = startInNanos + (++count * periodInNanos); mas.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS)); } } }; mas.set(schedule(recursiveAction, initialDelay, unit)); return mas; }
assertEquals(ErrorResponseCode.INVALID_ID_TOKEN_MISMATCHED_CLIENT_ID.getCode(), responseData.getError())
It seems a shame to introduce a WikipediaApp dependency to obtain the screen density. Consider a small refactor of getContext().getResources().getDisplayMetrics().density; from WikipediaApp to a utility class.
I'm kind of debating here. On one hand, looks short&nice. On the other - this is essentially .forEach() masked to map() to make it intermediate operation instead of terminal operation. The debate is: separating steps makes reading code easier but it results in couple extra lines. Personally, when everything is one concatenated chain of operations it looks cool but hard to parse whats actually going on in the code. Open to discussion.
readability of this test would be increased if you named them createdRefund, submittedRefund, refundedRefund, errorRefund or similar
Might be a lot more efficient to make fewer writes. Unless the stream you're immediately writing to is buffered.
Let's add this log as well. This may be useful for some users.  logger.debug("You can disable this check by adding this line to your GWT module:"); logger.debug(" <set-configuration-property name=\"verifyNewerVersion\" value=\"false\"/>");
Should use all lowercase, as people may reference this test for examples and think that using uppercase mod ids is okay when it isn't.
Following code seems more clean to me  java /** * Gives the preferred video url for downloading from a specified {@link VideoData} object. * * @param video Data of the video whose preferred download url is needed. * @return download url of video, return null if unable to find any suitable url for downloading. */ @Nullable public static String getPreferredVideoUrlForDownloading(@NonNull VideoData video) { String preferredVideoUrl = null; final VideoInfo preferredVideoInfo = video.encodedVideos.getPreferredVideoInfoForDownloading(); if (preferredVideoInfo == null || TextUtils.isEmpty(preferredVideoInfo.url) || video.onlyOnWeb) { preferredVideoUrl = null; } else if (!videoHasFormat(preferredVideoInfo.url, VIDEO_FORMAT_M3U8)) { return preferredVideoInfo.url; } if (!new Config(MainApplication.instance()).isUsingVideoPipeline()) { /** * If preferred video url for downloading has HLS format and * {@link Config#USING_VIDEO_PIPELINE} feature flag is disabled, try to find some .mp4 * format url from {@link VideoData#allSources} urls and consider it for download. */ for (String url : video.allSources) { if (VideoUtil.videoHasFormat(url, AppConstants.VIDEO_FORMAT_MP4)) { preferredVideoUrl = url; } } } return preferredVideoUrl; }
We have FileUtil.detectedOS.isWindows to show whether we are on Windows, no need for separatorChar magic.
The code elsewhere in this plugin has preferred is rather than equalTo. Since this is comparing strings, could you switch it to use is instead of equalTo? suggestion assertThat(result.getArchitecture(), equalTo(expectedArch));
Need the created timestamp here instead of fe.expiryTime
marking @Nullablewhenever it is possible. IDE will help a lot to warn null check in invokers.
It should be Could not get launch config for server {0} to attach remote debugger, should it not? This way it would be in some way related to action 'Attaching remote debugger' and it would by obvious why it cannot be attached.
probably worth exploding here so things fail fast.
Since this line is removed: BackupWalletDialogFragment.show(getSupportFragmentManager()); the backup dialog is not shown until onResume() is called.
not necessary - it defaults to TIMESTAMP DEFAULT CURRENT_TIMESTAMP
Why not just else? As there is only 2 possibilities
I'd probably include a baz here, too.
(Occurs, occurrence, and if you would like to get fancy, coccurrence in UK dialects.)
This is a throw-away array allocation on what might, given the class name, be the hot request path.
I think next one is more readable:  java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());
Having no certificateVerifier is a bug on our side ? Why should we launch a BAD_CERTIFICATE error ? internal error would be more appropriate ?
This should be outside the if-else?
Could we just return if fields== null instead of nesting the for loop?
I meant something like : assertTrue(expressionEvaluator.evaluateUnaryExpression("? = 1*?", BigDecimal.valueOf(2), BigDecimal.class));
We shouldn't rely on a hardcoded binder name here.
Style: Y u change '!=' to '>' :-/?
Do we need to get all the configurations for an Integration Service when listing?, the resource is using this method to return the existing services and I guess will be used by the listing portlet, I don't think it needs to get all the data for all the hosts, we just need the basic service data in here for the listing.
The behaviour's probably the same, but is there supposed to be a newline or an else here? That said, this would be best represented with a nested if for the courses empty check. Also, if you do intend to have this other option, do provide a more accurate message. It's the lack of permission to modify the courses' sessions, rather than the courses themselves. I do wonder if it's better to use a single message for both cases, though, like maybe "No usable courses found!". The instructor should have the same capabilities in either case. This can be a new issue.
FYI: hudson.Util.filter is very useful! This could be written like this:  for(TriggerBuilder ctb: Util.filter(cbs, TriggerBuilder.class) { ... }
I doubt it works reliably in all cases, because the file can be technically replaced by an older one (e.g. move operation). I would expect something like Map<File, Set<Long>>, where the set stores modification times or even MD5s of the files.
shouldn't this be connector key? Just wondering...
size before sounds better to me.
Should be a for loop which iterates on all the converters, rather than a converter != null thing...
Due to the return in the if block, the else is not necessary. Omitting the else reduces the indentation for the following code.
BTW SemaphoreStep is usually helpful for things like this.
Do you realy want this assertion? When assertions are enabled, this can create some problems.
Perhaps you can use an 'explaining variable' to clarify what regkey == null means. <LINK_0>
Don't we want this to run on linux as well?
Need to change it to java8 lambda expression.
should this be true then?
unnecessary casting
messageString will always be null here, is this on purpose? If so, perhaps just passing 'null' as a parameter would make it clearer?
I assume this is just a short term fix. We can't force target wizard providers to use this category. They may already be using a different one. We should really be doing a new wizard that can forward to an wizard that the target provider provides.
Shouldn't this all be in an "else" statement? Do we support moving a host to non-operational twice, showing two reasons?
The throws needs to be based a specific exception.
I don't think this prefix is necessary. I suspect most people will want to copy only the sha1 so they can paste it into a command line.
else if
Remove //modified harsh.
Can this be moved up alongside the screenshotSaveVerifier checks for simplicity?
It would be nice to have a test for this "recursively rename submodules" functionality too.
This seems to duplicate getFullExpr from Block.
You should create a constant for containsOnlyReservable
Instead of the encoder use the DecimalEncodedValue:  edge0.get(encoder.getAverageSpeedEnc()) edge0.getReverse(encoder.getAverageSpeedEnc())
It is generally good to avoid mixing different works in PR :)
should you throw the multipliers into a constant? I see you're reusing them in a few other spots
As this is under the synchronized (lock), is this synchronized required?
Can this repeated part be wrapped into a function?
If I undrestood it right, we want display.timerExec(X) here. X can be 50 - 100 ms. I probably would prefer smaller values.
I think I'd prefer to do something like this: java Response res = allHealthy ? Response.ok() : Response.status(503); return res.entity(response).build();
Copying numRows and numBytes is insufficient. aggretated should be set as the stats of resultTableDesc.
This line is unnecessary since this is the default behaviour of the mock
Why is this unknown? Can't we have 1 tick per task in the map? + some work for the context store?
Ya @Value with @Builder seems more appropriate. Better thread safety and invariant guarantees.
Please use request.getTitle() instead of feed.getHumanReadableIdentifier(): In this case, feed does not have a human readable title yet
Seems like this logic is duplicated in a couple classes, lets see if there's a way to simplify
Null-checks for both getCurrentFragment() and recyclerViewLayoutManager wouldn't hurt here.
What about "solved"/"rejected"/"candidate"? This is a big commit and I may have missed those, or maybe the gene/variant design has changed?
Same here, common case first?
Should this delegate for flush and the other forms of write, too?
If userData is still not a SolObject at this point we should break / return -1
does it need 1s? Can we give it 1ms to speed up this test? This 1s might slow down my fancy new compute to run tests. (The minimal legal value server accept is 1ms) Similar for the async one.
Does the code actually nest patch scopes like this? I thought patch was the parent scope - but child scopes were always normal request scopes.
nameToken shouldn't be null or empty now, and the content of the conditions is the same. You could create a method like this:  private boolean localeAndNameTokensAreNotSame(nameToken) { return (localeHelper.isEnglish() && !NameTokens.isEnglish(nameToken)) || (localeHelper.isFrench() && NameTokens.isEnglish(nameToken)); }
file separator? BTW what are you doing here?
I thought we wanted to code the list of redirects as a JavaScript constant in order to avoid this sort of middle-tier support? What if we just have a redirectList.ftl that says  javascript var redirects = {};  in the webapp and override it with the actual stuff in plos-themes?
Shouldn't be here "firstResult, maxResults" instead of "null, null" ?
ObjectMapper is threadsafe so you should just create it one time for the class so we don't need to re-create it over and over.
nit: maybe use newSingleThreadExecutor() instead? (for all similar places in this file)
suggestion if (StringUtils.isNotBlank(userCoreCacheIdentifier)) {
Should be isWindowsDesktop() -- otherwise users on e.g. Windows using Chrome to access an RStudio server on Linux won't see this option.
Are NotFound and BadRequest not already covered by the WebApplicationException catch-all immediately below?
why do we still have a condition on getParentCommand() ?
As a practice its a good idea to call commit on a connection that is returned from the pool before performing a SELECT operation. This ensures that any uncommitted data will not be returned by the DB. The pattern to be used therefore should be,  try (Connection connection = GatewayArtifactsMgtDBUtil.getArtifactSynchronizerConnection(); connection.setAutoCommit(false); connection.commit(); PreparedStatement statement = connection.prepareStatement("SELECT ...")) { }
you should go into vdc_options directly.
I believe this is a problem and is related to some review bug we had quite recently? 'L' vs no 'L'
Should this line be moved up, too?
Change this conditional to iterate with a counter from 0 to length, and check the counter rather than 0 in the lines below.
Aren't these two lines are unnecessary?
nit: use "module.exports.".length so it's clear where that number comes from (likewise 2 lines down)
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
You can do java Integer.valueOf(0).equals(categoricalValueId) ? null : categoricalValueId)
Is it really useful to list all this if it's going to be filtered?
I'm not sure I love the lenient check, I'd prefer checking that it.trim().equalsIgnoreCase("1") and the same with preview below.
Make sure pageBuilder is in a consistent state before you throw. i.e. You probably need some code before throw Throwables.propagate(throwable). In addition, since you are refactoring this code, remove usage of the deprecated function propagate.
Not to be picky but why do you have switch here?
Do we need:  String algorithmName = evidence instanceof AlgorithmEvidence ? ((AlgorithmEvidence)evidence).getAlgorithm() : null;  ?
Since they occur in both cases, these should be outside the conditional. Also, a direct method reference can be used.
Please format this like:  Settings settings = Settings.builder() .put("client.transport.ignore_cluster_name", true) .build();
Guessing this is just in here for testing? Probably don't want it re-retrieval the datastream profile.
Would drop this assert, for reasons mentioned above in similar tests.
With "for" loop usage this can be reduced to one line. This is the standard idiom here: for (ZipEntry entry; (entry = zip.getNextEntry()) != null;) { [...]
If you do the class check you can omit the instanceof check. But I would prefer if you use equals instead of ==, because in OSGi you might actually have the same class provided by different class loaders. So something like this should work in all cases: GeometryCollection.class.equals(geometry.getClass())
What about using constants somewhere for version numbers?
please extract the getModel().getIsSubTemplate().setEntity(false); from here and from line 96 before the if statement
not sure if this should be a preference
rename to os
We might want to add a log here for HEs.
Based on the eclipse output you only want the conflicts to be highlighted, not the entire tree. I'd advice to add a screenshot of the result to ensure we're working towards the same result.
No spaces inside round brackets.
you can get this value from the Entry instead. No need to traverse the map again.
can we reference the class directly?
method reference? asking
Pease rename the variable transformer into the kind of transformation. Do not suggest OptimusPrime or something :) Tell what the transformation does.
Again about using TaskConfigurer
This should not happen on the client side.
We should use java resource handling here. I know it is not possible with the current tool base class, should we change it?
This button should also be "re-enabled" when the Messages tab is hidden, otherwise, if you have the Messages tab selected and then hide it, the export button shown/enabled is the Messages one instead of URLs.
Remove this. This suppresses test failures.
Can you please move this logic to a method to improve code readability?
Why not just return the result: super.view(mission).getAsJsonObject(); There is no need for this variable.
Sorry for the late review, I was working on getting stetho-1.2.0 out with a much improved API to support this kind of customization. I think we can now approach this with a new, much stronger API:  new DefaultInspectorModulesProvider() .provideDatabaseDriver(new ContentProviderDatabaseDriver(...)) .finish();  This implies that the default provider is install installed. If the default is to be configured, they can use the existing (as of 1.2.0) method .databaseFiles(...) and just provide a no-op files lister.
Similarly to the reader side, in the writer we want to transparently support either representation in the memory/Protobuf model (user can put the native part either in the string field requestNative or the object field request) but the output will be always the same, and that should be the most standards-compliant representation which is (even after OpenRTB 2.4) the ugly JSON-escaped string field. However we want to support a child object representation too, but the right way to do that is not by binding the output format to the user's choice of requestNative vs. request; this choice must be independent, it's a convenience and performance feature: when you create the native request programmatically you want to always use requestNative, but when you already have the complete native request as JSON (e.g. you may read it from a database of campaign data), then you want to just copy that to request. In the reader we could handle the external-format choice via detection, sniffing the first token or character; in the writer we can't do that, so the only solution in this case is adding another boolean option to the factory. Above I had suggested an option named forceReadNativeAsObject, but we could have a single option that does the job for both reader and writer, maybe just nativeAsObject. Usually you will have the same choice for the request and response, it would be strange to use the standard escaped-JSON form in the request but send the child-object form in the response for example (if someone really needs that, then just create two factories - so we optimize the API for the common case).
java } else { issue.setAssignee(null); }
nit: can directly use buffer(byte) instead of writeByte
space after if before (
After use the SSH session should be closed: sshSession.close() Not sure if this is really important though.
CloserUtil.close
Please format all Java code at 2 space indents.
Should this actually be hard coded to localhost?
We can have getter for the host we should not expose map to the outside world.
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this with a call to the "toFile().exists()" method [![rule](<LINK_1>](<LINK_2>
#1585 will replace these, right?
Maybe clientQuery should store an AnalyticView (since that is all they can query) instead of a Table.
Correct me if I am wrong; but organizationalUnit.getRepositories() returns all Repositories associated with an OrganizationalUnit whether the current User has access to the Repository or not? You are safe using ouService.getOrganizationalUnits() as this only returns "authorised" OUs. Do you need to filter Repositories here?
isNullOrEmpty check is not necessary if you're using StringUtils.containsIgnoreCase as it checks for null
Add one more indent for parameters if they start a new line.
We already have a method WalletApplication.eraseAndCreateNewWallet() that handles removing the wallet. This method does not remove any other files (such as the logs, which we want to keep in the event there is an issue with the wallet reset function). Additionally, it will create a new empty wallet. Another place to look that handles this is when the PIN is entered incorrectly to many times in is in PinRetryController.showResetWalletDialog
Propose to make this put(Collection<LookupExtractorFactory> lookups) and make the LookupExtractorFactory have a name. If the internal handlings of this class uses a map (probably) then that's fine.
I don't believe we need to manually calculate everything here. We should be able to just throw the collection at the HashCodeBuilder like we do with content.
This is a nice attention to detail but I do wonder: - Is this something people want? Is this worth adding an extra permission for? - Do we consistently vibrate on CAB display throughout the app? Sorry if this came off as a negative. I don't object to this feature but felt it was worth asking about.
Does this correctly handle the 2.0 case, which is a different security realm by default?
EventDAO can have a delete by user for example, done via JPA delete.
Use logger.error() instead of e.printStackTrace()
I would change this (and Get response {}) to .debug or even .trace
Why is this assertion error thrown after removing the ban? Or asked in a different way: Why do we even attempt to ban a user with a null username?
We decided not to use these plain sleeps but rather wait to specific thing. Please take a look at other tests in the class. You can do something like waitFor(() -> assertThat(MoreStatus.TOO_MANY_REQUESTS.getStatusCode(), client.getResponseCode()));
Would be nice to make "superSecret" a static final constant
Can we make this not double negative way?
Please remove the extra blank line
There's quite some duplication with MethodOrderingVisitor. Have you already tried avoiding that?
this is kind of weird and i am sure I am not understanding it correctly. but if this get method already returns a value, then setting would just be redundant. Unless of course this isn't a typical java getter in that its actually going to some external storage to retrieve.
should be easy to register all persistables using PersistableFactory.getInstance().getClassIdMapping().entrySet().forEach(e -> kryo.register(e.getKey, simpleSerializer, e.getValue())); in place of specific concrete class registration.
Could you also use a cache mechanism here?
We should not initialize resultStorageEngine. Please refer, how we initialize AsyncQueryDAO in Standalone and Spring. We should do the same. <LINK_1> <LINK_0>
I would create a new method to convert days in milliseconds, something like daysToMilliseconds(int days)
i'd use logger#debug in both cases... what do you think?
There's a trick here: Named Styles are compatible with CSS, which means that if a CSS exists and declares the "delta" property, the IntValueStyle will be non-null. However, it would be a transient style, so any changes to that style would be ignored. Since we want this value to be user-driven (And not CSS-driven), you need to iterate on the View's style list manually (Instead of using the getNamedStyle method)
I'm really not sure that using a Condition is more readable than testing individual fields. I would go for a series of: assertThat(gelfConfiguration.getQueueSize()).isEqualsTo(10) ...
Similarly, I think this should either test that the two reads are mapped, or explicitly state that the read must be mapped.
applicationId > 0 isn't it?
Do you think it's worth using StringUtil.parseInt(<...>, 1000) here, just to avoid a potential exception from a parse failure? (It looks like invalid options are handled in the dialog directly but being paranoid doesn't hurt here)
This variable is not used any more, can be removed.
Not a big deal, but in the future it might be useful to loop through the enum just in case we are forced to add another descriptor type down the road.
Does every Label in this class need this style class? If so, would PropertyPaneController Label be more appropriate in the CSS?
I think that this should fail if key is required. It looks like this will fail when key is not required.
Does it makes sense to check also that both config + devfile are not present?
Validate the input is exhausted
Can we change to  if(!query.equals(targetInput) || !targetCond.isAlwaysTrue()) { return null; } ......
@Serranya same here. See above.
why do we need "|| commonDataService.getWebClientProperties().isTagsAvailable()" in if clause ?
can we test head() with empty file?
Replacing string2DigitalValue with convertToSwitchOutput and convertToContactOutput is a bad idea because OpenClosedType is stored as 0 or 1. Furthermore I prefer the overhead of the Bigdecimal approach over the exception handling of the Integer.parseInt().
I believe the old code used to throw the OwaspDiffRunnerException when we did a .get() on something that was null so you can use orElseThrwow() instead of setting it to null.
Naming convention. getXXX returns a singleton. newXXX returns a new object instance.
If we aren't going to use it we should remove it
So I guess the automatic refreshing is tested in the integration tests. I don't think we necessarily need a unit test, just checking :)
How about if there are duplicated in the newBricks list? Is that possible?
This seems like a strange patter: we're faking a PendingIntentRequiredException just to launch the hint picker. Should we instead bubble up some event that will allow this to be fired from the ViewModel as normal?
I would say that stream != null is redundant part
try to use stream and java 8 instead of for each loops
the compiler warns that this exception isn't thrown by this method
Can you do in the same request? filter for all type or something
If you allow duplicate field names, this will match the first that is found and not touch the other one(s). Whereas before it would change every one of them. Is this on purpose?
final
s/.toString()//
Please remove this. Tests are by intent using a string and not a constant here.
I thought this solution would pop up. Do realize that instead of like 10 squares per dragon, you are now checking up to 100 players per dragon, which increases the amount of work by an order of magnitude. 100 is not much, but 100 dragons \* 100 players will grow quite fast. Scalability is a thing
The callers of this method should know where the root is. The EmbeddedServerFactory.create methods take separate params for jbossHomePath and modulePath, so the relationship between modulePath and jboss-modules.jar may not be fixed like this. But the relationship between jbossHomePath and jboss-modules.jar should be.
Don't just assertNotNull here. You have the proper commit and tag objects above (well, you threw away the tag). Assert that the values read from db are equal to the values you created in db2. That covers both the not-null did-it-create and also the did it copy as expected tests in one statement.
You could check the winding order of the holes here as well.
Can we not capture this condition as a final boolean by checking the return type in a CTOR (to avoid running this code on every non-null return)?
I could be missing something, but, other than the exception handling below, what is different about the bulk call over the iterate and delete. Both seem to do the same thing. bulkDelete seems to just iterate the environments, and call the same delete as the old loop with the transaction being on the delete call.
should also be StringUtils.isNotEmpty())
This method is to long divide into smaller methods
and yet, fyi, (after hearing Chris out) I have also come to prefer close-brace-on-its-own-line before else, catch, or finally, yet NOT before a (do's) while. This in spite of similar diff effects.
Attribute handling during git transports? Is this required?
it looks better with the padding :), feel free to add it to the PR
tumorSample here is not used
.git is not mandatory on github. will it work if I have defined project without .git?
Why was this added? The replaceTextBox_ already has an accessible label via the above FormLabel replaceLabel.
Why not name it from 0, like b0, b1, b2, b3 so that it matches the index of the array?
parallel stream?
use Hadoop constants here
May be its better to log the exception?
Hook up these bare "cwl" entries to AbstractEntryClient.Type (lower-cased)
This code is not easy to understand. Improve readability.
too big sleep. Please, add explanation why it is needed.
@jrmartin check if there's not a better exception to catch here
Do we still need to have a suffix in the table name for the other schema mutation lock code work?
You should probably log the exception as well.
We can replace iterator with for (String s : resourceAccess) {}
Concatenating the exception to the String here will just call toString() on the exception. That generally doesn't provide much information, so we pass the exception in as a second parameter to the warn method and the logging framework will print the stack trace for us. That being said, as I'm thinking about this more, I think we should maybe log the exception at DEBUG level and have the warn message just say "Set the log level to DEBUG for more information". Otherwise, this exception could spam the logs quite a bit, depending on the scenario.
Why is this check needed here and not elsewhere?
Very sweet.
As mentioned above, move those to the BenchmarkSuiteDao
I think this code would fail (with JBAS014803: Duplicate resource) in case deployment already existed on AS7 server (which is what happens when you deployed version 1 of your bundle with handedover deployment and afterwards you deploy version 2 of same deployment file name but different content)
Huh?!?!? What was wrong before? (Well, the logic is a bit weird anyway which is not your fault but why do we need to extract out to a local variable first?)
super.configurePipeline can throw IllegalArgumentException in case reference name is invalid. We should catch it and add to the collector.
I am thinking if it makes sense to write imperative for-loop here? -- My general preference is when Stream API is used in such a complicated way, it's actually more difficult to understand than old good for-loop. But it's just a personal taste.
Any reason you don't drop that into the cache before returning it? That way this method is "cache-optimized" on re-entry -- cache miss leads to lookup leads to cache save.
The lines above can be simplified using joml methods:  Vector3f min = new Vector3f(a).min(b); Vector3f max = new Vector3f(a).max(b);
deleteRequestInfo.replica could simply be replica
Do you think it is worth an intent != null check here? It was unclear to me whether the framework and filters will always protect us from receiving a null intent.
FYI, these credentials have been disabled. In the future DO NOT EVER commit credentials with TODO from properties. They will be available through git history even after you fix this.
Background Effect, oder?
avoid usage of onFailure/onSuccess for efficiency purpose
parhaps Collections.singletonList?
This allows a default value. Why don't we just assign it "1"?
Should we warn users about that?
Maybe we should change it to be DEBUG since this is on a critical path (even though this method might not be called very frequently)
Does DbxNetworkErrorCallback need to be a Runnable? Instead of having setNetworkError() + run(), would it be simpler to just have one method like onNetworkError(T error)?
This should also probably relocate any old items to the order given in the collection. e.g. collect existing, removeAll(existing), addAll(items)
Why do we need to proceed when there is some exception
why not replace with boolean okGroup = (group == lastGroup) || !seenInThisCycle.contains(group) ? I don't think there is a point in comparing the identifiers, and this way it should be faster, since the seen... collection is consulted less often.
cluster is null on dialog init (looks like a bug). this method is invoked only when changing OS.
is this to switch to mapFrame? If so, consider changing it to explicit states driver.switchTo().frame(mapFrame);
Shouldn't it be isDownOrSuspended or isNotRunning
use CollectionUtils.isNotEmpty()
Nice. It might be better to call stop() or stopImpl() instead of quitting the Looper directly though.
Is there a constant for this env property?
Logging to INFO should provide contextual information useable by system administrators. This message seems more appropriate as DEBUG or it needs more context to be useful by a system administrator.
Exception#printStackTrace goes to stderr by default.
Avoid using Thread.sleep
This local variable appears to be unused. Suggestion to remove.
This could just be created when it's needed. This variable doesn't seem to be reused.
Basic
can we rename list to entries or something similar.
QQ: Do we need to delete the old node?
Don't forget to cover all if conditions in the validateQuestionDetails. You can see the coverage by the CI or in your IDE.
- At this block, it looks like the new student entity has been persisted to the DB. Is it safe? - If I understand correctly, this happens by chance if the key (which is supposedly RNG-generated) is identical. If that is the case, shouldn't there be retries?
out.open or tran.abort can thorw exceptions. Call getAndIncrement() right before try { && getAndDecrement() right after finally {, or use another try-finally block.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Not a good idea to use the same phoenix connection across multiple threads since it is not thread-safe.
put each parameter on a separate line, currently this is too long
missed three
GradleDistribution should have applyTo(Connector)
can you realign this line - merge it back to the previous?
Should this be part of the messages.properties?
If we add max>0 in the condition there it will cause the issue because in finally block we always reducing the endCount irrespective of max value. e.g. 1)max value is 0 so in RpcStatus.java's begin count we will not increment the counter but in ActiveLimitFilter's invoke's finally block we will be always reducing so the final value for single invocation will landed up -1 active count. I think not including max>0 and adding java } finally { if (max > 0) { RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, isSuccess); synchronized (count) { count.notifyAll(); } } }  In ActiveLimitFilter should also work, but I beleive you can rewrite this into more clear way then we suggest. I think we might have another issue too (not because of your changes), in a scenario if max>0 (in RpcStatus.java) get satisfied (or lets max>0 condition is not even present in code as earlier version) and the methodStatus.active.incrementAndGet() > max return false then code of else block will be executing and again it will increment the count. So for one call we are eventually incrementing counter twice. Do you feel this might be also a another problem in future?Correct me if my understanding not correct.
if Cipher.getInstance(CIPHER_NAME) failed next line will raise an NPE. Should we handle this in a better way ?
This is another case where the null logic and default logic should be combined in one place boolean noMatch= false; if (fJunitVersion != null) { switch .... default: noMatch= true; } if (noMatch) { default/null logic }
This code block seems redundant - the next statement is a call to setVcfheader, which handles this.
Instead of closing like this, I would suggest to have a try-with-resources: java try(final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) { ... }  You can also include the writer there...
Unable to understand this change. Why is it required for this test?
consider applying De Morgan's law here, it should make it more readable.
Isn't error also set in the controller?
The requestSet should be created only when we're about to start a transaction - when there's ongoing transaction with multiple writes it shouldn't do it on each request.
Why no JSONObject?
have a check for null tablename, since @NotNull is now removed
@jindoujiao Unity SDK is not failing the banner ad when the width is less than 320, instead it throws an error log, saying invalid adsize, but it is returning a banner Ad with width less than 320. Tested requesting a banner Ad with Size 250X40, I was still able to get banner ad back with that Size. Is this expected ? If that's the case I think we should ad a case to map any width less than 320 to 320 width.
Better use getCanonicialPath and getAbsolutePath instead.
1. The last index segment can have the start offset that lies within the journal right? Why is this check required. 2. This was bit confusing. Can you have two diff loops. One loop to go over segmentsToRemove and throw if any of the start offsets lie within journal. 2nd loop to create the newIndexSegments. bcoz, if you want to, you can combine the previous check (segmentFilesToAdd's ) in here itself. But I feel having it separately makes it more readable.
You can use Guava's Iterables.getLast(catchList) instead.
Maybe put it right at the beginning of the method in case any of the other initialisation stuff tries to do anything with DNS first?
This won't work.
Should be:  assertThat(System.currentTimeMillis() - t1).isLessThan(45000);  Also, maybe we could lower the limit a bit. On my laptop, the optimized version consistently runs under a second.
Do we really need to lock by hand? Isn't Optimistic locking on by default?
fAspectMap.computeIfAbsent(aspect, a -> fAtomicLong.getAndIncrement) will ensure that each call to fetchTree returns the same IDs for the trace
What about JSON Arrays? Seems to be a valid case
suggestion cacheManager::getCacheManagerConfiguration);
shouldn't we have non null values for all new fields in V2?
throw?
There will be better to tell user which host is the problem of privilegeException. He probably has no privilages for adding specific host.
There is an execution path in this method where close() is not called.
Maybe rather than return List<String[]>, return List<Configuration> ?
I prefer not handling host with migratable vms (###) and use the host list supplied in method params
I don't think we need this duplication. Instead we can drive off GlobalCapability.getAllNames() here. The duplicate entry in the properties file was a hack for GWT.
myProject doesn't exist anymore since the last merged pull request. Use getJob or job instead. Hence the build failure.
We could move the \n with other cases: i.e. ' ', '\t', '\r' a
Reader needs closing ? If so then it should be in final block
partToRefresh2.removeAll(partToRefresh1): sometimes the simplest solutions are the best :-)
TBH I don't really find this useful. Since the condition is quite long, the previous approach has nice advantage - you can tell right away from the variable's name, what it means. I would vote for the previous approach then.
Not sure what does returning null mean for such method. Is it a failure? Then why not IllegalArgumentException? In any case, it would be better to avoid returning null in a simpler method.
not sure about this.. every time that this command is instantiated it will use a different GUID? note that coco is supposed to cache the command so it will work on regular flows, but if the engine is restarted, the command may be instantiated during the template creation
it seems insecure to have the credentials in every record. We can address this in a follow up PR, but maybe the sink should require the source credentials in its configuration as well.
Wording nitpick - I would omit "is". It just reads better to me; I can't tell you a principle of grammar to justify it,
the potential NPE warning reported here can only be circumvented by assigning the bridge to a locale variable (like for the handler).
nit: s/LeaderLivenessCheckScheduker/LeaderLivenessCheckScheduler/ Also, what does "Leader info 2" mean? Perhaps a typo?
This catch is redundant. Without it, the code should be able to throw e as well
nit, could be simpler by adding a buildEmptyCloudConfig method which returns a static cloudconfig instance which has been configured as cloudEnabled = false.
This could be removed now.
Can combine into one line.
Refactor lines 272-278 and lines 282-287 into...  void rmdirs(String... directoryNames) { for (String directoryName : directoryNames) { File directory = new File(directoryName); if (!directory.exists()) { throw new FileNotFoundException(String.format("No such directory: %s", directory)); } FileUtils.deletedRecursive(directory); }  You could even refactor your rmdir(:String) method above (throwing the RuntimeException if necessary) and have this **new** rmdirs(directories:String[]) method call it.
Did you determine these to be redundant?
Please use the BigtableInstanceName.toGcbInstanceName() here.
Can you try making PoolEntry a java.lang.Comparable to see if it makes this cleaner?
Maybe put isCast in StandardFunctionResolution as well and have this as a class variable.
It is a module precisely so that it can be pulled into core via the dependency mechanism
java logger.logNext(logTag, observableTag, value);
Add curly braces around else block. Also, falling back to a default-constructed ReferenceSource will (I believe) eventually produce a NullPointerException deep in the cram parsing code provided that Defaults.USE_CRAM_REF_DOWNLOAD is false (which it is by default). I think we should throw here if referenceSource is null and Defaults.USE_CRAM_REF_DOWNLOAD is false.
The pr #3491 which has been merged into the main branch has changed this constant name. Would you please update the latest code and change it here?
DATA_ constants should be about field names in the JSON, while ATTRIBUTE_ constants should be about field names in XObjects, so it's wrong to use DATA_CONTACT to get values from an XObject...
This method has duplicated code that could be simplified by calling UncheckedFiles.createDirectories() unconditionally before the write call.
every test will shut down all the locator/servers and restart them again, making the tests taking longer. If you would like make the tests run faster, you can lump these two tests into one. first do region.clear in a client vm and then in a server vm. And would be nice to verify that after these two clears, the region still has those 2 records in them (clear didn't go through on any servers).
we already have different methods for dropping rows with NA values in DropNAHandler, don't need to overloading the convertRowType function.
If I'm not wrong, I believe you could omit this too. We can check if the course does not have any students (line 54) using courseDetails (line 47)
This looks like a debugging print that should be removed.
Perhaps I'm missing something, but starting with line 171, isn't this equivalent to a somewhat simpler: return model.getActionCols().stream() .filter(c -> !columnsToMove.contains(c)) .filter(c -> c instanceof ActionWorkItemInsertFactCol52) .map(c -> (ActionWorkItemInsertFactCol52) c) .filter(c -> c.getBoundName().equals(binding)) .map(modelColumns::indexOf) .noneMatch(i -> i >= tgtIndex);
nit: unrelated formatting change
Add sort and other generic options from superclass.
Using Exception.printStackTrace() is _very_ seldom justified. Why not propagate exception instead?
Would prefer to see loops replaced with standard "for (int i = 0; ...)" style, rather than declaring 'i' and manually incrementing it. A stream would also work, using 'mapToDouble()' and 'toArray()'.
This code is repeated a few times. It may worthwhile to have a complex metrics utils class that will register HLL and other complex metrics in the future
Extract notification to own method notify...
or maybe min/max this instead, I dunno?
Should we check this is empty then?
same thing here, moving the for statement in the RedisLock block
After all, it turns out that we don't know the last bucket of the requested time range, only the last bucket that contains a real event (fLastBucket) and the time of the last bucket in the array (fTimeLimit). Since the scaling is done to accommodate the last real event (fLastBucket) it's not even sure if the area to the right of the last bucket bar is within the requested time range or not. So in the end we should just let it count and draw lost events up to the last bucket in the array.
is(both(greaterThanOrEqualTo(sleepTime)).and(lessThanOrEqualTo(startDelay))) to show that it's a range?
Are you sure this is correct? If a CSP has script-src '<LINK_0>' and also script-src-elem '<LINK_1>', would <script src="<LINK_1>"></script> be allowed? This (if I'm reading it correctly) implies that it would not, but I'm not sure what the spec says. Another example: script-src a b; script-src-elem a; should not allow <script src="b"></script>
Add a validation clause for currency. If Currency code is not valid throw BadRequestException
I do not understand why we need this block.
Is this needed? Seems that this will never evaluate to true since the menu is being built at this point in time.
I am starting to finish up an issue that re-organized our inputs. Please rename new input files to InputTranslation.... If file can't be renamed, please give us a reason why.
There are a few of these logging statements in this class that could possibly be cleaned up
Missing @Override
Instead of returning AsyncQueryResultStorage we should return byte[] to keep the code extensible.
Shouldn't this be an UnchargedIdentityDisk?
@pynicolas I think it might be better to keep all the logic in JavaScriptNodeBuilder: You'll need to subtract 1 to the column if the token is on line 1. With the current solution, getColumn() on a token that is on line 1 with a BOM UTF-8 character will return an incorrect value.
I think this should be null, not an empty string.
Consider converting this to IntOpenHashSet from fastutil and storing Float.floatToIntBits() results. The latter is to match NaNs.
findBugs: this is ignoring mkdir()'s return value, instead use FileUtils.mkdirs()
Should be able to pass m here.
Not a big deal, but mp.getValue() is already fetched into partitions.
@danielezonca Could you pls semplify this if (!!resultValue.isSatisfied()) { resultValue.getErrorMessage().ifPresent(_lambda) expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } else ... or something similar?
i can be moved inside the if.
We should change the [reply == NO_OPTION] to [reply != YES_OPTION]. Currently, if I close the confirmation window with X, it saves the file. In my opinion closing the confirmation dialog (and any other operation other than clicking YES) should result in aborting saving.
exception, so STDERR
There is no need to verify the response deserialization in mock tests, so you can remove all these asserts. We just want to make sure the generated requests are the expected ones. That method uses basic authentication (via its filter), so let's modify the assertSent method in the base mock test class to verify that the authentication header is sent too.
This looks wrong. You added the code to DeleteOperation to throw BlobDoesNotExist if no server has the blob.
If the 2 classes below are combined, this simplifies to:  java List<OperatorRequest> operatorRequests = new ArrayList<OperatorRequest>(); operatorRequests.add(new RegulateRequest(normalState)); response.operatorRequests = operatorRequests;
Not sure how often this method is used, but this does not seem correct.
ditto, missing fail() call
Are these wrong too?
maybe possible to remove duplicated codes by extracting the below condition checks.
needs to be type.
Can you use org.junit.Assert.assertThrows(..)?
problem with the argument passed to setupDiskSpaceTest
.noneMatch()
Single line?
This whole block does nothing, so not sure why it's needed other then logging, but logging is also cryptic "detected mode disabled", isn't it easier to say in flight mode, not in flight mode etc?
Catching Throwable is generally a bad idea, these catches should probably be Exception
how about throwing RuntimeException here? When image generation fails code dependent on it is also going to fail.
Could you assert that the destruction was successful somehow?
I think it'd make sense to check for the presence of id and timestamp and use the different StreamsDatum constructors depending on their presence. This assumes a lot about the item as it currently is.
@tsr-thulio please move this from root to src/main/resources dir.
This should never happen. We should add an assertion.
Put this in the Subscription? (it's not thread safe afaik)
Why aren't you loading the profile name from org.jboss.hal.testsuite.util.ConfigUtils#getDefaultProfile ?
you could just say startProgress
The MediationAdRequest's [isTesting()](<LINK_0> can be used to determine if a publisher is requesting test ads. Please note that this requires Google Mobile Ads Android SDK version 11.8.0 or higher.
We should explicitly @Override here.
nit: On a different line.
it'd be preferable to use something like .subList() instead of this iterator stuff
To keep tests declarative, could you please move this into a separate method like sortById(List<Group>)?
Maybe these can just be static constants somewhere?
lets pass the index to readData, so that we can eliminate the split function inside read.
Might be nice to define this as a member variable DEFAULT_ASSERTION or the like, for clarity.
I had to change this to "Remote Services" for the terminal to work. Note that it is possible for it to work just by coincidence if "Remote Services" is the first entry in the array.
Here we could call getValue for each raw value in filterParameters and collect the results in PropertyValues. This would allow the client side to make a single request to resolve the selected values rather than making multiple requests, one per selected value.
We call associateSymbol each time we call addUsage. Why not factorizing that?
Are these exceptions part of the spec?
Maybe just throw an exception?
I would also think about limiting the degree of parallelism here. I recall issues in 32 node tests, where a node joining the cluster requested state from all other nodes at once - and the other 31 nodes started sending it, effectively DDoSing the poor joiner.
The clear button calls attemptAddBudget() when clicked instead of clearing the fields.
Just for the records, today I'm seeing 4ms - 6ms timestamp resolution for all changes (patch set 12).
Nit: This can be done easily with assertJ: assertThat(resources).containsOnly(resource, resource2); This is the import you need for the method: import static org.assertj.core.api.Assertions.assertThat;
consider using SimpleChannelInboundHandler and just consume the message in channelRead0. This way it is correctly released without hitting the tail of the pipeline
I think we can start removing the id parts and be dependant on index only.
We can simplify this part a bit:  java String name = author.map(TurboUser::getRealName) .orElse("").toLowerCase();
you need to move fileInputStream out of TRY scope and merge TRYs, so finally become part of top TRY.
Could you close the resultSet at the end?
Isn't this checked by JNI?
HTTP POST request for a getTrackerDataForDates?
In this line the input stream (in) can be null. Maybe treat it or log something
Would you either update the description or make it so that we're really testing for an empty region?
If you're going to hardcode the class, just hardcode the string, you _know_ what it will be, so making a call is silly.
Maybe it would be better to do filtering in EthashMiner.setListeners() to keep the main flow clean?
Having two local variables for the "same" indicator is a bit confusing. I'd change to parseIndicator(ActionParameters, StatisticalDatasourcePlugin) and move the existingIndicator logic to that function.
Should this include: java if (skipRuntimeScope && skipCompileScope && org.apache.maven.artifact.Artifact.SCOPE_COMPILE_PLUS_RUNTIME.equals(scope)) { return true; } if (skipRuntimeScope && skipSystemScope && org.apache.maven.artifact.Artifact.SCOPE_COMPILE_PLUS_RUNTIME.equals(SCOPE_RUNTIME_PLUS_SYSTEM)) { return true; }
This is correct and pretty nice, though I'd prefer a method that says what this step is doing
There is one extreme condition might not work: main and reference project contain some item with the same ID. Normally we do not support it but we can't guarantee customer do not have this kind of case . After this commit , object with the same id in reference project might be editable. Possible to store the key with project id+object id ?
Let's use Iterables from Guava. The code will be much shorter
I think it would be better to rewrite it in more Single Responsibility Principle style java private Map<String, String> toMachineAttributes(String pluginId, Map<String, String> wsAttributes) { Map<String, String> attributes = new HashMap<>(); Optional<String> pluginAlias = findPluginAlias(pluginId, wsAttributes); pluginAlias.ifPresent(s -> attributes.put(DEVFILE_COMPONENT_ALIAS_ATTRIBUTE, s)); return attributes; } private Optional<String> findPluginAlias(String pluginId, Map<String, String> wsAttributes) { List<String> aliases = new ArrayList<>(); String pluginComponentAliases = wsAttributes.get(PLUGINS_COMPONENTS_ALIASES_WORKSPACE_ATTRIBUTE); if (!isNullOrEmpty(pluginComponentAliases)) { aliases.addAll(asList(pluginComponentAliases.split(","))); } String editorComponentAlias = wsAttributes.get(EDITOR_COMPONENT_ALIAS_WORKSPACE_ATTRIBUTE); if (!isNullOrEmpty(editorComponentAlias)) { aliases.add(editorComponentAlias); } if (aliases.isEmpty()) { return Optional.empty(); } return aliases .stream() .map(value -> value.split("=")) .filter(arr -> arr[0].equals(pluginId)) .map(arr -> arr[1]) .findAny(); }
s == null?
Redundant cast.
forEach
use anyMatch to find the elements matching the requirements (if any), that will simplify the code a lot.
You add, search in and go through this list. It contains String instances so it may be presented as an HashSet<String>. It will work if you don't need to be sure of the order you'll access the data. If you need such guarantees, you may use a LinkedHashSet<String>. Or you may consider you don't need better performances.
This should be 1024 ^ 2, right?
If pluginName is null, you need to call the other refreshPaymentMethods API.
elementGetter should be out of for loop.
minor: I guess this should be named orSimplified1 (and the one below in line 3182 should be orSimplified2)
I don't know why we did these generics. It should be java sequence(Iterable<? extends Validation<? extends E, ? extends T>> values)  (see Either.sequence for example)
That's equivalent to just conferenceName. Did you want the string "null"?
Delete twice, why?
Is special handling for performance? Is there perf data to prove that it impacts performance? For now NON-BLOCKER, but worth revisiting perf vs maintenance forward.
I wonder if this should be logger.warn() instead of logger.debug(), which we will not see in normal running mode.
These will not work until you pick-up the apache sink version 0.11.1: <LINK_1> Specifically, you need: <LINK_0>
webContextProperties below here is not used. Properties webContextProperties = new Properties();
It will be good if you write a test case for shared lock failure resulting in more than one error messages. It'll help me understand that part of the functionality better.
maybe add a break; here?
Logging exception as info is not good. Should be warn or error.
final :smiling_imp:
I think we want containsOnly or containsExactly here and below
We can skip the loop now.
Shouldn't need to call setupPipes() explicitly. Should be part of the service start.
This seems pretty late to call this. Can we do it before posting to the main thread?
I don't fully agree here. Only the requiresStateParameter tells you if you want to use the state parameter, the value being static (your stateData) or dynamic (generated using the getStateParameter() method)
Given the large number of HTTP response fixes we have added, I believe the per-operation retry should suffice and we can remove the outer retry loop. We can address this in a subsequent commit.
Change lambda's arg name to something more expressive like 'file'
Is this still producing <LINK_0> ?
synchronizing inside synchronization seems like a recipe for problems to me but I will let @rcordovano weigh in on this one.
Do we need to guard this on "startDragItem != null"? The pointer may have been pressed initially in the blank area of the grid.
Can you add another edge case here with hard and soft clips on the same read: "2H3S10M4S5H"?
Huh?
The coding standard, I believe, is the way the curly braces were prior to the change. So, opening brace on the same line, closing brace on the subsequent line. Braces needed even if it's a one-liner.
could use '('
minor: Might be more human readable if you replace is with equalTo.
This change in data(LightblueRequest, Class<T>) reverts changes to use new LightblueResponse#parseProceseed method. Why?
Nit: Can be rephrased as "Table config required to use NormalizedDate..."
I don't think TimelockService should gain a method that's related to lock watches - rather we should be maintaining this state as some part of the hierarchy _below_ timelock service.
Would a receiveNoWait (either in or outside the loop) like the other tests be nicer than burning 2 seconds? Slow tests is a key reason eventually noone wants to runs the tests :)
Is it intentional that you don't remove /config/rolling-operations/<uuid>, /status/rolling-operations/<uuid>, or /status/rolling-operations-tasks/<uuid>?
does this need to check for string content, eg. trim whitespaces, lower case etc? since this is user input?
Can also just use params() here as by default they are put in the params :)
What's going on here? Just run two selects and do nothing?
Humm, why is this done here? I don't think we need special treatment for the str here...
Move it up a few lines, so that Boolean switches come before parametric modifiers
If inStream.close() throws an IOException, the outStream may not get closed. You might consider using Apache Commons IO's [IOUtils.closeQuietly](<LINK_0>
same deal: these verifications are redundant.
optimisitcTable breaks the abstraction of SMR. All optimstic updates assume that the initial table is empty. This is correct for CorfuTable because different keys are orthogonal, but it is not true for general SMR.
Hi @eleduardo, I'd prefer to add explicit final int field to CircuitBreaker.State, so we can be sure that enum elements reordering won't affect any of our users.
The policy unit can be called often, so 'info' level would pollute the logs. Please change it to 'debug', and surround it with a condition if(log.isDebugEnabled()), so the parameters are not evaluated if not needed.
Now there's another problem relating to filters. This applies the action to all files, even filtered out ones. Stage/unstage applies only to visible nodes. We should be consistent. To see what I mean: have a test project with a folder foo containing two files A.txt and B.txt. Modify both. Enter "foo/A" in the filter box in the staging view's toolbar with Compact Tree View enabled. There should be only foo/A.txt visible in the unstaged viewer. Now choose "Untrack". Staged viewer shows deletion of foo/A.txt. Now clear the filter text in the toolbar. Oops, foo/B.txt also got removed from the index. Looking at stage(), I see it uses contentProvider.getStagingEntriesFiltered() to get the children of a StagingFolderEntry. I think that should be done here, too. (I also see that stage() has a funny "if StagingEntry {} else if StagingFolderEntry {} else {}" structure. I wonder what that else-branch could be good for... might be a leftover from old code. AFAIK we only have StagingEntry or StagingFolderEntry elements in that tree. unstage() doesn't have a corresponding else part either. Looks like some more clean-up and duplicate code unification would be needed here; but maybe in a later commit.)
There is a requirement for password policies to work for an example when following order of extensions are available [1], Password.policy.extensions.1 Password.policy.extensions.4 Password.policy.extensions.6 In that case decrementing size won't satisfy this scenario. [1]. <LINK_0>
this test is not verifying that we call testFunctionIndexFunction only once? which was the original bug.
Why adding VmBase?
Can you do an abstract getter for this instead of passing it in through the constructor? It feels.. weird to me to do it this way. Same for end of partition.
Same here as the passed arguments to exceptions. The logger can handle stack traces by itself and there is not need to pre-render this.
While you're in here can you also fix this? We should be using this value from ClientBase. Is there a reason why we can't convert this class over to subclass ClientBase?
Can this actually be null?
Should this be a logger.info instead of a System.out.println?
Duplicated node **StartNoneEvent**
It's unusual to use Mockito.anyString() in a call to something that isn't setting up a mock. Any reason these can't just be dummy values?
Kubernetes-client provides different means for Deserialization, please either use Serialization.unmarshal or KubernetesClient#load to deserialize the class so the test actually tests something from our codebase.
firstRow variable is not used
Please define an interface for TypeLiteral<Supplier<Map<SchemaTableName, ElasticsearchTableDescription>>>. Maybe  interface ElasticsearchTableDescriptionProvider { ElasticsearchTableDescription get(SchemaTableName table); }  ?
Simpler: BindingAssertionHelper bh = getAssertionHelper(); Same in the other test.
Move this to a SpanEventListener. That way it works for other request types as well.
would it make sense to move both apply methods into the upsert map callback so they are done in one spot?
Recently, we don't use the explicit new Object[]{ ... }
could you refactor this into smaller parts or move the logic into a separate class?
This is super hard to read. We should just use policy for the main loop and leave the rest inlined unless we have a very strong reason to abstract all this into policies.
Don't capture unused data.
Object returned by this method is not used e.g. method can return void
What's the corrective action one can take if this problem happens and why would it happen.
space
Nit : Method name, entityHasExtensionJobTag, is good enough.
can this be a better name like createdDateMillis etc? Also better to add a reference to RecordType enum like above fields
This should probably not be executed if processedEClass==null
I think this needs @ApiResponse if changing the return type so that swagger knows to describe the api correctly.
This will be removed after data migration, right?
But why not to add /api/v1/concepts to http config with permitAll instead of constructing filter?
Please put this into a ANY_ADDRESS constant.
Why do we need Timer for these metrics? We don't have to track the rate, do we? A Histogram should suffice
Let's make "00000000-0000-0000-0000-000000000000" a constant, put it in to a utility class and use the constant instead of a string
I know we said Java might diverge on this (doing file for sync, url for async), but I think that because you've added a recognizeReceipts and a recognizeReceipts FromURL, you can have the other sync and async functions call the files functions
could use StringUtils#isBlank for better readability
It looks strange without verification. Is it expected?
Please make sure that componentObjects does not contain projects PVC
Do we really need stream in pipelineConfigs -> pipelineConfigs.getPipelines().stream()?
I think it'd be good to add 2 more error expectations here to cover all possible overlaps: Key: |: start or end of frequency -: active time of frequency _: frequency not active A covers B: A: |---------| B: ___|--|____ B covers A A: ___|--|____ B: |---------| A starts before B starts, but A ends after B starts and A ends before B ends: A: _|----|____ B: ____|-----| A starts after B starts, but A also starts before B ends A: ____|-----| B: _|----|____
Debug logging statements should be wrapped in a if (s_logger.isDebugEnabled()) check to avoid the overhead of string concatenation when debug logging is not enabled.
I wonder if anyone relying on custom DL templates would be pissed about this change if they expected the volume to be present (for whatever reason). I know we are already committing such a change by overwriting the RAZ flag just a few lines below.
rename 'resource'
It looks like this is going to cause us to re-do all the trigger matching logic twice on every pipeline start. In a lot of cases, there is a reasonable amount of logic in withMatchingTrigger. For example, Jenkins triggers call back to igor to get information on the build that just completed; we'll now be asking igor for information on the completed build twice per pipeline. Is that extra traffic/duplicated computation a concern?
It seems like we could do better here. P.S. the guys who did migrations regarding StudentProfileAttributes also had missed out something.
I think you'll need to check to make sure that the thing being indexed is either a work or a fileObject, and if its not then return immediately. Otherwise there's a good chance this will throw an exception. Be good to have a unit test to make sure that bit functions correctly too.
assertThat(links, iterableWithSize(1)); provides better defect localization.
More efficient and with less repetition: if (excludeSpecialChildren || excludeRegularChildren) { boolean specialChild = specialChildrenTypesNamesSet.contains(docState.getPrimaryType()); if (excludeSpecialChildren && specialChild || excludeRegularChildren && !specialChild) { continue; } }
Thanks for raising this issue. I think you could argue in both ways, hard fail on any failure vs. fail only if no connection could be established at all. Having this safeguard in place is beneficial. Please do not use .map( ) but rather flatMap( ) and return Mono.error( ). Throwing exceptions in reactive operators isn't a proper way to communicate failures. However, this question raises another one and it became obvious why there is no SSL support for Master/Slave right now: Redis does not know about SSL (which require a tunnel/proxy), Redis topology discovery reports the actual hosts and ports. For SSL with Sentinel and Master/Slave auto-discovery we need some sort of mapper function to make it work. The reported addresses must be mapped to an URI that points to the actual SSL endpoint. For now, I'd keep the mapper aside and introduce such a Mapper API in a new ticket.
Instead of having this conditional, how about something like:  java hosts = (!isNullOrEmpty(host)) ? singletonList(host) : client.getChildren(...);  That is to say, there's no need to do the ZK operation if a host is provided. We can just trust that it's an actual host for the job. If it isn't, then it will get filtered out later when we loop through the hosts list.
Why are we querying these one by one when the method allows us to pass in multiple? This will be a significant bottleneck if someone wants to specify a large number of channel groups.
if this is boolean, why do you need "=="?
Can you do this in a metadata store transaction? We take advantage of such transactions for other operations that must be atomic, such as segment publishing and kafka offset committing. See IndexerSQLMetadataStorageConnector.announceHistoricalSegments for an example using connector.retryTransaction.
@inverno Do not use toString, put this expression in message
Perhaps creating a VisualEditorContents class in ContentPatterns would be appropriate for the constants you are using for VE
I don't easily get what the last bit of the condition is required for ?
I think this could go into service class. ChargeEntity shouldn't ideally go beyond get/set
Use new utility class GlusterTaskUtils
Don't trim username and password.
Suggestion: have only one **for {}** block and do: if ( hidePassword ) { conn.setPassword( null ); }
Perhaps we could create this string w/ String.format(...) Also, we should probably use e2-standard-1 as well.
encodedCollectionName
The exceptions are subclasses of IOException. Do we really need to specify them here?
rename
I am wondering whether this isn't something the DefaultLeaderElectionService can decide when receiving the onRevokeLeadership callback. It could then decide to call writeLeaderInformation(LeaderInformation.empty()).
can we use <LINK_0> ?
to loop var, use cast to ClasspathEntry when calling getDelegate() below
This method has quite a bit going on and I think it would be easier to understand if you split it into 2-3 methods.
did you move the method on purpose? public methods go first, and all helpers, private and so on goes below them
Does any of this code touch the DB? If so this means listing accounts will be pretty slow.
We need to evaluate the value of the property, 'SET_REQUEUE_ON_ROLLBACK'. WDYT?
You can use Strings.isNullOrEmpty here.
unneeded check : imageToDomainMap.isEmpty(). It is not , but at nay case
Perhaps include the componentName in the message?
Granularities.NONE is a simpler way of writing this.
I think it would make sense to somehow extract the onclick listener to a method or something, so that you do not simply need to duplicate the code, but instead call a function :)
write to a temp file and rename. Look at StoreDescriptor for eg.
can you rebase, this is already fixed in master
you probably don't want a silent fail here, extract a local variable trace = fTrace, then assert that it is non null instead
**question:** Should this actually be a LOGGER.info or debug?
unexpected
It would be good to place persistence unit name as constant to some shared place like KieServerConstants to avoid duplication. It is already used in JbpmKieServerExtension and CaseKieServerExtension and locators.
Should double check with service team if this is what they want to do with those exceptions.
I'm confused with this change. Is there anything else other than code reorganization? If not, then the current version is desirable, as it makes more clear the various branches returning values.
Refactor it to a static and reuse it in all tests
nit: would it make sense to move readResource method and resource names to BenchmarkData class to avoid copy-pasting?
Maybe we want to include the resumeBehavior field to hashCode() and equals() methods.
why do you close baos here, while you can do it in finally block as in another situations?
how/why is this expected to change?
Would it be better if we use getFirstAnnotation(declaredClass, Arrays.asList(Include.class))?
Consider moving this to a top-level class in the commons package (e.g., DefaultValueMaps).
Will need to see how we handle the equivalent of a "Subscription", but there is currently a potential leak here, I guess.
Space after if?
The preference text refers to the 'chart', and about 'querying' the view. This class is just a tree that supports grayed state and maintains consistent checked states. It doesn't know that it's coupled with a chart or that there is data to query when elements are checked. The place where we know that we have a TriStateFilteredCheckboxTree coupled with a XY chart viewer is in TmfChartView.coupleSelectViewer(). I believe it should be there that we 'install' in the tree viewer a listener that can prompt the user and abort the selection. Maybe it could be a method added to the ICheckboxTreeViewerListener interface, like a 'preCheckStateChanged'? It also seems like TmfChartView would be the right class to choose the limit of 20.
Throw BadRequestException instead of IllegalArgumentExceptions in from Request implementations.
could you please explain the scenario which this bug shows itself? why do we need this?
looks rather strange. What about removing the isAutoDelete parameter and using  case DEFAULT: return UserPreferences.isAutoDelete();  ?
Just a small question.. can the nameAttribute be non-null but the value itself from .get() be null? Or should it be checked in the above nameAttribute == null || nameAttribute.get() == null ?
It's not about incompatibility but use the most appropriate (prettier?) look and feel by default when running on macOS.
This pattern (and the whole query) seems very similar to ImportTemplateFromExportDomainModel.createSearchPattern() Do you think it would be possible to extract the code so that it can be shared between the classes? It could go to AsyncDataProvider and take async callback as its parameter (there are many other methods like that there)
why not a single if with Strings.isNullOrEmpty ?
To be proper, this should return an error status. It is not that there was not change necessary, it is that the sourceLookupDMC is unknown.
Very much nit: maybe change the label here? This will be grammatically incorrect for, say, the 91st percentile.
If we didn't have the existing problem with the entity create locking would we have done this the other way round?
You don't need to change this method signature. I would leave it to be a private method.
Are you sure this is not rather a configuration error? That would mean using InternalErrorException.
This needs to remain IReverseToggleHandler for the other changes not to break things.
is 80 a standard size or should it be a dimen resource ?
It looks like you can simplify this code by reusing removeFirstMatching method
There is an extra indentation in the above lines, please remove them. Also alertImage is not being used.
I don't think we need to clone the entire trees here. Just detaching them should be enough.
Revert this.
We usually use dc for dublincore prefix.
This should probably be handled in some other way than just closing the software (is this what happens if an error occur in a separate thread in Netbeans?)
Let's not swallow the stack trace here.
Unnecessary final
suggestion Date date = Date.from(Instant.parse(html.substring(start + 1, end)));  (Although probably better to use Instant directly for increased precision.)
Once typing is fixed we do not need this casting.
Can you replace java if (optionalBlobName.isPresent()) { uploadFile(file, optionalBlobName.get()); } else { uploadFile(file, file.getName()); }  by java uploadFile(file, optionalBlobName.orElse(file.getName());
this should be done a validator on attribute.
I think it's worth checking that keyfileUrl isn't null too just in case someone changes the behaviour of usesAuthentication later on without realising that this block implicitly relies on keyfileUrl being non-null.
It is unfortunate that the API for AmazonInfo is a bit leaky, but the preferred API to extract data is <LINK_0>, where the enum can be used directly.
Why do we need to call clear here?
naming
These could be fail() instead
The code would be much easier to understand if the decode was done here. So that checkedPages actually contain a list of pages :)
(Critical) Don't use arbitrary whitespace as the delimiter (they might be valid as the value, also I don't think '\0 is a whitespace). You may refer to RangePredicate.java on how to parse the range string
Remove these checks, since we should never call the method with null. (As a general code style, we don't write code to be lenient of nulls in Presto.)
I feel like this would be more readable with an if-else rather than the ternary operator.
- [x] I think that you should return Null instead of IllegalStateException if no CodeList of all locales, , respecting the previous design.
This should remain as "single". Hunters have a "single" action and also "joined" actions.
I don't think we would need per topic level checkpoint metrics, Commit latency and number of commits in aggregate probably is enough, Thoughts?
is it correct to omit existingCriteria if it's null? if it should always be not null, this if is bad: it delays the detection of a missing value, and it would be better to add an else with an explanatory message (if the field requires clarification why it should not be null) or just let it throw the NPE.
When registering a Job, we throw a DuplicateJobException if it has already been registered and put the onus on the caller to unregister first. I'm not arguing one way or the other, but I would expect the behavior to be similar across the two calls...
It looks like code redundancy with the Task bean.
This will cause ConcurrentModificationException: removing items from the underlying collection while iterating
This code isn't trivial. Please extract it to a method.
try-with-resources? (the ones in this file)
error log must be i18ned
so not really specific to this changeset, but is there a reason we are using 2 different StringUtils in this class?
Maybe you could use endsWith instead of matches? Then you wouldn't need that string.
Did you mean to suppress the exception here?
I think it is better to split "addAndReplace" method in "replaceEntry", which will replace existing entry but return null if none exists. And "addEntry", which will add new entry. This way overall classpath order will be fully controlled from this AbstractJavaProjectConfigurator, and not as side effect of addAndReplace method implementation.
I dont think we should be stripping. We need to ensure anycast messages only end up in anycast queues and like wise multicast. When theyre consumed by a retroactive consumer
I think a part is missing here <LINK_0>
I think just iterating of the string to find . characters and creating a new substring each time would be even faster, as there would be just substring allocations which are very fast (reuse the char[] of the string without new allocation).
Ha! Never noticed this, but we should always normalize to the smallest scale. Right now, 1234ms > 1s but 1s == 1234ms !!! ITmfTimestamp t1 = TmfTimestamp.fromMillis(1234); ITmfTimestamp t2 = TmfTimestamp.fromSeconds(1); assertTrue(t1.compareTo(t2) > 0); assertTrue(t2.compareTo(t1) < 0); The second assert fails.
suggestion initTemplate(new ElasticsearchRestTemplate(client));  with the change in the base class
why do this at all? To make sure it succeeds? Shouldn't we check that the return is ok in that case?
I guess getListParser should get the injector... (Is that something unit tests should have caught?)
Good point. I've added Dropwizards Jersey Client integration.
Add a //TODO statement about optimizing the sort for large files.
The order arg here is quite important given the way ND4J works with reshaped arrays being a view of the original.
Can't we make calls from txClient to the tx service before and after running the admin command to test the change in state? Asserting on an exact match in the printed output here is brittle and going to be subject to easy breakage in the future.
whaaaat This line makes no sense to me. Care to explain it?
Include the microservice classname and path in the log message.
Is it possible to avoid "global" variable (leftFieldNameSet) ? It seems like you're using "state" in lambda. Is it really necessary ?
Shouldnt this be 'else if'? If not the layouts wrong ;)
I don't think we need to do this. We should deprecate the HttpLogOptions one, and have it take lower precedence to the clientOptions one (so we only use it when the clientOptions one is not set).
Should be Interrupted exception instead of KeyChain exception?
is there any reasonable way (and there may not be) to make all the places that use this value leverage a single constant?
I was confused because the existingIndexes structure looks like some sort of deserialised JSON! Well I think that listIndexesInDatabase and similar methods should return more self-describing data types, and this should include the use of the Enum. This way you can limit the conversion between enums and strings to the database specific code in IndexManager.
Would it make more sense to inline these just before the </head> tag?
Shall we turn-around the equal check for avoiding any NPEs ? For ex: "something".equals(string)
You might want to catch NumberFormatExceptions here and transform them into suitable exceptions. One try-catch-block seems enough, since you cannot recover from this error here anyway.
Give more error info instead of empty seems more friendly?
Optional is java 8, I don't think we should base too much of our logic on it
I cloned this branch to play around with moving adding splits into this class. I got as far as writing the following function. I think this function would work for 0 or more splits. One thing I realized while attempting this exercise is the current code is using the same dir for each tablet which is not ideal (it may work). So dirFunction below represents this TODO. java private void writeSplitsToMetadataTable(Table.ID tableId, SortedMap<Text> splits, Function<Text,Value> dirFunction, char timeType, ZooLock lock, BatchWriter bw) { Text prevSplit = null; for(Text split : Iterables.concat(splits, Collections.singleton(null))) { Mutation mut = new KeyExtent(tableId, split, prevSplit).getPrevRowUpdateMutation(); ServerColumnFamily.DIRECTORY_COLUMN.put(mut, dirFunction.apply(split)); ServerColumnFamily.TIME_COLUMN.put(mut, new Value(timeType+"0")); MetadataTableUtil.putLockID(lock, mut); prevSplit = split; bw.addMutation(mut); } }  One possible way to handle this is to do the following. * In the ChooseDir FATE step, read in the splits and choose a dir for each split. Write out a new file with the dirs. * In the CreateDir FATE step, read the file with dirs and create them. * In the PopulateMetadata FATE step, read the file with dirs and use those for creating rows in metadata table.
This code duplication doesn't bother you? I'd create a preceding patch extracting the common logic among createRow() and createBlankRow() to a separate method, and then only change this once.
request is not an argument here. This should be checkState
Use just 1 here (The single value form of grant).
Could you please move the URL hash code to it's own method? I think this will make it easier to read here and understand what is happening.
Can you use different test values for stock, experiment and instance IDs for better assertion?
Suggested "floatBits" or "valueBits"
This method should be tested via a unit test. And this change should cause an update to that ttest (but I don't see it). If it does, update it so that the tests pass. If not, please create one.
It is quite surprising to me that the provider will save the result but not try and load it first. I think the API should not save the authorization. I am even more convinced the API should not do save without trying to perform a lookup as I find this asymmetry confusing.
Maybe here we can break the loop.
[optional] eliminate the 'token' variable dest.append(LoginUrlToken.getToken(req));
shouldn't that be set in a finally block ?
Is this part of the issue?
The given ...
Not sure about MULTIPART_FORM_DATA can we rework it to accept octet/stream?
IMO this should only be set when -Ds3guard is passed on the command line, similar to what other tests were doing before. Tests that are only meaningful with S3Guard should Assume.assumeTrue() on this, but other tests that are meaningful without it as well should still be getting exercised.
super.getProcessName(event) does pretty much this. If pName is null there, chances are you won't have anything here either.
fileLocation is printed out twice
Add final keyword.
Please, consider moving Runtime start spans names to a dedicated class with constants.
I suggest removing this newline
s/, error//
Should the substudy filtering tests be updated to also look at external IDs?
I think these two could be combined as well.
this can potentially log a tremendous amount of errors. Can we cap the logging at something reasonable? Default = 10 or something
Is the cast needed to get the generics right?
Isn't it the same thing?
forms.isPullSelected(form)
Might want to wrap this in a ConnectException. In general, I think attempting to restrict exceptions that get thrown up to the framework to ConnectExceptions and then ensuring we have enough expressiveness in those will allow the framework to correclty respond is better than trying to handle arbitrary exceptions. (Of course we need to handle them since we can't guarantee that they won't be thrown, but trying to minimize them and also indicate intent will encourage correct handling of exceptions.)
it would be better to get only vm static instead of all vm object
It's not the good I18N.
since mData could be null at this point, let's check for npe
It shouldn't be removed as it is more likely needed for displaying amount of results.
You don't need to enumerate all the keys one by one in a Collection...you should be able to use getPropertyKeys("oai.harvester.metadataformats"); to get a List of all matching keys, instead of looping through everything starting with "oai" and then looking for "oai.harvester.metadataformats" within that.
This should be in a separate commit for ISPN-11295. Also, I would expect no blocking in the vast majority of cases, so we need an optimized path for that case and/or a PerfAck test to see if the extra thread switching affects performance.
queryStatement will always be null since it is never used, so removing this logic as well as the variable
The alignment is a bit wonky, I'd rather split it into java responseBuilder.contentType(APPLICATION_JSON) .entity(JSON_WRITER.toJSON(configuration)); return CompletableFuture.completedFuture(responseBuilder.build());
Why do you need created n files? It'd better use >> instead of > and cat all content into one file part by part.
use getVdsDAO() instead of DbFacade.getInstance.getVdsDAO
Might it be worth it to confirm that the logged thread terminated?
braces
Maybe QuasarHelios.clamp.openControl.set could have a good helper addition to the base class?
space before '(' Applies in a few other places in this file too.
Worth extracting a method and change the read of the property name to also use it (to fixing that one as well).
can be null
This is a fluent model, you can chain these properties.
Now the relativize command is missing, right? Maybe have something like if (linkedFile.isOnline()) link.setValue(...) else link.setValue(relativize(Paths.get(...)))?
Does this code handle the scenario when proxying is not required? Note how Spark has an if/else statement depending on whether shouldProxy() or not <LINK_0>
Why was this removed ?
parseGrid1Request looks like it either would throw or return RegirstaionRequest. Should this just throw? Or at least return an empty request object?
Remove this.
Same as in other checks and same below.
java8-isation [optional]
I think it would be better to not call .connectionPoolSize(int) at all if the flag is not specified for helios-agent, that way the default value when not specified still resides within the DefaultDockerClient.Builder class as it does today.
It should be ... State.PLAYING && isTTSInitialized ...
why isn't this implemented in ViewGroupDescriptor ?
This certainly should be if(!values.contains(modifiedValue)) values.add(modifiedValue); and it could be placed in the previous if condition after &&
Could you please explain what's the purpose of this removedRepos list? You seem to be accumulating repos in it while they're being deleted, but then you don't do anything with it.. Shouldn't you fire some "repo deleted" notifications like you're doing in the method above? This would probably deserve a unit test
nit: Do we need to do a ImmutableList.copy over variables.build()? (Since it already generates an ImmutableList
Use constant for "replica". Do we want port and partition with no separator?
Its slightly awkward that landmark is unused here; its really just a for loop over landmarks.length.
You don't seem to gain much by moving the synchronized method from createRealmOrGetFromCache to doCreateRealmOrGetFromCache ?
Nitpicking, but I'd like this in the test before the node is killed
Store the positive concept in a variable outside of the loop so you don't have to re-fetch it each time
can this be storageQos?
nit: For consistency, can we rename delayMs to latencyMs?
This can be misleading in cases when running on non-Azure hosted machines. As we default to VM credential if MSI endpoint is not set. Should we check if IMDS available before logging the environment ?
This is not needed
why not init fRequirements in the beginning and make it final?
You can put the guard clause first to reduce nesting i.e.  java if (!response.isPresent()) { return false; } // Successful flow
It would be interesting to check the stored ids also, and not just that they are not null
Merge the HandleServiceFactory and the HandlePersistenceManager
Do we have a potential leak here? I believe if we are calling resolve() we need a close as well.
Is it really valid to always do this? If a user registered his custom function via native APIs as lower case he wouldn't be able to use that function through our API. Maybe we should look up the function in a case insensitive tree map and use the name by which the function is registered? That would only work in the sub class ResolvingQueryGenerator
log in this case
This finally block grew too big. Consider moving its contents to a separate method. I'm also concerned with exceptions that can be thrown by this method. With the current code these exceptions hide exceptions thrown by the body of the try statement.
My first thought was that this is an impacting change as AQL implementation will deactivate its expression cache for all evaluation in activateMetamodels but the SiriusEvaluationTask is used by the Sirius interpreter of the InterpreterView. So ok
Introduce a private method for the right hand side please, I don't know what we're doing here ;)
You need a new line above.
Why not to do it once and use it 4 times?
heap is unused here?
use {} in LOG statements
Replace with a TypeScanner:  new SimpleAnnotatedTypeScanner<Boolean, Void>() { @Override protected Boolean defaultAction(AnnotatedTypeMirror type, Void aVoid) { return type.getAnnotations().isEmpty(); } @Override protected Boolean reduce(Boolean r1, Boolean r2) { r1 = r1 == null ? false : r1; r2 = r2 == null ? false : r2; return r1 || r2; } };
Sorry, but I am not understanding this: can you explain why you are setting this system property?
I think that this method will never be called passing "false" as the parameter, so it may be better to have only one "readOne" method, that doesn't receive it, and that behaves like the current one when it receives "true".
totalCount could be got from configLoader
log.trace if anything
equals or compatible? For example return 0 will work for a double return type?
Should we change the test to actually verify the onChanged events separately? Kind of confusing to verify that the second time is a PendingIntentRequiredException but we don't assert/care what the first event is.
This should probably default to 443
do you want to add the cookie name/value in the message?
I have a vague recollection that this has broken in the past and we added in the toLowerCase to fix it.
CatalogServer.alterTable() throws only UndefinedTableException. Did you add handling other exceptions for future work? Even though you did, I think that DuplicateTableException does not occur.
I slightly prefer using a Visitor: java out..walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { public double visit(final int i, final int j, final double value) { return matrix.getDouble(i,j); } });
@vkuchyn better message is "Use diamond operator"
Should we only alert if the failure to contact the executor is consecutive? If Azkaban is up for a long time, then it's likely there could be intermittent failures to contact the executor, and these could eventually add up to 6, but the last failure could have been a few days ago.
c != null check is redundant with the instanceof check after
I think if we move the logic into the UserAgentInterceptor we could new up using the prefix string and avoid all the reflection.
This locking technique is fine for now, but if we want to be able to scale to multiple processing nodes, we aren't going to be able to rely on a lock that is within a process/thread.
What about testing the usage of [var in lambda parameter definition](<LINK_1> (JEP-323)? java @Nonnull var x = new Foo(); (@Nonnull var x, @Nullable var y) -> x.process(y)
condition can be simplified as data cant be null
logger.debug
IllegalArgumentException seems like a better fit here.
Do you have to do hasReplicationServer first? And then read it if present? Or maybe this defaults false if not present?
Doesn't this need to be a bootstrap datastream? I thought generateDatastream() only generates DUMMY datastream?
Maybe there should be a Style.getAllSkins() method returning a collection? Then you can still use addAll :) <logic,review
I think we should provide customMsg as argument (or instead of DiscoverySpiCustomMessage msg) and do not duplicate:  DiscoveryCustomMessage customMsg = msg == null ? null : (DiscoveryCustomMessage)IgniteUtils.field(msg, "delegate");
The variable should be renamed similarly?
Similarly this line can be removed :)
We've a Configuration value for ?stable=false, not sure if it's client only. If it's client only, add it to the internal API configuration.
One might want to perform a long comparison due to potentially problematic floating point comparisons.
(...).equals(Boolean.FALSE) -> !(...)
why hardcode objCount?
With empty string, "".split(delim) returns array of length 1 with empty string as the element. Then, adding to the list a folder "myFolder" and joining will result in ";myFolder" - with leading delimeter. Maybe it is not important in this case, but please check it.
Instead of ignoring the test, please catch the exception and verify that the right exception is thrown i.e. check for a known part of the exception message.
Is there any reason to support authentication-realm and authorization-realms attributes at the same time? Or why isn't here else statement?
This is checking for reference equality, not string equality.
suggestion Map<String, Class<?>> extensionClasses = new HashMap<>();  It looks better like this.
awaitRetentionExpiration(500L); -> awaitRetentionExpiration(500); for the three last use
Just a question, why do you use Objects and not something like:  if (getContext() != null) { getContext().getContentResolver().notifyChange(rootsUri, null); }
is confirmed locally about test results <LINK_0> could you please check those?
Just wondering, why SQLiteTemplates?
the same to <LINK_0>
i don't understand. may you describe logic of this method?
This change is not equivalent to existing code if coins[j] contains 0
Why not try-with-resources?
Don't do this if there are no case insensitive indexes
Also, let's update the log - someone didn't try to roll it back, they did.
Is it really that complicated to extract the preferences and replace Globals.prefs by constructor arguments?
why two variables? you can just use one found of type Method. If it's null - it means that nothing was found.
why are you removing initial character? This is partialy responsible for test failures on *nix I believe. What is the output for you on Windows?
might want to use optional.map().orElse() or optional.ifPresent()
I think you need to have 2 loops here. As is, all the checks are still duplicated when the parent gets rejected. Or, you could keep a rejected set.
0 is a magic constant. I think this should No_Error or some such. Maybe also offer an interface to PutResponse that does not require an ErrorCode to be passed in (i.e., implicitly sets No_Error). When we have error codes, hopefully the interface is an Enum type rather than a native short.
This method seems to be a copy of SourceForeignKey.checkImportedModel().
I don't think this is the right thing to do here. This is supposed to be the maximum size of a sample, which is unrelated to how large the AudioTrack buffer needs to be. Based on L103/L104, it looks like the maximum sample size would be the maximum size of a tag payload. Is that bounded in FLV? It looks a bit like it could be up to 2^24, which is really too big to be setting here. If so, it's probably fine to leave it set to Format.NO_VALUE as is done for the AAC case.
Shouldn't this message be added to another class in the same way the other logging messages were?
I am wondering if it works as expected. Let's say currentStandbys.keySet() = [2, 3, 4] and newStandbys.keySet() = [1, 2, 3]. So 1 got added and 4 got removed. We do retainAll on newStandbys on line 207, this will make it newStandbys.keySet() = [2, 3] and 1 (a new standby that is not in the current config and is only in the new config) will be left out?
Better to use doAnswer(invocation -> values).when(mockMemoryStore).getAll(); or when(mockMemoryStore.getAll()).thenReturn((Map) values);
please here use also getBooleanValue, it should simplify the code a bit
violationstore.save("msg");
I think this keeps the status permanently at 99%. I think we want something like Math.min(progress, 99.9)
sorry, I realize that setting this option whenever a failure reason needs to be sent creates a lot of duplicate code. Maybe a better solution would be to have a request-level internal key that can be set to true when that request should be allowed to receive error info (for any exception type). THe approach in this PR should work, though!
What happens if user-agent is not set? Does this return an empty list or null?
remove?
this may not always be true if it's to be live reloaded
If the integer cannot be accessed from multiple threads, there is no need to make it atomic.
typo: request.
if input is null isn't it valid for blacklist patterns ? I think we should either throw illegal argument exception or consider null as valid. I prefer it to be considered as valid because then the caller doesn't need to unnecessarily check for null of the input all the time.
Do we need this as part of this patch? If it fixes another issue, let it be a different patch.
Why don't you directly build String[] here? Btw, there's a findbug violation on casting to String[] below
Minor typo in variable name; has an extra unneeded "m".
Is there a reason why these lines are removed?
rename o1 to method1 and o2 to method2 for better code readability.
If path is simple, i.e. just the project name, then ppath.lastSegment().equals(path) is true and as a consequence locatioURI is set to null (the default location). The parameter insidews is not taken into account in this case. Please fix that. I think (!ppath.lastSegment().equals(path) || !insidews) would work.
Even if this is just temporary, we should still use OkHttp's client: java @Override public DownloadResponse head(String siteUrl) throws IOException, ReCaptchaException { final Request request = new Request.Builder() .head().url(siteUrl) .addHeader("User-Agent", USER_AGENT) .build(); final Response response = client.newCall(request).execute(); if (response.code() == 429) { throw new ReCaptchaException("reCaptcha Challenge requested", siteUrl); } return new DownloadResponse(response.code(), null, response.headers().toMultimap()); }
The thread should clear the interrupted flag here, right?
This if doesn't do anything
We could probably simplify this a bit: suggestion return supplier.get();
We should move this statement to the outside of else clause. Also, what do you think about a more detailed log message? For example, we can log information about blockId, old & new owner Id.
Don't we need to kill the thread pool in the end of test? The point is because of this:  public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); }  I mean it dies, of course, in the end of the JVM, but it still going to hang on during test suit execution.
For my curiosity, why the parenthesis is needed?
Why keep the random number? But the bigger problem is that CountMarshallingPojo uses static fields for the marshall count, and it breaks when 2 of the many tests that use it run in parallel. Either it should have a custom raw marshaller, with a different marshaller instance in each test, or it should have a test name field and it should maintain a map of marshall counts per test.
let us avoid any new lines unless there is a reason.
Same as with the radio
We must check if resourceClasses is empty and in that case, set the width manually, as is done in fill(). Currently the following test is a problem: Run two debug sessions. Display a resource class. Select the other debug session => the Combo box is resized much too small and does not resize anymore.
this should probably be bounded by the max ttl config?
Use assertNotEquals instead of == operator combined with assertFalse, == does not work properly for non-objects. <testing
can you please use {} brackets around single line if/else too?
looks like we have to do this in all code paths that consumer the response.
getContent can be null if the file was only moved
This may throw exception
We could cover it with some tests.
Same here final AgentProxy agentProxy = AgentProxies.newInstance()
These shouldn't be in the memory cache section.
Do you really want to wait 6000s here ? This is almost 2 hours, that's insane for an automated test.
use this instead NhincConstants.ASYNC_DB_REC_EXP_VAL_UNITS_SEC.equalsIgnoreCase(units) and remove units!= null
Looks like I see an issue with TcpNioConnectionTests.int3453RaceTest. Previously we waited for the TcpConnectionOpenEvent, but now we have a new one TcpConnectionServerListeningEvent, which definitely is emitted before connection.publishConnectionOpenEvent();. The  if (event instanceof TcpConnectionOpenEvent) { connectionLatch.countDown(); }  fixes the early exit from the factory setup.
Move to static getActiveInstance() and use it everywhere?
Instead of isOptionAvailable, getGcType makes more sense
I may be getting lost in the diffs, but where did this method go?
I don't think "%s" works here. Should be "{}".
Minor: false is a default value.
arePublicKeysValid (or something like it) But *VERY* minor
Instead of passing StringBuilder can this be only String?
I wonder if it's quicker to just do one query instead of two, then separate the results by ToolMode? Filtering and sorting are a lot faster in the DB, but here, you end up fetching all tool modes anyway, i.e., not filtering on ToolMode. That said, probably not worth worrying about, and maybe it is faster the current way.
This function up to here can be replace with a call to fixNowAndGetAllowedWindow
This is unit test running locally, where is hdfs coming into picture? why do you need hdfs??
You need to instantiate LttngKernelTrace here otherwise you will get a class cast exception
We should probably use the separator for the slashes in the /stor/multipart string as well.
29 seconds is a fun number :)
Shouldn't it be !Number.class.isAssignableFrom(clazz)?
We should only do this for direct exchanges. Rabbit seems to be forgiving if you set a routing key for, say, a fanout exchange, but maybe they will tighten it up in future. Unfortunately, though, the factory bean doesn't currently know the exchange type.
IIRC, since CommonModel#signOut was removed, this listener will never be called, so we can remove it.
I guess you mean: java return DEFAULT_ENCODING;
+1, I generally prefer this style so that all occurrences match.
String.valueOf is unnecessary. So the following should suffice: "operatorId=" + getOperatorId()
Framework.getService(RetentionManager.class) can be extract outer the for loop
Don't do the string formatting yourself, that's done by the logging framework, i.e., change this to log.trace("Sending delete request: {}", queryUrl)
maybe move this up and use the reference to avoid the repeat calls of  ((CheckBox) view.findViewById(R.id.layerCheckbox))... below. I know it's not your code, but would make it much more readable below :)
You probably want to keep this? Do change the connectorName though, seems like a copy-paste error
Why you throw plain Exception ?
name1 must be final here
Lets do this with a traditional try/finally as it is more obvious what is going on. If there were more things going on in this code (e.g., loops, conditional code, etc), then closer might make sense: java try { input.close(); } finally { if (decompressor != null) { decompressor.destroy(); } }
I'd rather have the original exception propagate rather than be logged; just drop this catch clause.
you should make sure all the apis have been called
Why does it check for platform here but not in other places where this is used?
Response is not closed
Why logging at trace level?
Trailing whitespace. You can set eclipse's save action to remove all trailing white spaces since we might not be able to detect all of those manually.
Must be uppercase, too? Or would we also be happy with lowercase input?
Check item and expectedType compatibility?
shouldContinue = (done != total)
Should we create a constant for the value 10 and use it here and when creating the insert string?
Line 307, using as h is inconsistent with line 291 where the as is removed
please change to validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDi sk)) to align with the rest of the method, no need for that variable.
else is not needed if you return
nit: space before "time"?
debug/trace/remove?
suggestion - replace it with ternary-if: setspice(pluginSpice.detectBrowserPlugin() ? ...) , it will be shorter and more readable
Just a note here. We have an unchecked cast from java.io.Serializable to java.util.HashSet<java.lang.Integer> that could lead to aClassCastException if at runtime the type cannot be found. In these situations, a Parcelable is normally used to avoid this but I think for this solution we can use this as-is.
suggestion if (error != null) {
Same as above - old version was more readable in my opinion because now the condition contains more parenthesis, even wrapping multiple lines.
Doesn't look like this is used
Might want to encapsulate all of this into one object.
You should not call the parent impl
suggestion AccessExecutionVertex[] taskVertices = ejv.getTaskVertices();  Could we do this renaming to improve the readability since we're dealing with different types of vertices in this code segment?
we do not create the extension, we can do it lazily so defer the instanciation to the Registy.get*()
Would an warning message be appropriate where in the case the SVG is not found ?
I think we can just do CorporateCardSurchargeCalculator.getTotalAmountFor(charge): it will return the correct total if there isn't a surcharge
this.coll = new HashSet<>(); this.coll.addAll(input) -> this.coll = new HashSet<>(input);
Keys like "attempt" should be defined as constants somewhere
Use fail again?
This one needs to remain unchanged, if only so we know that API is working.
here that should be possible to initialize DatagramWriter with a size ?
Looks like updatedAssignment = topicsChanged as it's used currently? In theory it's unnecessary, but at least it can be used more clearly? Edit: I see what it's doing, nvm
Then it's IllegalStateException?
Do not use equals here - reference equality is what you need here.
This could also use try-with-resources.
Should be response instead of method.
Does NOT DISTINCT return NULL or FALSE if only one side of the op is NULL?
How about userTypes().contains(metricType) ? This stream+filter+findAny construct looks a bit convoluted in this case.
try / finally here too
In my opinion the target should be a member of the ProcessingInstruction and not be part of the textual content. It is equivalent to the element name. There is also the possibility to formally define PIs using NOTATION. So it's much easier to handle this if the target cannot be edited as normal content. There are some formal requirements the target has to fulfill which can be validated easier if the target is isolated from the content. Also getText() would always include the target. Users of the API would always have to remove the target from the text. To insert/edit/change the target of an existing PI we can provide a special action or dialog.
this is a candidate for a faster alignment detection (pos & (BIT_CHAR-1)) != 0 The compiler won't be able to optimize because he can't proves 'pos' is only a positive number.
This change is not needed. Please restore changes made to DatabaseShardManager.java.
rename to operation
It is possible that containerId is null here as well. It will be better to handle containers with ExternalId null in this loop only.
Can't we use the same line without exceeding the row width?
The signatures here are good, but I am wondering where the work of actually creating the object in fedora is moving to? It could be directly in these methods or could still be in another class. But someones got to do the dirty work in the fedora api!
@webron is this correct? That the _wrapped_ value would take the name items and the XML property itself would be item? I believe it's the opposite, but I've been staying far away from XML-land.
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
Are we hiding a bug here?
This should be a test error.
Use a more complex path in the test to also verify the fact that the entire path is not encoded. We need to verify that in the tests too.
This should be done also when not using a SiteNode. Any reason not to do this in authenticate instead?
no provisioning will happen as long as there are things currently provisioning? do we want to be able to still provision here, up to a limit?
Did you mean to leave in this em.remove()?
might be worth creating a function selectButton(View button) to set the typeface and the color?
Use AtomicReference<RealmAsyncTask> instead. It is much more readable IMO
Use (SWT.H_SCROLL | SWT.V_SCROLL) instead of SWT.NONE style when constructing the table
The term 'processing' is rather ambiguous in the case of scheduling. I would recommend using 'triggering' here.
@omkreddy can you make similar changes here as well?. I had missed this in the previous review.
If it is an error, it should fail and the process should not continue. What the customers/support can do with such error/warn logs ? The purpose is only to help us debug a problem.
It's not obvious that 102L is the same as 0B1100110L...
shouldn't this be called by private constructor? what is the meaning of calling it twice on singleton?
This check should be the first thing we check. Need to define a boolean isDiskImage = disk.getDiskStorageType() == DiskStorageType.IMAGE
we know that values produces at most single row here, therefore PROJECT/FILTER/MARK DISTINCT is not needed
I do not like that we do not pass segment to doSnapshotIndexes .
fail
I would not include this message. Usually an interrupted exception happens when we are killing the thread, which should only happen in shutdown and in that case the error is misleading
could you change this to List<PartitionId>?
Why do we only remove the task if it was active now?
isEmpty
Shouldn't metadata be the default?
I think it will be better to have separate property for ability to tag/untag sessions.
pk -1 ?
@gknapowski it should most likely be route.isSecure() && !route.isTunnelled(), that is a direct (non-tunneled) connection to the proxy can be considered secure if the route is considered secure.
mitSearchAdapter should be instantiated with an array of size 0 if set == null
I don't really know how this is used, but we might want to do something more like.  final OutboundSocketBinding binding = outboundSocketBindingSupplier.get(); if(outboundSocketBindingSupplier.get() != null) { senderConfiguration.withAgentHost(binding.getUnresolvedDestinationAddress()) .withAgentPort(binding.getDestinationPort()); }  I don't know what the overhead of get() is in MSC, but it seems like a single get() would be better.
Should probably change this method to query initially for matching IDs then pull the status records by ID. If not you'll hit the error that I did.
Why is this needed? If this is done because of errors, then the problem should be fixed where the update is called where it shouldn't be. <bug
logger.error ? logger.debug ?
don't delegate to the value processor. Just do this yourself.
This will break the LogicalLineNumberRulerColumn in EGit introduced in <LINK_0> . Besides, it doesn't update the fCachedNumberOfLines. Just call computeNumberOfDigits() instead?
do we need to do this if updateDescriptor is set to false?
117 can be moved to before 59. this line only needs to be done once and shouldn't have anything to do with cancelled/completed. Remove 116.
actually you don't have to copy bytebuffer to an byte array, Crc32 has a method to update CRC with ByteBuffer directly and it doesn't matter if it's heap bytebuffer or direct bytebuffer.
You should split existing rpc docs for this branch (I believe its second doc) and add version with new param onlySponsored. Also it should be added to OpenApi, but I'm not sure, if we have this part of API already done. If not, then its not necessary to add it right now, as it will be done by someone later.
Looks like this trace line will cause us to call resolveUpstreamDNS twice rather than one and storing in a variable for logging.
Is it safe if we moved DB operation outside of synchronized block and let the database handle concurrency?
static import
Looks like they need to match, this does not serve the resources
You are comparing floating-point values with '=='. That may not work all of the time. In this case, you are better off using as BaseVector3f.equals() seems to have some extra logic in there. It's also a lot shorter and easier to read.  if (lastCollisionLocation..equals(collisionEvent.getLocation())) {  I guess the only question is whether checking the Y location matters. If you do not want to consider the Y location, then maybe using the code that BaseVector3f.equals() uses would be a better approach.  return Float.floatToIntBits(getX()) == Float.floatToIntBits(other.getX()) && Float.floatToIntBits(getY()) == Float.floatToIntBits(other.getY()) && Float.floatToIntBits(getZ()) == Float.floatToIntBits(other.getZ());
Could we assert the expected fetchedRecords?
System.identityHashcode ?
hasHostMachines() can be used instead.
I see the code here and below is only used to generate the big JSON test data but you can't call it from tests since it uses the same JSON utilities being tested, so it's smart to generate only once, validate the output, then dump it into static golden data. But we could have one improvement here: make this helper class a unit test too, with one @Test method that validates the golden data by comparing it to the output of the generator functions, i.e. similar to this main method except that you would do an assertThat(REQUEST_...).isEqualTo(generate...) for each constant. This is important to detect bugs that may inadvertently change the output of the generator functions, but might not be captured by the existing tests which only read the golden data.
Removing this line has only one impact on unit tests: we don't raise an issue anymore on:  def raise_builtin_function_python2(): raise super2() # Noncompliant {{Change this code so that it raises an object deriving from BaseException.}}  I don't get why we expect an issue on this test case.
You could fetch config.isFactoryResetOnDeletion() only once from the config and hold it in a variable.
Why isn't this a for loop? That brings all the control structure into 1 statement; currently it's on 2 statements here and on 1 more statement that is 43 lines away from these.
SuggestedFixes.qualifyType on "com.palantir.logsafe.UnsafeArg" will add the import automagically, or fully qualify the type if there happens to be a foo.bar.UnsafeArg already imported. We can append ".of" to the result.
Sets.intersection(subTypes1, subTypes2)
You should return the error message either via an Exception or just a simple return instead of returning a ResponseEntity. ResponseEntity should be constructed in the controller
If this fails, should we try to move the backup back to current (provided the first rename passed)?
Please use consistent indentation when adding new code. The changing indentation within this single method makes the pull request more difficult to read. Most integrated development environments (Netbeans, IntelliJ, Visual Studio Code) provide automatic formatting that can be applied to subsections (like this new block of code). suggestion r.waitUntilNoActivity();
whitespace  tile.execute( this, tileCanvasViewGroup.getBitmapCleanup() );
Even if the caller of the method is acquiring the lock, you should also acquire it in here to make it clear you are. Doing a wait() on an object in a method without first synchronizing on it is not a good practice and can easily lead to issues during maintenance if a developer decides to remove the synchronization in the calling method.
this condition, negated, can be added to the if above: if(!p.isOpen || projectLocation == null || !repositoryPath.isPrefixOf(projectLocation)) this saves us the more expensive IO check for the file.exists()
I just wanted to verify that UTF-8 is working end-to-end, can we do this test with any other entity, like a survey or a study?
would it be a bit simple we maintain this map instead of a normal hashmap in this class ?
It would be good to assert that the password is not null at the beginning here
Correct me if I'm wrong, but here you just setting the original body and status code, headers are lost. Or it is a desired behaviour? And what do you think, would it be reasonable to use ProxyExchange [<LINK_0>](docs)? However, I have never worked with it, maybe it doesn't worth it.
This can be condensed: _preserveSourceEventTimestamp = Boolean.parseBoolean(datastreamTask.getDatastreams().get(0).getMetadata().get(DatastreamMetadataConstants. PRESERVE_EVENT_SOURCE_TIMESTAMP));
Why is this synchronized? It looks like it might is because there is a concern about multi-threaded access to cacheMap. If that is the case, then you *must* synchronize all other access to cacheMap on the same lock... and I suggest that you might consider using a lock other than the Class object.
You could totes put this all in one line \o/
I think you can do something like  return Arrays.asList (roleAPI.loadRoleByKey(Role.ADMINISTRATOR), roleAPI.loadCMSAdminRole()) .stream().filter(role -> null != role).map(Role::getId).collect(CollectionsUtils.toImmutableList());
Hmm... if the tile is not there do we need to init it to remove a tile that won't be inside it? :-)
It is mean that you have one puppet instance per each region. Is it correct? is it the same for Chef?
Please use parentheses when combining || and && to improve readability
It may be confusing if we do this when user is waiting in the confirmation pop up for started volume. May be start all volumes(with and without force)after the confirmation for force(if there is case for force) in a single call.
> Verschwindungszauber This doesn't feel like the correct term.
Likely, getClientTags
could be simplified to:  if (site == null) { return new StandardUsernameListBoxModel().includeEmptyValue(); } else { URL url = site.getUrl(); ... }
This hardcoded list sucks. Maybe a meta-annotation?  java @SqlObjectAnnotation public @interface SqlQuery { ... }
Maybe rename to something like: suggestion var unresolvedWindow = maybeWindow.get(); final Window resolvedWindow;  To clarify the difference between overWindow and window
Can be simplified with lambda evt -> evt.getKey() % 2 == 0
rename to  final Container container
Please keep this method simple by moving added logic in separate method
PLease use injection to check env variables.
Is it on purpose to not give exception to WebResourceNotFoundException ?
These exceptions can go into the method signature I think. Removes some clutter.
suggestion buffer.skipByte(); // OkPacket Header  Does this need to be checked to ensure it's 0x00 (or 0xFE for EOF payload functioning as OK payload?) or can we just assume it's correct?
I'd really avoid the habit of re-writing method parameter values. What about: if (isMainTab) { commonModelProvider.get().addPluginModel( searchPrefix != null ? searchPrefix : label, historyToken); }
Add this to be consistent with the above
Confused about Java. Should it be } else { (all on the same line)?
with change I74e932d5eacd74dbf6b0dffcfc65ba3222a8250e this should become getTrackingBranch(), then this will also work if the tracked branch is a local one
there were no close calls in this method before. How did closing the file become the responsibility of this class now?
Should this just be a RuntimeException? OFE indicates a client mistake of some form. Server faults can be runtime exceptions which then get logged in the server.
What's the difference of this line? Let's try to minimize the diff for reviewing.
Do we really want an INFO here? You made it a debug elsewhere.
What is the lifetime of the MathJaxBackroundRenderer object? In most cases the DocDisplay returns a HandlerRegistration that needs to be manually deregistered (look for "releaseOnDismiss" for examples)
redundant parentheses
This method can now be private.
I would not use final here, the scope of the variable is relatively short. The final obstruct the reading more than it provide guidance.
I think this empty line is not needed.
Could you have a test on setting request id?
Use query.setParameter and use TermId.LOCATION_ID.getId()  instead of appending to query string
I wonder if there is anything else to assume about the completion. I'm just thinking about the forward compatibility, where they change it to "Complete" or something completely different. Perhaps onComplete is a good place to set the flag?
This would not be needed when passing context with processStats.
I'm not quite sure about that code. Shouldn't it be removed?
Doesn't getInstanceResultSubset already apply numResults before returning? If there are i1-i20 instances and if startTime is i11 and numResults is 5, does this code return: i16 - i20 OR i11 - i15 ? From the code changes, I think it will be i16-i20. But, what Pragya is asking for is i11-i15. Can you please confirm?
let's also rename this to contentTypeAPI
This does not seem realistic? incrementFailureCount() returns the new failure count, so should not return 0, and certainly not anyTimes()..?
Do i read correctly the only purpose of the map is to extract the value of this single entry 10 lines below?
You can disable the action if volume is down
might be useful to include the actual length too.
Should add more tab spacings to line 60.
Why the batch here? It only contains at most one operation.
can be invoked if the remove is successful.
can this be mandateId please?
Remove this unnecessary ArrayList instance.
Guessing that after setting the axon_code_style.xml, these changes would be reverted.
there is no need to handle visibility in the action. This logic is the responsibility of UserSession
There is already a runOnUIThread in this class that takes a Runnable. As this callable does not do anything with the result I would recommend changing it and getting rid of the then unused runOnUIThread(Callable)
log.trace("Proceeding event " + event.getName()); ->  log.trace("Proceeding event {}" , event::getName);
Don't see reason to have this if...else. It would be just enough to use: firstRecordExpression.getValue(evaluationContext, requestMessage, Number.class)
Looks quite useless. Since this is the viewer, any reason why you have the getViewer() method that basically returns this?
why did you wrap in a ThrowingRunnable?
Since this isn't actually what we're testing, maybe we don't need assertThat and can just call hasNext directly.
please use { } for all ifs suggestion if (!EXTRACT_CONTAMINATION) { CONTAMINATION = 1 - CONTAMINATION; }
That should be toHtmlForPeriodical. You mixed those two up.
Interesting! Wonder why you calculate mvbsSize in two steps rather than one?
Too long
Do you return all the states or just the ones within range? Also all the states? No resolution? I don't remember how it was written originally, but if there's work to do to improve this (large traces can have large critical paths), please add a todo. Or I may be mistaken.
this shouldn't be required any longer I think.
cache the value of getModel().getObject(). I suppose, it may be expensive to calculate in some cases.
We don't do this. Please replace with a proper log statement if you feel it necessary
The above two cases are not errors.
TargetControlledPermanent needs to have notTarget set to true as it doesn't actually target anything.
please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO();
Sadly I am not at my working computer. I can do a push on Monday if you prefer.
break;
I suppose I18N is needed here
this line is superfluous.
Putting NoClassDefFoundError here can hide our own stupidity in other parts of this code :-( Perhaps we should narrow the window for catching NoClassDefFoundError to only the calls to testClass.getDeclaredMethods() and testClass.getDeclaredFields() since I think that is the only source for which we need to worry about it?
maybe add "&& entry.getValue() instanceof IntegerDefinition"
As we talked before, I'm not sure if this should be left to HIGH or the default MEDIUM... Your quick test showed that it appears the difference in terms of size is very small, but I guess the difference in CPU utilization may not be as negligible.
Should be comparing Sets instead of array comparison, as the order is not guaranteed.
v -> versions? Since in the else branch it is fully named.
Why not use EntityType#getName()?
Could you turn the resultType in an if else case and if none matches do asString?
this variable is not used; remove
change variable name to something more descriptive.
I would suggest getting layout manager from registration client, rather than construct zk layout manager directly.
Would be nice to have a describe() here too.
Well spotted, this is confusing :)
Instead of adding 2 levels of callback, can you extract the for loop into a function and call it at onSuccess() and onFailure() below?
the ArgumentCaptor isn't used any more so should be removed
I think it's better to use indexedPath.toURI().toString() since it's more likely to roundtrip correctly for non-file paths.
suggestion // global stores are on every node. if we don't have the host info
This sequence of database queries needs to be wrapped in a transaction.
What band this refers to? Gems certainly uses a few bands to select Guide Stars
what is the reason for calling trimTrailingSpaces(codePoints) here?
If strictFilters becomes a Set, this one can be simplified to:  java if (!criteria.isStrict() && !criteria.getStrictFilters().contains(filter)) {  And it avoids the creation of an ArrayList every time this method is called.
nit - the indentation is wrong. It should align with "Read" in the previous line
Perhaps creating a VisualEditorContents class in ContentPatterns would be appropriate for the constants you are using for VE
Use ExtensionDefinedObject<IAtsStateItemCore> instead of this class. this class should be deleted.
I see why this was needed with the current API, but let's just change the API and reduce the complexity - add a T getData() method on the Payload class, and then instead of writing to a new file just get the Uri directly, e.g. if (payload instanceof LocalUriPayload) { uri = ((LocalUriPayload)payload).getData(); }...
This will require more HTTP calls. I think it's better to use a single API to check this and get the server view below. That API should be able to notify caller that the handoff for the requested segment will never happen. We might improve the existing coordinator API, DataSourceResource.getSegmentDataSourceSpecificInterval() or we can add a new one for it.
Prefer adding curly braces if more than one line is under an if statement.
What about making Line.toString() return <sourcename>:<nr>?
Make this "Persist should have failed - exception should be thrown"
Should existingTypes be an ImmutableSet?
Why do you need to remove this?
Need break after this
This changes are not covered by unitary tests in SubProcessConverterTests
Might want to refactor this as a for (each) loop
making a while loop to check the session state would be more efficient.
please use: Backend.getInstance().getResourceManager() .RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
Do we need a call to Instrumentation.markLocatorReRolled() here?
Why not return an Collections.emptyList() here?
Why does it even allow adding the same ticket twice?
Since we can't safely ensure that the profile location map is always a subset of the generic package one, I think it's better to keep them separate in the end (so that we don't have to iterate over profiles twice when doing lookups for packages).
Is the local variable name a leftover from the previous ConstraintPack naming?
Picky: need space before bracket
you could make this more concise: facultyMemberEditor.setSabbatical(_sabbatical.getSelectedInex() == 1);
@tarilabs I am not understanding this? getParentDRGElement should never return null, unless it is used on "<definitions>" or "<itemDefinition>" elements... what is the case here?
The convention is to have all mappers static in order to reduce their instantiations as they have no state. Please extract it into a private static class.
WDYT about passing an empty var-args here instead of new ValueGroup[]{null}?
Why not %d entries?
![MAJOR](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
Can LogicalPlan class provide a new method that allows to add Operator with existing OperatorMeta? Something like  private <T extends Operator> T addOperator(final String name, final OperatorMeta operatorMeta) { }
For exclusiveLocks we don't need the same safeguarding?
AFAICT this only happens in tests, the actual code doesn't need the caching. Maybe refactor to avoid that? Also, could we build this such that the options class is immutable once we parsed everything? Seems odd to have this change state and hold onto file contents.
Do we need some sanity checking here in case it gets triggered without seeing a prior QUERY event type? (i.e. if transactionStartTime == 0 it's probably not legitimate). Or are we guaranteed to always see QUERY before XID?
Seems like we are just reconstructing the original string here, but without the leading V? I wonder if it's better to use the original string instead of reconstructing it every time.
Same thing here and below: not relex but any resource
Maybe reduce this logging to debug, in favor of the cleaner output of OcflPropsConfig.
Only the own implemented interfaces (immediate implemented?), or also transitively?
I am wondering if a standard foreach would be simpler than multiple streams?
Integration test for this new method? @freddyucv
This name is a little bit confusing when mixed with calls to Mockito's verify() methods.
presumably, there no need for the final .toString() here.
This should be 3.0.0?
tiny nit: if we import Versioning.Sha256Versioning and other Versioning.* classes, the changelog should be smaller :)
This method should reuse already found server of ws-agent.
Any special reason why previous test uses Collections.singletonMap("key", "value"); and this empty HashMap ?
That's existing behavior, of course, but let's try to find something similar like a batch for JDBC to increase performance!
Could we just to this with the getAnnotation call and a null check?
Since onPreferenceClick returns true when the click is handled and false when it is not, we should return something from setupPrivacySettings similar to the other methods (i.e. handleDevicePreferenceClick, handleAboutPreferenceClick, and handleOssPreferenceClick).
should it handle rejection?
Please filter the executions that failed (and collect) instead of grouping.
This will not work, you need to  / 255 each value. getFogColor must return 0 - 1 color values
If we are using ViewStub then we don't need separate layouts for legacy vs exo.
If you call with null as a TileEntity parameter, should you add @Nullable on the TileEntity parameter in the getOutput method in the interface to notify users that the tile entity might be null?
minor: typo in "isEncrypted" in the message
change to static import ?
consider this case: - the vmLeasesSupported == false, so in setVmLeasesAvailability() you set the changeProhibityReason - than you change the HA option and you clear the change prohibity reason here never restoring it back But anyway, will it not be easier just call the setVmLeasesAvailability() from here and add the if (!ha) { getModel().getLease().setSelectedItem(null); } into setVmLeasesAvailability()? That would work much better.
I think we should break here. I don't see any reason to explore other arguments as soon as we get the constraint. Especially as there is no way to discard the APPEND option.
Strongly prefer combining these messages into a single log line. Same for other logs from this method.
And what about the UNARY_PLUS ?
Pass the allocator via the constructor. Accessing a resources from multiple entry points makes it hard to change. You can wrap the default allocator and pass that instance to the constructor.
You can move the three lines in a private method extractArchive.
out of curiosity, why is this public?
The method does not need to be public. If so, please lower the visibility to 'private'.
why the double wrap?
For the engine to properly handle the result as an array it will need to be an instance of an array, not ArrayList.
why we are settng timeout when it is zero? And wouldn't zero be non-negative anyway?
Should probably use a Redis.Pipe here. Will do everything in one connection instead of two.
Can the label already have a specified height at this point?
call encoderChannel.finishAndReleaseAll() to fix LEAK
Split up to make readable
Ditto here about error message
Unsure if we can make this change. We are returning the actual stream in the method. Are we doing anything with the stream after this method returns, and if we are, would closing it affect the implementation?
I think this returns null as the fTrace objects are instances of CtfTmfTraceStubs at this point, so their set of analysis modules is empty.
Why not use lengthOfCodePoint and setCodePointAt, instead? That way, you'd avoid the intermediate slice, byte[] and array copy.
I'd replace this test with !spanContainsAnyZipkinConstant(span) to reduce the if statements.
I think this is hiding the original interrupt, better to not catch it.
distinct should be upper case
I am not a fan of assertions in non-test code. Assertions are disabled by default anyway. Could you please remove them? Thanks
Use if
I think in this case it is better to define <code>headers</code> variable above <code>580</code> line + move <code>headers.add(Pair.of("Content-Type", "application/json"));</code> after that declaration, then it will be like this:  java final List<Pair<String, ?>> headers = new ArrayList<>(2); headers.add(Pair.of("Content-Type", "application/json")); headers.add(Pair.of("Content-Length", entity.getBytes().length));
Can there be a scenario where this is null ?
You don't need to materialize the entire list Sequences.toList(Sequences.limit(resultSequence, 1), Lists.<List<Long>>newArrayList()).get(0);
Lets check each job view:  for (ComputeJobView job : jobs) checkJob(job);
consider idToTaskStatusMap.forEach((k, v) -> { ... } for coolness's sake
Is this really defined like this in plugin.xml? I think we should use builder ID. Please use org.eclipse.core.tests.resources.regression.SimpleBuilder.BUILDER_ID
UnsignedNumeric.writeUnsignedInt and 0 when no params ?
Not sure if we need a new transaction here
typo . donwloading--> downloading
Get rid of this
this doesn't look good, use:  String expectedUrl = urlBuilder .getUrlForPathWithoutWiki(Configuration.getWikiName(), MercurySubpages.CC_CATEGORY_TEMPLATES);  or if it is too long:  String expectedUrl = urlBuilder.getUrlForPathWithoutWiki( Configuration.getWikiName(), MercurySubpages.CC_CATEGORY_TEMPLATES );
import static org.apache.zookeeper.server.quorum. ZabUtil.* then you can simplify method invocation by using createQuorumPeer(tmpDir); instead of ZabUtils.createQuorumPeer(tmpDir);
This would be a good candidate to split out into some smaller methods to clarify what's up
final
should this be >=? consider calling contains() instead
Do we want to hide this behind a feature flag? I'd say yes.
The field is volatile; is there a specific problem that adding synchronization solves?
Does this need to change to be a more specific Exception?
I don't see the motivation for this change. It seems that you are trying to handle the case where the input parameter pathParameterValues is null, since the caller does not have path parameters. Fine, but shouldn't the caller simple send new HashMap<>() instead of null? This way, we don't have to take the risk of changing this method in core. and I believe this makes sure the caller know what they are doing.
The test must also follow the format of the others in the file. If there is a configuration for which the test is not valid, then the test should be skipped for that configuration.
Move the if(...) outside of the lock
2 times filtered
Please rename x for title or something similar
ok, i removed it. <LINK_0>
it seems that you can use 'this' instead of creating a new AuditLogableBase instance, which makes me wonder - why not use the command logging mechanism for this logging ? After all, the command is failed, so the getAuditLogTypeValue() should be used to report the event.
one option is to return a Point2D
Since this is part of the V2 implementation, shouldn't this be v2_rest_url instead of rest_url ?
IMO any component that injects an ExpirationManager should inject an InternalExpirationManager instead.
also warm up l1 cache here ?
Wouldn't it be better to do:  for (Repository r : storage.getRepositories().values()) { MutableRepository repository = (MutableRepository) repository; ... }  And use it like this? If I recall correctly, casting to a sub-class was actually expensive. (I might be wrong, but it also looks a bit unpleasant).
The logging is duplicated, but no error is reported to the end-user
@CarlosGines please read <LINK_0>
no need for the fqdn - since now there is no collision in class name
For compatibility with OH2, should use Objects.toString instead. eg. >... = Objects.toString(config.get("accessToken"), null);
No, the reason this works is simply a timing issue: It takes a while for requests to complete. We start more than one. We get backed off because we get a timeout. Then another request completes successfully, so we cancel the backoff.
inline builder variable.
Why not simply using instanceof here? if (!(ldc.cst instanceof String)) {
what does this neutral mean?
Call put() alone is sufficient to replace the old value from tree map.
Can we avoid usage of username and password in sourceStorage at all?
if we throw an exception at either line 47 or line 56, do we clean up our state properly?
What is a ServletException doing in the API module?
align ? and : for better readability?  error = shortName.isEmpty() ? "" : validator.getInvalidityInfo(FieldValidator.FieldType.PERSON_NAME, shortName);
I think as google translator don't think splut is english word, we shouldn't use it :)
processTriple is just part of the logic of the constructor. Move the contents of processTriple to the constructor and then get rid of the processTriple method.
Same here, why the double protection?
Does this need to be logged too?
could we use PROVIDER_ID in pay-java-commons for this?
this is a one-time variable, we can just inline this value
RGB constant?
mockActivty -> mockActivity
should this swallow out of memory errors?
inputData will be better
[minor] Is this indent change intentional?
Shouldn't this be: r.getPatchSetId().getParentKey().toString();
Is there a way to just handle the error instead of the success/failure?
Let's also check that error message !isEmpty() with this condition
abc can be made in a one liner inside the setItem
I would extract local pmcXmlHandler and saxParser variables to class property and instantiate it in @Before section. Then use it in all test cases in this class
nice, include in same loop as provider aspects with Iterables.concat?
The default values on the tracer side changed for LTTng 2.2. Now, the default value depends on kernel or ust-pid or ust-uid or metadata. I wonder if we should change the implementation of the Dialog box and the command execution so that we pass only a value for the parameters if the user enters a value in the text box. Otherwise if text box is empty this particular parameter is not passed to enable-channel command. What do you think? Let's talk about it in our daily meeting.
We should Log.d(tag, message, exception) here
Is this TODO still present in subsequent commits? If so, think it would be best to resolve this prior to merging.
Do we support all fields from the given example? We have to compare the body of the input with the body of the stored annotation similar to the the validateOutputAgainstInput(Annotation storedAnno, Annotation inputAnno)
velocity.
can you break or return after this, instead of an indented else?
failOnLimits should not be needed here.
should be also part of the hashcode && equals?
Why don't you add append below to StringBuilder as well?
Does CloudException actually not tell you whether it is a shared group or if it's a different error?
You could define the right comparator directly, so you don't need to do an additional Lists.reverse() afterwards: fProviders.sort(Comparator.<SymbolProviderFactoryWrapper> comparingLong(o -> o.priority).reversed()); and extract the Comparator to a separate variable if you find that too long
maybe rename var to "attsValidated" or something that means the attrbiutes were correctly validated
lit(annotation.value()) will output the int value directly. Instead we'd want to output the corresponding R field, such as R.layout.component in your example. That's what we're doing with @EActivity when we call setContentView(), please check the EActivityProcessor
nit: maybe something like JackBasedToolchain, since we check a specific error message
@vilchik-elena Why not Map rather than HashMap?
Can we not support generic OBJECT? The idea is to only support specific types.
Same here. Let's create a newLinkedHashSet method in CollectionHelper and I'll optimize it.
what i meant is replace these 2 lines with something like: java final QuranRow[] updatedElements = getSuraList(); adapter.setElements(updatedElements);  and in onCreate, make the adapter in a variable so you can call this setter on it. expose the setter on the adapter also. then you can just remove the show/add methods that you added below.
this is the same problem as before. I don't want to make the code uglier by checkstyle. Is there a way to configure the check that enforces the braces?
This variable is used only once, so can probably be removed and inlined in line 78.
this code is also not so clear. Could you please give it some love?
These are fairly cheap to evaluate. Maybe just use fields in RestApiServlet as the filtering method?
This is bug. It exactly must be local var, because of uuid + QUEUE_NAME_SUFFIX
what about DELETE \* FROM ?
Is it correct to pass null null null? You think we can have like 2 separate methods or to wrap those nulls in a single object? when it's more than 3 parameters in a method it's normally difficult to use and understand.
From reading just this line I have no idea what the second and third argument are for. Maybe have two different methods for each value of the boolean argument. And include something about the integer argument in the method name, e.g. simplePostAuthenticationDialogStartingWithTag()
I think this should be an error...
It's not a big deal, but I'm curious why this was changed to use mPost.blogId and mPost.postId?
minor nit: same, please add more details for error if possible.
Even better would be to have an SshValidator class, which knows how to validate the Ssh entity, and invoke it from both HostValidator and ActionValidator. Not critical.
Nitpicking: Please doublecheck if the indentation in this method is with tabs or spaces. It looks like tabs are used.
Minor but since this method is only a local helper, let's close it down to private. Chances of ShareIntentReceiverActivity getting subclassed in the future are quite slim and if that ever happens we can open up the method. Usually, when reading the code and encounter a protected (let alone public) method, you expect to find subclasses (or other classes) using it. And when you can't find such classes you tend to think that something is missing here or this method might be a relic from a refactor. Again, nothing big but still, more clear if we turn it into private. WDYT?
can the name actually be null? I would have thought that the [rename operation](<LINK_0> returned an error if the name parameter was not supplied
i wonder whether this condition should be moved higher up in the block, so that a bunch of unnecessary calls of childResc.hasProperty(RDF.type) aren't made
Please include more detail about the operation being performed to assist operational debugging.
Why do we need brokerRequest.getSelections() != null here? It will never be true for aggregation right?
take this out
We probably want to log the stacktrace here, so I think you want to remove the  due to {} part.
@ikhvostenkov please name it json
Infra has been eaten
This isn't necessary. CatalogManager is injected. All catalogs should be visible as long as they are installed.
input could be a standard String
move error log to condition body
I believe these are swapped.
will this crash if the file doesn't exist? Is it valid to simply run kinesis without extra configuration?
Using a plugin result makes it so that the JS side can't distinguish this special-case from an actual plugin-response. Instead, I think we can do: if (arguments == null) { return "null args"; }
This would not be an extension, but should be on the object directly.
1. if connecting to iso domain fails with exp, you will not try to connect to ImportExport domain 2. maybe worth adding a variable to hold the name of the domain that failed to connect, so the log message can specify what domain failed to connect. Something like that: String domType = "ISO"; try { connect_to_iso; domType = "ImportExport"; connect_to_import)export; } catch (EngineExp e) { log.info("Ignoring ... of type {}", domType) }
additionalAttributes can not be null.
Please use Java naming convention for instances , e.g., hiveQueryExecution.
will it ever leave this loop when rowId is removed?
Should lines 174 through 176 move into a UriMakeImpl.setInputName() override that also calls super.setInputName()? If the user provides their own URI maker, should it be their responsibility to handle the case of a null input name? The same concern applies to some of the other splitters.
Please don't append ex.getMessage() to the message.
nit: and here too.
You can use this instead of actual time to make tests faster and reliable. <LINK_0>
why are we using name instead of label?
Use lambdas. As there may be a backport you may want to use instead if (log.isDebugEnabled()) and regular string concat. Same further down.
externalize. I must be somewhere already, just need to find the correct Message class
From Java doc:  the total number of bytes read into the buffer, or -1 if there is no more data because the end of the stream has been reached.  Is it safer to check for -1 or >= 0?
This will inadvertently change path separator to host OS witch might not match target OS path. In case of remote debugging of a Linux App from WindowsOS host this will change the path. So instead of "/home/user/workspace/project.elf" the changed path will be "\home\user\workspace\project.elf" and debug session will fail. Solutions would be either to change back to using "remotePath.toPortableString()" or an option would be to manually append separators using IRemoteFile API, i.e. selectedFile.getAbsolutePath() + selectedFile.getSeparator() + lastSegment.trim()
As this is thread outermost loop try/catch we should catch Throwable exceptions. Otherwise the registry refresher may silently fail without us knowing about it.
also need to make nullStateDescriptor aware of the TTL?
Are these important settings we'd need to advise use of or are they just for testing?
what about not using a ternary but rahter an if (needsAlias) emitName += ...?
@pqueixalos sorry didn't notice this minor thing previously, but in terms of arg ordering schemaPattern makes sense after the context
I'm not sure what we are trying to guard against with retries here. When trying to retry a read from file, if the checksums don't match the first time, it's unlikely they will match the second time, no? Otherwise, this would indicate memory corruption issues, in which case we have much bigger problems.
should the default value of snapZxid be -1 instead of 0? -1 is what Util.getZxidFromName returns if finds nothing valid.
style-nit; surplus braces
This needs to be updated, in a way similar to the next else if. Now that multiple links can be bound to a file, we can't save the file as not shared until all of those links are removed.
You don't need to check that, tje check is done inside RunVm, if it is not successes EndSuccessfully should not be called.
Please use slf4j parametrization instead of string concatenation
TopologyUtils.getTotalInstance() doesn't work? Maybe worth adding this code to TopologyUtils as a util function?
format this file please
Not localized. Should probably use the same mechanism as other dates on the UI.
Minor: invocation.getArgumentAt() might make this slightly less wordy.
I think this is available as a system property, exposed by maven. Not sure how reliable this technique is :)
Is this definitely Ok that the context is returned but we are still working with the results? Are the results eagerly loaded?
Need to throw GovernanceException instead of RegistryException
Missing method name.
It would have been _nice_ to assert the values of the GridBodyCellEditContext but a test is better than no test :-)
the client has close() so we can - worse case - use that. Also if the beanManager.isNormalScope(bean.getScope()) is true we don't need to call context.release()
this is an unrelated bug fix. it should be in a separate patch
The "." could be configured to something else by the user as I learned. This should be resolved from the meta-data.
@cvrebert You can inline this statement from the new MkIssueEvents() statement above.
I would assert that the proper rs ids are found.
Should be scriptDefinition not config
This should be a test error.
Now the number of processor threads will never actually decrease. Maybe you wanted to set end to true in applyProcessorCount.
This is still a hard-coded assumption of where the sash model is stored, which for legacy (Kepler) models is not in the workspace metadata area, so the next statement attempting to load it still fails with an exception.
Lines 187 and 188 should be testing event2 instead of event
suggestion bounds = new Rectangle(0, 0, bv.hex_size.width, bv.hex_size.height);
Remove the catch? (test won't fail)
it might be useful to log the metric event sent from druid in this msg
_me likes_ note: I'd provide an equal abstraction for this, since it's so common to query for equality on an attribute.
We should do this in a background process to avoid blocking the UI thread.
Maybe do something slightly more specific? Like check that the message refers to CursorWindow.
investRepayModel.getStatus() == RepayStatus.REPAYING
Is flatGroupSets still valid? groupSetCount and flatGroupSets seem to duplicate each other.
Please include the function name in the message
Extra blank line.
Don't use random. Just pick a size
Same here: use a copy constructor?
You'll have to be careful here. With Hibernate-backed objects, there's no guarantee we'll get a sane container. As such, with the collections, you may need to use our Util class's collectionsAreEqual method for comparing them. Take a look at Product.equals for an example.
suggestion ret.task = executor.scheduleWithFixedDelay(() -> {
You can call set since it is scheduled. You don't need to do a cas.
Why we need this flag?
The only prefix we use is m for member variables. Please rename this boolean to a question format, so areActionsSet
please add single quotes around fieldEntity.getType().getName()
Seems this breaks one time whole operation into several times of sub operations which need to connect to cassandra. Not sure how many candidates in real env (3000+?). We can test if this will bring connection performance. (or maybe concurrent them?)
I know it was there from the beginning, but please this empty line :)
Merge the logic above.
Bad formatting?
Nexmo.
Is there anything special about an @?
This is racy. Any thread reaching this block will compete with a undeploy thread that just set the remainingHystrixConfiguringDeployments counter to 0. This can result an undeploy thread clearing the configuration that a deploy thread just created.
Remove
Might result in NPE when the regkey is not valid
do we have a version that accepts appvalues ?
StringUtils.isEmpty can be used.
change this to: JSONObject cookie = getPayload().getJSONObject("cookie"); then change the references below to just cookie
This still needs to be addressed
I wouldn't bother with an else if you are returning in the if.
I hope I understood it correctly, does it means * that System properties are returned for Proxy-configuration if there is no ini-file present * that configured proxy-condigurations are read from ini file if present? What if proxy configuration isn't set in ini-file. Does't it mean for callers of getProxySettings() that there is no proxy-configuration? What do you think about returning system properties if ini file doen't contain any proxy-configuration? What happens if system Properties are not set either?
info?
Is this related to improving namespace support?
Second part can be properties.keySet()
Parenthesis around (!logic.equals(LOGIC_AND) && !logic.equals(LOGIC_OR)) are unnecessary, please drop them.
timeout == null is redundant with !(timeout instanceof Integer)
@niteshsarda Can you confirm if XenServer is the only supported hypervisor with valid parent snapshot ID for a given snapshot ID? Instead of hardcoding the hypervisor type, could we fetch hypervisor type categorically?
should we pre-seed the candidates map with 0 -> something to ensure we don't get an empty map?
This should not be changed.
Please add a space between keywords and parentheses. Also in rest of change.
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
:art: Personally I would lean toward using a guard statement. java if (entityType == null || StringUtils.isBlank(entityId)) { return null } ...
Should this be in a finally? If an an exception is thrown on line 57, this code will not get executed
This method should not be called here (and I think it shouldn't be needed anywhere else). Here, the repository is only marked for deletion by the organizationalUnitService (with lock acquired), and later the FileSystemDeleteWorker#removeRepository(final Repository repo) will remove the whole repository directory at once, which should remove the change requests along with it.
make it as debug
You should wait on the task; delete by query is asynchronous like all write operations.
acc.......
Does it make sense to move this check above a little bit? java if (offsetAndMetadata != null && subscriptions.isAssigned(tp)) {  That will make the log message less confusing.
At that stage the event is always modifiable, right? So the check could be removed?
Print statements should be reserved for local debugging - let us not include this in the core codebase.
Just so we do not forget - how do we ensure that only the intended app can process the token result and not some malicious app.
result suggests like this is THE thing returned from the rule, which it isn't. Call this partial, the TopNNode call final and return Optional.of(final)
how come we are removing the second batch?
Should this be something like 0 or -1 to indicate that we didn't charge? Otherwise the charge rate check is going to fail on this, but it should really be skipped in this case.
Isn't \\. a regex defined in Locator.java ?
reduced panel counts
So this logic tries and retries one time. It seems like this could be better organized for readability and reduced code.
ditto: add a check it either has to be connector partitioning, or FIXED_HASH_DISTRIBUTION
Dangling bracket still sticking out :-)
such approach will lead to setting up the property in Maven executions. Maybe you want to introduce a new method instead
I don't think we need to call this anymore.
We have to improve this line. It would not always give correct results because of an integer divison: 5/2 = 2 2*2 = 4 In such a case it should produce 2 for the first node and 3 for the second node.
Looks like ISE is not thrown?
Typo in button caption ?
You can combine these 2 lines as sandboxPath.createDirectoryAndParents().
Have you verified it from the UI? It should send the 'imageIds' array in RemoveDiskSnapshotsParameters's ctr. So this block would never be executed..
Check type of insn2 before cast
<LINK_0> please name it in better way "iface" ==> "interfaceAst" CIs must pass.
Please use "if (ComponentCategory.CATEGORY_4_MAPREDUCE.getName().equals(process.getComponentsType()))" instead this hard-coded way.
Why do you need .* before and after (?s). after is enough I think. Mb you mean \\.(?s).*
Change to "size must be non-negative but was: %d"?
why not naming it proxyFactory?
This part doesn't have any relationship with addPreference method. Try to split the methods
just out of curiosity - any reason that you don't do "initialWritableBookiesFuture = ...watchWritableBookies"?
I would use 'AbstractRegistry.DOCKERHUB_REGISTRY' just to make any changes easier to track.
Did you take a look at this? <LINK_0>
Can we make this more exact so that it's only final when actually needed inside the anonymous class?
s/tile.getZoomLevel()/tileZoomLevel
if you fail the command nicely with can do action, you could give better error to the user here, by translating the msgs
This loop is building a new full SQL string upon each iteration. I would recommend using some other alternative that can operate on the string more efficiently (like using a StringBuilder, or creating an intermediate string that replaces all the question marks with placeholders that can be processed by String.format() or a similar substitution method).
We're very vulnerable to injection here. We should be using SQL arguments to pass these values over, not construct a string manually
I'm wondering about the default value for this. How easy it is to set the value for someone in OSGi? And how likely it is that they would want the OSGi service loader instead of the normal one?
Unnecessary parenthesis
This is probably the lowest priority thing I've ever requested, but could we call this LegacyDTOFilter rather than Old? I don't know why, but "old" feels very rough to me.
SUBJECT_HASH
in variable !
That's wrong place for this kind of filtering. That's because the question if an action should be visible or not for non current revisions depends on action itself and is not global for all actions that GET actions endpoint provides and are rendered here. The right place for this filtering is Action.getDescription() method (per Action class) where the setVisible() and setEnabled() must be set on action description for particular revision. This change broke DeleteDraftPatchSet action in core: it dropped this action for non-current patch sets, even though it should be offered. And this change also broke all plugins, that relies on the fact that exposed revision actions are offered for non-current revisions.
GraphDatabaseInternalLogIT.INTERNAL_LOG_FILE ?
you should also check that luns list not empty
what if this byte is before/after the hard delete range inside the blob? Hard delete starts at a non zero index at the blob and ends before the end of the blob. Maybe you need to make sure it is written inside the range that will be hard deleted.
why u initialize outside of new Thread("jvm-pause-detector-worker") scope ?
Remove all unnecessary ()
same thing with returning ""
Unneeded change
you can declare just a Set<File>
Please follow the pattern we had to declare/add metric in SamzaContainerMetrics (i.e. instantiate the metric inside SamzaContainerMetrics class and just refer to it from outside like containerMetrics.callbackCompletes.inc()
can this throw? and if so, can we handle it?
Shouldn't we use setImageId?
The newly added code is the mostly same as those of INSERT. It would be nice if some code to get ProjectSchema and InSchema are distinguished.
What about putting time to the name to make clear when each snapshot was created, just a suggestion.
How is it reset if the test failed before?
it's much simpler if you write the code like this  java if (!payload.containsKey("errors")) { throw new APIError(response, body, payload); } ...  notice that you do not have to have as much code inside an if statement so it's easier to read.
I believe you could directly instantiate Database as H2Database, rather then looking it up from the connection, because we precisely know the type of the database we connect to.
FileReaders should be opened using try-with-resources so that they are closed for sure.
Could this be configurable?
hmm .. was this superflous?
DriverManagerUtils::getAccessToken may be changed to getAccessToken(properties)
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
You should use an Iterator to remove entries in the for loop (your code might also work but I'm not sure how indicies are reshuffeled if you remove an entry. <LINK_0>
The method currently always set e new label provider without checking if the eef runtime is present. We should change the provider only if the EEF runtime is present (see patch set 1). If not present we should just check that we explictly have the expected label provider for each dialect. The current patch always force the label provider: we do not test the default behavior and we will not be able to detect a change around this.
This calls checkedCardCount() twice Also: the previous code returned false.
Let's move this check in GoogleCloudStorageReadChannel, it should determine during initialization if opened file is GZIP encoded
Can we fix this log statement to also reflect the fact that attributes might not have matched?
please reformat this piece of code, it is pretty inconvenient to read  ContiguousSet<Long> addresses = ContiguousSet.create( Range.closed(lower, upper), DiscreteDomain.longs() ); Map<Long, ILogData> range = runtime.getAddressSpaceView().fetchAll(addresses, true);
This can be if (optionalChargeEntity.isEmpty())
It seems like we're changing the semantics of this method. It's not really just expanding the template into a resource group id, it's giving you an entire selection context. I would keep this method unchanged but make it private, and make a new method which calls this method to get the id, and also does the below (and it's public).
Jenkins.getInstance().getQueue().maintain()
Why is adding refs/heads/*:refs/heads/* conditional on HEAD being a symbolic reference?
You need CHANGE at least because we filter on the project name.
Shall we pass Identifier object instead of the apiTypeWrapper itself? It will make this PR cleaner. Example: ApiTypeWrapper apiTypeWrapper = apiConsumer.getAPIorAPIProductByUUID(apiId, requestedTenantDomain); Identifier identifier; if (apiTypeWrapper.isAPIProduct()) { identifier = apiTypeWrapper.getApiProduct().getId(); } else { identifier = apiTypeWrapper.getApi().getId(); }
This seems incorrect: * A relative path like foo/bar will become an absolute path file:///foo/bar. * An absolute path like /foo/bar will have four slashes file:////foo/bar. This probably works, but is incorrect according to RFC 8089. It should either have one slash (no authority) or three slashes (empty authority). It seems safer to construct it like this, which guarantees the format is correct: java return new File(url).toURI().toString();
These seem the same as the class variables
Will it be good to have duplicated log messages here and [CloseDriverCommand:18](<LINK_0> Maybe at this point, we can say that browser will not be closed after running? What do you think?
This looks to be similar to other method except file name check in the code. It is good to refactor something like below to avoid duplication.  private byte[] getJarFileAsByteArray (File tarFile) { return getFileAsByteArray(tarFile, x -> x.endsWith(".jar")); } private byte[] getFileAsByteArray (File tarFile, final String fileName) { return getFileAsByteArray(tarFile, x -> x.equals(fileName)); } private byte[] getFileAsByteArray (File tarFile, Function<String, Boolean> filterFunc) { byte[] data = null; LOG.info("Looking into file {}", tarFile); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(tarFile)); TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(bis)) { TarArchiveEntry tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); while (tarArchiveEntry != null) { if (filterFunc.apply(tarArchiveEntry.getName())) { data = IOUtils.toByteArray(tarArchiveInputStream); break; } tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); } } catch (IOException e) { LOG.warn("Exception occurred while looking into tar file [] ", filterFunc, tarFile, e); } return data; }
you already have setUriInfo() at line 249
This case happens when the user presses escape (closing the dialog). So the progress bar is cleared through that.
I think we need to move into this null check
does it make sense to add a null check for getPossiblePools?
Why not use [TransactionStatus#canRollback()](<LINK_0> here?
This is a pretty heavy operation, which you need only when upgrading from a DC that doesn't doesn't support discard to a DC that does. You should use FeatureSupported to make sure you don't do this redundantly.
I would prefer it equal to BigDecimal daysAfterApril = getUsedDaysAfterApril(account);  BigDeciaml daysUsedNextYear = getRemainingVacationDaysAlreadyUsed(nextYear); //... .withVacationDaysUsedNextYear(daysUsedNextYear)
how about checking this return value in case it's null, would it make sense?
This equals implementation should include attributes from the Command super class.
Is this essentially the same as the both null case? I know you've covered the bases but it's difficult to see how we can be sure that o1 and o2 are the same type. I think it's because ORDER is guaranteed not to return the same Integer value for different enums?
This isn't actually asserting anything. Needs to be:  java assertThat(one).contains("ping").contains("pong");  Same thing below.
What happens if server-side mutations are enabled? If enabled, since we no longer would need to rs.next and read all the data from the server + generate delete mutations for them, is there any difference in behavior w.r.t. whether we create cloned connections?
Why this change? If this is not related to this PR, please undo it.
Please extract new SegmentMetadataQuery(...) as a variable.
Why not check for IDs not being equal?
nit: might be worth extracting a local predicate
There is now a new method to make your life easier. Replace the previous lines with this: StateSystemBuilderUtils.incrementAttributeLong(ss, ts, tidQuark, inc);
Why connect twice? If you already connect obtain the fingerprint from the existing connection.
Remove getTreeViewer().getTree() != null check since its also done internally in Widgets.isAccessible().
@bxf12315 If we launch here DependencyPathSelectedEvent with the param isselected = true allows to respect the changes done at Runtime Strategy configuration changed by the user throw the wizard. I think the behaviour would be more consistent with the one that is performed when a kjar is selected from list. WDYT?
I would suggest making use of batch operation here.
assertTrue(inputMap.equals(actualList)); <LINK_0>
This should come from the mergeTip that was read at the start of the merge op, *not* one that is read at the end of the merge op.
Reference.of("state", initialState.getId()) could be replaced with initialState.toReference(). Showing the example with the String constant is not the best practice for users.
Can be a do {} while since the hasNext is already done
when loading to cache i would suggest to load ALL records because they are not many.
respones -> responses
The build is failed. I don't see how but let's try revert this. Perhaps this hasn't the behavior I think.
shouldn't this be the name of the datasource?
StringUtil.isEmpty?
use try-with-resource. java try (Response response = executeGet(bucketName, objectName, null, queryParamMap) { ... ... } catch (ErrorResponseException e) { if (e.errorResponse().errorCode() != ErrorCode.NO_SUCH_OBJECT_LOCK_CONFIGURATION) { throw e; } } return null;
also if its VSTS and we are using PAT, the username will be empty.
Maybe already send a statusUpdate here that the task is starting.
Reformat this class to 3 space indentation and 120 line length.
Don't lock the DirCache if you are simply reading and unlocking, its sort of a waste of time. Use read() if all you need is to look at it. But, I have to question, why is this block here? If the file doesn't exist in the working tree, and yet we were told to add it, we have nothing to do, don't we? That is rm foo; git add foo doesn't stage the deletion. We probably don't want to do that here either.
Maybe if the file type can not be inferred by it's extension name, we can try and read it as a property file by default (or maybe .yml?) and let it fail if it's not in the correct format, so that it's not simply ignored.
This is just an accessor so I don't think it has any effect when the return value is unexamined.
Where does nocache come from? And why should all services not have caching?
1. Do we need to include e.getMessage when passing the exception as the second argument? 2. Also, do we need to do both logging and throwing? This will result in having the same exception printed in two or more log locations
<LINK_0> is also used multiple times and could be a static final.
So this is using PrepareRequest as the entry key. I see that you added equals/hashCode implementations where appropriate, but a quick look into the implementations shows that DefaultPrepareRequest.equals() will call SimpleStatement.equals(), but DefaultSimpleStatement.equals() has a very complex equals method that compares much more than the query string. This could lead to a situation where two non-equal SimpleStatement instances sharing the same query string would actually generate two cache entries. Is this a problem?
you aren't removing duplicated entries...
please add logging at least in trace level
what happens if server does not start ? i.e. port is already in use ? Then this would loop forever..
I'd suggest expanding the exception a little, with who's currently holding the token by doing adding processorName/segment
For code like this please use traditional for loops / iterators etc to iterate the values in the collection. This is a command line tool so not a big deal in this case but we try and avoid using streams for collection iteration as they cause a number of classes to be defined / instantiated contributing to the overall overhead of the application server.
Not sure we need all the double checks? Can't we just do context.replace(...) and if it doesn't match it won't replace? The strings here are super short. It might even be slower to do a check and then replace anyway.
Hint: pass the "mode" parameter into the "setActionModeIntTitle" function. Also, suggestion: make the setActionModeIntTitle function private.
could -> may
since this class implements Closeable, shouldn't we wrap that with try (CloseableHttpResponse response = request(query)) { ... } so the close method will be called at the end of the execution ?
Add context specific message without using e.getMessage().
isNotNull() ?
Is it possible to add a similar assert for CPU_CONSUMED_NANOS?
This should be checked on construction (using Preconditions.checkNotNull()), and throw an exception if the file is null. It's usually better to fail fast and loudly at the point of origin of the fault (here, when the caller provides a null IFile) than silently try to recover, or worse, make it look like we did what we were asked for but do something else (or nothing).
Not entirely sure we should generate Disk_Ok for this. Will discuss with you.
Is toArray required?
onErrorMap?
try to new layout manager from registration manager
please invert
clonedFactIdentifier and clonedExpressionIdentifier not needed
Exception containing the cause is dropped.
As real part?
The uri of me endpoint can be configured by stormpath.web.me.uri. As @dogeared requested, I'll do the change myself
@pmlopes can you also call channel.close().sync() ?
I have a feeling this one isn't going to be saved either as it nulls out all the values.
In apache/master, we have "SELECT 'Upgrading MetaStore schema from 2.1.0 to 2.2.0' AS MESSAGE;" which shouldn't have the issue as per description in jira. I think, skipping the row based on null values is incorrect as it may have any other side effect.
please split these changes in another review
We should probably have these as part of the object, as they're used a lot.
Maybe also change to not have slow logging?
Call super(name);
Should we use Collator.getInstance(Locale) ? Otherwise this will use local machine or JVM default which might not be what we expect. I guess en_US would be safe choice.
I'm unsure how this connects to the fork-join related changes.
If we are touching this code, we can also add curly braces {} around all those if/for etc conditions.
I maybe mising something here: The isUseUserAccessToken() returns true if the token composedTaskRunnerConfigurationProperties is not null and isUserAccessToken is not null. However if isUserAccessToken is false, the method will return true. Wouldn't this cause useUserAccessToken to be set to true when it should be false?
Please throw an exception if the query type is unknown.
So if I'm right you can now catch an exception here in case getComputedValue didn't worked for some reason. And in the catch I guess you can log an error with the actual exception, and fallback on serializePropertyValue(property);.
Wouldn't onChildMoved affect the indexes of every key? I have a feeling that's why @puf didn't use a Map in the first place but I could be wrong.
I like the solution behind the headers&items. :+1:
Same here. Pls refer to <LINK_0>
Two more unintended ofs here - yeah this is always a problem with renaming methods that are named as common English words
Here is where you could use the parseFileds method and do all this in a single line. values.addAll(parser.parseFields(iotasMessage.getData())
How about coordinates.length instead of 7?
Would it be worth putting some kind of warning here? It is an unexpected situation....
So here's a general question: IIUC, you pass on the original type of the change event (i.e. the Struct obtained from the SourceRecord); I'm wondering whether that's a good idea, as it exposes the Kafka Connect specific types to the Camel route, which might not be desirable. As said, I'm no Camel expert, so I have no idea really by which types messages are typically represented. If it is hash maps basically, you might do the following: * create a Map with the fields of the "after" Structfrom the SourceRecords value and use this as the message body * create a Map with the fields from the SourceRecords key and propagate this as message header (assuming you can have maps there) * pass op, ts and all the values from the source struct as header properties * create a Map with the fields of the "before" Structfrom the SourceRecords value and pass this on as a message header That way, the message body would just a map with the new row column values (or null/empty map in case of a "d" event), which *may* help to make these messages easier to handle with existing Camel sinks. Alternatively, you also might create a nested structure just with "before"/"after" and propagate the other things above as headers (that kind of mapping is what we currently consider for CloudEvents). Yet another solution might be to convert the entire Debezium event envelope into a JSON structure. Again, I'm not sure what'd work best in terms of Camel's conventions/expectations, but exposing the Kafka Connect types might be not ideal. Probably it'd also be a good idea to do some integration testing / PoC of sorts with selected consumers (at least JDBC sink), so to get a better feeling of what would be most useful.
Inconsistent line breaks.
swallow?
I would prefer using a HashSet<Branch.NameKey>.
Maybe rename to "lastSelectedEntry" (keeping the "entry" name in the for loop)
This could easily be a UUID returning function.
or Duration.standardMinutes(10) like you've used above
Duplicated check? ;-)
Format! And separate handling of handles and datasources.
createSafeXmlSource
Unchecked cast. same below
This second variable with the same value seems to be unnecessary
this seems like it violates the "correctness" of how data cube works in that the user defines the "capacity" of the id range and it honors that. what you've done here is possibly burn them all up and throw them away due to database contention. that seems wrong to me.
Please don't generate 3 RPCs sequentially like this. It really slows down the UI when presenting information. Instead what we should do is create a ListBranchResult data type to return the branch data from listBranches. Within it we should add a "canCreate" boolean that indicates if the user is permitted to create a branch, and if so, then set addPanel visible. Branch deletion is a per-branch right, so we might need to add a "canDelete" flag to Branch, and use that to decide if the delete checkbox should be made available. Then the server can perform all of this checking through RefControl, and we don't need something like Util.hasOwnRight on the client UI side.
Please use the same pattern we do elsewhere. Also, this is already being set in the configFactory, so  RealmConfiguration realmConfig = configFactory.createConfigurationBuilder() .name(REALM_NAME) .compactOnLaunch(compactOnLaunch) .build();
why not use StringBuilder?
You should probably squash both commits. like this commit here wouldn't compile as you didn't declare LOGGER, and the next one you remove this LOGGER. As a matter of fact, I would call it log just like everywhere else, but that would be too much OCD on my side.
It would be nice if we could have a metric counting the number of discarded items.
Let's remove this line
This string should be stored in a constant and the branch type should also be a %s parameter
Can you replace this with a "validateArchivePath" method? I imagine we can do quite a few additional checks (e.g. invalid characters in the page).
Is this gonna be stripped correctly in user builds? I heavily doubt it. You're gonna have a lot of call overhead. And nobody wants to see your webview logspam in a userdebug build.
disabling the non-durable parquet appender should get us a durable appender
Why this check? The interface should provide all needed methods.
We need a test that the default would be with root, but we are forcing it to be without root using the option. that's why we did this whole feature ;)
Is this the correct message to provide here. The internal key store is available only for the super tenant. Shouldn't that information be mentioned.
Don't use i for the intent as it is usually used for counters. You can probably avoid creating a variable and just call getIntent in the next line
The shuffle won't have much effect because the stream will get sorted below. I am not sure what the right behavior would be, but are the entities always supposed to be sorted by distance? It also seems a bit waste of performance if you don't actually use it.
![MINOR](<LINK_1> Assign this magic number 0.02 to a well-named constant, and use the constant instead. [![rule](<LINK_2>](<LINK_0>
nit: if debug log is not that imp, this could be replaced with few lines of code using for-each and lambda:  replicationLoadSources.forEach(replicationLoadSource -> Optional .ofNullable(replicationLoadSourceMap.get(replicationLoadSource.getPeerID())) .ifPresent(pairs -> pairs.add(new Pair<>(serverName, replicationLoadSource))));  However, if debug log is imp, feel free to ignore this nit.
else is not needed since you returned in line above
These tests do not, in fact, throw Exception. I would prefer that the signatures be changed to reflect the exact exception that is thrown, if any.
Any reason to not pass e as the 2nd argument, to preserve the stack trace?
change it to LOGGER.error
So this is this?  relationship.setLeftPlace(leftRelationships.size());  I think this would be more readable then leftRelationships.get(0).getLeftPlace() + 1 and it would even work for the case if the relationships are empty. And is there any reason, why the sorting and reordering is done descending and from the back of the list to the front? Should not something like this also work?  leftRelationships.sort((o1, o2) -> o1.getLeftPlace() - o2.getLeftPlace()); for (int i = 0; i < leftRelationships.size(); i++) { leftRelationships.get(i).setLeftPlace(i); }
Although this may be technically equivalent, it breaks with the structure of the rest of the method. As such, I do not think the change is warranted. So, please revert this change.
Move this back to line 105 so it doesn't show up in the diff as it hasn't changed. Let's try get the diff as small as possible with only necessary changes.
maybe want a default value here ("unknown?") - I think that can return null
end could have a value of -1 if a user makes a typo in their expression. You can probably avoid that by checking that value also contains } _after_ ${, before entering the body of the loop. Alternatively, if you've got a fix to Util.replaceMacro() pending review, you could copy-paste its implementation here with a TODO to start using the fixed version as soon as it is released.
weird method name
I have a cute one:  timestampMapping().values().stream().mapToLong( LockWatchVersion::version).summaryStatistics()  should get you sorted?
Boolean.parse(String) is probably nicer, but not essential.
This is going to need to be verified with Forge since I believe Forge handles entity registration differently.
It seems that there is an unexpected race condition. Consider following test: java public class QueryHistoryRaceTest extends GridCommonAbstractTest { @After public void stopCluster() throws Exception { stopAllGrids(); } @Test public void updateMetricsSimultaneously() throws Exception { IgniteEx ign = startGrid(0); IgniteCache<Object, Object> cache = ign.getOrCreateCache(new CacheConfiguration<>("test") .setIndexedTypes(Integer.class, Integer.class)); cache.put(1, 1); CompletableFuture.allOf( CompletableFuture.runAsync(() -> cache.query(new SqlFieldsQuery("select * from Integer")).getAll()), CompletableFuture.runAsync(() -> cache.query(new SqlFieldsQuery("select * from Integer")).getAll()) ).join(); cache.query(new SqlFieldsQuery("select * from Integer")).getAll(); cache.query(new SqlFieldsQuery("select * from Integer")).getAll(); cache.query(new SqlFieldsQuery("select * from Integer")).getAll(); cache.query(new SqlFieldsQuery("select * from Integer")).getAll(); } }  In the end of the method we can observe a situation when qryMetrics map contains one entry but evictionQueue is empty. I suppose that a particular query will be kept in statistics forever. No idea so fat how to fix it simply.
This is a regular interface, not an annotation, so remove the @.
Do we want to make the formatting a bit more safe? If I am not mistaking, this also breaks if the number of parameters does not match the number of placeholders. On the one hand it is good to see it breaking so that one could fix the text-template or the parameter list. But logging the exception and inserting the text with unreplaced placeholders would be a bit smoother. Don't know... Just a suggestions.
If you return here, you can avoid the else { } and thus reduce nesting :)
Formatting.
Method should be called isUnique, not uniqueSampler.
Minor: it would be "cleaner" to do the hasNext check before checking for migration stamp and destruction. It's not clear from the contract does the hasNext interact with the underlying store or not (which potentially can be destroyed or migrated).
This is oracle specific implementation. There are other JVMs too: IBM, Azul, Openjdk, etc, if the JVM is not oracle based implementation is com.sun.management available?
why is "int index = 0" not in here?
this remote is not invalid but it only accepts user2 s/invalid remote/not permitted fetch/
Are there any tests that cover these changes?
This condition is missing the workaround for the old "VendorIsEmployeeOrNonResidentAlien" route node.
if-else can be simplified as: 'errorMessages.putIfAbsent(Constants.INVALID_TRIAL, new ArrayList<>()); errorMessages.get(Constants.INVALID_TRIAL).add(message.get());'
Hoppers with slabs or signs above will not work. getType() will never return null, only air.
Do you think it makes sense to include the generation Id in the logger too?
Do we actually need this to get login working?
May want to give the implementor the rule that prohibits this so they know where to look.
please move to AsyncDataProvider for re-use. Implement an IAsyncConverter to integrate the sort logic...
Move this up to the other create methods?
There's a spinner that appears while it's loading. Should wait for that to disappear instead of explicit wait
nit: use parameterized logging (same with the following LOG.error).
This variable has only this initialization and a few get in this class. I guess the Optional here is not needed.
This should just create the group directly rather than trying to lookup and catching exceptions
I actually think we should deprecate BulkheadConfig.maxWaitTime(long maxWaitTime) and add a BulkheadConfig.maxWaitDuration(Duration maxWaitDuration).
What happens if the operation did not run correctly, e.g. an exception was thrown inside the execute block? Given in that case it is possible that modelFile does not exist (was not created), it makes no sense to select and open it.
code reformat please
How about halting if suitepath does not end with .java?
looks like line 136-150 is duplicated at 249-263. Might consider creating a method to do this.
Sets.of(cell1, cell2) // much easy to read.
Our convention is to wrap if clauses in curly braces
I think I'd like to see two methods here.
Can we use a ScheduledExecutorService to do this? Feel free to refer to HistogramDumper in NonBlockingRouterMetrics
DateTimes.wrapFormatter(ISODateTimeFormat.dateTimeParser()) could be cached more globally. Maybe create a constant in DateTimes.
suggestion BrowserWebDriverContainer webDriverContainer = new BrowserWebDriverContainer<>()
This could be called in the above try block (after the for loop), then in scan(HttpMessage, String, String) the try/catch and try/finally blocks could be removed.
Except for Safari users, all the others should get TIFF issue.
inline
rename to config,cfg or launchConfig
Since getParameters().getCustomCpuName() is always != null (value is taken from cluster/vm as a default), then once running with run-once without changing custom cpu type field manually then passthrough will be disabled. Is this what we want? It is a regression... but not sure if an important one
Just make the method throws Exception.
Likewise as for ForwardedHeaderFilter, it is worth applying a check if this even needs to be done.
With these changes, there is still no exception thrown when the file does not exist. We need to check if the LDIF exists and throw an exception if it does not. We can add the check for isFile() and isReadable() after we verify it exists. suggestion if (resources.length > 0) { if (!resources[0].exists()) { throw new IllegalArgumentException("Could not find LDIF " + this.ldif); }
use jnit.Assert instead of framework
format: { on the same line than method declaration
Do we need to run decomposition here? Why can't we just call Monitor.update()?
Did you take a look at this? <LINK_0>
Can use EnumSet here too, unless the order is important.
... and then here I would have  if (failed.get()) { throw new PreviousErrorsExistException(); }
This causes an NPE when updating an owner that doesn't yet have an access mode list.
Looks like this catch could just be removed?
I've only just noticed that the current core makes *every* BC fluid burn, which includes residue. Instead can you fix that as well by adding another element to the data array and declare it at the top of the method, like sticky? Perhaps only look at the config value once in this method rather than in the data array.
What happens if/when diff > m_spec.getInterval()?
One constructor must call another one to avoid code duplication and bugs. This constructor must call the first one.
Can you merge these three filter operations into a single one?
This assumes that file.toString() returns the full file path. However, the file is a public abstract interface org.apache.parquet.io.OutputFile, which doesn't have such method, so toString() is up to the implementation; no guarantees it will return the path. Also, new Path(string full_path) is not aware of the right filesystem (?) Maybe can be handled with an upcast to a known implementing class - preferably one that already has a Path getPath() method. But of course, this won't be very general.
![MAJOR](<LINK_1> Reduce this lambda expression number of lines from 23 to at most 20. [![rule](<LINK_2>](<LINK_0>
There's also a need to test this pipeline. ps: I know there's BuildPipelineInvokerTest.java - but stil doesn't test the provided pipeline.
Please don't use the "mocked" version here, it's not needed.
This can still take Argument of Type SQLDialect
Just a question, instead of introducing a new variable mImagesOnly here, can't we just set mFilter = Filter.IMAGES; when getActivity().getIntent().getBooleanExtra(MediaBrowserActivity.ARG_IMAGES_ONLY, false); is true? And keep saveState and restoreState without any change?
This is fairly expensive computationally. I think we could track this in a field and update it as requests are attached/detached from inside an Action. This would make computation incremental and access cheap (the latter of which is essential when the priority queue is calling compateTo multiple times).
state is a boolean - no need to _compare_
Shouldn't this be done here <LINK_0>
Sets and Maps contains useful static constructors fyi
this class can be private
This has been tested in AllActionsAccessControlTest, so it needs not be repeated anymore.
Unclosed cache manager :( You can use [CacheManagerCallable](<LINK_0> avoid running such risk.
@cwildman InterruptedException handling logic does not look quite right to me. At the very least one must call Thread.currentThread().interrupt() when catching and not re-throwing InterruptedException. I also think we should either cancel request at that point or propagate the exception to the caller.
without a timelock block instead. We can run without either of them and hit the error.
Why are you leaving this there? That will still link to the dead service.
Missing id comparison?
who writes code like this?
and if gitDir and localName are set (to clone a repo and let your repo have a non-standard layout)? I would simply command.setDirectory(localname); command.setGitDir(gitDir); Let the validation of localname (null or not) and gitdir be done in CloneCommand
You can also just pass the reference
no need to trim here cmt msg could mention sh
Is this line actually needed? The dialog is displayed even when disabling cast support, what is handled fine without a restart.
while I think it is unlikely, should probably handle uiIndex being -1.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Doing an HTTP GET to the pubsub URL here is fine with me.
i18n
Safer to cast to ViewGroup here.
is this intentional ?
@idelcano Remember that domain should not know anything about conversions then has no sense that the use case creates ConversionException. I think that we should create o refactor to MetadataException where the message can be "All necessary mandatory metadata tables are not populated" for example. Can you review it? thanks
Maybe checking the name to be sure these are the recently modified ones?
spell out Operator
Any reason to iterate downwards?
We try to keep annotations on the same line if possible
I think I would prefer handleLogicalBinary to check for the presence of date/time etc and then delegate to a helper method instead of inlining the logic here. Here is what I mean in code:  if (isDateTimeExpression(arguments)) { return handleDateTimeBinaryExpression(operator, call, context) // or pass it arguments, context .. whatever } // Continue normal handleLogicalBinary flow here
let's do this alwregardless we are in test; what this means is that the order in which the desc command outputs props is undefined unless we are running tests...
checkNotNull(type, "type");
static import pls!
I think this check should be done after every accept call. At least, this behaviour will be consistent with default forEach implementation from Iterable class.
This would be shorter with try-with-resources.
possible to convert into message properties or java constant so that we can change text message later
why not still use the limit in the case of not all granularity?
I'd suggest going java streams all the way :) For example: suggestion Map<TopicPartition, OffsetAndMetadata> result = hdfsWriter.getCommittedOffsets() .entrySet() .stream() .collect(Collectors.toMap(e -> e.getKey(), e -> new OffsetAndMetadata(e.getValue()));
Cosmetic/trivial: The code style is: JwtConsumer jwtConsumer = new JwtConsumerBuilder().setRequireSubject() .setVerificationKey(key) .setRelaxVerificationKeyValidation() .build(); (the first chained method is on the same line and then all further chained methods, align to the first dot).
@Test annotation usually appears on the line before the test function
I would propose to replace this ISA by a IAE, as it's a functional error
Is there particular reason to keep String, Long, integer and byte[]? can I send Double or Byte or Boolean[]?
This could be a lot of allocations.
right okay fine so toString I kind of get. But what's this?
This is null check only condition, so it makes sense to validate this as 1st step and then do database check on number of fence agents
If the previous try block throws an exception, does this next step have to happen (i.e. should it go in a finally block)(
This is a bad pattern in code. Can we fix atleast this instance of it. This threadPool is being passed from SamzaContainer as a null. val taskThreadPool = if (threadPoolSize > 0) { Executors.newFixedThreadPool(threadPoolSize, new ThreadFactoryBuilder().setNameFormat("Samza Container Thread-%d").build()) } else { null } a. We can either push the thread-pool creation down to the place its actually being used. b. Alternatively, can create it as a single-threaded executor pool. c. or pass it as an optional.
It looks like we can remove DEFAULT_ESTIMATED_WEIGHT entirely, since we're setting all the attributes here and overriding the default parameters anyway. This is the only remaining use of the variable.
move reader.close() to finally
I'm missing some permission check here?
We could probably use Epoll here (if it is supported). See how this is done in Hot Rod Server.
Say we get the input milestone:curr+99. In that case we would search for the milestone "curr+99"?
This will fail, for example, if reauth is enabled and we update the reauth token, or if it's a channel signIn that verifies the channel. It would be better to use accountDao.editAccount().
Better to have a mapping helper method as it continues to grow. Make the top API impl as simple as possible.
Didn't you mean to change the key on line 84?
I am not fully aware of Kafka internals, but I know that they have two APIs for consumers. Does this one use the new API?
This test definitely verifies that the thing gets closed. But it doesn't verify that things don't get closed while they are in the process of running. Is it possible to setup a test that verifies the closing behavior in case the thing is queued up?
When you import the hosts, the addresses that are auto-populated are the gluster addresses (backend network). What you want to tell the user is to provide the frontend network address in case it is different. So first, the labels in this patch should change to reflect that. Second, in the backend code - as the hosts are added, there should be a way to check if any of the interfaces returned for the hosts match the backend network associated with host
What if the view is not open? Would this be null?
LogUtils.clean(config.getRyaInstanceName())
I am not sure I like this returning the same object references because now it requires the command impementations to be thread-safe. I would prefer we return "new .ABC()" command each time. These objects aren't large and it won't be bad if we instantiate them each time... unless there is a reason for each request sharing the same command implememntation? Typically, sharing implementations like this across requests scare me because it requires us to be very, very careful about concurrency issues. I don't think we need to open ourselves up to that risk here - I think it would be safer to just return new objects for each "getCommand" call.
OAuth
This block seems to be to verbose, can we make it simpler?
same here, no need to have the same message for secondary
shouldn't this change be executed only for 3.2 clusters and above ? The linkState property shouldn't be part of any VDSM api earlier to 3.2.
In the parent class to this one I have a method "asBoolean". Would this have been of help to you? Users will often enter different boolean values 0, 1, true, false, tRuE, FALSE, etc and I tried to handle that variety
Do we have the logic for <LINK_0> somewhere?
perhaps remove the extra parenthesis around targetType.isIterableType()?
I think we still need to remove these catch clauses because they could hide the fact that none of the dates actually parse.
Do we really need to wrap unsafe args? There's a non-zero allocation & GC cost to wrapping for logging in tight loops or on hot code paths (though this specific case is not one). Also realize this was like this before, but we should not be calling toString() on any log args as that kind of defeats the point of lazy evaluation if we're not logging at that log level.
This should be a crash.
Should be static, as well as fromEnvironment() method. Also my IDEA says that parseInt() must be used instead of valueOf()
There is now a CaseDetails constructor that takes only a case name, intended for use here. Please merge in develop again and update this to use that constructor , thanks!
MM tables are unused here.
Please declare the dateFormat off the critical path of the method invocation. In other words, have it declared as a public static final variable at the top of the class, to be initialized at the class loading time. Please fix all such instances that exist in the code.
This will return null for non-platform URIs.
what does getInt() do if the value isn't an integer?
Do we need to do this read in a loop since we are not guaranteed to read the full data in one call?
Suggest we follow the *InPixel method approach here too: - Rename current method to getPathDataInPixels() - Create a new method getPathData() which will perform the AutoScaleDown operation
You can remove the "version != null &&", as StringUtils.isEmpty handles nulls.
This should call: Map<String, String> partition = OffsetProtocols.sourcePartitionForProtocolV0(tableId);
Would it ok to move the below three lines to BBCTTestUtil.removeCard?
Please try to get rid of the continue. I'd use the stream API here instead.
Which tests cover this block?
Too complex construct
I don't understand this bit. Why do we need something more complex than transferConfig.isAdvertiseSidebandAll() here?
setBindIntercept_**o**_r I spent hours battling this NPE, I knew it was a mocking problem but couldn't see it. Now looking at your PR the typo in setBindinterceptpr is blindingly obvious. I checked out your PR locally, fixed the typo and all the tests pass :shipit:
Should this line use the "safelyAddProperty" method, like in the other lines below it?
> by format by a format I would say bye bye to first part of this ;)
There is not much point to this check: if decls.length is zero, the loop would just iterate zero times.
nitpick: make it translatable
e.getMessage()
Should this condition not throw an exception?
Change 'if' to block in the new code.
we can use tokens.stream().anyMatch() here.
Wrong type. Should be List<String>
instead of keeping a map and a list, can we combine them to a single map? E.g. 'id' to 'disk' (to avoid maintaining two data structures).
MavenExecutionRequest executionRequest = createExecutionRequest(); populateDefaults(executionRequest); these 2 actions will be unnecessary in all cases where no lifecycleParticipants are defined, that is to say, most of the time. I'd move these within processLifecycleParticipants
silent errors are pure evil IOException should be thrown out
better to use the official way here true instead than "true"
This should also have one assignment per newly opened resource.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection only localConnection set to true.
The put method of a map returns the old object. So why calling get in front of if we notify the listeners after the put call now? Java final String uid = getUID(providedObject); uids.add(uid); final E oldProvidedObject = providedObjectsHolder.put(uid, providedObject); notifyListeners(oldProvidedObject, providedObject);
no need for type here
We should not continue if file read fails right?
If this is now a hardcoded list that never changes, then please move it to a static final field.
This would most probably again cause CCE in case of editing pools or instance types.
Minor optimization: grabbing the blocking queue for a given topic can be done in the higher loop and then the queue != null check can be done earlier as well.
construct the map outside the lock.
nit: for the @Nonnull you put it once before the plugin, other time between public and the return typed. I would prefer the latter but at least keep consistency.
Same here, use format strings.
Perhaps creating a more specific ConfigurationException here so in this case it can be logged as INFO?
Let's remove the stack trace from the logs here, since we know it's a TimeoutException, and if it happens there's bound to be a lot of these. suggestion LOG.warn("Timeout occurred while sending message to topic {}, it will be attempted again.", topic);
Will this cover the case when a tag was selected and the user un-selects it? We can add: private final List<TagModel> activeTags = new ArrayList<>(); field, together with following code: model.getSelectedItemsChangedEvent().addListener(new IEventListener<EventArgs>() { @Override public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) { List<TagModel> selectedItems = model.getSelectedItems(); if (!activeTags.equals(selectedItems)) { // fire TagActivationChange event } activeTags.clear(); activeTags.addAll(selectedItems) } });
Continuing sounds a bit like you'd be retrying or that the process does not stop, but I'm not seeing any way for this to resolve nicely. If we are getting an exception from call() on line 50, then surely networkResult will be an empty string (As per line 48). This would cause gson.fromJson(...) to return null on line 58 and thus the whole method would return null. Is there some reason we can't just pre-empt all that processing and return null right now? E: If i'm reading the code wrong, please do correct me :)
List<String> lines = Files.readAllLines(filePath);?
Please use executeHSMGetStorageDomainInfo - that's why you added it in the first place
Throwing an exception inside a map operator is odd. In this case, use handle() operator to either sink.error() or sink.next() depending on whether the response is an error or success.
streaming an empty list?
any reason you are removing the processAdapter?
set it to true here
I assume this is taking the agent's default character set. If so ... For various reasons (e.g. [JENKINS-13091](<LINK_0> we might be in a situation that the agent does not run with the systems default encoding, i.e. the -Dfile.encoding=  jvm parameter changing it to something else. Therefore system default encoding might be a good default. However, it should be possible to set the encoding explicitly since encoding of any shell output (IBM1047 on z/OS) does not necessarily match the encoding set by -Dfile.encoding.
This should probably be: if (lat != 0.0d && lon != 0.0d) { Android docs for Bundle say: > Returns the value associated with the given key, or 0.0 if no mapping of the desired type exists for the given key. They should be equivalent, but just to be sure... :)
use assertFalse
There is no way where storedAttribute can be null.
I believe this should be a 401 to mitigate enumeration. Further, I can't seem to find a place in Spring Security that returns a 404 in similar circumstances.
assertFalse
This will severely increase Jenkins startup and job save times. We need to find a different approach at solving this problem. For example adding a flag that dynamicGerritProjects is being updated and have isInteresting wait for that flag to clear.
Nitpick: missing a space here before catch.
Result.replace looks a bit like "replace result" while it means "result that replaces". Maybe Result.replacement?
final
Log should be written only when update is perfomed
shall we move this to process() method of the API so that we don't need to set it over and over again here into different cases?
Is it an intended change? because this file is an autogenerated file from RemoteInterpreterService.thrift
This seems pretty late in the method to throw an exception like this. Could we catch it earlier?
and here we could call config.getEnumList
@xupyprmv please move indentation back 4 characters
I think you forgot .build()?
I think the current code runs into similar problems that we had recently in a PR by @stefan-kolb: if the currently selected entry changes, then the binding is not updated. Here, this should be relatively easy to fix:  EasyBind.flatMap(stateManager.getSelectedEntries().getValueAt(0), entry -> entry.getFiles()) .map(files -> to boolean)  Here the getFiles methods needs to be changed to return an observable list. This can be done using the current code and a EasyBind.map(getFieldBinding(FILE), ... parse).
this is an interesting change -- how/when were we closing the connection before?
this kind of things is better to separated on two assert assertNotNull assertEquals (2, actions.size); Give you more info about what is the error
After separating dashboard things from MetricManager, then we don't need to prepend 'Dashboard:' at the front of logging messages.
Is this safe for re-use? In the TransportShardUpsertAction we create a single InsertSourceFromCells instance and then use it for multiple params. What if there is a null value early and later on there isn't?
It is good that you return null in case of the bloom filter is not compatible with the one supported by this implementation. This way this is forward compatible with format changes that may add other bloom filter related options. However, one would have no clue why a newer bloom filter is not used. I would suggest adding warn logs with the actual problem and the bloomFilterHeader itself. (Thrift generates proper toString implementation for the objects.)
s/Type/type s/status/status.state
Not sure that this method should be public...
I think what I really don't like about this is that this whole thing relies on the analysis module's developer to not forget to decrement the request flag or else it blocks forever. The default behavior is to block. We could add a function analysisHasRequest() { return false; } and the notifyPendingRequest(true) would occur only if analysisHasRequest is true. That way, the developer controls both calls. He knows if he overwrites the first method then he has to decrement the pending request flag. And, if he ignores those methods, but uses a request, then, well... it probably won't be coalesced and that's not the end of the world. We'll catch that on a review if the code makes it into gerrit ;-)
You can't move this to the first place and return. On Linux/Mac "device" part is always null.
Move this line outside of the loop
to remove
compatible (remove 2nd "a")
This orElse is internal within the filter method, correct? It's hard to parse as-is, because it's indented to the same level as the calls that are directly on stream(), so it seems like it should also be directly on stream(). Could you either change the indentation, or break this call out into two lines so it's easier to read?
Again, I think you can close the try clause here. Also, you are missing a context.restoreAuthSystemState(); in this test.
Hey @mderamos can we replace the data.getValue() into the array and adding the actual value to the error message like before? The more actual data we can inform the user of, then the more powerful the message is as it helps the user locate the exact source of the problem.
I take it this is the key assertion that indicates the script was overwritten. It would be better to make it much more explicit - make mock/start.sh and this assertion say something like "OVERWRITTEN VALUE" so it's immediately apparent to the reader.
why not use fail("")?
This isn't right, it will cause the promise to be subscribed to twice. Would you mind rebasing and using the [new time() method that I just added to Promise](<LINK_0>
Do we need TableType.valueOf?
Could there be assertions on the properties of the populated readHandle?
Trailing tabs
Please check the indentation here.
BUG? Why don't we decrementAndGet and set the future on 0
Same remark regarding !billedItems.iterator().hasNext(). Also, maybe billedUsage.compareTo(toBeBilledUsage) < 0 should be extracted around these methods, since it's the same in both implementations:  if (billedUsage.compareTo(toBeBilledUsage) < 0) { populateResults(...); }
Use the logger here instead of System.err.println. Also, include the entire exception:  java log.error("There was an exception quitting WebDriver.", e);
Would using the hash of name provide enough efficiency?
I have not tried yet, but I assume encoding the colon still works fine with the server?
This should be final.
Is it possible to wrap argument parsing into VarSimTool as a method?
I don't really like that test because isVariable has a strange semantic. I think I would prefer a test on the symbol usages.
use get() here not toString()
Can we stream the request instead of having this intermediate String?
This doesn't need to be fully qualified if this lives here
This should never happen right? Or conversely, should we wait to schedule the timer until after initialization? (the isPresent check is probably still required but at that point becomes and error)
suggestion System.out.printf("HttpClient is %s; Service Version is %s", httpClient, serviceVersion);
why is the windowRef property not preserved?
Why you have removed static imports?
Should method be like snippet below instead of copying logic (there is also a possible typo around %.02f B in above case and %d B below)? java public static String humanReadable(long bytes) { float fbytes = (float) bytes; return humanReadable(fbytes); }
Since serviceBuilder is a CapabilityServiceBuilder, use: java serviceBuilder.addCapabilityRequirement(Capabilities.REF_HTTP_LISTENER_REGISTRY, ListenerRegistry.class, ((HttpListenerService) service).getHttpListenerRegistry());
Please call setup and tear down of the operator.
use FileRepositoryBuilder.create
Is it necessary to explicitly include these three cases, if they're handled the same as default?
Can you move this inside the if statement to avoid making this call unless the status != 200?
this will call conn.close at the end of the try block. Can we use master.getConnection() and just make use of the shared connection rather than making a new one?
Let's clean this up to be consistent (ie: constants for both)
Is it intended to not count marker processing in the analysis time? IMO we should count everything
Is this where the test fails?
setErrorMessage
Afaik this only returns the features directly defined in the EClass. This missed features from parent-EClasses. I think we should use getEAllStructuralFeatures instead.
I think making it part of the version number here will emphasize it more than is necessary. Let's put it in the build info along with the release name and commit hash.
We need to avoid multiple value calls on the same Input as those itself might also be functions which would cause to multiple evaluations of the same expressions. This can add up and kill performance.
Log statements needed?
Is this going to be more expensive for logging that occurs with a large stack?
returning feedback to users seems a good idea.
Rename this variable name to something that references its purpose. It helps understand what the loop is doing at first glance instead of having to evaluate it.
nit: fix indention (best, move otherStream above to new line and also reduce indention for all other parameters too)
Use TimeUnit.DAYS.toSeconds(30)
some_layer is actually a group layer in this case sea_water_velocity is actually a layer name. Assigning it to variable in this code simply looks weird. We are interested in what is the layer name.
also test hydrate to bytes after the persist it should give back testRow. That will be a complete (ser/deser)ialization test.
Use Guava Sets.difference() and Sets.intersection()
I think this will always return null - can you please verify?
Please remove final from for loop variable.
final
While this creative re-use of a layout, I'm not sure this is a good idea. You create an additional, non-obvious dependency here. Whenever we change the navbar listitem layout in the future, we would also have to consider that the layout is also used here. You are also not using failure at all and using the former count (of new/unused/unused+new episodes) for the total runtime also has a rather bad smell to it. You should at least give your variables better names!
name it gooderer
Revert
this doesn't appear to be used anywhere
you can put IOException on the same line here since you handle them the same, it reduces the visual bloat. } catch (ParserConfigurationException | IOException e) {
I think we can change the condition from i >= start to lastPos > i. On the fast path there's nothing to escape, so this loop should be a no-op. This allows us to stop iterating once we've escaped the last unescaped character.
Will this check always be true if the two before were true?
Consider logging the exception without toString so you don't lose the stack trace, i.e. logger.error("Some message", error). This looks like it's a problem in a few places.
It's fine to fail fast here.
Could be replaced with selectedRisks.contains(alertRisks.get(alert.getRisk())).
this looks odd
Replace block with:  java if (IndexFileType.isIndexFile(fileName)) { val indexFileType = IndexFileType.fromPath(fileName); // TODO: Verify if this works for other layout types other than OBJECT_ID! val objectId = IndexFileType.getFileName(fileName); // We use the convention that fileName is objectId FUSE side return context.getIndexFile(objectId, indexFileType) }
I think you should use expr.replace() as opposed to replaceAll(). No need to deal with regex here.
The type of the source field should be InvokeSource instead of int.
this. is unnecessary
AbstractWaits have to be removed
These 3 if conditions can be merged together
but it also supports the '@' notation, no?
We can get rid of this particular null check too, I believe.
My understanding is that you're writing to a temp file? Use File.createTempFile() if that's the case. UUID is just a random ID.
Use Strings.isValid(value)
We can avoid having leaseManager as class field and use coordinator to get the value
Could you add braces here and for the below if? It's kind of hard to read in this case.
Why can't we change the name directly in hotel json file but to modify here after serialization? There are two other test classes which have the similar structure, SuggestSyncTests and SearchSyncTest.
Do we need to test that "_routing" is a meta data field here?
I would prefer keeping the helper function, if someone decides to muck around the with the specs for say ctf 1.9, we need to make it easy to support it.
Not sure if this is really more readable than the previous version.
this is a little silly
okay what is it....space after an "if" or not? The two lines above use different style. I vote for using a space :-)
Can this be more clearly named like inputPositionCount or something similar?
Should be done via a logger
Currently all operations in the RealmCache is locked on the RealmCache.class, which means this will block opening all other different RealmConfigurations. But never mind, i think having it here is OK, i will make the add a lock on individual RealmCache in the getInstanceAsync() PR.
It seems it do the work but maybe we can replace these 11 lines with these 4 ?  if (!prompts.contains(Prompt.LOGIN)) { prompts.add(Prompt.LOGIN); } session.getSessionAttributes().put("prompt", StringUtils.implode(prompts, " ");
Shouldn't it always end on ':'? Currently 'password' must be followed by ':' but 'passphrase for' can be suffixed by everything. Not even a space after 'for' is required.
remove byteorder
Am I missing something or is replacementLength always 0 if there are no errors? Because this replacementLength and replacementOffset information exist in the integration of the interpreters in Sirius and there are simple use cases without errors where the replacementLength is not 0. Having this information directly from AQL and not computed in the AQL/Sirius bridge would be interesting.
We found that the query compilation time for SQL has gone up to 5ms in certain cases (as compared to micro-seconds for PQL). One suspect here is the additional processing like these. Tagging @siddharthteotia to share the findings.
make sure to use spaces instead of tab characters
I don't think this should be called here. Growth from an update tick should be distinct from growth from bonemeal (the probability of each being distinct is important, at the very least). I'd suggest moving the func_149853_b code into a separate method like so:  java public void attemptGrowth(World world, int x, int y, int z, Random random, int probability) { int meta = world.getBlockMetadata(x, y, z); EnumSaplingType saplingType = getSaplingType(meta); if (random.nextInt(probability) == 0 && canGrow(saplingType, meta, world, x, y, z)) func_149879_c(world, x, y, z, random); }  and then calling that from both updateTick and func_149853_b
Remove redundant type info
Use new EnumProperty, instead of new StringProperty()._enum(EnumProperty.getEnumsAsList **Before:** new StringProperty()._enum(EnumProperty.getEnumsAsList(Order.Action.class)) **After:** new EnumProperty(Order.Action.class)
I'm not sure that this piece is required here. Or rather, we should only need it if the file we attempt to import is on Android M and above and uses a file scheme (ie file://...). If it uses a content schema (ie content://), we shouldn't require this. Would it be possible for us to only prompt for permissions after the fact if the user is trying to import a file:// schemed object? I have a similar flow in place for whenever the user opens an image file outside of Smart Receipts and clicks the send/share icon to attach it to Smart Receipts. Check out IntentImportInformationInteractor.java's process(Intent) method to see how it handles these different types.
you should replace the test by (primeRefining == null) and execute statements from the else block. Then always return primeRefining field after the "if", the main local variable is not useful
@ivange94 please use APIException(String messageKey, Object[] parameters, Throwable cause) with a messageKey = code from message.properties; cause is e you need to remember that all these exceptions might be shown to the user as devs are not forced to catch them. so its good if we already keep it internationalized.
Thanks for improving the tests. I'd suggest a separate test for the special long argument case. This will keep the tests more focused and intention clearer.
Does zone (reference) contain zoneID or are they completely different things?
Because you split the method, should you protect against count=0?
Minor: tableDescriptors
logServerMessage internally calls logAuditMessage. So in effect, you would be calling this twice. I think the fix should be in GlusterAuditLogUtil - in logAuditMessage, if server is passed, server.getVdsGroupId can be used to setVdsGroupId in AuditLogableBase
Replace with a constant.
You should discuss with Nicolas, but this class is probably useless. you should use LabelInternationalizationUtils.getSetLabelCommand directly I think
Can you get values for header1 and header2?
Is this something we want to make configurable via a system property?
Could you return a XML output instead?
Let's select a simpler name; I propose 'dropStaleBuffers' or 'dropStaleBlocks'
can't we hit some name length limit with this?
This should only return null if removeErroneousExpressions is true.
Based on this should this policy implement <LINK_0> with PER_CALL? Having this logic and the positional change are another route as well, to explicitly prevent duplicate SAS parameters.
Is this enough?
should the args passed into getString be constants as well?
I think we have decided to all use SchedLib tools for that even in server? Is it right? If yes, add missing tooling in SchedLib. Prefix is 'jack-server-' in other place.
We should add a third parameter for the path of the json output path and use : java // generate object spec file Ddf2JsonGenerator ddfJsonGenerator = new Ddf2JsonGenerator(); try (FileOutputStream fileOutputStream = new FileOutputStream(outputPath)) { ddfJsonGenerator.generate(new File(ddfFilesPath), fileOutputStream); }  instead of : java Ddf2JsonGenerator.main(new String[] { ddfFilesPath });
throw UnregisteredAliasException
We should have tests for both cases (a) we assign the external ID and call the commit hook (b) we don't assign the external ID, and we don't pass in a commit hook.
You can do FileUtils.readFileToString(file, encoding) as a shortcut for reading the output file.
I think we don't need null check here. Just let it crash.
Looks better to have a log message specific to this type of exception if you want to distinguish this exception from others, e.g. Failed when accessing extension store.
If condition of err.isConnected is not required when action is just to emit. By default its connected to Sink.BLACKHOLE on which put object does not do anything.
You can extract reqTopic.getResources() as a variable so that you don't need to call it again thereafter.
Probably can avoid one level of nesting with (subjects != null & !subjects.isEmpty())
I guess you can approach same result in an easier way (just boolean arithmetic):  java boolean password_hashed = req.getParameter("password_hashed") != null && req.getParameter("password_hashed").equals("1");  Then I believe it's better to name variables in camel-case (like everywhere in code). So password_hashed becomes passwordHashed.
SELECT 1E1 works with PostgreSQL/PgJDBC well, getBigDecimal() returns 10 as expected. I think you need to normalize scale in your implementation too.
This should not be here. We should not catch, swallow exception this is a very bad practice.
Remove these lines, as they are there for testing purposes only....
Remove //modified harsh.
I think you can replace this with executableElement.getKind() == ElementKind.CONSTRUCTOR to avoid the string comparison
'truth' is dubious. If that's not what you got, then how is 'truth' the truth? ;) 'expected' is unambiguous.
With the deletion below, CI (spotbugs and intellij inspections) is flagging this as unused now
When running for a bigger table the same message is repeated every PROGRESS_COUNTER rows but it does not tell anything about the progress, anything about the number of already checked rows. Such information should be usefull because you more or less know where you are even if you don't know the exact number of rows to be chceked.
why lastIndexOf(.)? hello.tar.gz will be hello.tara.gz
The funnel has a logAbuseFilterWarning() method that we could use here. Technically it has both "warning" and "error" variants, but since we're not really distinguishing between the two for editing descriptions, we can use the "warning" variant for our purposes in all cases. Since the funnel method expects a "code" string, we may want to pass the code into this callback method (i.e. pass the message name in addition to the message html).
getImages() already returns a List. There is no need to stream it and then collect it again. Consider something like this: Optional.of(ec2Client.describeImages(describeImagesRequest)).map(DescribeImagesResult::getImages)
sysout ??
Shouldn't we check for empty or null session id and throw Exception as needed?
PLEASE-FIX: This check is unnecessary because the other import-use-case only generates "file" URIs and this use-case ignores it. => the boolean-flag, the check, and these try-catches only obfuscate code. => delete it Thanks!
I would probably use switch or multiple else if sections for the QuotaAction values.
Please combine the two conditions.
Fair enough. Since FieldContextSimpleQueryParser is no longer used, can you please remove it?
Should we keep this check and add final else that throws an IllegalStateException instead?
How important it is to make sure that cached RevWalks are released even in case of an exception? Put this in a finally block?
please add curly braces here
Extra space after !=. There're a few instances of this.
Curious: Is the following scenario possible: - Some stats paged added - getOutput is called and returns the merged stats page - Some new stats pages added?
what exception do you expect here? Is it the deserialization failure or any thing else? Can you catch specific exceptions?
You should have a local delayError field for this, otherwise you are re-reading the flag on each emission which can cause unnecessary false sharing. java Queue<Object> q = queue; boolean delayError = this.delayError; // ...
Actually, the issue #794 is about getting an ArrayIndexOutOfBoundsException rather than NullPointerException which is caused when dataPoints does not contain an index dataPointIndex - so the exact same thing still happens with the code above. The proper fix would be:  if(dataPointIndex >= dataPoints.size()) { return ""; } return dataPoints.get(dataPointIndex);  Please adjust the issue title and commit message as well.
INFO messages are above, including WARN need to explicitly. For core, that's done in org.infinispan.util.logging.Log where you'll find plenty of examples.
loooooooop. should be getCause().getMessage()?
This is not a caller's problem, but rather a bug in the implementation of this class. Hence, verify would be more appropriate.
suggestion org.molgenis.data.Query<Entity> findQuery = new QueryImpl<>(findAllQuery);
are we sure that the root element could not be a Package?
nit: We could move the variable initialization after the if block as its not needed beforehand.
I think, it would be cleaner to build a BloomFilterUtility based on the required objects only instead of requiring to create a fake ColumnDescriptor.
suggest changing this so that we can see when a detected locale is (much) different than the browser/cookie locale Locale resolvedLocale = lookupSupportedLocale(locale, getLocaleKeys()); log.debug(String.format("Incoming locale: %s. Filter determined locale to be: %s", locale.toLanguageTag(), resolvedLocale.toLanguageTag())); return resolvedLocale;
should we also change this to match what the CL intents? i.e. e.g. recordVideoSizes
Should use the static isSupported() method . you have on TargetChosenReceiver to avoid propagating build versions everywhere
Looks like we can use here IntegrationConfigUtils.BASE_PACKAGE and remove both constants in this class.
Please log a more descriptive message here. Keep in mind, e.getMessage() may be null....in which case this will say "Null". We may also want to look more closely at the errors that could occur here. It seems like there are two likely errors...one is that id is NOT an Integer (and parseInt fails), and another is the BitstreamFormat cannot be found.
we should add a log here as well
Can't we move this (e -> Platform.runLater(() -> new ErrorMessage(tr("Error while creating shortcut"), e))) to another method called defaultErrorHandler or something?
I don't think this is the correct exception message for num == 0?
Suggest logging this as well.
cannot tell where this transaction was started.
seems a good candidate of method reference usage above  attribute.visitJdbcTypes( jdbcMappings::add, ... );
if we had commands pending for events and the engine rebooted we might be left waiting for a very long time which might be frustrating to the users. if we have a good chance that the events were missed we better not wait. if we do decide to not poll those commands, where do we add subscriptions for them on the engine start?
Why is the OSException not simply thrown again? throw e would keep the original stacktrace.
remove .getSucceeded();
Create a class that handles this and use the constructor for it here and replace this with a one liner
What is this change for? It looks pretty much the same as it was before, with the exception handling changed.
leftovers
how about checking if styledstring is null then assigning it.
I don't like this to be a side effect of this getBlacklist function. But I am still looking for a better way to better resolve this.
At first the comparison looked weird, i.e. comparing a Model with a Source. The comparison is good, just need to improve the name of the variables.
I'm a bit lost here: why do we read broadcastSocketAddress again? addressToUse is never used. address is only used in the log message.
Unnecessary assertion, please remove!
Why close the file directly instead of calling closeFile()? One of the tasks of closeFile() is to interrupt the fileTimerThread and set it to null. With this change, reset() may leave the thread running in the background. I am concerned that this may cause unusual problems with file expiration once processing continues.
Or we can use a stringBuilder here that we build at the end of the request to avoid variable re-allocation?
why update twice?
I don't see where postParameters is ever attached to the request.
How about changing createMessage to allow to pass the 4 fields and call that with the corresponding values? It would reduce duplication and still check the correct structure.
place this below getOutput()
Use GerritFixture.current().getCredentials(PrivilegeLevel.ADMIN). (We recently made a change so that this works).
can you do the arrows too?
Why do clients still need to call compile()? Why can't the evaluator compile itself either in the constructor or lazily on first evaluation?
@rubenmartin you should use entry.setValue("NULL") instead
You don't need this local variable, you can just put the String literal "Test" in the thenReturn() method on line 230.
I would extract all this: java Form form = Mockito.mock(Form.class); Map<String, List<ValidationError>> errorMap = new HashMap<String, List<ValidationError>>(); errorMap.put(errorField1, Arrays.asList(new ValidationError("errorkey1", "errorMessage1"), new ValidationError("errorkey2", "errorMessage2"))); errorMap.put(errorField2, Collections.singletonList(new ValidationError("errorkey21", "errorMessage21"))); Mockito.when(form.errors()).thenReturn(errorMap);  into a method, called for example formWithSomeErrorsForFields(field1, field2) This way the test is keeping only the important parts, with all boilerplate elsewhere.
postEvent returns cancellation status. You can inline it (and I'd prefer it for leaner mixins).
Actually, in this case it should still print this whole report to STDOUT not to the log file.
initial size 5000 ?
Could move inside lambda further down, where we have access to the cache through stmt
The logic in L201-L204 seems to be done in L194-199, doesn't it? If so, doesn't it make sense to remove one of them?
This does not seem to work, as there appears to be no space on the left side (or 5 is too small)
Maybe use IOUtils.write() from: <LINK_0>
I guess we may possibly avoid introducing UNFINISHED_REQUESTS by doing this: java for (long id : CHANNELS.keySet()) { if (channel.equals(CHANNELS.get(id))) { DefaultFuture future = getFuture(id); if (!future.isDone()) { Response disconnectResponse = new Response(r.getId()); disconnectResponse.setStatus(Response.CHANNEL_INACTIVE); disconnectResponse.setErrorMessage("Channel " + channel + " is inactive. Directly return the unFinished request."); DefaultFuture.received(channel, disconnectResponse); } } }
You could move this section into a well-named method to make the code easier to read.
let me suggest a different way: lets call it ClusterCompatibilityVersion in the ovf and use VM#getClusterCompatibilityVersion on the export operation. In the import operation we will do: vm.setClusterCompatibilityVersionOrigin(<parse cluster compatibility from the ovf>); I think it is more intuitive that way, what do you think?
It is quite hard to follow this condition. What is checked here?
suggestion "Might be caused by a previous networkNode.sendMessage.onFailure.");
Shouldn't get it from Serivce_provider too?
same as other, return once or instantly.
null == adapter
Can we do some sort of validation on the media type? At least to make sure it is in the standard format (ie. type "/" [tree "."] subtype ["+" suffix] *[";" parameter]).
Add a new line here please
Hours and Mins is relevant for Weekly schedule too
Nitpick braces
Please format this line so it isn't so long.
@paulodamaso why swallow the exception?
This test will run for 5 seconds+ if left like that, do complete the batch after your assertion to make it finish faster
please use isEmpty() instead
Can be replaced with lambda
This is not thread safe, but we could synchronize all accesses to this variable under the lock for fEntries. We should only clear the row of the view trace.
Iterables.getOnlyOne
We should better use Exchange.origin field to determine if this is an outbound request. For that purpose we could e.g. add a Exchange.isOfLocalOrigin() method.
why are these methods (cleanCachedNotifications and cleanCachedUniqueOutcomeEventNotifications) inside the thread definition?
you shouldn't perform any filtering on subject when doing faceted search on the subject, so you can't use setCommonQueryParams method as it considers any subject area passed in the query. In fact, don't extract the set methods in another method, since they will be changed for each filter. Also, you haven't captured the journal info.
mark it as @Nullable
just a style thing but maybe add in TypeMapping a as(Class<T>) to be able to do typeMapping.as(ClassMapping.class) it avoids to put cast everywhere and makes the pattern if (type == xxx) tm.as(X.class) more natural IMHO
If color output is not enabled, the # is not added into the prompt. Adding of # to the prompt shouldn't be dependent on color-output property.
and here submonitor.beginTask(NLS.bind(Messages.TmfEventMatching_RequestingEventsFrom, trace.getName())
Any reason to return List<? extends PartitionId> instead of "List<PartitionId>" ?
Instead of passing httpClient here, you can as well use HttpClient.createDefault() since you know httpClient is null.
I think usage of String concatenation here is an issue. Could you fix it?
we should at least log it no ?
Using a Set here instead of a list would be more efficient for lookups. We should also move to a static constant rather than defining it in the function here.
this seems wrong in light of the other constructor where you set creator/user to different values  null, null, sessionManager.getAuthorName(), sessionManager.getUserName(),
Nit: this is one MD5 value so it need not be plural ?
What has happened in order to return null from this method? This should never happen as we have done all checks before, right? If we return null because we hit an unexpected condition, please throw an Exception. Same for all return nulls in this method.
It's better to have this logic in its own method so that if a client wants to determine what is or what isn't a minified file they can do that easily. Additionally this can all be replaced by  if (StringUtils.endsWith(filename, JS_MIN)) { // Info log and return resource }  Typically there's an apache commons StringUtils method for most String operations. This goes for Collections, Integers, Longs, Arrays, etc. It's a good habit to check if there's an apache commons method you can use instead so that we don't have to reinvent the wheel. If you have a feeling that there's probably a library that does something but you can't think of what the static class would be just ask in the Slack channel "developers" and someone will be able to help.
This test should be where the check is made. In DeletePipelineConfigCommand
I'm just wondering whether you should test for storage being null. Can you check that please, and let me know? (Does loadAdapter support a null param, is it possible that variant.getStorage(...) returns null?
Is there a reason for not using Calendar.getTimeInMillis()?
Set interface
suggest to rename to assertionType instead of assertionTypeTest
Typo. suggestion fail("Expanded to " + expansion.getExpansion().getContains().size() + " but max was " + myDaoConfig.getMaximumExpansionSize());
Just minor, but things like ".ssh", "id_rsa", "known_hosts", etc. should be declared as constants in this file.
Nit: would it make sense to make volumeIds a set? If the same volumeId can be referenced by diff instances, duplicates are possible
What about DT_LOG_APPENDER that is being configured above. Can it be repurposed for this? Also, looks like createLoggingProxy is a pass through and system out and err are going to out and err as usual. Are those proxies needed?
I think this message field can be removed and used directly in checkState
Why is this test case removed?
Null check on ryaInstance
Shouldn't this be saved in the UserRepository too?
The dataFileChannel and indexFileChannel are created via data output driven. I am wondering that does it exist the case of empty output? Maybe the operator filters all the input data without any output, then finished finally. If so, we should remove above check to avoid unnecessary failure.
nit: spaces after commas (applicable everywhere)
Showing logging in this loop is good (it's consistent with OperatorManager) but throwing exception has a downside. Because throwing an exception will leave from this loop, users can know only one unused key at a time. How about moving throw before the loop if throwUnusedKeys is set? We can concatenate messages of getWarnUnusedKey with \n as the message of UnusedConfigException.
How come this moved from updateToken? I think it needs to be part of that synchronization block
Log the exception as well. I know I keep harping on this, but if these errors actually start happening in production, it will be really useful to have the exception logged to help figure out what is going on.
ignoreTagChanges needs to be in a try/finally since the tag add or removal can trigger a lot of code.
might want to just use MetricsRule to have it handle saving & restoring the metrics  @Rule public MetricsRule metricsRule = new MetricsRule();
Would you tell me why this change is needed?
can drop ternary condition
These variable names are a little unclear - could you give them more descriptive names?
getBytes should specify a charset.
It is possible to receive a memento not populated with KEY_TYPE causing type to be null and generating a null pointer exception, This was already present in the logic of the former "restore" method, but it would be nice to make it more robust to either throw two types of exceptions or wrap either one on a CoreException. Let me know what you think
this method does not use member variables and thus can be made a static method.
use the same error message as above for consistency: "Field %s must be of type bytes. It is currently of type %s"
What about just removing this method used 2 times, and give a doc name to both calls?
To be consistent with surrounding code it should just return true here (as it is a part of manifest.exists() check). May be it needs a bit deeper rework like Optional<String> extractPluginName(IProject project)
IMO we should also print a warning. This is quite important info, should be visible when running in CLI.
No, this method should not throw interrupted exceptions.
This effectively removes the possibility to use another root resource by extending CoapServer.
I would put this bind inside of WebSession.module(), as its really a private detail of WebSession.
Nit: java should be able to figure out that it is a String from the required type for GeneralTopologyContext
here we should throw: blocking work processor cannot be (safely) iterated over (add this as a first commit) then you don't need the while(true) in yieldingIteratorFrom()
I guess this is the virtual size?
I guess a more helpful message would be useful. This message seems like a debug "how did I get here?" message rather than something useful.
Minor (here and on line 80): Can you remove "JobPlanner.this"?
Shouldn't you decode the namevalue[0] as well?
Gratuitous reindentation does not make a reviewer's life any easier.
This was added because of a NPE; and it fixes that problem. However, it changed the functionality a bit. Previous version returned a Row containing null values. This returns null immediately. In extension_elasticsearch (our internal project) I added a null check to make it work fine with this, but I am not sure if this causes the same problem somewhere else or not.
Is it really needed to look up the PageArea like that (the implementation of the getmethods sound fragile to me)? Why not reuse the instance you already have? The fact you navigated away and back should not matter.
I think the logic should be extended with "if the memory size on the next-run configuration is different than this in vm_static, don't do anything" to handle the following case: 1. VM runs with 8G 2. User updates it to 4G and asks this change to be postponed to next-restart 3. Use unplug 2G => with this logic the VM will change to 6G after the next restart although the user could expect it to be reduced to 4G
This will perform sleep even for StopVdsCommand, which we don't want. Please move this execution into StartVdsCommand.teardown() method
typo: applied
you do not need fetch encounter from server, because it has been already done
This seems wrong to me, or at least ambiguous and unclear and will likely lead to problems. The Condition class has an "onsetDate", "endDate", and "dateCreated" property. I think that dateCreated is the least useful of these in most cases, particularly if systems are not used at the point of care and backentry of data is common. We need to be a lot more explicit here. I'd vote for having "onsetDateOnOrBefore", "onsetDateOnOrAfter", "endDateOnOrBefore", "endDateOnOrAfter", "createdOnOrBefore", "createdOnOrAfter", etc. and then handle each of these cases explicitly. We might also want something like "activeOnDate", which looks at the onsetDate and endDate and ensures that the passed date falls within those dates (or that they are null).
Maybe it is overkill to use Throwable instead of Exception?
As you're cleaning code, could you change the declared type to List?
These spaces should be removed.
Its not a bug: you can use new OkButtont()
This gives a fairly large group with three radio buttons. Would a drop-down combo look better?
This is all removed by #111 right?
Use non negative check it will help you to avoid nesting, also it looks better :  java if (userId.isEmpty()) { return null; }
it would be more OO if tags list would contain WidgetPageObject objects and inside loop you would call:  widget.isVisible()  and each widget should implement such method
One disadvantage of breaking up the state is the doubling of lines here and below.
Also log the count of "All checkpoints" ?
This sentence seems broken. Maybe 'denied for' or 'denied while trying to move'
Let's use assertTrue() instead of assert.
please revert all changes here, they are not needed / hide errors where code tries to re-use disposed parts.
what if the collection is not empty but a string in the collection is null or empty?
I think this will be simpler if you change this from forEach to mapToLong, returning 0 or getReservedRevocableBytes, and then use LongStream.sum()
This should be removed from AccumuloClient
We should break these errors out to help the developer.
I would extract the check if argument has particular value into method (to avoid duplicate in next condition and improve readability)
missing timeouts (I think)
Right now this branch always runs, because String.contains("") is always true. I think you meant something like this: suggestion if (variable.getKey().contains("\"") || variable.getValue().contains(" ")) {
Why not generified?
I believe there is no need for this check.
Also, is IllegalArgumentException correct? There's nothing wrong with the argument of itself, DocNotFound seems more logical here.
you should use a Set for scopesAndMetricsNamesToPut, similar to scopesToPut.
You could try the slf4j log native expression  log.warn(Error [{}] in database query: [{}]", ex.getMessage, expr);  log4j automatically replaces {} expressions with the resp. parameter. Additionally I prefer to put error content within square brackets for better differentiation and copy/paste selection :)
what would happen in the wrapper's environment status is ERROR?
startsWith("scsi") ?
Could be shortened:  if (!contentlet.getBoolProperty(CHECKIN_IN_PROGRESS))
Don't you mean isStatic ?
I think it should be: if (representation instanceof DSemanticDecorator) && ((DSemanticDecorator) representation).getTarget() == null) { DSemanticDiagram.getRootContent() is an EOperation marked as @Deprecated in DSemanticDiagram.java. It is used later in refresh (org.eclipse.sirius.business.api.query.DiagramElementMappingQuery.getRootContent(DSemanticDiagram, IInterpreter, DragAndDropTarget)). We do not need to add this entry point in DialectServices. Furthermore, I did not found any relevant call on DRepresentationContainer.refresh()
what is the usecase for having INT when we already have LONG and DOUBLE. If so is there any need for FLOAT ?
redundant parentheses
complete is set after the loop, so I think this check should be before the loop. The if (currentIterator == null) body is also getting a little large, so I'd start the loop with the "else" branch instead: if (currentIterator != null && currentIterator.hasNext()) { return currentIterator.next(); } If this doesn't return you know the currentIterator is either null or exhausted, so you don't need to set currentIterator = null.
Check that the main Id has been returned, because the equals method does not compare it.
this method should just call node.toKApp(), since this transformation is likely to be useful in other settings as well
not sure why do you need fixture and manual interaction with directories and page cache, why not using class rules instead?
In this transform, config.inputField is transformed to the json fields, which is one-to-many, all the other fields are identity one-to-one transform, your lineage should reflect this
![MINOR](<LINK_1> 'Severity: MINOR') Define a constant instead of duplicating this literal "AnonymizationTest" 6 times. [![rule](<LINK_0>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
You have to call data.clear() before using it. Yeah, the ByteBuffer API is full of nitpicks like that...
cryptoAlgo
It'd be helpful for debugging purposes which objects didn't make it into fedora. Also, for string formatting like this you need to put {0} into the message where you want to have the variable display
This should probably be dueFineAmount
Double the attribute compartment Same visual id InterfaceAttributeCompartmentEditPart.VISUAL_ID
Also for all other places. It looks strange to me that: 1. we make query with primitive parameters in the arguments, but 2. aggregate the results in a well defined structure. It makes more sense to me if we "build" a dns request with a Builder class, instead of creating various types of query function. E.g. DnsQueryBuilder dqb = new DnsQueryBuilder().setClass(CLASS_IN).setType()... finally: dqb.query() or mDns.query(dqb.build());
It's not clear to me what this last line is testing.
to my understanding the model cannot change anymore, therefore it does not need an adapter
Caching an inverse in order to replace division with multiplication is premature optimization IMO. Even with a million targets and a thousand samples, this saves at most a few seconds.
let's use a non-wildcard result with whenAnyResult
Hive stores MIN,MAX as well -- we don't use this currently, but we may in the future. Also, other tools may make use of this. Consider // TODO ...
This line doesn't seem necessary, as commandContext is never used in the methods where it's passed as a parameter.
inline
Is there a requirement to be able to set property value to null/empty value?
Ya, and this is the problem with this whole thing, there are multiple places where variables are set. url, properties, now env. Your specific problem is in parseURL it returns a new properties object and on line 46  if ((props = parseURL(url, props)) == null) { overrides all of the work done in the previous lines...
What about contains as @evoevodin has suggested?
Where you have found such a term as docker image FQN?
Minor nit, these can be collapsed to:  } catch (RuntimeException | OutOfMemoryError e) { AppLog.e(T.EDITOR, e); }
Ditto rename refactor
you don't need to do that , just call FileSystem.newInstance(defaultURI, conf), remembering to close the new FS afterwards
I think the save() operation should not happen in the templates (The wizard will/should save the model at the end anyway)
Can these two if statements be collapsed with the above ones?
here you have code repedated
I don't think we need this since the creds should already be set.
See getAllLifelines remarks
I like the addition to be able to check on both payload and metadata, but it kinda feels like we've added additional behaviour to the 'event-payload-matching' function which is not quite clear up front.. Not settled on what would be the best alternative solution, but the first thing that sprung to mind is to have a expectEventMessages(EventMessage<?>... expectedEventMessages) function. Just thinking out loud here, what do you think @bliessens ?
rename those to:  pagesIndexUserMemoryContext pagesIndexRevocableMemoryContext
Since all you need is the project name, you could use #getNamespace() from the route. It will return the same value. Additionally it will not make a call to grab the project since we dont cache this info at the moment
Shouldn't these be being caught, bar IOException, and written out as error summaries?
You should leave ternary expression and use if/else if statements.
what is this permission for?
This verbage is wrong, this should be re-worded to something like "Last Tracking Date"
Should we first check that it is a byte[]?
we actually dont need to collect that, can be left as stream, minor
What is this check for?
needs US-ASCII charset, or some other simple ascii encoding conversion
Small typo
Haven't we refreshed this in the BaseControllerDataProvider, can we just use that result here?
As noted above, we need tests for at least a few more GHReason values (specifically multi-word values).
This should already be handled by StringUtils.isBlank(brokerID)
nit: could be set to final and refactor as:  final Integer partition; if (partitioner != null) { final List<PartitionInfo> partitions = producer.partitionsFor(topic); if (partitions.size() > 0) { partition = partitioner.partition(topic, key, value, partitions.size()); } else { throw new StreamsException("Could not get partition information for topic '" + topic + "' for task " + taskId + ". This can happen if the topic does not exist."); } } else { partition = null; }
we should also write tests for removing a reviewer which is not on the review, and removing a reviewer which is not a valid user
You'll probably get away with this, but this is modifying a shared instance of the groupSpec instance (the EntitySpec is mutated by these methods). Better practice (probably) to do EntitySpec.create(groupSpec).displayName(bucketName)
Is it guaranteed that we will have an AbstractFile in Node?
this could be an int too. and could be declared inside the try {}
<String> is not necessary in new ArrayList<String>(); Are you sure you're coding in Java 8? Please fix up your environment.
small nit - can probably drop " for"
I think there was a reason... but for the life of me, I cannot recall which one. I'll check with Daniele Monday.
This relies on version being 0. Safer to do the right thing here now. Q: What should happen if the version doesn't match the field in the class? Should we throw here?
Depending on what to expect, you may be interested in using Jenkins.getActiveInstance() instead to remove the null check above
I have verified that we want the ability to run ingest modules on non-data source virtual directories. Please remove the isDataSource check.
java Stream<Pattern> patternStream = this.headerPatterns.stream(); Map<String, Object> headersToEmbed = message.getHeaders() .entrySet() .stream() .filter(e -> patternStream.anyMatch(p -> p.matcher(e.getKey()).matches())) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));  ? Also I would say the this.headerPatterns.stream() should be as a property, too. To avoid extra Stream object for each message.
I guess that if the pipe is broken, the return code should be 1.
This should not synchronize on repository due to a risk for dead-locks. BugzillaClientManager should use a private lock for managing the update job.
mobilePhone->mobile
Should autoCaptureSessions also be disabled if setSessionEndpoint is called with empty / null?
Wouldn't it be preferable to delegate this to an injected ErrorMessageStrategy rather than invoking the overridable method below ?
i would name it isFiltered to suggest that nothing failed
Change log level to debug
performance: init the string away with the size of the device list
Please make just one lookup operation for every key: putIfAbsent().
java if (params.length > XACONNECTION)  would be better
I think that would also help to address the potential perf issue on calling System.nanoTime() multiple times when invoking the onTimer() multiple times.
Variable name should be 'resource'
this code is duplicated (4x)
Why not parse the lang and moreInformationURL attributes defined in the spec, and put those into the ProgramInformation as well?
are you aware that this is a NOP?
Please clean up any ternary operators to avoid nesting.
These methods all need to be implemented and annotated with @Override.
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
else is obsolete and getting rid of it reduces nesting.
we can probably drop that line altogether in fact...
What happens if cluster is null?
@kingthorin was suggesting Constant.messages.getString("codedx.error.httpMessage", alert.getAlertId()) which does not require extra formatting by the caller.
metricNameDtoSet
In setRawTargets(), raw expressions are found instead of references. So, it seems that resolving level should be set as RELS_ONLY. If I misunderstand, please let me know. Thanks.
we don't use curly brackets around one line statements
Is it possible to extend StreamingStateEncoding with an abstract getStreamingState() method that delegates constructing the appropriate StreamingState to the corresponding StreamingStateEncoding subclass?
Maybe you will call it in the previous conditions blocks
I guess workspace could also be Optional<File> in Configuration so you could do orElse here and maybe simplify the code in other places, too? Didn't go through every place it's used, though, so maybe that won't work - just a thought.
code formatting is off (also please always use {} even on single line blocks)
static ?
double space
I would write this as:  Stream.of("a_0", "x") .map(Identifier::new) .map(LambdaArgumentDeclaration::new) .collect(toImmutableList())
The partial load callback should not be changing the progress loader visibility state, so this line should be removed.
Could we trim the given expression? Currently I see the following in the generated code (note the double white space at the beginning):  target.setTimeAndFormat( new org.mapstruct.ap.test.source.expressions.java.TimeAndFormat( s.getTime(), s.getFormat() ) );
This name seems wrong since it's not the last column. How about dropColumn or just column
Since you do really like the ternary operator, you could use it here, too. Besides, Uri.EMPTY instead of null might be more null-safe.
metadataOnly flag is always false in case of bootstrap. So, shall avoid checking it here.
move toString() into clickOrdersTableColumn() method same goes for OrdersTable.ELEM.toString() calls
Is this an eGit convention? I'd have used baseref == null ? null : baseref.getName() to avoid the negation.
You should log this. How else could the user figure out what the problem is? Though sometimes benign, LockFailedException usually means there is a stale lock.
Must change the maximum to 3. Will fix on merge.
This is not safe, you need to actually check if they are started, wait if not and check again. It applies to all the cases.
write a test about it!
When would you enter this state?
what is the meaning of null ?
The top and bottom parameters need to be switched. suggestion projectionMatrix = new Matrix4f().ortho(left,right,bottom,top,zNear,zFar).transpose();
your call if you want to convert this to a stream:  chunks.stream().map (chunk -> ...)
@rcpeters Should be releasing the lock there?
URIUtils.addParametersToURIQuery?
if constraint.isSubstitution then I understand this method should return BoolToken.TRUE. But what if constraint.isFalse is true, shouldn't we return BoolToken.FALSE instead of null?
please don't touch old formats, whatever they do let them do that
nit: put context in new line, and also for line 72 and 76
isCDTProject variable is redundant since ifl != null condition can be used instead.
The resource message does not seem to exist, it's also concatenating with the key instead of the resource message.
This part feels wrong. You should be using IClasspathDescriptor (which is designed to encapsulate IClasspathEntry). My guess is ClasspathDescriptor should probably be changed to receive a scope element, that'll drive the classpath attribute modification.
uswrPath -> uwrPath maybe? Not sure what the s stands for.
Make this 3
The null check is too late here. Should go further up.
Can you get the user from context instead?
Should this line be outside of the while loop?
Shall we mark it as final? Also I don't quite understand why it is named as dump? If it is just a copy, will a name called tagRouterRuleCopy be better?
Couldn't the EKM from the persister be used?
Can you please delete this logging? We don't need this anymore since we verified our theory about the issue.
The default provider is AD and id rhds attribute is null its becomes IPA? can you elaborate?
Is it even possible for si to be null at this point?
There's a ParseUtils.missingOneOf method for cases where at least one of a set of choices must be present. The missingRequiredElement message implies all of them must be present.
if (oldIndex >= newIndex) throw new RuntimeException("useful message")
does your logger take both %s and {}? The latter is more typical in my experience.
we don't expect the sort order to change, so I'm thinking this should be done at the filtersettings creation time, it would avoid having to do these manipulations to the table settings, wdyt? _FilterSettingsBuilderHelper_ would need to be improved to accept multiple columns.
the name & type check can be done here, here is example: java TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) throws TextException { this.names = names; this.types = types; if (timestampIndexCol == null) { timestampIndex = -1; } else { timestampIndex = names.indexOf(timestampIndexCol); if (timestampIndex == -1) { throw TextException.$("invalid timestamp column '").put(timestampIndexCol).put('\''); } if (types.getQuick(timestampIndex).getType() != ColumnType.TIMESTAMP) { throw TextException.$("not a timestamp '").put(timestampIndexCol).put('\''); } } return this; }
Can we change all the variable names in tests from globalConfigFile to sessionConfigFile? For consistency.
get without an assignment seems weird should this method be rename to appendImageList or writeImageList ?
If this is done in more than one CLP, it would make sense to move it to CommandLineProgram. (Also, it is odd that File is deprecated in SortingCollection but not in SortingLongCollection)
better to use the official way here true instead than "true"
When using a model tag, you can initialize your EventHandler in the org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.init() method.
this should probably throw close the store and throw a RuntimeException, because someone is trying to kill us
We might end up potentially adding null values to a list. This should never happen. Please check and only add non null values.
I'm just wondering what will happen if none of the renderers will have uuid matching the user-selected default? E.g. what happens when user sets -Dorg.dashbuilder.renderer.default=nonexistentUUID? Maybe that scenario is ok, but I'm not sure just from looking at the code..
Have you considered something like : toDelete.addAll(Arrays.asList(fMembersToMove)); toDelete.retainAll(Arrays.asList(all)); retainAll() keeps all elements in a collection (toDelete) that are present in the list passed in as the argument (all).
Hmmm where do you set the port to be opened?
JUnit way to skip some test methods from the unit tests (compared to ignore all tests. in which case it Assume is used in @Before method, ins which case all test methods are skipped) is to use Assume in that method (that we introduced last year in GWTORM): assumeThat(notesMigration.enabled(), is(true())); // normal test code follow When the assumption is met, the tests is executed otherwise the test is skipped. The only question is: does Buck support it?
ReportParseExceptions is true by default?
energy / energyCost will be > 1 when it has plenty of charge, no?
That's a sad error handling. Is there a reason why the test method cannot be marked "throws Exception"?
Don't think we need to log this. This is not useful for users.
Please change jsFiles to ArrayList. There is now need for type Vector in this single threaded situation.
Could probably just use hasExplicitlyConfiguredAddress() instead of getAddress() to skip the possibly expensive lookup while retaining the feature to set the email address automatically.
Duplicate check (see below)?
why is 1 added to schedulerThreads here?
1. it is wrong place to customize "isParkingPluginEnable" should not be here in the code 2. there is no need fofr this ifs , it should be always visible Code should be deleted
This should be logged as well. Use the monoError() helper method in FluxUtil instead.
Maybe use !frcs.isEmpty() here? Or is it necessary to check for the size here? We just have a for loop inside anyway.
We should delete If. Since if this message is logged, it means pacemaker is not being used.
I noticed that finishCommit is not passed cd2. Of course it still works fine because, cd and cd2 are the same. This made me think it may simplify the code to remove CommitData param from OnSuccessInterface.onSuccess(). Then this code could be written as : java addCallback(cfuture, cd, result -> finishCommit(cd, commitTs));
final modifier here and everywhere else where applicable.
entry (or something else since entry is already a field)
shouldn't you fail if the read of even a single account fails?
Hey @tonyr59h , got to say, this all-sites removal makes me a bit uncomfortable. I assume the reason you added it is to "clean up" any remotely-deleted sites, right? Is there some reason beyond that? Here's the thing though: an unadvertised removal like this can possibly delete data not synced to the backend yet, like draft posts that have local changes. Fixing/catering for a case like that might easily fall outside the scope of this PR so, may I suggest instead to avoid removing local sites en-mass? Perhaps we can remove local sites after we get the updated remote list and check that the site doesn't have any local drafts. WDYT?
nit: throw on next line.
That whole ordering is Comparator.comparing(row -> row.getRaw(column), Comparators.naturalNullsFirst())
Why it's three components and not just one string?
Why not just set stopGlusterService to true in createMaintenanceParams()? Isn't stopping gluster services already managed inside MaintenanceNumberOfVdss command?
suggestion if(entry.getValue() == null) { target.put(entry.getKey(),null); } else if (isSimpleType(entry.getValue())) {  rather than using continue, go on with an else if
Extract the value creation expression from the put() call to reduce nesting.
wouldn't it be easier to use scan consistency on findMaxAttendees so that request plus is implied?
Not sure if I get the logic here. Why is this block (from // Add responses that the user submitted himself to this line) moved to inside case STUDENT?
The timing dependency is still problematic. Does the API let you run the DAG and then terminate it once the results are computed? This can be taken up outside of this PR, but should be fixed.
[minor] This won't ever appear in the response from Ledger. It doesn't generate this link. It can come only from connector. I don't see the value of having this line in this test.
Change this to use MDKConstants.SYNC_SYSML_ID_SUFFIX.
this logic is too hard to understand. I would refer a simple something like: if(offset1 == null || offset2 == null) { return null; } else { return Integer.valueOf(offset1).compare(Interger.valueOf(offset2)); }
Shouldn't we be throwing FileNotFoundException here? Or otherwise at least some subclass of RuntimeException, probably SecurityException.
Again, I am far from being an expert in networking, but if I made a mistake in writing the port number, enough to make it unparseable, I think Terasology should not start and report the error instead of smoothly switching to the default port. Also, depending on what follows the current warning printout and at what speed, it could be swamped by subsequent startup and log statments, to the point that the user might not realize server port is not what he or she expects.
This will catch exceptions that extend RuntimeException and rethrow them as a different exception. Seems very undesirable. Looks like this is because of AutoCloseable. I think we need to do something a little smarter.
I would move exception handling into isReloadable() and returning false when exception raised.
What's the purpose of this providedVsCount? How come you can close even when not removing?
As we discussed make this method return void and let the producePage() handle output from getOutput() method.
This won't work. It's combining two directories which would more than likely result in an invalid directory.
Nit: stream on previous line
Minor: I'd prefer starting this before passing to the StreamMetadataCache, just in case it tries to do something with the passed in systemAdmins.
nit: you don't need new Object[] for the current version of slf4j
The propagate flag value is the same for all messages, to seen_messages and propagated_messages will always be the same. amirite? I'd then remove than metric.
maybe we can add the limit as the size of the array list?
inline compactedBlock
Why would a get something method have a side effect of setting something?
-1 sending order is important. You need to use a single thread to send the request or you risk it to be reordered.
good thorough testing! Could also test 3456 (i.e. where have just exceeded the kb > 2 threshold)?
Just return null here.
The arguments here should be flipped expected is now, actual is eventTime. The assertNotNull above is also redundant, if now.equals(eventTime) then eventTime cannot be null.
Lets just return after this and skip the next check
If you use theTable.getColumn(name), this will throw AmbiguousColumnException for you, so you can get rid of this else if
Need to put this back - cannot change the API
Make this separately lined for legibility.
It is not only unknown, it can be failed and failed restart also. you should simply print the commandStatus
logger shouldn't have **KHALID** in name.
Please add @Nullable (same below)
Rather than hardcode the string, can use the classname
Put this condition together with state.getBlock() == null; same for maxCombine
maybe assert that the entryId is the special entryId? Just a thought.
should long size ... be moved to right above Job job = ...?
[optional] Can you port this method to builder-like style?
MediaTypeHelper.isTextLike(...) uses .equalsIgnoreCase and .toLowerCase() It's not needed here ? This was noticed by @kanovotn
Arguments should be 1 element array. Type should be ObjectInspector for string rather than abstract.
here you have a positive test
!= will work only for interned strings . Use !str1.equals(str2)
Table {0} does not contain a primary key. A vast amount of memory may be required.
Catch this in populateReviews and just set the value to zero. We shouldn't fail to build the whole section just because one review has a bad value.
You override this in two test methods so this variable doesn't really need this scope. Make it per test
@wwjbatista I think for this PR (STICKY_POLLING), bypassing the logic from insertEntryFromTransaction going straight to the DB is fine, although we should at least update the stats (totalInsert.inc()). @sbrossie But I don't think this is what we want for the full implementation (i.e. considering STICKY_EVENTS <LINK_0> as we wouldn't re-insert the ids into the inflight queue (unless we want to solely rely on the orphan polling mechanism?).
I don't understand yet, why the facet check helps or is necessary.
check for postArtifact vs postArtifacts
Shouldn't Unexpected be a single word?
Is it possible to take this string from CorrectionMessages.properties without much change?
delete this line
Can't you get the fortune value from the loot context? Edit: Isn't this whole method unnecessary now that you've written the loot table JSON?
Jenkins.getActiveInstance() instead (nullability check)
why are we wrapping this now? we are declaring we throw E, but we're actually throwing a RuntimeException
Should be IllegalStateException
Super nitpick: but could this be expiryTimeString?
It shouldn't be necessary to create the fragment when the activity is recreated. Instead you can find the existing fragment, and if it's not there create it. Ex:  mPostList = (PostsListFragment) getFragmentManager().findFragmentByTag(PostsListFragment.TAG); if (mPostList == null) { mPostList = PostsListFragment.newInstance(mSite); getFragmentManager().beginTransaction() .add(R.id.post_list_container, mPostList, PostsListFragment.TAG) .commit(); }
Could we extract the test portion as a common function?
Not sure how likely it is, but this might the IDE to freeze if the saving takes a very long time. I upload a new revision of your change using the new JobGroup API. This should ensure that Jobs are queued but not blocking
looks like we should better return an empty String here, then callers don't need to check for nullness
Collections.emptySet()
This will give strange results for names with non-latin characters, for example the Japanese name: ?? ?? will result in: ?? which is a bit weird. This might be considered an unusual edge case though. And it should be fairly easy to add proper handling for it later. Just for interest, the following names: ?? ?? ?? ?? ?? ?? Should be properly abbreviated as: ?? (?) ?? (?) ??
What if the property is not set in system?
I recommend to replace it with the logger :)
@lbergelson @nh13 in that case, would it be best to put 0L here?
Must return true all the time (addCounters can fail with replace event, but cards already discarded).
Why are we doing this? This integration test doesn't use optional fields so no need to pass along card_expiry. The mock can be modified to not return cardExpiry.
is it worth it to extract this into its own function?
Place in ApplicationConstants instead.
Need to add the //NON-NLS to String.format lines. If an exception is caught, what happens to randomAccessFile? Will it get closed?
m.getGroups()
Shouldn't we throw an exception if execution reaches this point and the deletion plan is rejected? This will silently skip the deletion parts of the commit.
Lambda?
is there any way you could get rid of this return? Nested returns that aren't at the beginning of a function can make it hard to understand the flow.
suggestion toolTip.add(key + ": " + value);
Intenal -> Internal
This is a perfect log - all the data is there for investigation. Why don't we integrate all of these in request.getLogInfo? This way the correlation id will always be logged. Same applies to any errors.
getOnlyElement() instead of getFirst()
Suggestion: use <LINK_0> so that we don't need to catch exception in here. Make code more readable
as temporary decision, I refactored it so that "dice = null" in case if dices not thrown yet. IMHO, in future we shoud create separated JSONs for new/playing status and preparation/main stage
Shouldn't the rowData field be inside the serviceListeners.size() > 0 if below, since it isn't used outside of that scope?
EcoreUtil.getExistingAdapter()?
How come Default and Fragment is in the same branch? Maybe i do not understand something?
Need to remove redundant cast.
I think you want to compute extractMyRating() on computation scheduler. to do this you should use observeOn(Schedulers.computation()) before map and then use observeOn(AndroidSchedulers.mainThread()) before subscribe()
This line needs to be removed since the last commit.
unnecessary change.
Why is this better? IMHO we could do away with lastAttempt completely and just use elapsedTime = System.currentTimeMillis() - start; directly and move attempts++ back before the closure.
I am slightly confused. Why do we need a new class if existing one (MessagingException) provides everything you need to hold and access both the _cause_ and the _message_. Is it just a Marker interface? If so you could still simplify its implementation since you can still rely on getFailedMessage() and other provided functionality What am I missing?
Use some non-link local IP here as the resolver may filter them out anyway?
I would return a warning (as well as for the permission check case below)
There is a method org.scijava.util.ArrayUtils.safeMultiply32(long...) that you can use to downcast a long (or the product of multiple longs) to an int safely. It fails fast if the downcast would overflow.
There may not be a selected column at this point. You should check columns.getCurrentlySelectedColumn().isPresent(), or assert it.
Please clean it in every case
We should check closedStreamer flag only after lock acquiring.
why are we even using matches()? there is no regex invlolved. we could just use equalsIgnoreCase()
Here we can add some more info like "Access Denied! The given realm is not in the allowed realms"
Don't log and throw the exception
These two statements are so similar that I would actually just positive ? null : errorCallback instead of duplicating them entirely.
What purpose is customFileTag serving?
use try-with-resource. java try (Response response = executeGet(bucketName, objectName, null, queryParamMap)) { .... .... } catch (ErrorResponseException e) { if (e.errorResponse().errorCode() != ErrorCode.NO_SUCH_OBJECT_LOCK_CONFIGURATION) { throw e; } } return false;
I missing here how we are testing HtlScanner? I have a feeling that we only check expressions part but what about other stuff like TAG, TEXT... ?
Reset the thread to interrupted state
Why do we need to repeat creating flattenValue? This could be simplified to the following: java return name + SEPARATOR + flattenValue;
can we add atleast code in this error msg or if it would make sense then print complete paramters
please make this lowercase ("dsList") and then everything looks good
this looks like it will cause a ClassCastException to me. Did you mean instanceof VisitingException?
this can be simplified throughout to: getBody().readUtf8()
why not to check the group name instead of groups number?
Should this be exception-worth too?
sounds like util method to be reused.
In what use case the new DB name can be null?
Can the "base == otp" case trip? If so, what prevents cycles that don't involve otp?
invert condition
This will result in a bunch of round trip calls to the datastore/DB. A better approach would be to add the list of IDS as filters and then just call loadRecords with the list of filters.
*persian
One-line if possible.
@rnveach I think here we should have different name for parent and child to not confuse them
setErrorMessage
This null check is redundant because lastObjectPropertyInPath is never null.
These compareTo(QC) could be abstracted a bit: If it's okay to compare date before data, just make the impl classes do int compare = super.compareTo(t); if (compare == 0) {// impl-specific compare} else {return 0} If date really should be compared after data, make AbstractQc do the generic stuff, then call an abstract "compareQcData" method, which is overridden in all of the impl classes to only compare implementation-specific things. If that's still 0, do the date comparison. May want to move null checks around too (it doesn't matter if qcDate is null if it ends up basing the response on qcType) Just thoughts, no change necessarily needed. As is, it's better than before
Stripping trailing slashes is so common we should have a library function for it.
This looks complicated and hard to understand/maintain. I'd suggest using int for releaseOrTarget, something like this:  int targetedJavaVersion = 8; if (release != null) { normalized.add("--release"); normalized.add(release); targetedJavaVersion = Integer.parseInt(release); } else { if (source != null) { normalized.add("-source"); normalized.add(source); } if (target != null) { normalized.add("-target"); normalized.add(target); targetedJavaVersion = Integer.parseInt(target); } } // Put -parameters option back if no target option was provided or at least target 8. if (parameters && targetedJavaVersion >= 8) { normalized.add("-parameters"); }
third-party exception
This does not pass on OS X - investigating...
You can remove this if else. Nothing uses isLandscape. You can also remove variable declaration.
isNumericFormat(format) does not need to be computed for each object. You can compute this outside the function that is applied per object (on line 125)
please, stop container in finally block
ItemStack has a nice splitStack method that does exactly this in one call. Don't even need to check stacksize beforehand.
Typo on certificaiton; should be certification
If there are multiple primitives columns, users won't be able to tell which column failed to map from this error message. We should provide more information about which column failed to be mapped. Maybe include the column number (and column label from the result set metadata)? We may also want to include a suggestion in the error message to change the mapped type from a primitive to a wrapper.
Why removing this?
add CDA to check if the init succeeded, if it fails you'll end up with null vm which will cause to an NPE.
@pynicolas method trees also extend FunctionTree
Can be rewritten with a simple Arrays.asList() call.
minor nit....can you please rename isLinuxOS to something more fitting, like epollEnabled?
getForce() returns boolean we do not need to double check.
We may want to move this into onPause(), so the notification only start when the user leaves the view of the trip planning results. In some cases, I'm currently getting notified each time I tap on the different tabs for each trip plan result, which is confusing.
I don't think wrap up our exception with a library exception is a good idea, it is prone for falsehood assumptions (this AmazonServiceException exception won't have requestId, errorCode, statusCode,...). Also, this will lost the original cause with stacktrace. If we're trying to re-throw an unchecked exception here, I think a simple RuntimeException(ex) is sufficient and will retain information from the exception chain.
Is it enough to use max-data-volumes-supported as the max device id, seeing as device id 3 is not used? (or is reserved) E.g. let's assume that getMaxDataVolumesSupported(vm) returns 6. What device ids should be ok in that case? Would they be 1, 2, 4, 5, and 6 (since maxDataVolumesSupported is 6) which is a total of 5 data volumes, or should maxDataVolumesSupported be renamed as maxDeviceId and be assigned a value of getMaxDataVolumesSupported(vm) + 1 to account for the unused/reserved id 3?
This was actually my suggestion because the names are not unique when there are nested jobs. Continuing to use names for non-nested jobs means we don't break existing users.
Seeing this everywhere makes me think that we should wrap/hide the session variable such that it's not directly accessible as an instance variable, but is returned by this method, similar to how we used the ThreadLocal stores.
I believe you found the right area to fix, but the change works fine for y anchor equals to 0, which makes for top alignment. But what if bottom alignment was asked and the last line was significantly smaller than the first one instead? Try the following, change the y anchor to 1, and the string to "Espace\nabcd ef", and the result is this (with your code changes in): ![selezione_577](<LINK_0> Before the code change it would have been instead: ![image](<LINK_1> I believe that the code should be sensitive to the anchor value, at least for the cases where a human visible alignment is evident: - if anchorY is 1 (or very close, use a tolerance), use first line height - if anchorY is 0 (or very close, use a tolerance), use the last line height - for any other value, I'd use the average line height instead, just to care for the 0.5 anchor case better, the others are hardly verifiable
>Foretsry typo
1000?
It would make life easier if we logged something when a new broker is created and also when it's deleted in line 70.
These can be declared inside the try block, together with the return statement.
Better use this.ordinalDescriptorMap and test if it is empty. Same remark below for the second one.
Isn't this code being executed on the UI thread? The syncExec() shouldn't be needed.
As a practice, get the value of "HTTPTransportContextHolder.getInstance().getHandlerExecutor()" to a variable, and use the variable after that, rather than doing the same lookup twice. It may or may not be an expensive operation, but still, better for readability, and if in the critical path, can be better performance wise, if the lookup happens to be expensive.
This looks like an unnecessary case as it replicates the unbounded replay behavior with default capacity 2.
I think this should be negated if (!Strings.isNullOrEmpty(simple.getId())) { Otherwise it only adds null and ignores it when it's not null
Maybe UriBuilder would be better here?
maybe, this check should be above of the request-body validation?
static import?
Should we add the navigator's dependencies when this is not supported?
Please remove regex and such ambiguous numbers as "13" ? The code should be easy to read & verify now is totally cumbersome.
How can it be equal to false if it's a number? Am I missing something? Same question for default case as well.
Should we be passing the close timeout to join?
Only the createIndexes and the dropIndex synchronise on the IndexingService monitor lock as far as I can see. This means the state in here is inconsistently synchronised. If we are only worried about concurrent updates to the indexMapRef, then we should synchronise on that, and do so consistently. This synchronisation could, for instance, move into the IndexMapReference class and be exposed as an atomic update method that takes a lambda, or something like that.
we are not handling "timeout" anymore
If the correct flow of things depends on the order of calls, then something here is wrong. Why did you need to change it?
why not  if (lineCount == mMaxLines && layout.getEllipsisCount(lineCount - 1) > 0 && getTextSize() > mMinTextSizePx)
note to self: figure out why we can't use what we're ending up filtering by here as a key so we can prevent linear search thru idManager.sessionMap.values() unless @coyotesqrl already knows and wants to clue me in before I dig into it tomorrow
I think you can use method add(int index, E element)
Can you read back the address and make sure its a hole?
This change seems to be different to the original intension. This log appears to show which HDFS namenode is used in this TajoMaster.
I tested following code, and I think this line will throw exception. of course, when we write @Column(name = XXXXX) if will behave correctly.  @Column public String getLongColumnNameWitoutAnnotationParameter() { return longColumnNameWitoutAnnotationParameter; }  note: I didn't test this @column upper method grammar so much, just one try, and it didn't throw exception. Maybe JPA specification permit it.
Never used?
I think we need to set cachedInitialDefaultSchemaDescr to the returned schema descriptor before returning from the function.
any possibility that delimiter is something else? also, I'm wary of possible empty or null values. Do we protect the converter from such scenarios?
Why we have to transit to SUSPENDED before prepare-closing? Originally we want to check that CREATED state can still trigger close.
why not throw an IllegalStateException at this point? I would prefer funny business to be highly visible.
Env name is not compliant with other env names we have. Consider CHE_CORS__FILTER_ENABLED or CHE_CORS__FILTER__ENABLED
Please name the local variable differently from the field, for instance deprecated, because otherwise reading the code is a bit confusing. This will also avoid doing this.isDeprecated a bit further down.
Same as <LINK_0> Only the context autostart may be optional.
Can we wrap this with log.isTraceEnabled?
this doesn't look right
Maybe call the variable "label" rather than "name1"
razEntitlementEnabled
Please add braces. To see more checkstyle violations, please have a look at the output of the static-analysis CI task.
Rename that method to getPauseInfo
This logic seems not to be tested with a symbolic link.
I am a bit confused about the fix. This seems to already be doing what the commit message is describing.
add a message to the failure
this can't work. You haven't specified a message id
You can remove the toString() call.
Again: Capture, then test. getGenericParams is expensive.
Is there a reason to save the process, when the process flagis not changed again? I think this save is only neccessary when export failed and exportflag changed back. It is indeed only neccessary if the flag ACTUALLY changed. This also counts for first save. So if the process is already exported, no save is needed at all
Use early returns instead for these if/elses?
Just in case, you want to add the task which has no parent in successTasks, right ?
Calendar.getInstace already returns an instance set at "now", so this call is useless (and in all the other places where you call setTimeInMillis(System.currentTimeMillis()))
you can collapse the realmFileIsBeingCreated condition & remove the PMD exclusion warning
The problem os sort is not solved here, vmDeviceToSave.values() - these order is unpredictable, we should sort device here.
I think this would fit in 120 characters (same for lines 89-90).
Please change it to something like:  if (propsInputStream == null) { throw new IllegalStateException(propertiesNotFoundMessage); }  or remove it completely please. The problem is that java asserts need to be enabled by a command line argument, so they are not active by default.
If the Eclipse application does not have focus, then you can still get a tool tip by hovering on the time graph. Even after clicking the tool tip shell, the Eclipse does not gain focus, so while the tool tip has focus from OS point of view, it does not have it from Eclipse point of view. So when clicking on another application, there is no SWT.FocusOut event sent in Eclipse, and the tool tip shell remains on top. Possible solution would be to give focus to the tool tip when it is created (or when it is entered?) but I don't know if this will disrupt the user... keyboard shortcuts on the time graph will no longer work). What I would suggest is to dispose on MouseExit. But you would need to have it happen as soon as you exit the shell bounds without any offset (in case you MouseExit outside of Eclipse application. But you can also have FocusOut without any MouseExit if you Alt-Tab to another application.
![MAJOR](<LINK_0> 'Severity: MAJOR') Catch Exception instead of Throwable. [![rule](<LINK_1>](<LINK_2>
Letting it simply throw the exception is an easier way to get the test to fail, also gives all details including a stack trace, while this only reports the error message.
To align this with the OidcUser that OidcUserService creates, I think [an OidcUserAuthority should also be added](<LINK_0>
why public?
kie-wb-common-stunner-extensions/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms-client/src/main/java/org/kie/workbench/common/stunner/forms/client/widgets/FormPropertiesWidget.java:187: error: NULL_DER$ object diagram last assigned on line 186 could be null and is dereferenced at line 187. 185. final String domainObjectName = translationService.getTranslation(domainObject.getDomainObjectNameTranslationKey()); 186. final Diagram<?, ?> diagram = formSessionHandler.getDiagram(); 187. > final Path diagramPath = diagram.getMetadata().getPath(); 188. final RenderMode renderMode = formSessionHandler.getSession() instanceof EditorSession ? RenderMode.EDIT_MODE : RenderMode.READ_ONLY_MODE; 189.
Isn't the same as just removing the 'localrack != null' check in L372? That way we get the same behavior in one if condition.
You could also use Files.isRegularFile
You have some duplication caused by the fact that you check here the exception but also in the catch block above. I would either check here that we have the same exception or extract that code to an exception check method: checkBulkLoadingException(BulkCacheLoadingException e, Set<K> successKeys, Set<K> failureKeys)
Grammar nazi suggests: > Can't label the namespace due to lack of permissions. Grant cluster-wide permissions to \get\ and \update\ the \namespaces\ to the \che\ service account (Che operator might have already prepared a cluster role called \che-namespace-editor\ for this, depending on its configuration). Alternatively, consider disabling the feature by setting \che.infra.kubernetes.namepsace.label\ to \false\.
Do we need to call removeInvisibleOrgUnits here as well?
val -> value
@pynicolas fixed b6229cc713c75b2a4e8a4e5f378d14e5b03b3eb7
Looking at this I feel we should have 2 filters. One for inclusion and the other for exclusion. In other words instead of LuceneQuery.filter let's have LuceneQuery.include and LuceneQuery.exclude
we try to encourage all Checks to do log in visit.... methods. Please refactor this method to return boolean to make a log base on result from it.
diff tool?
An idea for code simplification - move new pvc creation and replacement to a separate method and make it return new pvc for reuse
When would you get into this code path, considering the updateCompactionCFList logic above?
Is it possible to assign from the putIfAbsent call without a get?
If we introduce new abstract methods to AbstractUserStoreManager it will break the existing implementations. Therefore let's implement the method here to preserve the backward compatibility.
I know that the original code used RelativeLayout.VISIBLE/GONE, but do you mind switching them to View.GONE/VISIBLE for consistency with the rest of codebase?
Use Adapters.adapt(getEditorInput(), IEditorInput.class)
Can't we just use ordinary indexing here, ie %s\n%s\n%s? I actually didn't know about explicit indexing syntax, but it seems ordinary indexing is more readable.
I just realized, this else is unused!
Same question like above.
minor: for "list" you can use BuiltinTypes.LIST
you have the method getVdsDAO().getAllForStoragePoolAndStatus
Repeating this is icky :( Can there be a tryParseTimestamp() method and a tryParseMessageTags() method we just call?
Can you please remove this new exception from here? I believe that it's unused and left from previous fix attempt. Thank you!
Please check that unsubscribe works in each phase of a running subscription.
m_pathList is a good use case for using immutable map
Should not it be set by default when it is JRE 8 on the machine?
Use the constant to construct the message so that it doesn't get out of sync if we adjust its value.
No space between the commas!
Objects.requireNonNull?
While we are here, and this is not a requirement (I've already approved the PR), would be good to have a small new unit test that confirms the new configuration parameter does in fact disable Unsafe usage when we would otherwise use it.
Oh, I see. Good find. How about "Finished subprocedure (pid={}), resume processing of parent (ppid={}), and use parent.getProcId() instead of the string replace.
please retrieve all non prestarted vms and after that put them to loop or retutn a vm and not its id, there are to many queries to DB which retrieved the same information
wouldn't it be simpler to just call entry.getValue().get(0)?
small formatting issue, please be consistent with spaces between the + it should be: host + ": " + name
Looking again at the docs <LINK_0> I am still not sure if the order is now completely correct. The doc says ColumnFamilyHandle > RocksDB > DBOptions > ColumnFamilyOptions but the code does ColumnFamilyHandle > ColumnFamilyOptions > DBOptions > RocksDB due to userSpecifiedOptions. Additionally, only some are set to null afterwards, does this have a special reason?
Why do we not have the same result on Windows? We can find the file on windows but not on *ix?
Not sure if this needs overflow checking.
InsertToRealm sounds wrong somehow. InsertInRealm? or just InsertObject?
these could be Ordering.natural().immutableSortedCopy(...), it incurs fewer copies according to the Ordering docs.
why don't you use: path.length() == 0
This can throw RuntimeException
Maybe something like array_position does not support elements of complex types that contain null? In theory T can be a map or a row.
This would be better sized as 2 it seems, although that's obviously a nitpick.
Charsets.UTF_8?
We could also try to use the icon theme here, for instance the group icon.
why is this doing concatenation instead of assignment?
Remove / update the log line.
Does is make sense to move the logic of only add if not yet added into pushHeredocMarker? That would allow to remove getHeredocMarkersIndexSet and to simplify this part.
Should we assume the table exist's when we can't check for it?
please avoid returning in middle of functions.
Why doesn't this use the key and value Schemas instead of the types? I think it would make more sense to check Schema.Type instead of evaluating String equality.
isEmpty? Do you reject file name " " ? :)
static import HiveSessionProperties.getParquetWriterPageSize and HiveSessionProperties.getParquetWriterBlockSize
Sounds ok to me that the outcome matches the false return
Let's not assume that COUNT is BIGINT. (In some type systems it might be INT.) Use AggregateCall.type?
this test demonstrates the usability issue in WaitAllStrategy, we should change withStartupTimeout's return method to WaitAllStrategy. You can do it in this PR if you want :) /cc @rnorth
we don't want to log the buffer as it enables log injection
&& !keywords.isEmpty()
You already have access to the list here, why not return the first item in the list as a mono rather than wrapping it in a flux from iterable and only choosing one item from it?
Instead of having if calls for each case, can be encapsulate the each condition inside a strategy class? That way, this could would be reduced to handler.execute() where the handler is typed for each case.
Cool that we're doing this now :) If automatic model runs is not enabled, and the occurrence's location has passed QC, is_validated needs to be set to true - can we add this?
calling delete model twice here
These exceptions should be logged
Add a newline here: suggestion final ListPreference durations = (ListPreference) findPreference(getString(R.string.seek_duration_key));
Any reasons to change the <code>DisplayName</code> to the project's full name. In such cases the status info will lose the information about the build.
keep on separate lines -IDE clearly thought it was being helpful
For the case source = "$table.bar". I believe this case will pass validation, but maybe you should throw an exception.
may not be in code you touched, but I would think the getField_changes method should be renamed getFieldChanges
Risks swallowing InterruptedException. Worth doing Exceptions.propagateIfFatal(e). Do we want to log it (at debug) when it's the first time we've seen the ssh exception? No strong feelings. Certainly don't want to log it every time (unless at trace).
We can make this static.
Minor thing, here there is no need to expose this as a List object (getSources().get(1) won't mean anything), so the return type could be a Collection<IAnalysisModuleSource>
Move the defaults to the class instead of having every user call the setters.
This should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig
But if this is happen because without a reason this exception is not thrown or declared a mostly not fetched RuntimeException is thrown.
I think Java's merge() function on map handles the case where a key is not present. So I think the following code will insert the value from stats2 if stats1 did not have a value (w/o calling mergeFunc). java Long val2 = stats2.get(key); if(val2 != null) { stats1.merge(key, val2, mergeFunc); }  This also avoid calling contains() and then later get() on the map which is two lookups.
Megre both if statement into single if
Spurious TAB, use a blank.
As with ArtifactWaypoint, I'm not sure why this class is not final with a package access constructor.
Catching a Throwable is not a good idea. What's the intention here?
Possible alternative suggestion: have CramRecordReader.read return the new alignment start.
Joao, you are not sure that selection is a IStructuredSelection here, the first if test could return false becauseof the selection type. Please review the entire if block: if (sel instanceof IStruc..ion) { if (size ==1) { ... } else if (size > 1) { ... } }
use getPlayersInRange(source.getControllerId()) to get a list of players that is not the controller who can interact with the ability.
Seeing that you have used <S> for state, for consistency, I think we should change the OperatorState to have <S> rather than <I>, which is what it is right now.
That's the method I was talking about. Probably we can simplify all of these by adding a method in NamespaceAwareVisitor. To me it's quite strange to see everywhere the same chained calls, while we could have only one method:  void reportIssue(Tree tree, String message) { context().newIssue(this, tree, message); }
I would suggest we make the sync version call the async version and block on the callback. This reduces duplicated code, and also doesn't serialize the calls, which isn't really what we want.
Can you remove whitespace before the parenthesis. Same below.
Any point logging here as for the StreamWorkManager?
the logic in testAckBeforeSync and testAckAfterSync does sounds good to me. I think for: - for testAckBeforeSync, you need to ensure callback come before sync and eventually sync will still advance the file and the log marker - for testAckAfterSync, you need to ensure callback come back only after sync and the log markers are advanced after that. One solution for this: - you need to be able to control force write thread, e.g. suspend forcewrite thread and make sure callbacks can trigger even forcewrite thread is suspended and verify the forcewrite request enqueued to forcewrite queue contains null items.
nit: while this follows the above, normal usage is e instead of ex, including in other places in this PR.
Let's try to decouple the UI concerns and the actual link shortening. Now the link creation is asynchronous. Ideally we should have a Listener with a possible method onDynamicLinkReady(String url). Listener's method would be called with the shortened link when it is successful. Then the place where we implement this Listener can handle progress show/dismiss. What do you think?
camel casing
nit: Druid format convention is like  1000, null,
Can be simplified with Providers.of(backupRegistry);
hard delete needs fixing. Token might become invalid is the indexes were compacted where the hard delete token was present.
Same here re: flatMap
The assumption here is that the implementation class of the Map (LinkedHashMap in this case) will take care of the serialization. However, when reading the string from the DB and converting it into string, the parsing is done manually. I think we should use the same semantics as specParams uses (line 46) to store and to read (line 146). In that way we won't rely on LinkedHashMap expected format if changes.
Can you use Number instead of integer here and below? So, you'd check if it is an instance of Number and then cast it to a number and use Number's intValue() function to convert it to an int.
if you have a prestatement visitor, why having this check before ?
would be more readable if entity was called authEntity or such. similarly for the other isAllowed() method
Could this (RuleConfigParam) be passed as parameter of HostProcess instead? (It would be easier to use custom configurations per scan, for example, through an advanced tab in Active Scan dialogue.)
no need for this
Missing final
Rather than deleting the previous entity, why not just remove the next part on recreating the same entity? Since nothing about fs was actually modified.
The recipients and signature fields aren't checked.
Ideally this lock should be followed by a try finally, in case something goes wrong.
id is null when calling from the web layer, so it will result in an unhandled NPE please find an alternative value, eg: user id
These days we have more robust test helpers like BindingAssertionHelper which avoid having to count names and update counts if the testcase changes. There's no need to change this now, just something to keep in mind for the future.
System.out?????? use a Logger.getLogger(). then trace.. look at how trace is done in other places.
Wouldn't this alter the item that is passed in? That could potentially break plugins.
I see this hardcoded strings in 3 places so far and in 2 different files. Can we define them as constants?
Print the tenant id in the log. Otherwise we can not figure out to which tenant this error is belonged
These are opened and never closed, using try-with-resources would fix that, although it's a bit awkward since InfiniumGTCFile itself is not AutoCloseable.
spaces around if/catch (we really should have checkstyle running in travis rather than manually reviewing for style errors).
replace "roles" with IPentahoSession.SESSION_ROLES
nit: rename to combineClosables/groupClosables and static import
How about setting the log level?
Log error before callback.onError?
Consistency with other methods: dataseManufacturer is used in other methods, suggestion to use here: databaseManufacturer
Should not we detect that the cache is full before continuing to read? Do we end up reading the lines for rowVal twice?
Would it be useful to see these log statements in production env.?
This expression is repeated in both if and else branches.Why not extract it before the if and reuse in both branches?
nit: redundant local variable. I'm okay with it, but IntelliJ complains :-)
This is quite unclear why the "if" is here. I imagine it's because the CreateExcelAnalyzer is still using a java.io.File? If so then construct the if around that fact so that it's clear: if (analyzer.getComponentClass() == CreateExcelAnalyzer.class) { ...
final #WontFix
Is it correct to catch and "swallow" the InterruptedException (and below as well)?
I guess facet should never be null. is that right?
We should think in refactoring a bit this to add a "Thumbnail" resource in owncloud-library, but maybe we should merge this first. On the while, some low level details: - Uri.encode(file.getRemotePath(), "/") does the same job than URLEncoder.encode(file.getRemotePath(), "UTF-8").replaceAll("%2F", "/"), but shorter. - Instead of hardcoding 100 x 100, define constants like THUMB_WIDTH, THUMB_HEIGHT ; or even better, we can try to request the lowest resolution appropiate to get 32dp thumbnails, depending on the screen density.
This condition is not correct from what I see. When build is null, the result will be always empty. E.g. getUsersAsSet()  will be always returning empty list after the change
Is "this" necessary?
The second argument here is the name of calling function, so it should be "Start", not "AudioRecord".
so instead of "using", we can say .withInitialConfig(CompositeConfig.builder().withConfigName("helloworld").withApplicationOverrides(...)) I haven't fully thought through how we can add this CompositeConfig to the layered hierarchy yet. But ultimately, I really think the relationship between Karyon and Configuration is composition instead of inheritance.
Like NMFREEF, let's import MLRParameters statically by adding import static edu.snu.cay.dolphin.async.mlapps.nmf.NMFParameters.*;
Do we need to do this every time we start the manager or is a one time thing. Does indexing a new record not index correctly? Would this break on the next index update?
Only one final? Or should we make all final?
You are only creating this list so you can later iterate over it, why not just iterate over the stream directly?
Suggest changing to  if (ess.getSettings().broadcastAfkMessage()) ess.broadcastMessage()... user.sendMessage()
This can be simplified return "<html><title>Google</title></html>";.
btw why not rename SyncManager to SyncService?
Might as well work with a RealVector instead of a matrix starting from this line.
Division by zero
Is this path always this way for all kubernetes users? Is default ever something else for example?
shouldn't this be done when a new volume is detected - i.e in the createVolume() flow?
Are these two different buttons that alternate?
it might be more efficient (or atleast clear) if, in activate(..) you parse the params out into a Map using [1] Map<String, String> rewrites = ParameterUtil.toMap(urlRewrites, ":"); And in this you just check the parsed map values? [1] <LINK_0>
You can do method chaining here also? java recipientToRecipientStats.computeIfAbsent(...) .addResponseToRecipientStats(response);
Add checkState(type instanceof UnknownType)
We always use {} blocks even for very short conditions: if (id != null) { ids.add(String.valueOf(id)); } However I'd keep the cast (String) id instead of String.valueOf(id) as the key should already have been turned into a String by lower layers, and I don't want to hide an unexpected change in behavior by doing String.valueOf
check finals
exception, so STDERR
I'm not sure if this is required. I think the caller should be shutting down and not the start() method. Not sure if this is huge change.
IGN? In-Game Name? If so and if it needs to be short I suppose that's alright :-)
That's why ConcurrentHashMap made it work (it internally synchronizes on its instance)
Split this line ?
What if getEnv returns null?
minor: bloomFile
could pass in mode too when finding by path
You should use SpliceSpark.getSession() here
For experiments that don't have an experiment type associated with should have the generic experiment type set automatically. This will make the upgrade for users that have already experiments seamless.
Should there be an assertion that the iterator actually returns something?
use slf4j string interp
I think both of these should stay non-final since it's possible to provide more efficient implementations in subclasses.
I don't get why the chosen name should be different between this case and the one above (when schema == null). Does that matter ?
Is it worth testing what happens if you try to deploy a Data Source that does not exist?
this is now never null.
what if there is no first ?
It's hard to read the long if statement. You could use _shouldRefreshCache.orElse(false)
Can be written as !Double.isInfinite(doubleValue)
nit: I'd suggest we have a separate recycle() function rather than piggy-backing on close with additional flag, since the clean is always true, i.e. we would always just 1) write checkpoints, 2) call stateMgr.recycle(), 3) then transit to CLOSED and if it is not in CREATED / RUNNING then do nothing. Though it has some duplicated lines but it is a bit straight-forward.
I think that a single (warn) message should still be emitted. something like: "there are intervals that are failing to liftOver, but logFailedIntervals is false. To see what intervals have failed, re-run with logFailedIntervals=true."
not supported yet
you should be able to replace DbFacade.getInstance() with getDbFacadeInstance()
bundleKey or bundleExternalKey (no space).
Use CommonHelper.assertNotNull
Nit: more compact alternative.  int i = s.length() - 1; while (i >= 0 && Character.isWhitespace(s.charAt(i))) { i --; } return s.substring(0, i + 1);  Similar for treamLeading.
Why do filters need access to the results of previous filters? Is it so that we can skip call screening if something else blocks the call?
Add the new queries at the end of the cleanup run?
@fabriciofx Let's use Text matchers from cactoos-macthers to assert Text implementations
What is the purpose of this override? It seems to just call super.
Much as I prefer !isEmpty over size() > 0, the latter is used everywhere else in this method, so switch to that?
use Math.toIntExact(index) instead of a cast (int) index.
Is it possible for this vmGroupMapping to be null? Looking at the code this seems an impossible case.
Remove empty line
What kind of operation would throw IllegalArgumentException? I'd usually expect a 4xx for bad input.
this map is not required to build rulesByDbDeprecatedKey. Loop at line 220 can easily be changed to work directly with the Set<SingleDeprecatedRuleKey>
The write lock should be locked ahead of line 67 (before getReplicaIdsByState() is called). Otherwise there is a race condition to miss remote leadership change.
Logging could be improved here to use parameterized messages <LINK_0>
This code is the same in multiple classes. It would be great to reduce the code duplication.
remove
This normally shouldn't happen. So could some log.warning be done?
Shouldn't we also update super.latestAsyncCheckpointStartDelayNanos?
I'd prefer an alert instead of a toast. The later can be easily missed. Great job!
Use !isEmpty() check
Same deal as with FileSender.
So, we write the bloom filters into the row-group. It means we have to seek to the row-group and read from them even if the whole row-group could be dropped based on the bloom filter. Because of the similar issue we decided to the put the column indexes after all row-groups (just before the footer). I don't know if it would be feasible/beneficial for bloom filters as well.
if you return here, you don't need to the keepWaiting boolean.
why not set javahome property for all launches to be explicit ?
I think we can ignore codacy on this one going forward as it's possible to merge even when it's complaining. Perhaps we could even configure codacy to ignore it.
There's a MediaStreamImpl#getRTCPTerminationStrategy() method which amounts to rtcpTransformEngineWrapper.getWrapped(). Why not use it here and in the method setRTCPTerminationStrategy and, thus, simplify the source code for the reader?
incomplete
invalidate() acquires locks, and I'd rather not block while holding the shared topology lock. Ideally I'd like only dataContainer.compute() to be done while holding that lock.
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "execute" is 14 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_1>
Make a static logger
This is no correct anymore. It should be 2, 3, 4, 5 now.
compute can remove entries, too.
I would change the variable name. monthBefore is missleading. It should be something like nextMonth.
Log the exception here
The check should be done in the SSLConfig.Builder.
Can the executor be user provided? (e.g. ICompletableFuture.andThen user can provide the executor) User executor returning this exception may not always mean that the client is being shutdown, does it?
Just curious, not a problem, but why set sysNameList to null before setting it via the map operation?
How can you confirm that these two objects are unretired objects and no more retired objects in this list?
y+1 <- Yeah... Nup. Squashing such things simply hurts my eyes
Connecting an already shutdown runtime is not a good idea. Probably we should add a check to avoid that (Not in this PR). Just create a new runtime.
This message is shown to user as well as position of the error. User needs to know what to do with this. 'likeString' is not a commonly known term :)
Some useless white spaces here.
Looks good!
nit: if statements could be combined to reduce indentation
When you remove this key (Pair) it clears out all data from that row in the underlying table. So when you try to add back the List<ITimeEvent> as a new row with a new key (Pair), it adds nothing because column.entrySet() is always empty.
As we have discussed, we sould have the response/resquest rule here also. I am unsure wrt to the use of .appendSuper(super.equals(other)), I'd favor a short note of @buehner here.
Consider using LambdaValidator to be able to add a lambda for the toString method of this validator.
This is not needed, please leave the code "as is". null is never instanceof of anything.
The local variable *ListData* should be renamed to *listData* as per local variable naming conventions.
Is it intentional to remove synchronized here?
need to set timestamp
I suggest passing all of the variables we access in this constructor viaSustainedConnectionWorker.this.spec to be switched to parameters we pass upon instantiation
KuraErrorCode.CONFIGURATION_SNAPSHOT_NOT_FOUND in my opinion
you don't need to make this a List, just set it to the double[].
Wouldn't be good to use the return value of ISet#add instead of calling ISet#contains + ISet#add ?
@adavid9 can you please add throws IOException and replace original catch (Exception) with following:  catch (IOException e) { throw new ArtifactStorageException("Unable to undelete trash for storage " + storageId + " in repository " + repositoryId, e); }
Were we using this IS_FWD_PARAM for anything other than the backend publishing?
This produces findbug warning: > 06:13:08 [INFO] Sequence of calls to java.util.concurrent.ConcurrentHashMap may not be atomic in org.jboss.weld.bootstrap.SpecializationAndEnablementRegistry$BeansSpecializedByBean.apply(Bean) ["org.jboss.weld.bootstrap.SpecializationAndEnablementRegistry$BeansSpecializedByBean"] At SpecializationAndEnablementRegistry.java:[lines 79-115] I think this should work:  AtomicLong value = specializedBeansMap.get(specializedBean); if (value == null) { value = new AtomicLong(1); AtomicLong previous = specializedBeansMap.putIfAbsent(specializedBean, value); if (previous != null) { value = previous; } } value.incrementAndGet();
couldn't the execute(HttpHost host, HttpRequest req) method be used here? Or is the default context somehow breaking things?
No null check for zone?
shouldn't we throw the SQLException? or at least log it
Maybe would be good to talk to RedDeer people about making org.jboss.reddeer.eclipse.wst.server.ui.view.Server.ServerStateCondition public as this abstract is just copy-paste of that private class.
investigating....
Shall we fail here since we don't expect exception?
Why do you search for the same path twice? Is it a test case to validate the results won't be merged?
This will never be true, since we just checked that node is instanceof IASTDeclarationStatement above.
Did this have any effect? Don't we want to shut down the bus _after_ we disconnect from the cluster? By shutting down the change bus first, might we not lose some events that are sent by other members of the cluster?
Is this test useful? I don't think so...
Would it be possible to just include/set the hostname when we construct the health object instead of setting it over here? I feel like it is more bug prone to have the object mostly immutable but then have a single field be able to be set like this. If there is good reason it's fine to keep it
Should this be an info log? It feels like a debug log to me.
This is used a few times, could benefit from being a const or defined in the set up. Depends if its necessary
The same here as in updateUploading()
same instance on both cases
prefer a local variable as this method could be called many times because the LabelAndIconRefresher is created for each AbstractNotSelectableShapeNodeEditPart
We should support depth and FileVisitOptions.
Why was it necessary to move the JS from resources/org/jenkinsci/plugins/p4/console/P4ConsoleNote/script.js into the generated html?
I think this is something wrong for this component contract. We can't constantly poll from the source until null. The point of the receive() is to get file or nothing.
checking same condition twice
Why are you clearing their inventory? I dont remember that ever being a thing...
This wrapping is hard to read since the ifPresent() is part of the lambda above. I'd write it like java new HiveFileIterator(path, fileSystem, directoryLister, namenodeStats, FAIL).forEachRemaining(file -> splitFactory.createInternalHiveSplit(file, getVirtualBucket(bucketCount, file.getPath())) .ifPresent(splitList::add));
Maybe use List interface?
Maybe also test a repeated key? Should Just Work.
Gotcha. And we don't want to create the table when the worker is run the first time, probably because we don't have any mechanism for that?
Can't the whole test be boiled down to: if (longLineCnt > (longLinesThreshold * nonEmptyCnt) / 100) { This will also work when threshold is 0.
Just a thought. Can you please extract out the common portions of on<Actions> although I don't see any gain apart from the code size reduction. Same for the window displaying functions also.
Shouldn't we be revert everything and throw an exception since it failed to update the Carbon Profile? Why are we logging it and carrying forward?
All possible paths must be in the index, not just the first path.
a call to license validation is required after to fail the nomad prepare phase if needed since we cannot rely only on client-side validation. TopologyService.getLicense().ifPresent(l -> LicenseService.validate(l, updated))
No reason to delete files: TemporaryFolder Rule takes care of that.
Can we include some of the agent details in the log message when this happens? i.e. What agent was affected?
I was told all resources have to be closed. connection is a resource, so I miss try/finally/close around it.
Maybe a shorter way to write these inputs is: byte[] input = asBytes("1\n\r2\n\r3"); private static byte[] asBytes(String in) { return in.getBytes("UTF-8"); }
Same as above, no need to re-add the product here. The one you've edited is the same that the pool already has a reference to.
If the default is null, you may use caughtTypes.get("BaseException")
(nit) reformat (or just put 3600)
It doesn't make sense to have a null value here. We should fail with a null key or value
r.getString("category") doesn't have to be in the try/cactch
don't need a thread for this since it is a one store shutdown
This is a blocking call.
setParent is missing? is this good or bad?
I am currently trying to remove CoreRegistry usage. The AssetManager can also be obtained via depenendcy injection. e.g. by adding a private AssetManager field with an @In annotation. The registration can be done after #1721 is merged by obtaining a Context instance via dependency injection. It offers a put method like CoreRegistry. Although I find a bit strange of a location for registering objects.
Please remove this line
I think you actually need to count the number of matches: Integer.bitCount(format.roleFlags & parameters.preferredRoleFlags)
Could you make this derivativeTmpPath? I seem to be having a hard time following which paths are landing in which variables since everything is derivatives.
Should be extracted to its own method I think.
Logging should be done where the exception is catched rather than where it's thrown. The message is already in the exception
Add the reason for dropping message?
Put content in 1 line as many as possible.
Should have an assert or some check that remoteTools is found.
what is the need for a postfix here?
The default value should be false for barrierConsumedChannels, otherwise it seems inconsistent with the variable semantic. Only after task processing the barrier from respective channel, it should be set true.
how does this test work?
It might help prove out the contract if a line was drawn here between the relying party, the request, and the final Saml2AuthenticationRequest instance. For example, I'd probably do authnRequest.getDestination() instead of relyingParty.getIdpWebSsoUrl().
>Object [](start = 14, length = 6) why not using string? #Resolved
Awesome :-)
Need this? Don't we have enough spew in log already around assign?
Just a minor thing that these objects can be moved into line 125.
I think if you inflate with the attach parameter set to true, you won't need this line (here and elsewhere).
debug statement?
Node with idx = GRID_CNT - 2 is also a client node.
Can use Map<String, ?> flags = ImmutableMap.of("name", "Controller targets tracker");
we know scope here because of if statement, so no need to concat scope variable with slash
just create a keep list using new ArrayList<>(fieldsToKeep)
stream must be closed with resource at the time it is created.
Let's use if (GenericUtils.isNotEmpty(headers) && headers.contains(...)) just in case *null* is passed
Lets add the cnf folder to the tableViewer so we may need to add more than just bndWorkspace.getAllProjects() since that doesn't include the cnf project.
Could we please do this as a single query for all patches within this patch set that this user has reviewed, and then do a hash join here in Java? When the patch set contains 1000+ files, this is 1000+ queries against the database, which really blows performance wise.
this method can be written better. We should check only ProgramEnrollment created by task action. Verify if all fields are filled correctly. Check also if programEnrollmentList has 2 objects
nit: make this a string constant somewhere and use it at both of the logging sites
Huh. Why would this be null? Isn't it just in the activity layout?
I think this close is redundant since assertExpectedNumberOfVariants closes the iterator, and the other call sites don't manually close it. Having said that, I think the tests would be much easier to read if they used a try-with-resources at the call sites, and asserted the count in a finally block.
what about segments that partially overlap the interval ? earlier they were also being returned as usedSegments, I think we need to preserve that behaviour.
Add a util method boolean isSingleTopic(ReadableConfig). It can also be used in sink side.
1970
Similar approach here, maybe create a function to do this test.
why is this exception ignored? (except for a log message)
it seems that we should check this in resourceSetChanged
You could use Preconditions.checkPositive(int,String) method in the same way as it's used below. It does logically the same thing as this conditional statement.
This probably won't work as expected. you do not know the rest of the where condition in here.
Externalize log
you need check rc first. if rc is not OK, then fail ReadCallback. Otherwise do the logic to read actual entry.
Extract name.toLowerCase() as a local variable?
Only spawn items serverside, this creates clientside entityitems
So how is doing getItems().add(item) going to work in this scenario? it obviously won't be added to the positions map.
Can't we safely throw a RNFE on every 404, without checking the method and path?
Free?
I guess that the project state could be moved as constant to the client lib (we currently have lots of places where we use a "Running" to check for pod (and other resources) state)?
how about check whether the type of a field is comparable in shouldPushDownUnaryExpression method ? then the logic of binaryFilterApplies need not to change
I don't believe this is necessary - we'll never get a delivery after a cancel or cancelOk, but I suppose it doesn't hurt, except for the (small) overhead.
this does not make sense, you are doing a write and locking on read ?
* The check should be on storage domain. * So the change in Ie50e7dd9 is no longer relevant?
wrap super.close() with a try/finally so the channel is always diconnected
I think this check will never be true, therefore it's not required.
please keep one var per line.
DatabaseUtils.makePlaceholders(1) should be replaced by the literal ? in the string.
Use Ds3DocSpecEmptyImpl
![MAJOR](<LINK_2> At most one statement is allowed per line, but 2 statements were found on this line. [![rule](<LINK_4>](<LINK_0> ![MINOR](<LINK_3> Missing curly brace. [![rule](<LINK_4>](<LINK_1>
might be better to say CompactionTask.TYPE.equals(status.getType()) to remove reference to literal and to cover for the case when status.getType() is null for any reason.
So every time this is called, we will shuffle the tasks and have a completely different assignment mapping?
Could you rework this code to not use SWT. Even if this code is in an UI bundle, it will one day, I'm sure be used/moved outside of an UI bundle. Just copy/paste the value of those three SWT constants.
As you say, does Oracle or H2 have to do this? For the DummyXAResourceRecovery I can see that is likely a requirement
blockX, blockY, blockZ
I'm a bit confused what's going on with this API. We first wait on the aggregate future and then we wrap it in another future. That seems wrong, right? The call to all() shouldn't itself block.
I'd argue that  java import static pl.allegro.tech.hermes.integration.test.HermesAssertions.assertThat; assertThat(publisher.publish(topic.getQualifiedName(), avroUser.asBytes()).hasStatus(CREATED);  would be more verbose and clear at this stage than having it tested inside the publisher.
Assertions has a method to handle collection size. Use that, test fail messages will be much nicer.
Why executing so late? Shouldn't we execute that as soon as possible after Backend?
Why introduce ra = cp?
Why not map this and then collect it as a list?
Would you please invert this if as well?
objects instead of values here too if you are doing in the provider
Seems only one test is failing, We can first convert the key to Path and then use getPath instead of getRawPath in URIBuilder. Something like this worked for me - suggestion Path p = new Path(key); URI unEncodedURI = p.toUri(); return new URIBuilder().setPath(unEncodedURI.getPath()) .setScheme(unEncodedURI.getScheme()).build();  Give a try, if this works, if everything comes out to be safe post your testing.
Does not compile on Neon, prefer: autoScaleDiagramCheckBox.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent event) { autoScaleDiagram = autoScaleDiagramCheckBox.getSelection(); } });
Again you're concatenating strings instead of using the API as provided. How about java final Path confPath = Paths.get("target", "test-classes", "hbase-site.xml");
What happens if the Folder plugin is not installed and the class is not available?
Have you merged master? I thought I fixed this to include the exception in the message... I might've just not pushed it yet, but let's make sure that we have the exception in the alert. That is, please make the edit here and if I haven't pushed, I'll deal with the conflict if it creates one.
I was assuming a different syntax for this:  values("id", "name") .row(k(1), k("ana")) .row(k(2), k("fred")) .row(k(3), k("manuel")) .row(k(4), k("rita"));  Does it make sense? Or is it trickier to use?
Maybe we can be a little more conservative and avoid creating the new type TimestampedSerializedKeyValueStore, and therefore avoid changing the decorators at all. I'd like to avoid any reasonable possibility of users encountering the new methods. suggestion final StateStore stateStore = context.getStateStore(queryableName); try { store = ((WrappedStateStore<MeteredTimestampedKeyValueStore<K, V>, K, V>) stateStore).wrapped(); } catch (final ClassCastException e) { throw new IllegalStateException("Unexpected store type: " + stateStore.getClass() + " for store: " + queryableName, e); }  Note, I know this is an awkward hack, but the whole state store hierarchy is a mess, which will take some work to clean up. Until then, I'm personally comfortable saying that internally we can depend on always having a single layer of wrapper over the MeteredTimestamped store and just unwrapping it to get access to the new methods. The advantage is that we really minimize the surface area we have to change to implement this feature (and therefore minimize building a lot more on top of the mess we already have). The risk is small: we don't get compiler checking, but any/all of our tests would fail if we broke this assumption.
Why is this public, when ExponentialMovingAverageRate's is private ?
I don't think the Intent can be null in the normal course of things, so this check is not needed.
This logic is not same as per branch-2 patches. What is different here? why?
not just the size, but also the contents of the list can be useful.
shouldn't this be return totalExternalAccounts > 0?
Is the coupon automatically redeemed? Or should it be applied to the subscription explicitly?
Would be better to not turn off, this affects all tests.
remove setting location
Looks like the specific instrumentation method that ClassPathAgent uses can be used with Java 8 and below. Why not just use that there?
Will create a constant with a meaningful string.
Code style: just wording, "Completed" sounds a little bit misleading, imo "Retry Limit Exceeded" would be easier to understand from the logs.
I would have liked to see another file to get another value for cognitive complexity here, showing that it is now indeed computed on whole file/project and not only at functions level anymore
I don't think this is correct. The explain interface wants to explain _only_ this entity projection. The getQueryText function is returning everything to date that has happened with this projection.
I'd replace that by just !invert.
Should this method be final?
We should log this exception. It is OK to continue, just make sure the error goes into the log.
This is not a good assertion, it should instead check that the count you get back when you call getOrderTypes(true) has increased by 1 and that the new item has an orderTypeId
all single characters can be represented as ','. Might make it slightly easier to read.
Also here we can print some warning message or something for us to know its not yet persisted.
Please use the closeQuietly methods at DbUtils
Please remove the same set on 1065.
suggestion if (!chatChannelUser.getAvatar().isEmpty()) { return; }
We still need to pass the blockchainState here so the notification will be updated with the sync state.
I think you would also need to teleport the passenger after dismounting, no?
here, you should add some assertions. I would set a variable to the result of saveUserLocation, then assert that an ID and a UUID are assigned.
Instead of creating a GridLayout here, use a GridLayoutFactory at the end of the method.
I was thinking of keeping it, just making it less verbose.
This results in a rather ugly label - I would reduce it to product.getName()only. For the address, you can use 'DiscoveryResultBuilder.withRepresentationProperty()' - this makes sure, that the address is also shown to the user as an identification.
static import max (similarly to min in this class)
Please remove the done boolean as explained above.
I would just close the if and don't use the else --> way too much code for an else branch. I think, using the if as guard here is OK.
Need to revise to trace() for the final version.
We are to ensure all other attributes from both sources are still here.
This should use getIndexId()
merge with the previous line
Might be ok to assume the tuple elements are not null.
It seems not to be a good idea to open the same file for reading and writing at the same time. If you move the output stream back down, it should work. You can add another try-with-resources, there.
Should this class and its methods be package-private instead of public?
This doesn't appear to be working -- that is I have stuff that I can resolve in an editor, bvut I'm not seeing an icon.
There is one more place we check emittedEventDao.hasBeenEmittedBefore(event);  <LINK_0>
This won't get called in situations where System.exit() succeeds. <LINK_1>
So we are adding a new top-level element to ejb3 subsystem configuration. How is the version and namespace evolved? Do we need to bump it from 5.0 to 6.0, or to 5.1, or remain the same? Since 5.0 is already in WF 16, I guess we cannot modify a released namespace.
why do we need to check bound here? wouldn't min be null if we only ask for maxtime?
put a <code>list.size()</code> into a variable, before the for statment, its best for perfomance
I'm curious how we decided that 1h is the recommended value for monitor interval, and why a smaller value, say, 30min can cause pressure on metastore?
export LD_LIBRARY_PATH= doesn't seem to be necessary with my distribution of bitcoind. Also, config.bitcoinPath seems to expect to be pointed to the bin sub-directory of bitcoin-core's home (the one that contains the bitcoind executable). That's a bit unexpected. I think it's more intuitive for it to point to the executable directly, or alternatively to bitcoin-core's home directory.
Why move this before clearAllErrors()? The tracking call should probably be performed at the end.
TissueOriginImpl.UNSAVED_ID if we're being pedantic.
what happens if a task finishes in this block of code?
Since you intend to resolve the property by its name, you should be aligned between this value to the property name as defined in the enum itself, The resolution of the enum is done by "ConfigValues.valueof(enumName). If the name doesn't match, an exception will be thrown. By setting the ConfigValues.AsyncTaskPollingRate.toString() with the toString() - you're at some risk since this method can be overridden, however, by using the final method ConfigValues.AsyncTaskPollingRate.name() code is safer. Please replace the toString() with name() around this patch.
typo: Unsupported pool type...
You can skip this peek and add requireNonNull(columnType, "columnType is null"); in createColumnStatisticsForEmptyPartition instead
I think that this condition is not sufficient. We end up creating an ambiguous symbol in the following case and I suppose we should not:  x = 42 x = 43
Check for null - someone might be calling createChannel() while someone else is calling destroy().
newStory
I think this may have been White for a reason...
possibly add this for safety to prevent an infinite loop, wasn't sure about adding it in the while loop condition as he may want it for the first exception, and do-while wouldn't help for the same reason, also not sure if this is a valid case, but safety won't hurt here ? suggestion } if (e == e.getCause()) { break; }
it's more readable to just close it - especially when using Java7 try-with-resources.
rename to launch
This kills the app. No seriously, keeping a reference to the activity as the context is a bad thing. Use getApplicationContext to make sure you dont get Activity leaks (not very friendly for you memory usage). Also, if you need to make the entire Context static, I'd say you need to rework the design, because it's simply something you dont want static. I'm all for making code more readable, but not by making the application suck up memory and unfriendly for testing.
sysout
if Deprecated, do we wanna just not add it ?
FWIW, in case you were unaware, OutputSettings supports the builder/fluent idiom so you could chain these calls without referring to a local variable over and over. In fact, I suspect you never have to call the setter, you can likely just do doc.outputSettings().charset(CHARSET).escapeMode(EscapeMode.xhtml) ... but, it's a subjective matter of taste. I literally just mention it in case you didn't realize it. I like the terseness of it but I'm not sure I believe it's more clear or easier to read/maintain ... although the wikipedia page claims it does.
ts -> typeSpec
One minor nit, would you mind add check for other distinct functions? coz we don't support SUM DISTINCT yet.
will this always split after first comma (or at index 70), also for commas e.g. in version ranges ? I was thinking maybe to reuse ManifestElement.parseHeader() instead of this low-level (potentially error-prone) MANIFEST parsing. Then we could fill up to n elements until total length > 70 and render n-1 elements using ManifestElement.toString() into one line. Wdyt?
Rather than directly accessing these instance variables from the metrics class, it would be clearer if you have a method such as: reportHourlyRunnerStartTime(String topic, String hour, long startTime)
Should this catch the more generic Exception instead? If there's any kind of exception thrown from the plugin, it won't be caught here. Also, GoPluginFrameworkException might not mean no support for this operation. It might mean the plugin ID is wrong or other framework-level issues, right? I wonder how this can know whether load-settings is not supported.
This is nitpicky, but c is not a very readable name.
You need to change the text on the effect because you're changing the filter text
setErrorMessage
Add a class like GerritEventKeys to gerrit-events then use it.
Need a default case?
Use FragmentUtils:isFragmentUIActive
One general question that is not in your code change. Why do we use nanoseconds instead of milliseconds here?
You have this same line in every case. How about moving it after the switch.
Since you now have access to the page.listKeys() property here, maybe you could add a check to update the delete button label to name the specific list the page is contained in per the spec, if page.listKeys().length() === 1? Fine to kick this down the road to a follow-up patch.
instead of replacing, can you escape the quotes?
nit: rename this variable to filteredChildren
Maybe: private static <T> List<T> extractList(Map<String, Object> xmlRpcStruct, String propertyName, boolean returnNullOnEmpty) { Object[] items = (Object[]) xmlRpcStruct.get(propertyName); if (items != null && items.length != 0) { return Arrays.stream(items).map(item -> (T) item).collect(Collectors.toList()); } return returnNullOnEmpty ? null : Collections.emptyList(); }
concepts are cached, so it's not a big deal if the conceptconnector is called twice.
Arrays.asList?
This assumes that the order of your expectedLanguage is the same as actualLanguageList. What if they returned "es", "en" rather than "en", "es"? Your test would fail.
And this one too.
Hmmm, this changes the semantic of what we do significantly as we now replace every occurrence in the query. There's no risk at doing that?
Why do you need this? Is this the case when cluster is down and cant get connection? Also should this be only when auto connect is enabled?
Any tests to show the interaction of the 2 holiday calendars?
Seems a little repetitive wrt. the method above.
this needs an assertion that the operation was retried
- How about replace the other fields (i.e. domain, path)? They can also have variables. - Does it really need to create new cookies? (It could use the setters.)
Why does this need getCallerModuleLoader? I realize the previous code was doing this, but there are better ways to obtain a module loader. (getClallerModuleLoader use stack crawling which is quite slow)
Is it possible that this query will still return more than one broadcast? If so, is there a way to be sure that we're getting the intended liveChatId? For example, if there's no videoId specified, would it make sense to only retrieve the authorized channel's persistent, active broadcast? (Though, to be honest, I'm not sure if there's only one of those.)
Fix cyclomatic complexity sonar issue
This should use a StringBuilder.
forgot something?
conditions -> breakpointConfiguration
Dont you need to check for exceptions here too.
I would expect the compiler to optimise it but still, how about moving this line after the check below so it would be more clear that this field is not used if the VM has no custom compatibility version?
The isEmpty() test is redundant. You can just call itemsToRemove.forEach(item -> thir.remove(item))) directly without testing for emptiness. If it's empty no item will be removed in the forEach, which is ok.
Can you rename any local vars that have used NS - otherwise could get confusing.
This is a long lambda; would it make openEventStream() easier to read if it was granted private-method status?
Would it be better to use explicit values instead of random? For example, we know all the corner cases would be around bits being split across read boundaries. We can then programmatically generate all the splits. Given this is a fundamental change, I'd feel more comfortable with exhaustive testing on all corner cases explicitly tested.
given/ execute/ assert sections.
I think we need to add first theMonitor.begin("Refreshing", 1);
Can be simply replaced by:  OrganizationDto organization1 = db.organizations().insert();
Add newline before return.
Enclosing the IPv6 address in [] is not needed with the URI constructor you use at L248. OTOH, NetworkUtils.formatPossibleIpv6Address() does more than just add the [], it also does the whole canonize thing, so calling it seems ok. But, either way this and RemoteDomainConnection.call should be handled consistently.
Maybe remove the first 2 :?
If it's null it's invalid? If it's null, shouldn't it be valid (and default to 1 basically)?
can be done on 1 line
I would choose another name for the property name, the term version being probably widely used in existing databases. Ideally it would be configurable by the user.
Instead of checking a concrete class ConsString that's tied to Rhino implementation, check a common class instead: if ( source instanceof CharSequence)
why is the overlapsInterval part needed in the filter? won't that always be true due to the query?
I know it's a PITA but I really think InterruptedException should be dealt with specially here to reset the interrupted status.
Add final keyword.
final?
there should be added a break;
Could you update this to also add a Logger.warn statement if we ever do this? I want to work through updating these flows. Thanks!
- Did you checked if return value of this method is used in calling methods? - Did you checked if previous thrown exception is handled in calling methods?
Is this the same as System.currentTime in milliseconds?
@tarun0 why don't you use this <LINK_0>
reformat code
This needs to be mapping.getTargetAnnotationValue() instead of mapping.getSourceAnnotationValue(). This property is actually not used in Java 8, but it is used correctly under Java 9, and not because of us, but because it was correctly implemented in the JDK only then.
Interface appended to variable name
nit: empty -> null here and in other places
discarded non null all the time. You must use !isEmpty() or ignore it here.
I am concerned about this synchronized code piece, since this will be called on every request. My concern is this will slow down things. Do we need synchronized block here even though credential is volatile now ?
don't really like the "continue" keyword but why not. But can you use brackets, I'm not sure it is 100% true but we prefer to not have if without them
I personally would prefer to use a dedicated type for the return value. Fiddling with multi-dimensional arrays makes the code unreadable and unmaintainable, from very beginning.
superInjectionTarget.injectionMap.isEmpty() always false
setted is typo
Is 30 correct here?
Actually this prevents passing durable=false to any binder, including Rabbit.
you shouldn't need .toString() here...
P3: "Jenkins TFS plugin" -> "TFS Plugin for Jenkins" ?
We can remove this soft assert as well as this path will definitely get hit for someone using this functionality,
Can this method be private?
Did you just mean to use LoggerRule? Or are you doing it the hard way specifically to capture agent logs?
Delete the file afterwards
Again I would prefer SystemUtils.IS_OS_MAC_OSX
Shouldn't be here null instead of String relating to the name of violation?
Should we just always cast to MutableYamlMapping without instanceof?
Is it possible for this token to be an instance that is not assignable from BaseAuthenticationToken at this point? Should its class be checked first?
You need to take into account that the default is fs, and can be omitted. So having 2 entities with one of them pointing to local-heap, would cause only 1 property with DIRECTORY_PROVIDER_SUFFIX but two backends.
redundant else
omit Assert. ?
suggestion double[] offsets = getOffsets(minRange, maxRange);  Might be a better name?
static import
As far as I remember, Stream.append is an O(n) operation, so the whole op will be O(n^2). I believe you should use two java's ArrayList objects to partition.
This would continue to attempt to lock regardless the lockAcquisitionTimeout (if any): i suppose it would be more robust if you will check the timeout anyway. There are tests that are using that timeout and I suppose it should be honored
suggestion System.out.printf("Requisition import triggered asynchronously for URL: %s\n", url);
Passing in this looks ugly.
Make this an else-if instead checking that it is a CharElement. Then add an else case that logs an error and returns some IToHex that doesn't do the conversion (like your unused InaccesibleToHex).
Maybe we should refactor it . I mean... it seems little complicated :) I mean this big stream pipeline.
This code looks chaotic. Please simplify. boolean result = verifier.verify(); boolean timeout = (System.currentTimeMillis() - start) > timeout; if (result || timeout) { if (timeout) { LOG.error() } return result; }
It is preferable to use something like : Manifest manifest = new Manifest(is); Attributes attributes = manifest.getMainAttributes(); String eeVersion = attributes.getValue("Bundle-RequiredExecutionEnvironment"); instead of a BufferedReader that reads each line...
we should add also persistCommandIfNeeded() to keep the parameters update
nit: final here. And the following variables.
Besides just checking whether the exception is thrown, is it possible for you to check the error message? This is because even with ActionFactory.java, there can be ActionMappingException thrown for different reasons. (Same for the test below)
indentation (and rest of PR)
A note here about why the exception is being swallowed and null returned would be useful to the reader.
If we want to limit maximum percent of heap to be used for the cache, it should be done in the preference page, not here.
Use a constant
What was the bug here ? Can you file it in issues and separate out from this PR ?
I do not see such test which especially covers the ZK case
This is the only usage of the RepoWalksCache and it show that we only need the RevWalk object (not the RepoWalk). Change the return type of RepoWalksCache.get to RevWalk?
final
This will be needed in all binder tests. Create a base test class for all binder tests that initializes the injector variable in a @BeforeClass method, so tests can just use it and focus on tests.
The space on the following line should be added to this append. It will be cleaned up by the trim at the end in the current code, but the space is only needed if the comma is needed.
Add here: String contributorName = "<unknown>";
![MAJOR](<LINK_0> 'Severity: MAJOR') Use "java.nio.Files#delete" here for better messages on error conditions. [![rule](<LINK_3>](<LINK_4> ![MINOR](<LINK_1> 'Severity: MINOR') Do something with the "boolean" value returned by "delete". [![rule](<LINK_3>](<LINK_2>
The idea here is to wait for at least 1 second. 2000ms is used to be safe. Is at most 2 seconds safe here?
This variable isn't being used anywhere, is this DB access requires then ?
Why did we change it on 1? It doesn't work with multiple partitions?
I think this will fail if the field is nullable. You will need to check and get the simple type. An example can be found here: <LINK_0>
Nit picking here, but why wrap all of these Exceptions in RuntimeException if the method is throwing Exception anyways?
In RW, key serializer, value serializer and transform serializer can be evolved.
The properties from the base are null even before the mapping. To show what you want I presume they need to be non null before the mapping?
The cyrillic letters should be removed from the message.
When logging, the format should be "some_message: " + ... notice the colon, and the space after that. This must be consistent, fix in all the places.
There is no need to be explicit with these type arguments. JVM can infer them so they can be omited. java Collections.emptySet()
Why wouldn't we want to be able to follow renames for a pair of files? I might be able to live with the restriction if there is a good reason for this.
This should probably also check for active proxy support and fetch the UUID if it's enabled using GlowServer.getProxySupport().
You don't really need a list here. You can just update it as context = context && node.isTypeOnly() assuming context is Boolean.
could we rename to something like isFirstPacketOfNewFrame maybe? also, if we initialize it to false we can get rid of the else block below
:scissors:
getActivity().findViewById(R.id.tabs) should work here.
Sometime, IdPs uses samlp2 and saml2 as prefixes instead of samlp and saml, we should be compatible with that fact.
Should be all instance config. Even it is not live, we will calculate the baseline with the instance config.
That's a bit unusual approach for testing data to use StringBuilder. Typically we rely on the AtomicReference. But let it be.
This is a little roundabout, right? The conditions where ids == null is where either !endpoint.equals("followers") or !endpoint.equals("friends"). Really the Preconditions should be checking _that_, and throwing a more verbose exception in the case it fails.
For now we should keep this method package visible only
do we need arraylist or an empty list ?
this if should not depend on webdav vs. dokany. windows drive letter selection should always be possible
The ones that you just moved here (from being defined as constants) don't have the line break indentations. Don't forget to add them.
Consider renaming splitedURL to splitURL
will take a look at it today
This requires that an export decoder is only used for one stream which is the current behavior of E3 but was not the original implementation so this a good limitation that should be known and maybe enforced
If two threads call update with different bytes, but the same path, there is a race condition here where they both might end up calling announce(). We can either make this thread-safe, or we can remove the delegated call to announce() if it hasn't already been announced. I'm fine with either, but this needs to be thread-safe.
I'd correct also the local variable name
We should either do this check for all updated limits or none.
Why did the name change to "GMSMember" here? It was "MemberData" which kinda made sense because GMSMemberData isa MemberData. I could see leaving it alone or maybe making it GMSMemberData.
These properties had better go into a default instance of Config implementation. SqlToConverter constructor without config should use the default config instance. this(viewExpander, validator, catalogReader, cluster, convertletTable, default_config) Move line 289-303 to the constructor with config parameter, which will has the full logic.
Setting the submit enablement should be in the method buttonsEnablement
Is the replacedSql.replaceAll needed for postgresql?
please use StringUtils.EMPTY or StringPool
JDT Core used a = b and not a=b. Use the formatter if in doubt.
I recommend keeping a reference to the client. The previous implementation appears to have omitted request management on Activity destruction but a future patch could add it
what does this false -> true change do?
This test could be a little more concise by using instance of Invocation.Builder request object in // given block and then in // when it could be just posted in one line. Then it would be possible to just iterate over all the headers from request and compare them with response if they are the same.
For better performance, check it at line 86
conditions -> breakpointConfiguration
If both multiplication operands are ints the result will be an int. If at least one of them is floating point the result will be floating point. request.getSpeedForMode returns a float, the result of the multiplication is a float, and you need an explicit cast to truncate it for storage in an integer variable. request.getMaxAccessTimeForMode returns an int though, so the result of the multiplication is an int and the cast is redundant. An IDE should show you that it's redundant. However also be aware that the operator precedence of casting is higher than multiplication or division, so here you're actually casting the output of getMaxAccessTimeForMode (which is already an int) to an int before multiplying it. If getMaxAccessTimeForMode was a method returning a floating point value, this would truncate the value before the multiplication, which would be bad.
why do we need it here
Is catch block needed after this change or is it redundant?
you meant !equals ?
Is this possible? also, whystartKey.length > 0? Maybe !=HConstants.EMPTY_START_ROW?
This stack trace, and all the other ones like it in this file, will never get printed because the fail(String) method itself will cause an exception to be thrown. Personally, I tend to just declare exceptions in the test method though I don't know what's the JGit convention here.
rm line now that it is deprecated and does nothing?
Cosmetic: Please, re-indent all these parameters according to our coding convention.
?Actually this is a bug. When *encryption* fails you're not allowed to store the value in the DB. This is not the same as decryption failure, where you can use best effort to use the cyphered value. Please make sure that on exception this will fail.
Maybe suggestion LOG.warn("Application failed unexpectedly: ", t);
No timeout?
1. Maybe rename to blobIdsAfterPut 2. Not sure if I missed anything, just wonder why this is not a concurrent list?
Can we do this outside of the try/finally that has the database ReviewDb open? That way the connection can be returned to the pool and reused for the recursive lookup of the parent. If the parent chain depth exceeds the number of connections available in the pool right now this code would freeze until the timeout, and then throw an exception. By moving the recursive get to be after the db.close() the connection can be returned to the pool and we aren't confined by the size of the pool as the maximum project recursion.
please, add NON-NLS tags
I would put them mandatory by default. I don't think you do anything about it yet, but without those events there is no analysis. Same applies to LTTng kernel analysis.
This variable should be moved closer to its first usage. (to have first to deal with return types then params)
UuidFactoryFast should be used in production. Collision risk is too high. (and this create a static binding, which should be avoided) a UuidFactory instance is available from the pico container
rather than using a pair, getConnectionInternal() could become getDataSourcePoolInternal() and then call getConnection() explicitly here (I think this is a little bit cleaner than making and unpacking a Pair)
Does it make sense to hide the not startable embedded server and keep the OSGi framework informed that the activation has been done successfully? Other services that rely on this one are activated after that. If you throw the exception so the caller of the activate method (the DS implementation) knows that there has been something wrong and will not activate services that depends on this one...
be consistent -- either all STDOUT or all logger. Please look at where this method is called from and decide whether usage indicates STDOUT or logger should be used.
Good idea to setFilterPath, but I don't think using the Platform location is the best start... Not sure what is that is accessible? Perhaps the binary file location is a good default. Another option is to save the last selected path. But not sure if that is a better option really.
i think if we go down this path, we shouldn't take in an HttpClient as an argument, and probably have the sitestreamHosts host list as a default argument.
Take a look at MultiValueMapUtils - it will save you this if statement
I would even "warn" as this is not a quite valid state, so we warn that action should be taken. Also I think the MAC would be also nice information for the log, besides interface name
I would have grouped this with the leftSide.setValue above on line 154.
You can reduce this to map("id", aUser.getUserId(), "type", USER_TYPE_VALUE ....) from CollectionUtils.map
You don't have to set the properties manually here as you call the PropertyHelper.copyProperties later - the properties have identical name, therefore, these are set automatically (then you probably won't need the setters at all)
No IT test? We can create a separate ticket for it at the very least
Can be simplified to:  e.printStackTrace(listener.error("Unable to send to address: " + address));
Notice there's another getConfig some lines below this code. Also notice that this client's execute method already uses a SphereApiConfig. Why don't we better save the config as a class field and use it in both sides?
You should ideally make these values different in case you're reading the wrong one accidentally somewhere
Any synchronous exception in this code block will cause the semaphore to leak leases, and eventually lock up. I'd suggest using a helper function that catches these, and releases the semaphore for these circumstances. * An immediate exception is thrown. * The future completes.
Could replace with addAll: allRepartitionSourceTopics.addAll(topicsInfo.repartitionSourceTopics.keySet());
The naming here makes me a bit confusing. This message is updated as NEW because it is cannot be processed right? Maybe call it MessageUpdatedAsNew or something.
No need to define it here - it is runtime exception.
Perhaps we should rename the xxxSeeAlsoDetails to xxxCrossRef to be consistent.
How do you know that the buddies collection is not empty here?
Or, assertThat(category.getAttributes(), hasEntry("Title", "The Title")) (this will print a more useful message when the test fails).
Missing localRootId
There is a bug with read() that we doesn't remove the unused bytes if the buffer is large that needed. It could be fixed by add something like this:  Java if (length < buffer.length) { byte[] b = new byte[length]; System.arraycopy(buffer, 0, b, 0, length); buffer = b; }
So I was going to say - if both excludeFields and includeFields are set, then an exception should be thrown, which is what ResourceFilenameFilter does. I think that behavior makes sense when a single type of resource is being updated. But if this is ever used for multiple types of resources, there's some potential for overlap of field names. Perhaps we need to account for this now by requiring a type of resource? e.g. "database:triple-index,servers:url-rewriter". But that would be annoying for the common use case of e.g. "I just want to update the forests on this database, or I want to update everything on this database except the forests". So... I think let's assume String[] works here, and if both of these are set, let's throw an exception - i.e. either use mlExcludeProperties or mlIncludeProperties, but not both at the same time.
I think the 2 sql statments can be combined into 1 command
order of operands
why not try-with-resources for this one?
What if the connection actually fails? I think in that case you should reset the just initialized connection info in the catches below.
this and the previous line are not aligned.
remove this shit
Add body check.
those strings are for accessibility so especially the close string makes no sense here. I suggest something like "open drawer" and "close drawer"
I don't see where result is ever getting set to anything or updated after is created, so I don't think this status check would work, and the MetadataResponse returned from this method would just be the initial value (new MetadataResponse())
Lots of duplicate code in here again, see if you can pull stuff in a common class for smeltery and furnace
adjust this test to use Form
should also read data in this case
Is it impossible for getLabel to return null? Please use Strings.isValid(getLabel) instead.
one() should suffice. Side-effects are aggregated internally to the returned ResultSet and only return one Result object.
Can you add a break for the default case in order to keep consistency in the code
Also some OSes don't support 0 or 255 well, so they should be excluded
can you elaborate on this change?
suggestion: else-if and else not needed when you use return in the if-blocks.
Is getView() != null required since showQuickStartDialogTaskPrompt(boolean) has if (!isAdded() || getView() == null) as an early return?
This appears very complicated. This if and all code below (with this if and the next if swapped) essentially boils down to:  if (!partitioningScheme.isPresent && redistributedWrites) { partitioningScheme = Optional.of(...); } if (partitioningScheme.isPresent()) { source = add exchange to source so that it matches partitioningScheme (if not already) } return rebaseAndDeriveProperties(node, source);  As a result, I find this code extremely complicated. Is there a better way to write this, @martint?
Although logging is nice in production, it should be implemented with a logger class, instead of just printing into the standard output.
Use old name? s/userMetaReplicas/useMetaReplicas/
Since we don't rethrow here, is it maybe valuable to print more than the message and include the stack trace?
didn't understand this - why do this?
BTW, you should test directly the method validateQuestionDetails. extractQuestionDetails is deprecated in V7 now.
[optional] since changeId can now be null, I wonder if it makes sense to check here for it: if (changeId == null) { throw new InvalidChangeOperationException("changeId is required"); }
In my opinion, this approach of for loop can lead to making mistakes. I would use classic for loop. What do you think?
May be this needs to be an info log? WDYT?
This method should probably not be removed. It would be used by the annotation methods
brrr, why so complicated? why not just for (String key : params.keySet())
need to check latch here too
space before "was"
I think you make this section of code more neat  java if(!showAppWithAds || (showAppWithAds && map.get("summary").length > 0)) { itemList.add(map); }
suggestion && (alias.child().resolved() == true)) {
@ramindu90 if we are making it generic, I think the output can be something other than latitude, longitude. Shall we rename additional attributes to be more generic (e.g. something like kalmanX, outputX or filteredX or similar?)
what if target file already exists? should we handle FileExistsException here? thanks.
Maybe add a helper that takes a single stack and just forwards the call?
This "patch" is also needed for methods that return individual files.
This will probably not work with native compilation. Can you please create a ticket to track it so we will verify?
We might also want to verify if this Active Source is fully correct Active Source. Except for the source and destination address we are checking right now, also want to check the physical addresses match.
Enhance exception handling by providing a better error facade in new tweet api
We can log the error here. WDYT?
Prefer not having to modify this test. I actually wanted these APIs to preserve order.
rename to rPackageName?
Unless there are performance considerations, otherwise I feel like it's better to call with createActionBlocker.
Does the code test still work if you revert the change?
I'd log.warn here - this isn't an error per-se
loadJsPlugin does not need thmp so why did we make it above?
suggestion if (null != getUnit()) {
Instead of throwing WebApplicationException should we exit the JVM? WebApplicationException should be effect of client request, here its during server startup itself.
In AbstractPropertySource there are already some methods, that may help here (or need to be adjusted to do a real deep copy): copyPropertyDescriptors, hasDescriptor.
Why change it?
Let's propagate the cause here. Also, I believe JSON is the correct term, not Json.
This line should be:  java if (!elt.isAbsolute() && (buf.length() == 0 || buf.charAt(buf.length() - 1) != URL_PATH_SEPARATOR_CHAR)) {  Otherwise the behavior of the function is not the same as before the change.
Return an immutable singleton instead of a fresh object for null?
nit: Instead of storing session, how about we only store getMaxConcurrentMaterializations(session)?
Let's log the RequestDetails object directly using its toString() method, so adding/removing attributes in the future won't require updates to all log statements.
I think that it will be good to log both exceptions. Please remove this check.
Do we really want to skip assignments that we've already completed? I reckon they should just be at the bottom.
create a static string variable for deactivated
Edited. @perezp
Can probably keep this view permanently visible now.
Applying the Tags and returning the entityMap can be moved outside if-else to avoid code repetition. Also, not related with patch, but, getEntityList method itself can be re-organized a little to avoid code repetition.
This way it won't return any Templates unless unregister param is provided, no good...
can you check whether this is O(N)?
Collections.EMPTY_LIST (assuming the caller won't try to modify the list afterwards)
this could be setId(actionId)
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
![MAJOR](<LINK_1> The Cyclomatic Complexity of this method "getDeviceIpAddressFromSessionProvider" is 12 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_0>
Before removing from storage, should we check whether triggers are fired and data is send to downstream for window that is too late?
Should probably be targetEObject (the iteration variable) instead of target (the method parameter).
... specified. Allowed values are " + Joiner.on(", ").join(delimMap.keySet()).
This should probably go on a new line.
I think you mean CURRENT_ACCOUNT_VERSION. CURRENT_PREFS_VERSION should be irrelevant to the pickling code - it doesn't need to read prefs. And see below
same as above, can we have this blocksDir parameter configurable?
nit: if its more than once, should we create a variable that casts it to AuthenticationException
System.currentTimeMillis() ?
To make it easy to use, probably construct the Map<String, Pattern> here and throw a runtime if a pattern doesn't compile?
if we don't actually care what format the hostname has (which this error message kind of suggests we do), I'd make this message be Endpoints must be of the form %s://<host>:<port>
Should use assertThat
suggestion .getStore(300_000L, storeName, streams, QueryableStoreTypes.keyValueStore());
Incorrect exception message.
This one too.
This can throw an NPE if the localMediaId doesn't exist in mUploadingMediaProgressMax (HashMap.get() will return a null Float, which will crash when unboxing into a float).
I am just wondering we can only trim the first and last interval? I guess there are only possible overlaps in the first and the last one because intervals returned from segmentGranularity.getIterable() are continous and made with inputInterval. Correct me if I am wrong.
We want to set the depth and the number of channels here instead of just "1, 1"
this will never succeed, because createSymlink run only if oc binary file does not exist and thus removing such file is pointless, if it does not exist.
this change can be skipped till we handle individual errors.
the pattern to take/release a lock should be: lock.lock() try { // do stuff } finally { lock.unlock(); } This way you guarantee that you release the lock, even in the event of a runtime exception. We could implement our own Closeable locks at some point, like some projects do, it enforces correct usage. Not sure why Java's own locks are not... Also, the whole method (as it is right now) should be in the lock, until you can the reference via the new.
If a common interface like catalog info was used this if could be avoid I think.
try-with-resources
if this is only at startup, I think people talking about this will want it to be something higher than debug, like warn
I'm just being really picky, but can you swap this with the line above? So that for option and childOption it sets send buffer then receive buffer
Does not work correctly if the command does a remove, or keeps the value unchanged.
Minor: it's better to include the value of propertyKey in the message since it's not always equal to hazelcast.config.
same here, needsComma seems like a better fit.
@kevinoliver sorry for nit-picking but if you would fold this method into translateHeaders you could just have the StringBuilder as local variable and remove the declaration of private StringBuilder cookies. IMHO this would be preferable.
Don't initialize to null - the value is set in both paths and not setting it to null would correctly cause a compile error if it was used before set.
Should we also clean the dataIdsCache?
line too long
this as well
maybe go with static finals and more meaningful names, like EXPECTED_NUM_OF_MEDIA ;)
Iterate through entries instead
No need to new each time. make it a static
I'd prefer using G.allGrids and iterating thru it here.
this is a pretty vague name
Another option would be to return an SourceDebugExtension object from IFilterContext.getSourceDebugExtension(). Such an instance would do the String parsing lazily and only once.
If you set it directly in EditorSite/ViewSite, why is it needed here?
![CRITICAL](<LINK_0> 'Severity: CRITICAL') The Cyclomatic Complexity of this method "insertItem" is 11 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
Another case of it being closed before it is being used. I think switching to more try-with-resources syntax in these cases would fix a lot of these kinds of errors.
This could be done within the previous loop for loop, c.f. <LINK_0>
please, log warning in such case. warning should contain info about failed node
What is this guard meant to protect against? I don't see any code path where activity == null is possible.
Could we use a switch statement here?
The part I meant to extract was the index...refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName())
Put node.get(i) in a local variable.
I don't think we can remove type only casts (if the value is an Expression). I think it's purpose is to preserve type information for the execution and operators. Also, type only cast might fail (e.g: precision too small).
This value should be 1024
Should be List.
How about put this line in the synchronized (mScanInfo) { } too? to eliminate another possible race condition that the callback arrives earlier than the requestNetworkScan() at the caller.
readKeyData would throw out the IOException, I think we should also catch the exception here.
Need {} even for single line.
I believe we can achieve the same thing with this: suggestion } else if (site.isJetpackConnected() && site.isUsingWpComRestApi()) {  Alternatively we can just add the site.isUsingWpComRestApi() but also keep !TextUtils.isEmpty(site.getFrameNonce()). I think all 3 of these solutions would work, I just like the explicit isUsingWpComRestApi check because it makes the code a bit clearer for me since we call openJetpackBlogPostPreview afterwards.
Check args?
Extract this to a method in the [TestUtils](<LINK_0> class, similar to what we already do with OSX.
What is the use of this? A user changes their own password
The logic using maxUnwrittenRows is confusing to me. What does it mean for a row to be "unwritten"? I think this should calculate the next size check row count more directly.
I think there should be some kind of custom error message for providing a RealmList<? extends RealmModel> that is not RealmList<DynamicRealmObject>. Currently it'll just throw a ClassCastException
Unrelated change?
We already have a trace statement inside SecretManager. Shall we skip this debug statement?
It took me a moment to understand this. I think it would be more clear to write if (port1.isConjugated() == port2.isConjugated())
!(a && b) is clearer than (!a || !b) (to me anyway)
the change in this class can be removed now that the test are moved to a dedicated class
Do these paths have to be manually removed using a zookeeper client after the decommission is complete and all replicas have called removeOldReplicaInfo()? What if, instead, HelixBootStrapUpgradeTool created a znode before it begins updating using HelixAdmin and then deletes it after it is finished? Than, this loop could wait for the znode to stop existing.
So the problem with using this watcher is that the ability can't be copied. If you were to clone this creature, the ability wouldn't work since the watcher wouldn't be watching its events. Take a look at Grothama, the Devourer.
make this the very first condition so that mule startup doesn't go through unnecessary processing.
We can get rid of the type argument in the class as part of this change
if the fullpath is really full path, then the File(parent, fullpath) construction does not make much sense. maybe use just File(fullpath) ?
What if return type is java.sql.Timestamp, and java.sql.Time I think we should do Timestamp timestamp = Timestamp.valueOf(zdt.toLocalDateTime()); Time time = Timestamp.from(zdt.toInstant()).getTime();
why did we remove this assertion? it should remain true or some other state... we should evaluate the transition, as that is the purpose of these tests.
Line#179 should move in this if block.
a few of those are only used in their respective compute* methods. I suggest that they are moved and there instead, to make the constructor a bit shorter (it's still a bit heavy!)
should you keep a ref to the conn.getProperties instead of keeping the conn around?
Please directly update the expected value (in its file)
This does not handle classifier and type, not sure it was intended
yes, definitely should be a constant
Either no brackets or put return on its own line.
Why move this block down? Seems to me like it could stay up there.
String[] synonyms = new String[]{ "Maven 2", "Buildr", "Gradle", "Ivy", "Leiningen", "SBT" };
actually I think you might be able to straight up use CryptUtil here, but the file/cipher input stream would still be good to refactor
You can move this line outside of the try block. Sorry. I just saw that now
IllegalStateException
I understand the necessity to convert between ByteBuf and ByteBuffer here, but we should add a TODO to later to clean it up.
I guess we should check for maybeProjectId.isPresent() here as well
This is a general question for all policies which mutate the request, should this just insert the header value? @JonathanGiles @srnagar
Nit: Is there a way to merge this line and the InstallComponentsPath.createExtra(...) line below?
log this error
can this be in a try with resources block to guarantee it is closed?
There's no need to find the MetadataSchema object first, you can just use the other findByElement() method which takes in the metadataSchemaName: <LINK_0>
Suggest mentioning the exact class(es) rather than the the possible choices.
Doesn't code rely on this semantics? Can't constraint be none? Shouldn't callers be fixed too?
I think that 500 deserves a static variable :)
This boolean value is there twice. I would add a variable with good description in name. Something like: boolean dataExceedMaxLength = maxLength < data.length; And then use this variable in both if clause.
This change looks 95% great, but I think there's a mismatch here. IIRC the object passed to anyMatch() will be of type NotificationAttribute, and as such it is tremendously unlikely to produce a true response when passed to NotificationState.READ.equals().
For brevity, declare a local ret = getReturnType(). Order the comparisons in the natural way: if (variable == constant)
why?
This sentence is wrong. "Claim processed ok" seems better.
This should be in a separate patch
would be better if we check accountService == null because accountService is directly passed to getBlobStorageService method.
can we refactor above statements, they contain similar functionality. Additionally assigning and setting the click listener can be done in one line instead.
Make sure this is the correct exception
- Better with \n otherwise the string is too long with many contexts or with lengthier names. - Could use method reference Context::getName.
Must be AIDontUseIt. Same effect as Outcome.Discard (no cards selection by AI), but useful to find AI unsupported cards in the future.
Instead of sending another variable to snapshot save, can it leverage the URI template variable?
Shouldn't this lifecycle listener be removed in a finally block?
isEmpty()
Similar question here -- when will this get thrown and what will happen when it gets thrown?
minor: you could avoid calling getSize() multiple times
Please keep existing unit tests
We may need to broadcast the ALTER_STATS messages to invalidate the plans based on that stats too and remove the entry from the dictionary cache. See StatisticsAdmin.ddlNotification().
IMHO It would be better not to wrap PushResponse DTO but create missing methods in the DTO and place the logic inside the method in JGitConnection.
This log message lacks the context to be actionable by a sysadmin as an INFO message. Either add the context necessary for actionability by a sysadmin and change to DEBUG.
In general I prefer using MagicKeys, so that the primary owner is always the same.
Suggest leaving as final and assigning values in both cases of the if statement.
This is not testing the new method for the relative path and I'm not confident that the new method is working properly for the relative paths. Could you please use the new method signature to validate the relative path? Only the new one is used in the doAutoComplete* method, so we might have a feature regression on the form.
assertThat(someContainer).hasSize(4) is shorter and gives better error message. The same 15x in this PR: CTRL + f ".size()).isEqualTo("
I'd say we should do it the other way, enumerate the "good" states. looking at the list of host states I'd guess "Up" and "Maintenance" only? Roy?
I think that this method would be a bit more readable and concise if it was written as follow:  private void refreshNotifications() { list.setVisibility(View.GONE); progressBar.setVisibility(View.VISIBLE); getPageAndNext(1) .flatMap(page -> Observable.fromIterable(page.items())) .toList() .subscribe(threads -> { adapter.setItems(threads); progressBar.setVisibility(View.GONE); list.setVisibility(View.VISIBLE); emptyText.setVisibility(threads.size() == 0 ? View.VISIBLE : View.GONE); refreshLayout.setRefreshing(false); }, e -> ToastUtils.show(getActivity(), R.string.error_notifications_load)); }
TestNG uses assertEquals(boolean actual, boolean expected), so assertEquals(groups.size(), 1);?
Can we get StringIndexOutOfBoundsException here for some malformed JSON? Do we need to handle it?
All channels already inited after initClient, what else do we wait here?
suggestion out.message("I'm no longer managing the Everyone team. Please add committers to specific repos.");
@ptirador you can use RepositoryFiles.relativizePath here and below
Doesn't this have to be unsafeSubscribe?
This should be inside the for loop otherwise failure to close one socket will cause all other sockets not to close
we actually want to do this as part of trySetBytes so that we compact the index if needed. I would recommend having an overload of trySetbytes and setBytes (and then tryUpdateBytes and updateBytes) that takes in a boolean of whether to enforce the broadcast limit. Additionally rather than calling the full chain of operatorContext.getDriverContext()... here, this should be done through the localUserMemoryContext
This was really puzzling. Extracting it to a "packOnlyContainsReftable()" function would make it clearer.
pushContext(lcc)
@mswiderski could you move this String to _PerspectiveIds_ file and I think its also missing to create the actual perspective to link in here instead of the screen directly. I believe that's why the breadcrumb is not showing.
Maybe could be nice having a similar behaviour of the corresponding js file: __resultSetProcedure.js__. In term of write and read data from a real cache.
How about making this exception message a little different than the below one. Suggested: No token generated from GSSContext for request %s
We should use the assertEquals which includes a message argument so we can log a failure reason instead of just the exceptions stack trace.
rename to event
It can't be null, by construction.
licences is misspelled here - intentional?
Should this have some sort of explanatory text to indicate that these are suppressed exceptions? We don't do that above for the getCause() handling, but now with 2 possible types of extra information does it get more confusing? Should this be recursive:? buf.append("\n").append(getMessagesFromThrowable(suppressed)); If not should it have the if (t1.getLocalizedMessage() != null) { ... } else {...} handling like we do above? getLocalizedMessage() will be null if no details were provided to the exception constructor.
remove
It allows 0.0 and 1.0. What each value means for decay rate?
you can use writeTrashFile to shorten this: File readme3 = writeTrashFile("nested-repo", "README3.md", "content");
If LocationListPreference implements OnItemClickListener these lines would be cleaner. What do you think?
java final int checkedItem = Math.max(0, cacheTypes.indexOf(Settings.getCacheType());  should convey the intention more clearly (IMO).
s/header was/headers were
This check can be moved prior to Class targetClass = (target != null ? target.getClass() : memberClass); - like 2.6.
Return an empty list instead of null (same for L77)
Why not just folder.delete(true, null) ?
The exception message should be improved to print a proper function name.
Let's keep that block where it was before. The idea is to emit items which arrived before an error occurred and then terminate with a call to onError. Streaming output will still behave that way but non-streaming outputs would no longer emit items but terminate directly.
shouldn't the fail be outside the for-loop? current impl runs at most 1 iteration (either exit through break or fail)
I think this should be ok as it should get encoded. It should point to the newly created role.
These will generate 2 transactions, making the operation non-atomic. I think it would be better to aggregate this in a single transaction if possible
Safer to split on \w+
Actually I find this highly confusing. "checkWidget" left me puzzled -- why should we check a widget if we're going to create it? Oh wait, we're checking the parent. But checkWidget actually also checks that widget == null... Would be much clearer if the condition was simply inlined: if (widget != null || parent == null) { return; } Then a reader can understand this right away: "ah yes, if we already created the widget or there is no parent, don't do anything".
The VALUE should be a constant ;-)
Should the value be 5 (seconds)?
We need to check whether debug is enabled here
This looks like all evaluators are treated equal. We wanted to have weights for combining the scores. Wouldn't that be done here?
rename to listIterator
Is it possible for this to remain a Collection/Set instead of being copied into a List? I think there are a few methods in this class that take in the List but it seems like they just rely on it being iterable (I could have missed something, though)
Pass settingsRepository as argument to DownloadLanguageTranslationUseCase is not necessary
This particular test doesn't need this header, right? If so, please remove it. Also, there are a few more tests that don't need the header. Please update them.
why we need these extra brackets?
This would force the DSE driver to use the OSS LBP. I think instead we would like to make this test work with the DSE driver using its default LBP (DseLoadBalancingPolicy). From what I see we could do this but the incriminated test is creating a hard-coded CqlSession line 137. This should be changed to SessionUtils.baseBuilder().
Same here, this cast shouldn't work. You'll need to expose it using an additional interface (check org.spongepowered.common.interfaces for some examples)
Should this be "object name REQUIRED"?
why do you need to return a boolean from processEntityInfo? Could you not handle the adding of the new EntityInfo list in processEntityInfo directly?
If we specify a cluster size for this test of 3 (i.e. without using the CLUSTER_SIZE constant), we can write a single assert to verify that arguments.containsExactly(1L, 1L, 1000L) (pseudo-test-code, actual method required may be different).
Timber.e :)
The essence of this assert is not clear for me. Can you, please, clarify it?
If (shouldCopyRequestHeaders() && !this.copyNoHeaders) {...
typo: success
This is already done by the setUiForInteraction(false).
The truncation handle is already updated above, I think you can ignore it here.
You should use static definitions for these, not "magic numbers": private static final int START_TIME_COL_POS = 0; etc.
Can we abstract this description as a tool method and reuse that ? Something like RelOptUtil#generatesDescription(StringBuilder builder, int relNodeID, String digest)
Please, always use braces in cycles and conditions.
I think this one should be exactRef.
why is it always partition 0?
This one and the previous test can be refactored into a private method taking a location of the config file on classpath as a parameter.
Perhaps this should be instantiated with the urlmap rather than setting static maps here
GlusterTaskType should be validated as well.
Better print mCurrentDownload.getAccount().name in the log, instead of calling toString().
![MAJOR](<LINK_1> Refactor this code to not nest more than 3 if/for/while/switch/try statements. [![rule](<LINK_2>](<LINK_0>
You don't need to divide the block size by 2 here for the latter case. That was done in the previous query because it had two in-blocks, so we needed to make sure that each block was no more than half the total number of parameters for the entire query.
Is that a valid behavior?
Add debug logs in each block and add a newline at the end of each block to improve the readability
you don't need this factory, you can use mockito to mock Url.openConnection method
Please use here getPackageName() instead of "com.owncloud.android", the package name might change in brandable solutions
Should message be "progress response received" ? Also this: + (progressResponse == null ? "null" :" progressResponse.toString()) can be replaced by: + progressResponse They are equivalent, if the variable is being appended to a valid string.
I think we could get rid of both the constant and the local variable and just write e.g. 2 instead of offset+1.
Recommend to use StringBuilder to concatenate string
could do  java Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles;  slightly easier to read than for loop
Please reduce allocations here. Default ArrayList size is 10, it's pretty unlikely that we get more than 2 cookies for a given domain. Also, it can be allocated lazily on first match (lots of AHC usage won't involve cookies at all).
Do you know what scenarios would result in the NoSuchAlgorithmException or the KeyStoreException? It looks like you essentially disabling hostname verification if either of these excecptions occur, by using a no-op instance, is that right?
This throws an NPE when originalContentType is null and setOriginalContentType is false.
this will lose the original cause of the error.
This is getting quite expensive. Let's just change this to getTaggedMemoryAllocations(queryId) instead. If tests are not easy to fix, introduce a separate function instead so this one (with the old implementation) is only used in tests.
continuing
Needs assertTrue(...).
The original file appears to have a call to "setBankDataViewCode" in this method, but I don't see that call in this overlay. Can you please add that back in if necessary?
you can probably declare the field directly as a CachingField if that is going to be enforced later anyway
Just a note that this (existing) use of index Strikes me as fragile. If we put constants in for all of these indexes the code would be clearer and we wouldn't have to worry about potential mismatches.
under which case, you get an ntlm challenge but you have a null ui event? #Resolved
ClassCastException! You already have fTraceWithSize, use it!
You don't need the group-id bit here, ServerManager will include it automatically since you passed in it via the constructor
But it's also weird, because WorkerGlobalBarrier is already initialized by itself.
you can replace 15 with n.
The only user of FieldFormatter is DbaseFileWriter, which in turn cannot possibly be used by multiple thread in parallel because it keeps state about its position inside the dbase file. So these synchronized statements are not useful, and if the vm is not smart enough to get rid of them at runtime (it should be, but one never knows) they can also be harmful. Please remove them.
I know this can be kind of a pain, but we need to assert the sent payload too for all requests that have a body. This *really* helps future maintenance of the different APIs.
While this works, we can just define another small data structure with 3 fields for this. That way we also don't need the INFO_* variables.
This breaks the current handling of binary payloads (InvalidUtf8Exception is no longer thrown so we end up replacing its contents, with potentially malformed data). When the view is editable we should use the older method.
if (!disableAcl) { copyReqBuilder.acl(ObjectCannedACL.BUCKET_OWNER_FULL_CONTROL); } CopyObjectRequest copyReq = copyReqBuilder.build();
How about adding the possible type of sinks here? (TEXT_SOCKET_OUTPUT, MQTT_OUTPUT)
The three inner blocks make the code hard readable, but I was not able to come up with more readable code. So probably we can keep as it is with one expcetion. We do not need the line final Node node = (Node) element;. Also we should minimize the dangerous of NPE by Objects.equals(e, definition.getDefinition()) The code will then looks like: java final Element<?> element = event.getElement(); if ((element instanceof Node)) { if (element.getContent() instanceof Definition) { final Definition definition = (Definition) element.getContent(); hasExpression.ifPresent(e -> { if (Objects.equals(e, definition.getDefinition())) { view.setReturnToDRGText(Optional.ofNullable((HasName) definition.getDefinition())); } }); } }
NIT: given you're already using assertThat below, using hasSize here would yield a clearer message in case of failure.
Objects.hashCode ?
Failed to send this message [{}] to SNS queue at {}, sending asynchronously -- should this be logger.info? Or maybe we should have same format in all these logs for ease of parsing if we need to use a cron job? "FAILED INDEX REQUEST: Failed to send message to SNS Queue, sending asynchronously. Message:[{}] URL:[{}]"
FreeIpa or FreeIPA just asking because in this pr both word were used.
This needs to be a FormLabel. The Label class, despite the name, creates a div instead of an HTML label, and there is a significant difference for accessibility. You can tell just by clicking on the label in the UI. If focus goes to the associated control (the textbox), then it is properly associated such that a screen reader would understand but that doesn't happen here. To fix, make this a FormLabel, and create it AFTER the replaceTextBox_ (but before adding either of them to the replaceToolbar_). Use the FormLabel constructor that takes both the string and the control to associate with, i.e.:  replaceTextBox_ = new TextBox(); replaceLabel_ = new FormLabel("Replace with: ", replaceTextBox_); replaceToolbar_.addLeftWidget(replaceLabel_); replaceToolbar_.addLeftWidget(replaceTextBox_);  This will generate a unique element ID for the text box, and then set for=ID attribute on the <label> thus establishing the connection.
same as before: please use Unchecked and consider a private method ref instead of a lambda
this was for: commit 99562fbbb40c72722468e5dc8c84b3e28494a20f Author: Alan Viverette <alanv@google.com> Date: Tue Oct 14 14:48:52 2014 -0700 Check type resolution on declared methods and fields in ViewDebug BUG: 17375269 Change-Id: I8a74dfab1a1cf11b4240afb011d2729beea307c5 which unfortunately was about making this tolerant to missing types for fields
If we add the mIPv6DefaultGateway member then we'll need add a corresponding IPv6 route here as well.
This is not multithread safe
Better to use StringBuilder.append() rather using String contact()
You forgot to remove character encoding setting here
:-1: ;p
LOL this is one of the things that PMD will catch once it's in recipientTeam.isEmpty() (oh no that means this will conflict with #5268)
Not currently used
Do we have any unit tests for this logic?
minor: may want to log when artifactsLocation is not a directory.
This could be changed for consequenceTypes.forEach(consequence -> this.consequenceTypes.add(new ConsequenceType(consequence))); which I believe required less overhead.
Do you need to pass constant STRING_INDEX_IS_BYTE_QUICK_FIX as argument?
There could be a separate method here to get screen name against dataType to keep case statement area smaller and more readable.
its a wrapper for all functions in FunctionRegistry. what name do you suggest - ScalarTransformFunctionWrapper
Can line 154 and 155 be done in one state to pipelineMetrics ?
try-with-resources
entry
I hate to creep the scope here, but it would be super useful to capture execution site, e.g. PG wire, http etc
This assertion is no necessary as it is tested in assertAllInformationMatch
can this exception be a static field somewhere, with the exception overriding fillInStackTrace to not capture a stack trace? the message is also not needed.
I think using a well-named constant e.g. DEFAULT_MOVE_THREAD_BUFFER_SIZE is preferable.
Since handleTimeout() and handleException() are called by a single thread sequentially, does this method needs to be synchronized?
actually we need three parameters: 1. if we use external authentication, redirect to the external url, this can be anything externally set. default: yes 2. if we want to accept basic authorization headers at all. default: yes. 3. if we want to activate our basic authorization servlet to prompt for credentials or not. default: no. the above default will not prompt for basic credentials but will accept them if apache is configured like so.
Here there are some duplicate code, please review it
This may be overkill, but this seems like it's suited for using an ArrayList + TextUtils.join().
Ok I thought about this some more. I think it actually makes more sense to make this method only take parameters that allow thumb and alpha jump. Then in the test where you're testing that the up/down buttons don't show, do an entirely different setup for the layout. It's better to be more verbose in tests. The reason is that if you pass "false" for the up/down button and "true" for the other two parameters, it shouldn't actually show anything. Meaning this method doesn't respect the values of the parameters. If the up/down buttons don't show, then nothing should show. So I'd suggest making: void setLayoutRestrictions(boolean allowScrollThumb, boolean allowAlphaJump);
Can you make the underlying block synchronized rather than the method ? Is it really needed ?
Use _int_ to allow for values > 127
Assert only the values you set. Not the database generated ones like the id
@tsr-thulio Please show @felipeaziz how we do that using enum abstract method
should we move all these != null && !empty checks into a helper, where we simply pass the collection in ?
close the result set
You will get an NPE if user is null. It shouldn't ever happen, unless the user gets deleted after it has been cached in SimpleAuthenticator, and given that we make it hard to delete users... Still, the Objects.equals isn't adding anything.
This seems a bit dirty - parse and register an XPathExpressionFactory but then only use the factory method constructor args. Perhaps we need to refactor the logic into a utility to add these constructor args to each builder.
Can you declare exactly what exceptions are thrown? I suppose IOException only?
this should really be done by separate catch clauses above line 364, e.g.  catch(AbfsAuthException | AbfsAuthUnhandledException ex) { throw ex; }
-1 the migrate operation should not add reference to unexisting socket-binding. The correct way to migrate such a resource would be to migrate the messaging subsystem, add the socket-binding resource and then update the socket-binding attribute of the broadcast-groups resource
Instead of counting forks by iteration, better to make an assertion like the following:  java MatcherAssert.assertThat( forks.iterate(), Matchers.not(Matchers.emptyIterable()) );
I would use java.util.function.Supplier<SSLContext> instead of your own ZKClientSSLContext type here
Could we add some logging when this happens?
Values put into positions never fetched back.
use the logger If you want to print something.
like Gilad Bracha's quote: "live is better than death", I would say "positive is better than negative" :) how about replacing it with: if (unmanagedControllers.isEmpty())
Should this also check the DerbyDialect?
not sure if this is the right thing to do. The channel is non blocking. If the write wrote partially, flush would return false and this will throw.
I think you probably want false here. true appends one of "created", "fast forward", or "forced-update" to the message. Considering this is basically an unconditional copy, I don't think this information is useful to the user. Also, it kinda feels like this should come from JGitText, but inspecting existing usages of setRefLogMessage shows that many aren't. I'll defer to Shawn.
I think we should clean that up in a different way: AFAIK we do no longer have a difference between "add to index" and "track", so I think we should delete the track() here and replace it by addToIndex(). In addition we could use the jgit AddCommand to heavily simplify this class.
Local size sounds better to me than "entries"
Style: can you inline this? Multiple rectangle creation makes debugging a bit more difficult. Instead, let's do: Rectangle eventBounds = DPIUtil.autoScaleDown (new Rectangle (rect.x, rect.y, rect.width, rect.height));
What happens if daily is enabled and hourly is not?
since admin has everything, I believe it's pointless to wrap it by AuthorizedAccessModel
this template also needs a version check
no need to call load here
Do we need to test counter reset case after this? e.g. makeDnsSuccess(...) assertFalse(...)
You can avoid the duplication of that line if you simply add this to the first if: && (((MemberProposalInfo) getProposalInfo()).fProposal).isSuffixProposal()
Cluster could not be resized?
Shouldn't e be wrapped in a CucumberException also in this case. The construct throw new CucumberException(e); seems to be pretty common in the code base.
Shouldn't this be last.arrival_time - first.departure_time? I wouldn't consider layover at first and last stops to be revenue time.
@narakim I don't think we should do this. This API specifically expects a valid account instance. Why are we substituting it with currentUser if an account isn't passed in? I'm okay with the null check below though.
The problem I have with this change is you now need two plugins: * one to load jquery. That's all it can do. * one to load your code. Which won't work without installing the other plugin. I think we really need to permit the plugin to have a list of additional external JavaScript source files that should be loaded. So added a List<String> getExternalJavaScriptUrls() or something that gets iterated here before the plugin's own JS. Of course then you have some issues about two different plugins both trying to load different versions of JQuery from a CDN. Or one loading from a CDN and the other loading from its own private copy. The namespaces will collide, but I guess we can't protect everyone from that. Instead we should recommend plugins that work with Gerrit X.Y all source the same JQuery CDN URL if they need JQuery maybe?
Maybe consider String.valueOf() to circumvent NPE.
Execution service usage wrong here too.
This will just prolong the execution of the command by including the Thread.sleep() in it. I think we discussed change on the line 664 that we need >= there, didn't we?
I'd prefer it as it increases readability imo
Method run has 33 lines of code (exceeds 25 allowed). Consider refactoring.
The test 'null != importedPackages' must be with the second one (the second manage the 'importedPackages'
Dimensions are not restricted to relationships. They can also be non-metric attributes.
What is the value being multiplied by 0.2?
Is SimpleName really what we want here? Should we use type name (which can be different)
why not pass exception e into StoreException constructor?
@Override
Definitely wrong. The implementation in storm-mesos is better than what you are copying into here. The existing implementation is more generic. Please revert.
does this inequality work with a NON_ADDRESS
The disk existence is already validated, please remove
I think what's left here (besides nit on formatting) is to simplify the code and remove the wait loop. For example, if we use a countdownlatch instead of AtomicBoolean for callbackCompleted. You can search for references to CountdownLatch in brave for similar examples. next, the assertion in 117 may actually occur off the main thread, which is why you are saving a boolean there. I think it is a bit cleaner to have an atomic reference of TraceContext, then you can do assertThat(callbackTraceContext.get()).isSameAs(expected) right after your countdown latch is done.
@llorllale Let's use IsIterableContainingInAnyOrder here
So i see why you need the PublisherClient.... I think you should take a RepositoryFactory and a PublisherSession here, where RepositoryFactory has a method to open the repository. It is likely the case that RepositoryFactory should be on the PublisherSession itself.
Shouldn't the exception be passed all the way up? We need a build failure to happen if an exception occurs. No one will be looking at the console for a stack trace unless there is a build failure.
Log
First condition is redundant with the second.
As discussed should we change the interface to this method to not give the impression that it would validly return an empty result? Potentially the code would be read clearer if it directly returned a RefundTransactionsForPayment and through an error for any other case.
Remove -- we cannot spam System.err. Optionally introduce a logger instead.
Did you miss correcting this and below?
This needs the same fix as in my change <LINK_0>
Might be unrelated to this PR, but is it possible to make isGroupedByTeam() a field instead of a method?
nit: Is it possible to show the name of the type here? Now that the exception type is UnsupportedOperationException, the string doesn't add any additional information.
Use parent.getFS() instead
Who will call circuitBreaker in this case?
Should we move an assert to the top?
Is this needed?
Simplify this by using .putIfAbsent / computeIfAbsent?
Change to "the allow partial"
Call RxJavaHooks.onError so no exception is lost.
accessInner -> getUpcallResultInner, this seems to be incorrectly copy-pasted.
I think it's the CheckboxTreeViewer's own responsibility to maintain the check integrity of the parents and children. The CounterView's only responsibility is to get the checked leafs and update the chart.
catch checkArg()
Out-of scope, but for future discussion: This technically only performs in-memory delete, whereas the modSchema is a database-centric action, if we move this to only performing the check, we may be able to avoid a few full uploads if the user cancels out of the action.
We really should not need to check for null (we don't do the check in the save method so it would NPE in the end). Worth creating it in the constructor to avoid these.
Check your indentation/formatting settings. FYI I'm using Eclipse with Sun Java Conventions.
Magic constants...
Remove this
Missing this. and potential NPE on type.
assertNotNull("Root plan graph is null", compiledPlan.rootPlanGraph);
No, I didn't
This doesnt account for the older explicitly set delivery annotations in the same way the standard message send process does. Seems like they should behave the same?
How about passing this color to the activity as well? On my device I see the primary color briefly when opening a task, we could avoid that by passing the color to the ViewTaskActivity. Just make sure you tolerate the absence of the color in case it's called by an external app.
Remove this?
I dont think this will ever return null for ENV vars, but its worth keeping the check. What about a check or empty too?
Can you try to force all the segments instead of short-circuiting and exiting on the first failure?
Missing final
execute that if block first so that we handle the case when both are null. after that execute the other if that checks if any of them are null and throw the error that will make less nested code and remove the need for the else construct
Should we use index + 1 to set the priority value?
use the builder pattern: builder.topicName().subscriptionName()
Instead of System.out.println you should use a logging framework. Check the other patterns for examples.
replace with a LinkedHashSet
Please add also VOOBSERVER.
No need to use UriBuilder
remove space after .tag and add space after the comma: notificationManager.notify(mixpanelPushNotification.tag, 0, notification);
Why this change?
If available, you should always include the name of the variable which is causing the problem.
Will this test pass after the year 2100?
Please use computeIfAbsent instead to not allocate ConcurrentHashMap on existing key.
Move into if statement here as above.
Shouldn't you use OgmTableGenerator.SEGMENT_VALUE_PARAM instead of haveing a duplicated copy in SEGMENT_VALUE_PARAM?
We should probably protect Log.v with VDBG and Log.d with DBG
This may be too broad an swallow other things, such as IO Exceptions?
Maybe, you should give back tempTvp
can you extract this to AbstractDiskVmCommand for reusability in HotPlugDiskToVmCommand?
This should always be the case. We don't need to expose a setter method.
I think registry1 and registry2 should be two different instances, but still don't know why it failed.
no need to close this reader as the underlying input stream is closed
In case showErrorDialog=false since the messages are aggregated, the fault is not localized (the localization of the fault is part of runActionExecutionFailed(..)). Consider removing the showErrorDialog from the 'if' and pass it to runActionExecutionFailed(..). In runActionExecutionFailed(..) localize the fault and don't show the dialog if !showErrorDialog.
when will the end method will run? if there are no tasks created you should run it yourself.
Are these log debug messages useful to retain after you've finished your testing?
expiration
Use  CTEProvider provider = providers.get(clazz); if (provider == null) { CTEProvider provider = new SimpleCTEProviderFactory(clazz).create(); providers.put(clazz, provider); } ManagedViewTypeImpl.this.cteProviders.add(provider);
Why is there an array of SortFields with null in it?
Is this needed? I thought the instructor remains on the same page after clicking publish or unpublish now.
There are a lot of getDefender().getAbility() here. How about just get them at the beginning
If your new conditional above on 339 evaluates to false we can't skip lastIdx here.
constant
Checked that this should get retried both by atlasdb-proxy and atlasdb internally.
Would you mind removing this manual setting to null? Environment will produce null if nothing with that key is set anyway. Thanks!
should be probably StringUtils.isNotEmpty because non empty string signifies inserted CD.
Merge these two if statements.
application/json is used in multiple files and tests, maybe use a constant to replace it?
suggestion g.drawString(text, x- (metrics.stringWidth(text) / 2), y + g.getFontMetrics().getHeight());
Nit: the scheduler understands negative intervals as "disabled", so you don't need to have this extra check here. Just have syncGroupOffsetInterval return -1 if it's disabled.
extraneous new-line
Minor thing: I think it's better if "columnResizePersistenceEnabled" comes first in this expression (but it's not a big deal since initializedColumns is empty when columnResizePersistenceEnabled==false): if (columnResizePersistenceEnabled && !initializedColumns.contains(column)) ...
part2, right?
space in between { and catch.
eh? we aren't literally sending the span in headers, right? that's basically the opposite of the intent of the in-band/reporting duo of dapper systems
The thread name shall be fixed, You can just regenerate the name according to our name convention.
Question - should we just use the value of user.skinId as the token id instead of adding another claim on the token? I think that might be best - less moving parts. When a user logs in, they get a user token with the id out of their user.skinId. If that gets invalidated/updated, then all tokens using that would be invalidated, right?
Why don't we check for this case? Could you please elaborate a little bit more what does the schema evolution mean? Is it the table -> partition schema migration? (changing the columns for a table with existing partitions)? What If there's a mismatch? Wouldn't it fail the old way when reading?
Better to always use {} IMHO.
why if and not just: options.add(VdsProperties.includePartitioned, filteringLUNsEnabled.toString());
do we need to differentiate between IOException and StoreException with ioerror?
why do you need this? i$
suggestion "Joining against a multi-value dimension is not supported.",
Why is the special casing for And/Or/Not needed rather than always taking the complement of the field's rangeSet?
name change
It would be simpler to get TmfTimestampFormat.getDefaulTimeFormat() and set its time zone to UTC, here or perhaps in the setUp method.
It looks like /dataset/ should be plural /datasets/ ?
shouldn't we throw an exception and halt the execution here? if we can continue with a null url then instead of print stack trace we should log
This isn't necessary anymore as soon as we use SLF4J.
still I claim that trim is not needed :)) per above split.
suggestion if (!rootBaseDir.getRoot().equals(baseDir.getRoot())) { LOG.warn("Unable to analyze module " + baseDir + " that is not in the same root"); continue; } Path newBaseDir = rootBaseDir.getRoot();
we need a test with number of resources with group message enabled > threapool size. This is the scenario where current code deadlocks. This test case does not cover that scenario
Given that other logic still leverage max weight, will this work for targetTasks.size() == 1? If it works, It may be ideal to have test on this case to clear out wondering.
Why changing to a File if you load it fully anyway?
Shouldn't this be true? By default, multi-world commands should be true.
Perhaps this is an IllegalStateException
Is expectedNodeCount needed to be updated here? If the transaction is restarted upon node failure, expectedNodeCount should be updated.
Null check in the full file.
Change to isEmpty, see below also, just for consistency with the condition above.
What about a direct update to a recurring instance? Wouldn't that lead to here and by simply changing it, braking the data consistency of the recurrence set? Shouldn't that be detected here if it is a recurring instance? Or are those going to have RRULE or RDATE copied from the master, so those are handled by the if branch here?
When is this JMXReporter ever stopped? It's lifetime should be tied to the lifetime of the Vert.x instance, and when the Vert.x instance is closed it should be closed and all the MBeans unregistered. Otherwise -> memory leak.
The contract of List isn't compatible with what SortedListModel is supposed to do, due to methods like add(item, pos). SortedListModel maintains data that's constantly and consistently sorted according to the comparator, while add(item, pos) will allow a developer to mess with the ordering and break the contract and cause inconsistent behavior. The right thing to do would be to suggest this as an alternative internal implementation for SortedCollection from the other patch, but SortedListModel should still use something like SortedCollection that is consistent with its requirements.
nonRepeatableDirectivesByName will travel directives three times. The code below seem to be faster: java public static Map<String, GraphQLDirective> nonRepeatableDirectivesByName(List<GraphQLDirective> directives) { // filter the repeatable directives List<GraphQLDirective> singletonDirectives = directives.stream() .filter(d -> !d.isRepeatable()).collect(Collectors.toList()); return FpKit.getByName(singletonDirectives, GraphQLDirective::getName); }
please use openmrs code formatter. Need space beteen passing parameters
This business rule should be part of the backend, not of the RESTAPI.
this doesn't look right. The only call to kem.print() should be in FrontEnd.java when execution ends. Why was this done?
You do peek twice (next line), I'd either move it to a variable or use isEmpty
I just realized there is an issue with the serialization of the Collection<? extends V> value here: - Collection<? extends V> is serialized to Data - It will then be passed on as value to MapEntries field of PutAllOperation - In [PutAllOperation](<LINK_0> it is deserialized. The Data will be deserialized to Collection<? extends V>. The problem with this is that it requires that the collection's element class Class<? extends V> must be present on the server, even when the MultiMap stores items in binary format. The solution is to first serialize each element, so the Collection<? extends V> is turned to a Collection<Data>, then perform the serialization of Collection<Data> to a single Data to be put in your dataMap:  for (Map.Entry e : m.entrySet()) { Collection<Data> dataCollection = asDataCollection(e.getValue()); dataMap.put(toData(e.getKey()), toData(dataCollection)); } ... Collection<Data> asDataCollection(Collection<? extends V> values) { // iterate values and serialize each }
This is not very good, it is bad practice to use instanceof in this case. We should have a common interface
I think we should throw an exception if casting is not ok. Else the description will be empty and further no notification is send to the user. Except that an exception is logged. E.g.: <code> try{ response.setDescription((String) meterResponseData.getMessageData()); } catch(final ClassCastException e){ throw new OsgpException(ComponentType.DOMAIN_SMART_METERING, "cast exception " + e.getMessage()); } </code> or <code> if (meterResponseData.getMessageData() instanceof String) { // do ... } else { throw new OsgpWsExceptionBlabla("casting " + meterResponseData.getMessageData().getClass() + " to String is not possible"); } </code> Edit: May be it's better to not check for 'instance of' and just let the class cast exception happen. The method 'handleException' will handle the exception, but we have to change it to also include the 'detailMessage' of the exception. Else the reason why the technical exception is thrown is not given.
NIT: LOG.info("Executing {}", mountCommand);
Why we still have other exceptions declared while in KafkaProducer only ProducerFenced is declared?
used multiple log's parameters here
Refactor to generate SearchSourceBuilder only in one place
We should assert that the message was sent in the request.
This can/should be outside the lock In general, anything that can be done outside locked sections should be. Putting it into the critical section implies that it is thread-unsafe.
This logic seems to be inverted
Could return early instead of nested conditionals? suggestion
This should be done in ctor and not every time during search.
Is there corresponding release ?
AFAICT you need to declare a future variable, but you don't need to return future, you can also return future.whenComplete(...)
It is a simple change that doesn't change the logic. I prefer that we change it now and then think of a way how to make the method more efficient
Shouldn't all of this be remove too - we aren't really attaching the domain to any pool in this command, are we? Moreover - now that you removed the previous validation, getSotagePool() may return null, in which case this will just fail with an NPE.
I think this would be easier with new Handler().postDelayed(() -> ..., 800)
Shouldn't you also set broadcastReceiver and settingsContentObserver to null, to prevent memory leaks?
Just let exceptions that would fail the test also escape the test give us some more information, such as stack traces and the original error message. Never drop the original exception.
Can you please create a function for this condition, instead of copy-pasting it?
You will have a NPE here if associationType is null whereas before the code would support a null associationType.
Since the headers are coming from the config are such as inmutable, probably you can load the headerMap as an immutable Map on a static block or so when the class just started and just return it, instead of using a lazy loading strategy, in that case does not need the concurrentMap and the syncro block just a eager strategy :)
This is syntactically correct but it would be best to use curly braces for consistency
Wouldn't it be an improvement, if you also extract all the code clones into a private method like illustrated in the following?  private Result visitElement(TInterfaceType node, P parameter) { if (node.getDerivedFrom() != null && !validateTypeIsDefined(node.getDerivedFrom(), typeVisitor.getInterfaceTypes())) { String msg = "The parent type \"" + node.getDerivedFrom() + "\" is undefined! \n" + print(parameter.getContext()); setException(new InvalidParentType(msg)); } super.visit(node, parameter); return null; }
Seems like a copy-paste. Can you refactor skipping logic to a separate method?
This can potentially cause NPE, @anuragaw can you check who are the users of the method and potentially what must be the ideal return value? The createCountSelect and its indirect users have atleast 70 usages codebase-wide, therefore while fixing the bug, new regression should be avoided.
I think we should either use logger debug message for this or just remove and assert message text like we do one line bellow.
Is it right to assign an empty string as the default value of the response? What complications do we have if we let it be "null"?
might be good to rename distance to "meters"
same. no "else"
Why assign the throwable to ignored in the first place? Also in completesTerminationFutureExceptionallyIfActorStopsExceptionally()
This might not be able to be a constant if SALT_LEN is different for the different algorithms
Here should be a space after for
Wouldn't it be better to use a stream here, instead of a loop? Due to the operations done inside the loop, I think this is a perfect candidate for streams :)
Unget service again after usage
Why do we need this? Isn't the default already 0?
maybe change to debug level and wrap in if statement for isDebugEnabled ?
We deprecated PORT recently (HOST is a (list of) host/port tuple(s) now). We should not add it to new data stores.
I take it that this could not be simply "exists = (results != null) && results.next() && (results.getInt(1) > 0);"
bit of duplication here.
@ikhvostenkov please use SplitText here
Awesome work so far, Eli!
nit: there's no value to using stringbuilder here. just exit early then retain existing logic if not present
Can you explain under which circumstances this happens?
Replaces #339
Likewise. extract "limit" out of the for int limit = Math.max(1, columnCount);
Hmm, really? I think aggregation may fail on other cases such as OOME.
This should go to info if the loggin below is in info
Nice, I like it! One suggestion though: I believe you can can do a logical OR in LDAP queries. I think that would be preferable to making multiple queries in the for loop.
If there are no segments, the map would be empty, but the analysis should not be failed, me think.
10s is a lot! :sweat: Can we reduce it to 1.1s?
Are there chances that status remain null. If yes, then we should have a check for status is null or not.
if/else block seems to be exact same as onError(), let's just call it here?
Someone switched into French part-way through this error message.
[question] why are we casting here? Isn't it project an instance of Project?
Confused by the chosen date? Should it be 2011 instead? Also, this should probably be static final, and with a timezone.
Use Configuration.getTimeDuration()
This test seems good, but can't we test whether the GlobalSchedEventProcessor consumed sufficient time period also?
not sure how this class is used but... can we have an NPE here? you are setting trackSegments before instantiating keyOnlyTracker
Wondering if the array elements should be casted if they are not longs.
Maybe rather Collections.singletonSet( )?
null check?
Ouch.. but if this is the only way.... then so be it!
This introduces a bug. Revert.
Maybe channel.close().sync()? Channel#close() is async and returns a future.
can you define constants for these versions?
This will receive null as fillColor which is used as a param for replace("$fill", fillColor). Maybe it should use a default color instead or is "null"/unrecognized color black or something like that?
Should the shutdown happen after the event thread is interupted? In other words, could we get an event after we shutdown the producer
Doesn't match coding conventions: Shoud be  try { ... } catch { ... }  (spacing and bracket location)
checking up just one block is probably not enough. Think of something such as:  if (checkPerms()) { if (myOtherCondition) { // DML here } else { // DML here } }  The blocks would just contain the DML, and not the check (assuming blocks are defined similarly to the Java grammar, since that's on imported jars I'm not certain). You should probably recursively move up block by block until you reach the method block (avoid getting into the class block). This approach will also guarantee you are analyzing the correct branches only, and not looking into sibling blocks that are not in the current block's execution path.
Only print if != default
nit: Failure -> Error
line length
for instance, in interpret, it will be much nicer to return the message in InterpreterResult than throwing exception
(int) would be sufficient.
I would expect preference listeners to process the selection. Also this code may be shoter If we have a "function" (Button, String) - it may be used both here and as a preference listener
can we just make a object column selector? It'll clean a lot of this code up
final
Extract this into a new method. Also, check if using <code>AppPage#changePageType</code> is more suitable here.
rename c to contentlet
@ketan Rethinking this, I'm not sure if this is a good idea. Can't calls [such as this](<LINK_0> affect the DB, while a backup is in progress?
You could deallocate in catch (Throwable) and remove shouldFree, but the method is just doing more than it used to (the old version didn't free the allocated memory if performPut failed). OTOH maybe I was wrong about moving the allocation outside the lock: by doing the allocation first, we allow more memory to be allocated above the eviction limit, because there may be more than lockCount threads in put().
Please use {} placeholders here
This method is so long, can we divide it to smaller more readable parts ?
Any chance you can be more specific?
This can be executed concurrently.
Nice catch
not sure why we need to do this
Number "of"
Please move else branch to the start of the method.
I took a poll (@domoritz and @7andrew7 present) and it was voted that this code is not good code. Suggest a series of if statements instead:  java if (castTo == Type.STRING_TYPE) { return CastType.TOSTR; }  etc. Also, I wonder if the CastType fields should have _ separating words? E.g., TO_STR instead of TOSTR.
Same functionality, consider moving priceList.add() and history.put() below the if else statement
Sorry missed that in my first review. I would say here (I did this in my Gerrit review for this issue): The org.eclipse.ui.IStartup extenstion instead of "The startup extension".
No method should complete() a Context that it does not create. This could have unintended consequences (as a completed Context can no longer be used).
@dmzaytsev better to use Paths.get("sub", "file").toString()
Please be consistent with names: operands are x and y, result is z. The suffixes i and l denote int and long.
nit: just noticed there's also received * datagramSize above on line 586, could do it once
this.partitionKeyPathInDomainType = getPartitionKeyPathInDomainType(domainType);
Please use try-with-resource on the input stream - this code opens a stream but does not close it. Better yet - use Files.readAllLines(file, StandardCharset.UTF8)
please be consistent with the command names. You could just use CamelCase
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Refactor this method to reduce its Cognitive Complexity from 16 to the 15 allowed. [![rule](<LINK_2>](<LINK_0>
I'd rename paths to types or subfieldTypes because this variable holds a list of types, not paths.
gets appended even if capacityTypes.length == 0. please guard it
Shouldn't the WRITE_ONLY check be part of the allowLoad method?
Doesn't Qulice complain about this indentation?
Did you want to remove legacy from this name also?
For performance reasons, it would be better if this clearCache() was moved down 5 lines next to the instance.usageCount = 0;. As 'close()' may be called by multiple threads - another thread may still need to get vulnerabilities.
This is a situation where I would like to see something like java logger.error(e.printStackTrace());  or java logger.catching(e);
Are you sure about that cast operation? You are asking for a service interface and cast it to a concrete implementation without instanceof check. You perform that check in the tracker that is only added to a SaveablesList.
I would not use vc.createExtension like it is. I would refactor this method, separate a past which returns the URI from the rest and call just the extracted method because you need the URI, not the extension object.
Remove
static
where is this being used?
should we make it isBuilder?..
Can this response be read and verified?
I think we need to handle partitioned columns in Orc and Avro.
Not needed
.toString() is not needed here.
This looks like an often reused check, would it make sense to make it part of the type?
The above line ParameterSet paramSet = task.getParams(); is not used.
shorten to boolean hasDarkTheme = getThemes().stream().anyMatch(t -> t.getId().startsWith(E4_DARK_THEME_ID));
This seems like an even odder test than before. A schedule from July to July will handled differently to one from July to August. Maybe keep the existing code, but inside the block check preferEndOfMonth and return EOM if true?
Can you pelase change the header to: " * Copyright (c) 2011, 2020 Eurotech and/or its affiliates"
[optional] s/commitSha1/headCommit [optional] Just compare the ObjectId's directly, then you don't need to invoke 'getName()'.
In the RemoteSpawnCache, the equivalent condition was moved before the concurrent modification check. It probably doesn't matter, but it doesn't hurt to be consistent either way.
Should there be a case for arrays, too (this would be either non-primitive arrays, or multi-dimensional primitive arrays)?
While updateCounter is in await, applyUpdates can be called again, causing updateCounter to reference a new CountDownLatch. Then, finishMigration will update the new one and not the old. Maybe this is not a concern because ElasticMemory.applyUpdates is synchronized?
Since a logger instance is there, shall we use that?
rename ctx -> context
missing {} in the if, so you are breaking the statement there. That's exactly the main reason why I *hate* the if without brackets If that code bug was not discovered by your tests => there is a missing path in your coverage.
Please do not use "blablabla" as a string literal. Instead, name it after the thing you reference. Use "invalid_type_url_example" in this case.
nit extra line
shouldn't headers be added irrespective of POST/GET?
Shall we send a 404 when the registry cannot be found for the given uuid?
I don't think we want a WARN log for user-specified readOnlyHeaders on every build of a message. Perhaps it would be better to put the WARN log in the for loop of GatewayMethodInboundMessageMapper.DefaultMethodArgsMessageMapper.toMessage Line 309 and don't invoke headers.put(headerName, argumentValue);
What if we instead change this to be List<Function> and have the code below run in a loop until the last function added was NOOP? This would enable a pattern like ${foo.localPart.toLowerCase} rather than needing additional functions defined for localPartToLowerCase.
Technically the email hint is provided by SmartLock, so this would make the API somewhat dishonest. Although I agree with you that enabling the hint for everyone may be a superior UX, I want to respect the intent of the developer when they say "disable smartlock".
Is this System.out.println leftover from debugging?
if ((mAidDo == null) && (mHashDo != null)) { or if (mAidDo == null && mHashDo != null) {
Why not append up to 10 sitemaps, versus appending nothing if there or more than 10?
at a glance this looks good. another approach would be to swallow every exception at the SetHaMaintenance command and translate it to error. that will make error handling even better and smaller. since this is a very specific command and for that particular flow I feel its more appropriate than the exception approch
Should also check for configuration "spark.executor.instances"
Let's move this down to be after the peak stats. Also, surround it with blank lines since it is a separate stat.
- This has to be the main method to do all the magic of setting up the values etc. It needs to be called both when the getDataCenterWithClustersList() changes and from the oSType_SelectedItemChanged() - please add something like: EmulatedMachine oldVal = getModel().getEmulatedMachine().getSelectedItem(); getModel().getEmulatedMachine().setSelectedItem(oldVal);
Are System.out statements still actually useful? Shouldn't they be removed or replaces by some more configurable logging?
Magic numbers
why having this print? Is doesn't seem relevant to the user.
Not necessary to check if font file exists
Maybe it makes sense to add some meaningful prefix like "tooling"
Need for this method? Construct file directly using  file = new File("target", "bigfile.txt"); InputStream testStream = randomStream(0, 256); FileIOUtils.copyInputStreamToFile(testStream, file);
Use IdentityDBUtils to get the db connection
Why do you need the gtkThemeName string? It looks useless to convert the buffer to string, not use the string and convert it to buffer to pass it to gtk_css_provider_get_named after that.
I might be wrong but I am really wondering if you did not, somehow shortcut erasure by relying on fully qualified name and therefore hacked a solution instead of fixing the real issue... We would need to discuss in depth what is going on here.
Is this log really needed? I also feel like this is left over from some debugging session. If you think we really need this then: - toString is redundant - Use %s instead of string concat - This is in a loop and we log plenty of stuff, so you may want to put this line in if(log.isDebugEnabled())
Shall we re arrange this conditions, else this will throw NPE
extract to top as constants. (alt-shift-t in eclipse)
can you put an explanation why this number 5 for the test so that test maintainer can understand better the significance of this number?
Do we want to allow being able to turn off polling by specifying a polling interval of "0"
Can we pull this into a static var at least. Should probably be configurable no?
Check code style for building mvc test rules on my latest commit on PR #556
can you only add try-catch without changing the if style to elif? Previous variant is more readable for me
Why this extra condition here? If there is no manager, shouldn't we always clear annotations?
If the idea is to get clear and index to be happening parallel, this may not guarantee that. There is a IndexManager.testHook that can be used to control index creation. And having more entries will help chances of occurring clear and create-index in parallel.
Whoops, I didn't think through this before! toString should not have side effects. Could you do this in setNewValue instead and maybe change the name to setNewValueOrClearIfUnchanged? That's a mouthful, maybe recordValueChange or saveValueChange?
Not sure about this change.
I was thinking more about this, it might be better to just use getTokens(HttpMessage) (with requestMessage) instead of making public. This allow us to use the same method for JSON messages (and others, which we can tell by its Content-Type) once the support is added.
will be never executed? factory.runNow throws exception if result nok
Use "return StringUtils.equals(...,...)" instead of the if-else cascade.
Tests directly against the service don't need to assume JSON is involved, only the controller needs to be aware of the serialization format. So I'd suggest skipping this step and asserting directly against the result map since the current approach to assertions won't be able to detect nesting.
StringUtils.substringsBetween(path, "[", "]")
Please switch these to keep the setResult -> notifyStatusChanged order consistent every time we do that. I think this matters because setResult is what updates TaskStorage (through a callback) and notifyStatusChanged is what triggers another supervisor run. Since supervisor does a getStatus we want that update to have already happened.
Could we please use Objects.equals ?
This type definition is not needed.
wrong formating?
Minor typo
The block from line 254 to 258 could be extracted in a method readModel(modelPath) and reused in the next test.
We can apply WSUtils.wrapWithStreamingOutput() here, too.
Shall we throw Exceptions with the error information here?
Use Json here too.
minor style issue, but please move this next to TextIndexLuceneAssembler a few lines up, because they're similar
shouldn't it be done only when disk is active?
The code will never go to the else statements?
oups, can we remove such "null" argument?
Let's be a bit more verbose here. And while at it, place this inside the JettyLogger as well please (here is [another logger](<LINK_0> as an example)
Do we need to specify all these properties. If yes can we && these values
Could we sort in an existing one in such a way that it appears on top of the list?
in -> input?
I could also live with this solution. as long as I don't have to hard code it :-)
We can simplify the long build block here. You can pass a parameter called toBuilder to ReadOption builder: Builder(toBuilder=true), then here you can simply use: java ReadOptions options = readOptions.toBuilder() .waitForHole(false) .build()  This will make other fields same as readOption except for waitForHole
Intuitively I would rather do HTML escaping in the frontend. The backend should just expose the database credentials in their true form, it is the frontend's job to render them to the user.
Nitpick: instead of -1, Stateless.WindowId
Iterable doesn't give us a .size() method, but you could check assertTrue(requirements.hasNext()), since (I assume) there should be actual requirements being sent?
These lines can come after L128 and the first line becomes ModelNode modelNode = resource.getModel(); The Resource from context.readResourceForUpdate includes the data that you need to restore.
We prefer use result to name the result variable
This message should be externalized in mondrianresource.xml
this number will likely increase to test new features, breaking this test. Check that there are at least 4 tools, 1 from dockstoretestuser2, etc.
Please revert this change.
I think we could probably run into the same issue as in #5566 in this line. Maybe checking ! TextUtils.isEmpty(mediaId) before attempting to run it through Integer.valueOf would prevent it
How about adding monitoring.broadcast_interval_ms to StreamsConfiguration and parse/load during setup?
Now that you have cached keyBytes at the instance level, can we get rid of the local keyBytes byte array?
You can use Objects.equals() and save the null checks
Suggest using an executor vs native thread creation.
Add a check here to verify that the serialDataReceived method was not called.
Nit: Capitalize F in "falcon" in all the occurrences.
I think this sort is not in place on master, would be good to send this PR in there as well.
At this point, why not make these registrations method calls instead of repeating the same field access over and over again with the same strings being used?
throw NPE
We should pass the compensation context when calling this command
Hmm I think you forgot to push the change here :)
Better to use the Map type for the declaration. And the diamond <> on construction should work. So I suggest Map<String, String> requirementsValues = new LinkedHashMap<>();
Since isDClassInitialized actually should hold whether or not initialization worked, what do you think about trading dclass_index!=0 for isDClassInitialized ?
An undeclared exception type should always be wrapped with UndeclaredThrowableException.
If there is an interrupt, the thread will not wait for count down of the latch and proceed. It would be safe if we assume that thread interrupt can suddenly happen.
same here, why not use flavored classes to do this instead of Class.forName based on a build flag?
Might have been more readable to simply use a mock Callback?
not required, but fine :P
tosca.template.id should be a constant in ApplicationSpecsBuilder. (There are two mentions in this PR and three existing.)
don't we have two separate arguments for log file and log level? why do we create relationship between them?
exsusts abd hem.... (typos were not there in the original exception)
1. Better to log it in warn or error level instead of info? 2. Typo, Creat -> Create. Better to have full sentence e.g. Create SFTP connection was failed: {}?
In this case the isEmpty check is redundant I think
Maybe call this once and store into a variable since it is currently being called multiple times.
If we store the IdTokenProvider rather than GoogleCredentials, we can implement this whole thing as: java return idTokenProvider.idTokenWithAudience(targetAudience, options);  I would expect the idTokenProvider to know how to refresh itself if possible.
If there is no SAN list in the cert then this would return null which would lead to an NPE. Need to add a ... !=null check and if null then skip SAN validation.
Well, you just verified three lines up that authentication is equal to ACL.SYSTEM so this seems redundant to me.
break?
Do we need this check. groupName starts with dn + "/" so lastSlash will never be -1. Please correct me if I am wrong
Changing from false to true is even more breaking. We need to avoid it unless we can really prove that it's safe.
Also, when inserting a MultiTree, you need to set the 4th arg which is the container instance on the page, e.g.:  new MultiTree(pageId, containerId, contentletsIds.get(0),"uuid-1");
The block of if...else if...else if... is hard to understand. I see you were trying to parse the jsonpath specification by your self. Can we avoid such a implementation? Or could you please explain a bit how it works?
This should be promoted to static or an enum or something
instead of return, make it an else
Is this range meant to be hardcoded?
it would be more clear if to put here instead of system.out some assertEquals and check either it equal to expected string.
isEnabled() not needed for simple strings.
I think it was better with the old static imports.
Please add error handling. We should not crash the whole service if the input is incorrect
Don't think it's a good idea to have two RepositoryManager classes.
Oh! I really have a bad memory... <LINK_0> Never mind.
Didn't see this earlier, but it should probably be deleted.
This statement could be moved to outside the then/else blocks (it's done always). We just need to invert the expression (and delete in the then block).
Oooh, the "exception message affects control flow" isn't limited to test code! This smells.
this should be error level, shouldn't it?
This is the wrong index if the method parameter 'columns' is not in the table's creation order. It can cause a returned string to be blank for a column that is visible, if this method is called from getItemStrings(ITmfEvent).
This is java 7's feature. We should use old convention because not all users upgraded to jdk7. So, please change to  try { ... } catch (JSONException e) { mListener.OnError(e); } catch (IOException e) { mListener.OnError(e); }
How about create toJson in InterpreterSetting.java, so that you don't to create toJson in Dependency and InterpreterOption ? I believe we may need to serialization interpreter setting elsewhere, although now we do it via InterpreterSettingInfoSaving, but this is due to legacy reason. We should unify the serialization of InterpreterSetting.
Strings "Level1.fofn" and "Level2.fofn" can be factor out (static or within the test) to re-use here and in the returned array.
Should not have to throw these exceptions
afaik best practice for apis that return collections is to return an empty list / map / set rather than null; can we do that here?
debug/trace/remove?
typo => create
@tmjee There is not a big sense declaring one-time variable (especially with such names). It's better to inline them all and put checkstyle suppression.
type is still a valid field on files.
positive test is better (isNestedLoadEnabled). I think default should be disabled (for now). Another alternative is to have 'NestedJsonLoader()' which just extends JsonLoader. working through pig properties is not very convenient for many users.
Maybe use specificType.isArray()? And add a SpecificTypeReference.isExpr() and isRest()? They end up checking the type name as well, but it's a bit clearer in the code, and it centralizes such access.
we need to keep public, right?
Could this be synchronised using UITest.waitUntilNodeDisappears? As in waiting for the notification UI to go away. Also, could you see if the tests work with waitOnFxThread?
Please use assertNull instead.
true. We can remove it.
Why not just thisRow-- instead? Clearer that you're just subtracting 1.
Worth a warning somewhere Incase both CPU and vcore set?
I'm confused; why do you think we need to synchronize on a [BlockingQueue](<LINK_0>
@leexgh personally find it easier to read when getTranscriptConsequences() is assigned to a variable and then used in this null check and subsequently to iterate over instead of calling the same method twice
it wouldn't a bad idea to set this as parameter, eventually someone might need a diff charset
Typo: has
These asserts don't look quite right, a translation flag in a test string, now two copies of long verbose strings that would need to be kept in sync or tests will fail. We should probably find another way here.
Is this needed?
This blocks, so it isn't async, you could just remove the future and call the code inline if you want to make it eager.
Can we first try with StandardCopyOption.ATOMIC_MOVE then fallback with no option?
What about OperationStatus case FAILURE? There are other retriable exceptions other than RegionTooBusyException, aren't there?
nit: consider prepending "I_" and "D_" to names
Wouldn't we want the old plug-in configuration to remain in the plug-in config history page of the resource? It seems that a configuration update/merge would not result in an orphaned configuration object. Granted, if the configuration object has no associated configuration parameters, I would consider the update to be strange/broken.
Could you apply the evidence/other info assertions in these tests as well?
@Arthur236 did you intentionally leave out the first three lines in the original save method of the emrapi module?
looks like a constant
make StoredWorkdlowDefinition.State implement Comparable?
would be better to extract the condition in a separate helper method
Check for isEmpty instead.
These printed messages should be cleaned up in both samples.
It would be better to do it inside org.carlspring.strongbox.services.impl.ConfigurationManagementServiceImpl#saveRepository inside modifyInLock block
Let's add to VmMapper a method that maps: (restapi) VmPayloads--> (backend) VmPayload Then reference it from here and from BackendVmsResource
I don't think this'll fix stuff, because foundMatchingRule will still end up false and the alerts will still get triggered. We should bail out and not do anything if the leader generation is wrongy. Also the startingLeaderGen should be set upon commencing running of the runnables, since if not then we still have a race here. The runnables could start in general, leadership could switch off/on, then this particular runnable could run and it won't realize it is actually part of an aborted leadership run.
as first partitioning can be null, but the 2nd one can be DEFAULT_PARTITIONING, I believe you need to check both values before returning.
The Exception is never thrown.
final . CacheStorageImpl cache -> CacheStorage
The filter().findAny().isPresent() chain can be replaced with 'anyMatch' It avoids creating redundant temporary objects when traversing a collection.
This seems like it's going to make this pretty hard to debug if there are any issues
I suggest putting this if statement after computing all (line 613) since previous computations are redundant if this is true
Should subclasses be allowed to override this method?
Would a NOT_FOUND be more helpful?
Please put all the setters underneath each other for better readability.
[minor] Move this to directly after Files.delete, for clarity?
can we remove the explicit setting of purgeLessThanEqualTo?
Can you move new code to a separate method?
even simpler: message = validateGroupIdInput(pomComponent.getGroupId());
I think it makes the code cleaner and short if you don't have the function call and just have two if statements like the following: if (args[0].getTag() != ValueTag.NODE_TREE_TAG) { throw new SystemException(ErrorCode.FORG0006); }
Wonder if we wanna put this check only in isLowMemoryMode just in case we may miss something and give false alert. For example (the metadata reader strips out string stats when min/max = null causing different hash result). So it won't affect production runs
This is a concern to me as it overwrites the value of Value and as such due will no longer work.
What about a return if this is true. This is what happens anyway and you do not have to indent the whole method.
add verify or assert
Don't we have to stop it?
The process has been killed.
<LINK_0>
checking this (and subsequent) changes to the conflict detection manager are intentional - looks like these tests are still passing, but would like to verify this
Pull in master. I've merged in a change that has the Budget constructor taking in a LocalDate instead of a long. Then you just parse the "start_date" string with LocalDate.parse(String, DateTimeFormat) as seen in fetchBudgets (after the merge) and use that.
Should this be initialPort + portTrialCount - 1?
Name generation and validation should be moved to service layer
Like with the OutputFormat, I think this should be done as soon as possible in a method that is called to setup the job. It looks like createRecordReader might be a good place for this in the InputFormat. We definitely want to avoid setting the default configuration in the job client process.
Please rebase on top of latest master, this is related to recent changes in <LINK_0> if (host != null) { event.setVdsName(host.getName()); }
Not crazy about having to do this null check as it may cascade to a lot of places. You may be able to create a PhoenixConnection from IndexMaintainer if need be.
put the magical constants into real constants pls :-)
To be more explicit, should we throw an error here if "clean-on-flush" is specified without neither "flush" nor "flush-size" being present?
The single-step probing used in this method for updating the local association cache gives me pause. I can envision situations (for example, some other client has added a batch of complex cache objects that are composed of Java objects new to the cache) where many failed puts would be required before the local copy of the class associations is synchronized with the server and nextStreamIndex accurately reflects the server state.
Add another relationship with a type outside of the characteristic type hierarchy. The rule should NOT report that as an error.
suggestion .filter(slaveInfo -> labelName.equals(slaveInfo.getLabelString()))  should avoid the null pointer exception.
What about properly remembering original value and putting it back after tests?
How about turning drawGlyphVector into drawComponent and just pass down the component instead of spreading the metrics computation around?
Indentation here seems a bit inconsistent. Personally I'm fine with the style the way it was (with leading periods) but in both cases the indentation seems off (4 spaces instead of 2)?
Delete ____TS as your method name already tells the story.
use constant
Sorry I was wrong before, after checking the original bug and talking with Eric, the version guard should be >= 3.20.0.
Just use forEach
Could we initialize the ExchangeUriChecker instance in a different line, It seems too much for an if condition
Can you move this code inside the if (isResultSet) so the headers is only pass through if we set some data because there was a result set.
combine if clause
It doesn't seem like you're popping the cause after pushing. You need to ensure that the cause stack is stack neutral after the method is completed, so either popping the cause, or wrapping with a try with resources on a stack frame.
nit: streamId
Note that in order to be sync'd with the rest-api, the "SIZE" text should be mapped to the "size" property (instead of the "actual_size" property).
Just curious. Why we set the visibility of footerLayout to "VISIBLE" if it does not set to "GONE" in view_wiki_error.xml
Nit: can we make this a constant?
We should be using TimeService.
This is just a failure in parsing the timestamp and it doesn't affect much. Message should be modified accordingly.
this database query executes, and does nothing. did you mean to return its result?
as with the other suggestion I think you could unify something here. i.e. move both cases into one if block that checks if the user is in the ScriptFragment and then go from there. this would make it easier to read the block. alternatively you could also just introduce a boolean variable for the condition getCurrentFragment() instanceof ScriptFragment && ((ScriptFragment) getCurrentFragment()).isCurrentlyHighlighted() so that both conditions stay separate, but look similar. you can do whichever you prefer :wink:  if (isScriptFragment) { if (areBricksHighlighted) { ... } if (dragAndDropActive) { ... } }  or  if (areBricksHighlightedInFragment) { ... } if (dragAndDropActiveInFragment) { ... }
_Minor_: somehow I find it weird to keep a lambda here when the other cases delegate to an actual method.
Component type for the inactive device exception should be DOMAIN_TARIFF_SWITCHING here.
Is it necessary to introduce dependency on Sets?
Would it be more broadly useful to have a boolean getter on Operator indicating whether an operator had ever returned any results (i.e. nextReady() != null)? If that could be reused elsewhere, it would be better than an ad-hoc flag.
Probably should assert that linkIterator.hasNext returns correctly here.
spell out buffer
I think you should factor out the common code this test shares with the previous one
Should add parentCommandId here since hashCode() now relies on it
Does it matter that we no longer increment the second parameter?
Is it fine to have less bytes than the optimal if optimalNumOfBits % 8 != 0?
No need to make this default in a test actually using per workspace services.
the method can declare "throws URISyntaxException, IOException" and the extra try/catch/log can be removed.
The enable and disable diversity code seem pretty much the same apart from minor things. Is it possible to optimise the code?
This defines what we are migrating from, and we are migrating from boxc3 data which currently uses the Normalization event, so you'll need to leave it as NORMALIZATION in this case. We would only need to change the event type as it is stored in boxc5
Most important is to create elements with the same XMI-ID as the elements in the fragment. Elements are compared by XMI-ID, not by element ID
@landreev and I talked this out in Slack and decided to go with switching from created to ok in 471dd25 (which is how this pull request started.
Someone else has come up with a similar solution. I'm not sure it's the way to go - what's special about 1000ms?
no need to break line
What if the id is not found? It would be better to have protective code instead of creating a connection to "http://x:-1/killexecutor".
maybe you can do a getAll here and assert the returned list is empty just to cover the basis.
address was nulled out above. maybe move physicalAddress up above
This code is unreachable because Assert.fail() throws an exception.
assertThat("Notification Type", orderNotification, instanceOf(OrderStatusChangeNotificationPayload));
if authorizer is null, then we should put a warn log. LOGGER.warn("No authorizer is configured for '{}' app.", appName);
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Inline to avoid the reassignation? this.metadata = metadata == null? Maps.newHashMap() : metadata;
We are not really using CaseDbTransaction here for anything, are we?
Don't just throw Exception. This is too general.
Is RuntimeException the correct exception to throw? Can we provide more information in the message?
notificationButtonView.setVisibility(showNotificationButton ? View.VISIBLE : View.GONE) seems more safe to me in case setErrorMessageUI gets called twice with different values for showNotificationButton
I see that Spring-Cloud supports only the single role per candidate, but should we really be restricted as well? I mean comma-separate value for the role attr and array value for the @Role. I don't understand the promise of this feature yet. So, let me read your second (docs) PR on the matter!
This shouldn't be this way. In tablets in landscape mode, when a file is shown in the right pane, the options for the current folder still make sense. Please, undo the changes on this file. EDIT: I see your point now, these options are shown also in smartphones when FileDetailFragment is filling the full screen, that's not fine. The safest way I know to differentiate what's the current state is the resource large_land_layout; can be found in the file bools.xml, in two versions: one contained in res\values , with value false, the other in res\values-large-land, with value true. Please, modify this patch so that the options are only hidden if large_land_layout is false.
I wonder if we should have a better error message here. It seems like a SQLException here means that one of the objects listed in the uri-list is not found.
It depends on how it is accessed by concurrent writers ie handleResponse and add could be accessed by different threads concurrently? Dealing with concurrent accesses here could be dangerous: If multiple threads are accessing concurrently Packet[] and the references are not padded by 128 bytes (ie 4 object references between the Packet references in the array) the cache won't scale due to false sharing
This is a good example of how the original way of using indexes to access the list is better for performance.
Maybe use OtherThreadRule class? It allows running things in a different thread and has ability to check thread state.
Given the text, this should be outside of the loop
Should this not be && previewSlideshow != null, not ||
@dgutierr - same here, try to avoid external iterations as soon as possible and do an incremental replacement by internal iterators / use of streams...
I'd move this to a method (create storage domain) that accepts the three arguments and replace all those creations with a call to it.
Why is a logger in the upper case?
Any better way to check if the text is a valid URL other than converting it to string?
suggestion log.debug("It took {} attempt(s) to find {} open WALs", attempts, open);
This can be a List
Remove this empty line?
This case is impossible AFAIK. Shall we throw an error instead?
Can we move these strings to variables? And reuse everywhere
Why not using the same try-with-resources block for in and out?
Not sure about all the usage, but if all test code is passing null, we can just remove this parameter from this constructor.
This line should be removed. Given that ITs pass I guess this is not covered by any test, could you write a quick one John?
Nit: might be a display of better craftsmanship/readability if you could explain why you're adding 1 here. I believe you're just trying to use a value that's not 40?
It looks to miss null handling.
this should take in the keeper org's OrganizationInfo, and the duplicate's ID. Looks like we're passing in the duplicates OrganizationInfo as well as the ID.
Replace the lossy conversion with a static util function. failWithInvalidConversion(Class<?> class, BigDecimal bigDecimal);
That's a massive chain. It's fugly. Not sure it can be made less so though.
only link detailed report, please :)
encapsulation
just wonder why only for DB Scheduled scheduler the existence of the class should be examined ? either it should be able to resolve the correct class by the value set on that map, or this logic should be applied for the simple scheduler for consistency.
We do have to copy, otherwise the view might change when someone calls the method again
Let's use lightStatusListeners.isEmpty() :wink:
We have a potential NPE there unless we can do it?
nit: Fix indentation. Also, what is this change for?
Hmm, so I thought about this when doing the initial implementation. I avoided using any timestamps from the node running this since then we're susceptible to time sync issues between the database and the host running the connector. And that is unfortunately pretty painful to unit test for correctness. Is it possible to rewrite this to do that computation via the SQL statement?
You can make this an "else" after the "if (forEditor)" block.
Is there a reason we aren't linking these up with the @UiElement syntax? Would save a minor amount of code. I assume it's because the Locale strings are required? We have a 'fallback' path that uses Locale strings if availalble, and then on-device strings if not, which would probably be helpful, especially if an app was successfully (or partially) seated, since that way users can see those recovery actions translated.
Consider using a HashSet instead of an ArrayList - this way you don't have to do the contains invocation in the if clause because sets don't allow duplicates.
You can use Predicates.equal here
Find English word for Dach in mathematical symbols
Same here. The true should probably be encoded in the method name.
The code should also be modified to not have an empty if.
Can endpoint.getParametersMap() be null? If so, shall we do a null check for that too?
I think we could get the same effect without as much repetition, by writing functions called 'isOctalOrSeparator', 'isDigitOrSeparator', and 'isHexDigitOrSeparator', and using those functions instead of 'isOctal', 'Character.isDigit', and 'isHexDigit' (respectively), while otherwise leaving the loop in its previous form.
Shouldn't it be in onEpochFinished?
generally try to keep HubSpot-specific things out of Singularity, even for tests ;)
Allocating a new buffer for each read will have visible performance consequences (this code is key to most benchmarks against shapefile data), please undo this change
nit: add string message (containing checkpoint id for easier debugging).
I think that it would be worth doing a logger.warn() after this line if someone tries to "useEpoll" but are not on linux. I'd further add a logger.info() to indicate the event loop ultimately used.
Inline all the requireNonNulls in a separate commit
I would call the related method instead. (E.g. call hash(int) for Integer).
See previous about IN vs OUT
closing the file?
You should already compute the qualified names here in order to not stream 3 times for the same data: java Set<String> symbolsQualifiedNames = getContext().symbolTable().symbols(node).stream() .map(Symbol::qualifiedName) .collect(Collectors.toSet()); isUsingDjangoModel = symbolsQualifiedNames.contains("django.db.connection"); isUsingDjangoDBConnection = symbolsQualifiedNames.contains("django.db.connection"); isUsingDjangoDBConnections = symbolsQualifiedNames.contains("django.db.connections");
This one should be called after onComplete.call().
It doesn't look like this test tests anything.
We should take setEnableASCIIOnlyStrings as a dataprovider param
It is better to pass serializer here
The PathManager should be used for this sort of thing.
Are those jacoco methods by any chance "synthetic"? If so, please simply filter out synthetic methods instead of checking if the method name contains "jacoco". In any case, please go ahead and push this to master since it is not related to this PR and should be adopted ASAP anyway.
Should move the instantiation of USReceiptItem outside of the inner for loop, this will construct it when the entire entrySet has been processed and will churn a lot of short lived objects.
Or old-style positions.
use Collection.emptyList() instead which is type safe. Will the unit tests cover that we handle empty list properly?
Should this be startTarget + 1?
line 109 till 112 are the same in both updatePlayer1Button and updatePlayer2Button and can be put in a different method.
What if partitionWrapper is null? If not doing anything, remove if, NPE is better than skip silently (I see couple of places like this).
This may likely break in the future if the config becomes unparsable. See GoConfigMigrationIntegrationTest, but basically you'd do this: java String migratedContent = migrateXmlString(configXml, 126); CruiseConfig cruiseConfig = loader.deserializeConfig(migratedContent); Approval a = cruiseConfig.....getApproval(); // perform assertions on a  Alternatively (a lot lower chance of breakage, but if something breaks, much easier to change): java Approval approval = xmlLoader.fromXmlPartial("<approval .../>", Approval.class); assertThat(approval.isAllowOnlyOnSuccess()).isEqualTo(true);
Should we just wrap this whole method in a local transaction? I am asking becuase what happens if this method is getting called in another API that has already started a transaction?
When executed alone it takes < 300ms (a lot of that could be overhead in the framework though). Makes sense to lower the max though just to verify the behavior in tests though :+1:
It doesn't seem to be a typo.
By looking at this, maybe another good metric to expose is in average how many opaque entries are sent per message... opaqueEntryList.size()
debug level?
Maybe you can add also check on Group-Resource.
Copying from.startDate instead of from.completionDate
if startOffset is negative here, this should return false. In other words, it is always impossible for a string to be a suffix of a shorter string.
Do you really want it to throw IOE?
It's a minor thing, but I'd say it would be nice if instead of true, you'd have a constants LOCAL_MEMBER in this constructor.
I'm hesitant to use empirically tuned unitless multipliers to keep the isochrone edges from extending out into the water. They would probably work in one place and not another, and seem to be prone to overflow. Also, because they are pre-multiplied into the distance we lose information that could be useful for dynamically applying speed or distance parameters during routing. It's also hard to justify why speed would change at some predetermined distance - if we consider a cell within reachable distance at all, how do we know where the hypothetical walking path to that cell ends? Instead I think we should just limit the linking distance, then apply the same walking/biking speed across the full length.
what about an @After that stops the scheduler, closes the log etc?
How does this.chunkBody[this.chunkPos++] evaluate? Does it return the value at index this.chunkPos before the increment? Is it non-idiomatic to do the increment and indexing in separate statements?
I would add a new constructor call to check that we are new raising issues in newClassTree as well.
column headers is first line and not line after skip. column header Must be first line.
we don't search for primary email anymore
Please use sl4j logging to format the message instead of StringBuilder.
Shouldn't the suggestions be returned here? It looks like this method always returns an empty list.
This whole test should use Core API imho. Or if we really want to test the cursor it should live in kernel API.
It would be better if the storage name is printed with this exception.
- no magic numbers: what's -0.80f? - you might want to store the result of getPlayer() somewhere, so that you don't have to get it through the context every time this method is called.
I think this change may not be correct. The spec says that for AES_128_CBC_HMAC_SHA_256 the input key must be 32 bytes, and the test in JweJsonProducerTest.testMultipleRecipientsA128CBCHS256GivenCek is passing in a 16 byte key hence the error: "The input key K is 32 octets long." <LINK_0>
Here we should ask the user, where to save the file. One thing, we did not consider yet is the file extension (not every driver outputs gcode). To make it perfect, the driver should give the file extension (e.g. via a method getOutputFileExtension())... but right now I could live with ".dat" or something like this.
the method name is isLambdaParameter, but the return variable is returnValue.
Why force JPEG? Webp and PNG are also possible.
prefer isEmpty to test emptyness :)
Needs quotes to be added around deployCmd.getAbsolutePath() otherwise it fails to find the executable
Are you sure these any() calls mean what you think it means?
Nits: 1: Space before %s 2: 'view index table' or 'view index'? 3: deleteall instead of 'Delete all' to match the option name 4: Do we use indexes here or indices?
You are always overwriting the configuration here? What if the user has already manually configured a username/key?
Please use slf4j parametrization instead of string concatenation
This is already implemented on iOS. Check out: <LINK_0> Please use the same name rawData instead of rawValue. What happens if the barcode does not contain a raw value? Will putString result in rawData being null or will the application crash?
A bit more optimized would be using Stream::findFirst. For large sets, it stops immediately when it finds the item, instead of iterating over the whole set. This solution of course works too, just an optimization.
we can get to this block even if logChannel is null. so add that aswell to the reason string.
Is the C supposed to stand for Celsius or would this make more sense as "temperatureF" or "temperatureFahrenheit"?
This test case has the same description as one already implemented. Try and think about what this new test case is doing that the other isn't already and rename accordingly.
This should use the JFace shared text font which is configurable by the user in the preferences and defaults to a platform-appropriate monospaced font intended for use in text/code editors. See the JFaceResources.getTextFont() API.
I don't think we have to worry about / support the case where the call to super has mucked with jedisPool (it's deprecated), in other words can probably just eliminate the null check here.
Assert it
Should this be "Unfiltered"?
This implementation sounds very complicated. And doesnot seem efficient. Esseentially it is a solution prior to Java 8.
I thought about throwing a fetcher exception as well. But on the other hand we have optional for those cases. So I would not throw an exception. @tobiasdiez
This should not be here - it was replaced by CommonLogger.LOG.archiveIsolationEnabled() / CommonLogger.LOG.archiveIsolationDisabled()
Do you have to reset the matrix otherwise? I.e. does this work if you switch from a complex to the circular case?
do not set the correlationId for the request. It is only applicable for the reqeust of the response.
This change is completely unrelated to this PR. Any particular reason for adding it?
I don't understand what this whole check is about.
Please add a space before and after the +, to be consistent with the rest of the file.
/NakadiException/Exception/
This if-else is very readable and I'm not asking you to change it, but for fun and curiosity I'll note that countOfAreaCodesForYear.merge(year, 1, Integer::sum); would've done the same thing.
unnecessary boolean field. just call the method inline below, the variable doesnt add any value for the reader since it literally has the same name as the method.
zoomOutEnabled = true; without if will do the same
this will be a little bit flaky. there will still be a small chance the thread set to interrupted state after downloadAllServerChanges(). Actually the interrupted state can be set inside the current thread. I think just call Thread.currentThread().interrupt() before the downloadAllServerChanges() would be enough and we can remove the latches.
We don't need to print the full stack trace if we're catching exception that we threw in this very same function. I'd prefer to use blocks like:  if(sample==null) { LOG.warn("{} is not in the JEXL context. A NaN value will be used.", sampleName); return Double.NaN; }  instead of throwing/catching new exceptions.
Unnecessary whitespace?
This check shouldn't be necessary any more as we are using an enum
What's the purpose of FAIL? I don't see anything in the tests below that checks for this exception to occur. I'm confused by the fact it's an IllegalStateException (vs a specific exception that can be tested) and the generic message.
missed this?
The class is named EchoApi but here you use ECHOApi. This code won't compile
do a StringUtils.isNotBlank(...) check before setting
@unyoungwax, are we able to make this private too?
Can you please use @InjectMocks instead
Is it something that you write by hand or use "generate equals/hashCode" in the IDE? It is strange that you consider "different class" objects to be equal.
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
Is this here for testing? We might want to use some logging library
I don't think you can be sure that the server returned the content in UTF-8, use the content type from the response instead.
Is there a race here where one query is killed an the other finishes immediately, so the general pool reservation is empty?
Same here. Assert.assertEquals(patientEntities.get(0), expectedPatientEntity2);
<LINK_0> it looks better to mock LogChannel and check whether mock logBasic was called, not getException from entry
completeStructure doesn't do anything anymore, still needed?
null check?
did you mean to get the name?
Keep indentation as it was; no new lines after blocks. More at <LINK_0>
nit: I think this'd be more intuitive/straightforward if expressed as: java if (isLeaderEvent(event) && !isLeader) { _log.info(...); return; }
You might want to store the view as a field in your class if used multiple time. findViewById has a non negligible cost.
I think it looks good now. Just change 100 to args.hits.
Should this and other numbers be assigned a constant with a meaningful name to identify how they came to be and for future maintainability?
Rename to numberOfMissingFiles, missingFileCount or something like that? Using both missingFiles and filesMissing (for completely different purposes) is a bit confusing.
We cleared it here, later only time we change it is where you add locations. So numberFound==fTagLocations.size() I don't see how its possible that this is not equal
I would call this "tableCount" and do also make a equals to 1, since you might encounter schemas without tables.
Please use parameterized logging here.
Strictly speaking, that is not robust, as it would also break the outerloop if there is a fastening element within a fastening element. I know, this is very unlikely, but the correct idiom is to break if the depth equals the initial depth, which is given as argument to the parse method. In order to avoid other patters being used in places where it potentially matters me, we should simply use this one pattern everywhere.
Ironically, this is only painful for the open source servers. Basically everyone other than me. I can rename a field pretty much at a whim, provided the column ID stays the same. Which it does here. :-)
So, I think we can miss this bit out?
You should have the same treatment here, the operation saves 2 disks in the same SD
You could also use ImmutableMaps.Builder<String, String> envMap = ImmutableMaps.builder() which might be nicer than wrapping your said map in the collections unmodifiable interface
why is this final and the rest are not
Not important at all, but you can just return jobDate.after(searchedTimestamp) directly.
A bit nit-picky, but I'd fix the indentation here and give the variable p a proper name.
This line needed to be reset every time? Looks out of scope for this method.
ProtocolAdapterException is not thrown in method. Could be removed
Please reverse the if condition
Investigate on why we need hashCode for this class.
ditto about message
Need spaces after the 'if' here and above (and remove the space after the parens)
Can you just do new JSONArray("{" + registrationID + "}") or something
There is an issue here. Since this updateCloudletsProcessing is called multiple times, the number of free PEs will keep decreasing, even if no Cloudlet has finished. You can implement like this: java long usedPes = 0; for (int i = 0; i < cloudletExecList.size(); i++) { ... ... ... usedPes += cle.getCloudlet().getNumberOfPes(); } vm.setFreePesNumber(vm.getFreePesNumber()-usedPes);
doesn't uniqued imply sorted?
java8-isation [forEach][methodReference]
This check leads me to expect that getOrderedPropertyValues will return null if the node does not have all the properties required by the index, but no such check seemed to exist in the getOrderedPropertyValues method.
This method will be executed although parameterValues0 has elements, won't it?
Anything to worry about if an exception arises during handleMessage()? Right now that would cause any other messages in the same batch to be skipped
setErrorMessage
Service can be injected.
Test is not working properly (passes whatever value the timer is updated: 10, 2, etc.) slaViolated is always false due to count of the latch never reaches zero, because countdown method is not called.
Since only expectedConceptEntity1's uuid matches, why is expectedConceptEntity2 listed here?
New line
INFO message is a bit confusing, maybe something like "Configuration is not clustered, clustered locks are disabled" or something like that.
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
I think is clearer the defensive approach:  if (requestCode != Shared.REQUEST_CODE) { ... }
This means it will NOT be CACHE. Is that what we want?
Can we have this as below as created instance is not used else where?  new CustomProcessorInfo().fromTopologyComponentBundle(customProcessorBundle);
This could be a one liner if you never need to access date or time again.  Timestamp now = new Timestamp(new Date().getTime());
Should we make this method final? I think it is used to be called by sub classes, not to be overridden?
typo
We can't do these like this - this convert every bit of the buffer to a string, even if trace is off, which will be a big performance overhead. I'd suggest we do this the same way you did it with the Input/Output streams - introduce classes that implement WritableByteChannel/ReadableByteChannel, and can wrap the regular channels. Then, when we create the real channels, we do something like:  if( logger.isTraceEnabled() ) { input = new LoggingInputChannel( logger, input ); output = new LoggingOutputChannel( logger, output ); }  That way, we don't have to intermingle these log statements with the rest of the code, and there's zero overhead if trace logging is not enabled.
the problem here is that you're using fixed ids for the child processes, that won't work when persistence is used. Try something like this: suggestion Collection<ProcessInstanceDesc> instances = runtimeDataService.getProcessInstancesByParent(parentProcessInstanceId, Arrays.asList(ProcessInstance.STATE_ACTIVE), new QueryContext()); assertNotNull(instances); assertEquals(2, instances.size()); List<Long> processInstanceList = instances.stream().map(p -> p.getId()).collect(Collectors.toList()); processInstanceList.add(0, parentProcessInstanceId); processService.abortProcessInstances(processInstanceList); ProcessInstance parent = processService.getProcessInstance(parentProcessInstanceId); assertNull(parent); instances = runtimeDataService.getProcessInstancesByParent(parentProcessInstanceId, Arrays.asList(ProcessInstance.STATE_ABORTED), new QueryContext()); assertNotNull(instances); assertEquals(2, instances.size());
Might as well use log with debug.
You should toLowerCase the material name.
how about removing setInstanceTypeId(..) (and the class member maybe) and then drop the second part (vmStatic != null) ?
You could remote @SuppressWarnings("null") for the whole method implementation using e.g. Java final InetAddress address = cidr.getAddress(); assert address != null; // NetworkInterface.getInterfaceAddresses() should return only non-null addresses interfaceIPs.add(new CidrAddress(address, cidr.getNetworkPrefixLength()));  WDYT? I am not a friend of supress warnings for the whole function. An assert should not change anything on runtime as they are default deactivated.
Also probably need to do difference on taskId instead of task object here as well, unless we make sure each Task has a proper hash and equals.
Isn't it simpler/nicer to create two static listeners in advance and use them accordingly?
When you send a PR don't rename a method and add changes in the same commit. It makes it harder to figure out where the important changes in this commit are
I am a bit confused by this logic. Why do we need to cleanShutdown only when it comes to testing? Also, we register the shutdown hook earlier before the while loop? Will it kick in on system exit?
I was not thinking of something dynamic like that. Given that the other parameters are not dynamic, Can we remove those replace and just have the default prefix?
It would be useful log a warning if the method has any annotation but is non-public. It will let the users know that the visibility of the method is the reason for ignoring it. Same for field too.
![MINOR](<LINK_2> 'Severity: MINOR') Remove this unnecessary cast to "StringTerms". [![rule](<LINK_1>](<LINK_0>
can we make this as warn
Can you instead fetch this again with diagnosisService.getDiagnosisByUuid()
Oops?
what if "_" string is part of the path?
As I mentioned in the previous patchset, while this should work due to type erasure, I think this cast is rather confusing because you're not actually casting to BusinessEntity<? extends Guid> - you're casting to BusinessEntity<?>, as you don't know in run time the generic type... Won't it be more correct to instead call: Object id = ((BusinessEntity<?>) entity).getId(); ?
1. If the user wants to delete the kit, they want to delete the kit. I don't see why they shouldn't be able to delete the kit just because they didn't add it via pastebin. 2. Always use translatable messages.
rename to child
Again, should check response code.
I don't really like this. I understand using a filter/concat/take wouldn't work if we want the favourite IDs to be a hot observable, but this seems wrong too. @Dorvaryn any suggestion?
You should use Bl layer to prevent unnecessary nested transaction creation. Like this: ((PerunBl)ldapcManager.getPerunBl()).getAttributesManagerBl().getAttribute(...)
This will end up in the users logfile who does not know what this is... Either change the severity to debug or if you want to let the user know so he can report the error, please give a description what the exception mean in this context. This also applies for the other exceptions you are catching here.
We should never catch Throwable. We should change this to Exception.
Can you swap the conjuncts, i.e (protoInfo == null && ...). This way in case protoInfo is not null, configuration fragment is not required. Probably it would also be best adding requiredConfigurationFragment to the RuleConfiguredTargetBuilder below.
Notice that what you call "fileFormat" in the classes undeline is not actually a format -- it is file extension. This kinda smells. I suggest creating enum SpreadsheetFormat with format ids, use its values in FileTypeOption and pass enum value to save
This validation will be better implemented with findAny, we dont need in this case to know the number of invalid notes.
isNullOrEmpty ?
oops
In all these checks, why not just compare to a list? e.g., in this case:  assertEquals(Collections.<String>emptyList(), clazzNames);  You could also use Arrays.asList for the other tests that actually have items in the class array. Also, you're not calling any asserts here, so the test isn't really testing anything.
Couldn't this call be more fine grained? It sounds weird we need to run all the configure code in a privileged block?
@arunmahadevan My bad. I closed the other PR thinking you had also updated LinkedHashMap to ImmutableMap in convertValue method. But here I see only doDeserialize being updated from LinkedHashMap to ImmutableMap. Can you please update LinkedHashMap in convertValue method as well in this PR?
Better to keep a map of (delimiter -> splitter) to avoid creating a splitter per key.
remove this change
should this do something like } else { warnTmpl = "Pack file {0} now inaccessible; removing it from pack list" } ?
If newValue == oldValue I think we shouldn't call the notifier nor update the entry.
java for (String msqChoice : msqChoices.size() {
misspelling
It implies that the file is being read lazily by Netty to apply the zero-copy transfert, but it means also that we need to be sure that the file won't be moved or deleted util the zero-copy transfert will finish
I don't think you need to call serialise anymore when you've got proper DTOs to return - should be able to just return the DTOs directly and let it serialise itself.
4 -> SIZE_WKID
Here we're actually looking for stars count...
Could use var here too. :smiley_cat:
is the null check still required when you turn around the equals call?
- How is the max depth related to "adding follow symlink option"? - Why do we need to restrict the depth of the abstract watch service? Isn't it a specific usage if the depth is limited to a specific value?
How about we print out the actual values of the arguments here?
A better name would be "saveButtonEnabled". When it is true the button is then obviously enabled, when it is false it is clearly diabled.
The !query.getContextBoolean(ScanQuery.CTX_KEY_OUTERMOST, true) needs to be flipped to just query.getContextBoolean(ScanQuery.CTX_KEY_OUTERMOST, true)
this code should go to onSaveInternalWithModel() method. And since there it is not a multipleAction, you can avoid the .get(0). call.
nit: hConf.set
Since this can return null, you should add the @Nullable annotation to the method.
Please, proof-read your code before submitting PR. You probably meant something like "lindad".
You could use one of the existing care settings in the test dataset
Encrypted password matches regexp and regexp require 1+ symbols in each group. It looks like NULL checks are not needed.
consider moving the if to the addVmCinderDisks method.
maybe remove wildcard import javax.swing.* ? I know IDEA adds it automatically but there must be a setting for that (let me know where it is ;)
Minor point; ignore if you want -- this L435-437 block duplicates L423-425 and could be dropped if this entire new code block from L426 was moved above L423.
Yuck to auto-generated hashCode and equals methods! Understand that it required less code for you to write, but it's certainly more code to maintain. I like return Objects.hashCode(additionalOptions, commands, hardware, hardwareId, ...)
not the same code style. use ("save.file", true);
double-conditional?
magic constants
How to process the version like 1.11? I think it have problem. Can you use org.talend.commons.utils.Version, it implements the interface Comparable.
ScalerFunction is not used?
This seems wrong. It's not about whether the field is an alias, but whether its name refers to a column in the source table (vs a column in the output of a SELECT). For instance, this will probably not work as expected with this fix:  SELECT my_alias FROM (SELECT name as my_alias FROM nation)  my_alias in the outer select will have an origin table, but is not itself aliased. To fix this, I believe we need to track not only the origin table but the origin column for each field.
I know we haven't been entirely conistent, but repeating the writer. reduces the noise of these lines  writer .emitStatement("...") .beginControlFlow("...") // instead of writer.emitStatement("...") writer.beginControlFlow("...")
This appears to already be visible in the XML.
Shall we use a logger?
indentation here is fucked up
Nice error handling here!
IF we go for supporting 3 kinds of test runtime (minimal TP, provision product or pre-existing provisioned product, it would be interesting to factorize installation of tests on a provisioned product: if (provisionInstallation || provisionnedApplication != null) { if (provisionInstallation) { testRuntime = provisionInstallation(); // provision only product } else if (provisionnedApplication != null) { testRuntime = getProvisionnedInstallationFacade(); } ((ProvisionnedEquinoxInstallation)testRuntime).installTestsAndDependencies(...); } else { testRuntime = createEclipseInstallation(DefaultReactorProject.adapt(session)); } Also, we could think about renaming "createEclipseInstallation" to "createMinimalEclipseInstallation" to make it clearer that this is not using p2 provisioning.
If in line 202 we set patchTable in the else block to null, could we then remove this if block? If a patchTable exists it would simply be always visible.
Java doesn't have string interpolation, I assume you mean something like: suggestion log.warn("Could not delete service account user {}", sa.getId(), re);
@Bhavik3 I don't think we should have empty space here, as It should be as close to case as possible
It's going to be slow to do the merge each time we call getDescriptor. I would prefer if the merge result was cached and the cache invalidated if there's a descriptor with this id that's added/removed.
I think the below logic is not very easily to understand and also has some overheads in practice.  if (!sortBuffer.hasRemaining()) { // the record can not be appended to the free sort buffer because it is too large releaseCurrentSortBuffer(); writeLargeRecord(record, targetSubpartition, dataType); return; } flushCurrentSortBuffer(); emit(record, targetSubpartition, dataType);  Here we have to flush current buffer and call emit again to try out whether the unfilled sort buffer can hold the large record or not. During sortBuffer.append it would request all the segments from LocalBufferPool until exhausted before return false to decide flush large record. I think of two options for improvement here. - Make SortMergeResultPartition more light-weight component to only dispatch record/events, then the SortBuffer can decide itself when to append records in cache, when to flush them and when to flush large records directly internally. No need to expose many interfaces to interact with SortMergeResultPartition. - SortBuffer provide another method to expose the cache threshold, it can be easily got from the internal LocalBufferPool. Then SortMergeResultPartition can decide whether to flush the large record directly to avoid unnecessary requesting all the segments.
Should we copy the source stacktrace of the original TimeoutException?
Better: throws Exception since it simplifies future evolution of the code.
Why is totalPartitionIds needed? Could you just use partitionToReplicaMap.keySet() to iterate through partitions? If you only need the map you can just do java partitionToReplicaMap = replicaIds.stream().collect(Collectors.toMap(ReplicaId::getPartitionId, Function.identity()));
You could add instanceof additional check, and return Result.ERROR if failed to avoid ClassCastException
Must check isDebugEnabled() before any debug log as a best practice.
I know why but can you please explain why you need a loader-writer here?
Why would summaries by null when you "new" it up above
Make sure that the order of the pluginInfos is same in all scenarios otherwise Etag will change event if plugininfos is same
Please make this final. A lot of methods in this class should have been final but aren't, but since this is a new one let's lock it down.
Please reimplement with invoking isDot and isForSideEffects on imports.next() object
Or false?
The same piece of code is used multiple times, let's refactor it into a common method.
RequestTranscation  => RequestTransaction  transcation  => transaction
@Happy-Neko Variable type can be relaxed to Collection
This is sensible... If the resource could be deleted without generating a task (200 response) this will actually be null but the delete operation succeeded. We should only do the polling if the URI is not null
Again drop assertion on operation results when expecting resilience strategy to be called.
throw exception here instead
use this utils method to show error <LINK_0>
Should we avoid searching the map 3 times for the "id" entry?
it should use the ctx1
In this case, all keys above should be found in the STATUS_MAP, so it might be more appropriate with a checkNotNull()?
@heejeongkim Why do you want to quietly ignore malformed max-age and expires attributes with strict RFC 6265 policy? That does not look right to me.
This could also benefit from inilne examples (takle the values from the tests)
handle this inside getExceptionsAsList(me), so adding unwanted elements to the list is avoided from the start
you need to add the 'throw' keyword.
is it really necessary to change the return type? copyRepresentation still return a DRep and createRepresentation(final String name, final EObject semantic, final RepresentationDescription description, final IProgressMonitor monitor) returns a DRep as well At any rate, it will break TransientLayerAndDecoratorTest tests because of the cast and you wil have to adapt more Capella code
@psytester can you change it to: String respBody = response.getEntity(String.class);
Please add .setVerifyMode(OpenIabHelper.Options.VERIFY_EVERYTHING)
FIXME: I get "Android System" as an option to choose photos. I don't think that should happen (?)
IMO you should always pass the scanPackageValues to one method and if it is empty check the default package.
probably doesn't matter as much in tests, but this isn't closed
L182-185 can be moved below first if condition.
Seems what this boolean flag does is the opposite of what the variable name means. If the response is a "Ask" response, we want to keep the session open (set shouldEndSession to false). L55 is doing the opposite. Also, what's the reason for moving this logic from MyColorIsIntentHandler to here?
val baby.
- Instead of ! anyMatch you can use noneMatch. - This would be more readable if you extracted a variable for the condition.
Could you explain why we set this here?
See See getAllLifelines remarks
enforce null when false?
maybe introduce a utility method that returns this factory; it is easy to miss that the list of arguments is part of the factory, and not the constructor.
It is possible for jdbc.query to return null?
we are passed in an AbfsInputStreamContext. We should hold onto that instance instead of creating member variables for each of the members of AbfsInputStreamContext.
Hm, shouldn't this be switchMap()?
Why are you using StandardException.newException while throwBadType("LEFT", receiverType.getSQLTypeName()); above?
@merciesa maybe matter of taste, but why not i-- instead of i -= 1?
This code should be removed. executeBatch is missing a call to closeResultSets, which would close all activeResultSets, at the outset of the method; which all executeXXX methods are required to do. generatedKeysResultSet is in the activeResultSets list.
It would be good to have a unit test for this method
This changes the semantics of comparison. Use sameElements (instead of Objects.equals) in this class.
try(FSDataOutputStream stream = fs.create(new Path("s3n://test-bucket/test"))) { // initiate an upload by creating a stream & closing it immediately } assertEquals(s3.getAcl(), CannedAccessControlList.BucketOwnerFullControl);
use static import everywhere if you star using it
There should be no way to delete an allergy by uuid _without_ also specifying the patient it belongs to. I think you should get rid of this third branch.
white spaces should be only after the comma, not before
I guess you can update the code to use putIfAbsent() and use the return value to compose the log message
Why does this allow the requesting thread to drain if requestedCount was already set to Long.MAX_VALUE? Doesn't that mean a request was previously made but nothing ever emitted? If that's the case, receiving another request seems like a no-op (and shouldn't happen). It also seems to mean there should be nothing in the queue to drain. So I don't see this as causing any harm as it shouldn't ever be invoked, or if it is then it should not result in anything, but I want to understand if I'm missing a code path where this is applicable.
What is left unsupported? Could you specify why this exception is thrown?
Predicate used twice (at least first part), should be method
Per the name, the multiplication should be hardcoded into the variable itself.
have to be specified? argument '%1$s' name not specified?
Please do not go for the suppression of warnings, instead use proper generic information to make it go away.
No need to remove parentheses here and below to keep equations consistent. Please revert the entire file. The final keyword at L69 can be removed though.
We should be able to return true here immediately after seeing filteredPattern < 0, simplifying the conditional below, avoiding the sourcePatternIndex computation, and making it clearer why the iteration is being skipped over.
The try-with-resources should close the output stream, why is this necessary?
Ordering here is unpredictable. Does that matter? It seems like it might. But I guess that is OK here isn't it, because the database model doesn't store any ordering. I wonder if we should at least make it predictable by sorting by project name.
style nit, preferred layout is  predicate ? res1; : res2;
Please also check the entire file and use injected storagePathProvider instead of new StoragePathProvider() like here.
you can retrieve all disks for vm
one param a line.
I think we shouldn't add new method into AnalysisReporter, but just call the existing public one sendReport as we do on line 65, WDYT?
The entire onPreferenceChangeListener can be avoided now that you have set android:persistent=true.
These should be internationalized too
Why do you add "toString()"
IMO, to sounds better to me.
s/pmPption/pmOptions
didn't you mean 'typeNode == null?
add " && tbl.getTableType().equalsIgnoreCase(TableType.MANAGED_TABLE.name() . " and throw exception
Please use Collections.emptyMap(), here the static import makes code less readable
nit: if else may make this easier to read.
Not necessary. Please remove it.
Why TransportFactory was removed?
not sure why not doing is gracefully by having true instead of false?
These two lines can be removed.
Is it neccessary to fetch the serving url, or can we just set the <img> src value to the end point, and have the end point respond with 303 See other?
Indeed. To the best of my knowledge, STATIC is being deprecated in favor of NONE.
It seems like you should synchronized before the while loop to prevent releasing and then immediately re-acquiring the lock as you loop
Something like this is about 225k+ ops/sec faster java CompositeByteBuf taggingContent = allocator.compositeBuffer(); for (String key : tags) { int length = ByteBufUtil.utf8Bytes(key); if (length > TAG_LENGTH_MAX) { continue; } ByteBuf byteBuf = allocator.buffer().writeByte(length); byteBuf.writeCharSequence(key, StandardCharsets.UTF_8); taggingContent.addComponent(true, byteBuf); } return taggingContent;  _Original_ TaggingMetadataFlyweightPerf.benchmarkEncode thrpt 10 678914.817 +- 3637.060 ops/s _Suggestion_ TaggingMetadataFlyweightPerf.benchmarkEncode thrpt 10 903925.613 +- 13036.852 ops/s
&& needs to be || as well
Wrapping so much logic here in a try-catch is excessive and makes it harder to understand. Given that the resulting service error says that the error happens because Rest.li was unable to build the criteria URI, it makes sense to me to actually put this try-catch and service error inside #buildCriteriaURI
minor race here, would be better as:  java long lastTime = lastBufferAddFailMsgTime.get(); if (currTime - lastTime > 10000 && lastBufferAddFailMsgTime.compareAndSet(lastTime, currTime)) { log.warn("Failed to add event to buffer with current size [%s] . Retrying...", buffer.size()); }
25 or 35?
Optional: use parameterized log if possible
Shouldn't we check that the URI is the same one as returned earlier? assertEquals(location, manager.locationURIFor(project))
I get this if it's closed. We can fix it at the same time org.eclipse.core.internal.resources.ResourceException: Resource '/delete-me' is not open. at org.eclipse.core.internal.resources.Project.checkAccessible(Project.java:150) at org.eclipse.core.internal.resources.Project.hasNature(Project.java:584) at org.eclipse.linuxtools.tmf.ui.project.model.TmfProjectRegistry.resourceChanged(TmfProjectRegistry.java:163)
The Service layer should be responsible for loading these. e.g. DefaultRunService#loadChildEntities. getUse and getSize methods will still be required on the DAO, but not on the Service
Why the catch here when you don't catch many of the other ormexceptions?
Thanks! Please just remove the ': %2$s', no need for the getMessage().
I think we should leave this PR open until Vector is finished. The master branch should contain production ready code.
Nice. How about changing this to apply retries with backoff but use one of the uris at random ? Sort of similar to lines 68-77
isEmpty()
No potential race-condition but other points from [this bit of feedback](<LINK_0> apply here too. I don't think there's a need to require the client code to call a separate method here, all that logic could be trigged form the existing toSubscribeMessage.
You should keep those on the same line
I would get rid of the JobChangeListener and simply leave the order of execution as it was before since I don't think this is changing anything.
@arukshani seems like the test code is completely identical except the different upgradeString. Consider moving all the code into an extra method and just pass in the upgradeString from both of the test methods to remove all the code-duplication
I don't know the AQL APIs, but is it OK to modify the environement here and not to reset it to its original value once we are done?
Ticks don't line up. Suggest using SubMonitor.convert(monitor, 1)
null checks for codedTest and secret ?
use java.util.Objects
CTFException instead?
instead of initializing to getSequencenNumber(), you could initialize to (and check below for) -1. It makes it more obvious that it is an invalid value.
so it doesn't a converter anymore as it creates loadbalancers. I liked it when it returned the loadbalancer instead of adding to a list in the parameters.
I would move this code into couldBeString
Can be moved to be inside the following "if" statement. Not a must. Just a minor optimization.
If we're going to make a writer around System.err, I think I would prefer to just use that throughout this method. So do this at the start, and replace the System.err.print* invocations with calls to your writer that you are sharing with the args4j library.
In this context, form is available as a final variable.
type is only created to retrieve the Class from it later. Can't we just use HashMap.class in line 211? Wouldnt the generics be erased from the type during runtime anyway?
inputStream is never closed, which could leak connections to S3. Recommended way in Java7+ is to use:  java try(final Reader inputStream = new InputStreamReader(s3Object.getObjectContent())) { ... }  it will close the resource even in the case of exceptions.
Same here, should be an externalized string
I know this isn't yours to blame, but while your at it, let's change this to "Successfully" :wink:
As I mentioned, do not catch all Exceptions here, just the ones that are thrown in the try block. suggestion } catch (InternalErrorException | MemberNotExistsException | WrongAttributeValueException e) {
For what I can read you only need to set the component key, no need for an internal map on filters objects.
would you use Arrays.ensureCapacity?
It is recommended to change addr0 to restServer
The use of DoubleSumAggregatorFactory here makes be very nervous. Do all PostAggregations HAVE to be doubles? The case I have dealing with nested queries certainly needs to deal with complex metrics (we have some sketch metrics), and I can see in the future wanting to pass a sketch from the inner query to the outer query for further processing.
there are resources without dot in the name. I believe this code will fail in that case.
it's a primitive, you can avoid using objectEqual
Interesting. Makes me think we should support env and property replacement in batches
I don't think this is needed - all the other actions which allow partial success just send all the commands to the server and the server returns error messages for the ones which can not be executed. I think the only change needed should be in the AsyncDataProvider
You could make the method return the base TmfXYChartViewer, and each test class could cast it to the right sub-class.
This can be instanceof as well.
typo not important "hotname"
model is already injected and should not be reinstantiated again.
getReviewUrls is already an ImmutableSet
Here you need to do a mapping as well, can't assume that the values of VdsProtocol and HostProtocol will always match.
Must have exactly one annotation...
This should be in the BCRobotics class, in preInit. It should _probably_ look like this:  java BCMessageHandler.addMessageType(MessageZonePlannerMapChunkRequest.class, MessageZonePlannerMapChunkRequest.Handler.INSTANCE, Side.SERVER); BCMessageHandler.addMessageType(MessageZonePlannerMapChunkResponse.class, MessageZonePlannerMapChunkResponse.Handler.INSTANCE, Side.CLIENT);  This does require you to change the handlers to enum types, with a single object "INSTANCE".
Style, structure, AssertJUnit.
Not sure if path here can be something like "hello.gitattributes".
I think this is going too far in the other direction :p. In #121, I'm advocating <var> (or <span>) when we're wrapping phrasing content, and <div> when we're wrapping flow content. I don't think there's a single element that will cover both cases.
why are you checking Build.VERSION.SDK_INT >= Build.VERSION_CODES.P if there is  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.P) { return null; }  above?
minor nit: hasAccess is perhaps a better variable name :)
It looks like this code should be part of 'General' infra independent provision or maybe installer configurations, so docker and openshift and any other implementation won't need to do it over and over again.
In this case, There is no need to explicitly specify the final.
In general, prefer Objects.hashCode(...). Here is an example in the Nova [Network](<LINK_0> class.
These functions seem to be deprecated, and also these values are already the default.
and this active instance?
How about adding a bit of logic that makes it possible for the user to also pass a byte[], without conversion from string to byte[]? This enables the user to use any algorithm to convert input data to a byte[](not just UTF8 string conversion), in a prior morphline command. Along these lines: Object next = iter.next(); byte[] bytes; if (next instanceof byte[]) { bytes = (byte[]) next; } else { bytes = next.toString(); } ... hex encode (bytes)
Please remove. It is provided by different extension.
Since the map is case insensitive why force upper case that isn't necessary
I'm not a big fan of array of generic type; Could we change the method to be public static <T> List<Future<T>> runConcurrentlyWithResult(final List<Callable<T>> threads), and change the type of threads and futures accordingly?
better variable name - ex numWidgets or just widgets or count
Move forward to line #93 (just before "foundTemplateDisk").
Typo in variable name.
maybe static import all of these constants
Listeners that use a UI component should be added in the initialize method.
Would it be much extra effort to include OutAverageLinkshare, OutAverageRealtime and OutAverageUpperlimit?
I would prefer using filterOnlyAllowedAttributes(PerunSession sess, List<RichMember> richMembers, Group group, boolean useContext) with group = NULL and useContext = TRUE. Its optimized to check rights for first member and store results based on attribute name. If members are from the same VO, you can apply same rights to their member/user attributes. If they would be from different VO, exception is thrown. Group is optional and not useful for this use-case. It saves up "init" part of attribute rights check method, where it checks if attribute definition exists etc. which adds overhead for each member and his attribute returned.
What's the reason for Double.NaN setting? You don't use these values below.
There is a reason we were using explicit LEFT and RIGHT for the gravity. When the system language is an RTL language, "start" will mean "right", and the position of the ToC will be broken now. Please restrict this PR to what it says it does: "scroller and onboarding text visibility".
Please add a new line after the assertion to make the method easier to read.
Is it possible to have a toText(Text.Builder) method? It'd be nice to pass an already-made builder here, if available
We should also check discoveryScript.canExecute().
isLessThanOrEqualTo?
Below we log " Response: " + result. Which one is **the** response?
This will override the system-wide prioritized crypto providers for Java set by the system administrator. This may be okay in some cases, but I don't think this should be the default. I think that we should set the default value to be null, instead of SunJCE, and if it is null, then we call the one-parameter version of this method, which respects the system-wide security settings. The specific provider should only be used if it's not null. Doing it the way I'm suggesting will be much friendlier on system administrators trying to ensure their systems are compliant with their organizational requirements. It also makes more sense if a single crypto doesn't support all of the algorithms the user has specified, because the default behavior is to search the providers set by the system administrator to find one that will work for a given algorithm.
nit: serverProps seems to have 3 elements. Should not this be 3 instead of 2? 4 instead of 2 for line 85?
We should use featureManager.getFeatures() here instead.
fValueNumber and fValueTimestamp are derived from fValue and fType so they do not need to be considered for hashCode() and equals().
it is not slew rate (users/seconds). it is extraUserStep (users)
This should return List<MemberInfo> if multiple members can be put at once.
why do we need synchronized?
I think you don't need it anymore ?
Formatting issues
split it on 2 lines; = and == are very easy to confuse, especially for someone with little java experience.
preferences.getPreviewPreferences() ? as you already have a JabRef prefs object
This is at least the third time in this PR that comparison of two targets' contigs has come up. It's worth extracting a method somewhere.
@sonalidhome Here you can use self-reference setter methods. destination.id(...).key(..).name('..') ...
Add newline before return.
Best to log the access value for debugging.
Probably should be continue here; we don't want to stop checking players just because of one bad apple
you can collapse the following three lines into one now that we are using java 8 ReplicationStatus status = keyReplicationStatusMap.computeIfAbsent(newKey, k -> new ReplicationStatus(replicas))
no longer need concatenation now that it's one line
Are we sure that the value will always fit within a single chunk?
Please log the exception.. Don't use printStackTrace(). If u found any other place fix them as wel..
Same here, can we input the empty list?
this call can be deleted.
This class is extremely long anyway. Please consider moving this logic to a separate class.
double check that no group has been created
SQL script for RecordLocationService--requestedPatientId are 1, 2, 3, 4, 5 this would fail if records are not in the database testGetAllByRLSId
@idelcano can you refactor this method extracting logic to new methods ExexuteDemoPull and ExecuteRemotePull for have the code more readable as UserAccountRepository?
!Strings.isEmpty(), or even !Strings.isBlank() to rule out whitespace-only text
Just a minor note, this line can probably be removed since this test doesn't actually make use of the clientFactory.
Use the constant <code>Const.Tooltips.FEEDBACK_CONTRIBUTION_NOT_AVAILABLE</code> In fact, this may be better as <code>getPointsAsColorizedHtml(Const.POINTS_NOT_SUBMITTED)</code>
May want to break; out of the for loop here so it doesn't continue looping over the remaining attributes.
if the purpose of adding to ocList is only for shutdown, I would recommend against it. Since there is only instance of BackgroundDeleter, it should be easy to shutdown/wait for shutdown of that one. I feel that keeping the _real_ ocs separated from the utility ocs is useful - one e.g. are the changes required for getOperationController().
We don't need this check. Better find the luns that need to be resized. If the luns list is empty, we will not find any luns to resize anyway.
can you simplify by always using second part (after else)
please move this few lines into new method
@Nullable annotation implies that the argument could be null. Correct fix is to keep the @Nullable annotation and do the following: return field != null ? field.getName() : null;
Please use Windows.OK (which is the default button)
This line should go to the css files
shouldn't isRelevancyUpdateScheduled be set to true here?
This if is unnecessary since it's tested again inside calculateUq()
The check needs to happen for decorators and interceptors also.
would be better to pack the uncommon path into a separate method
domainName is not the host name. In addition, the check should be done only if ldapServers is provided. You need to check that for example - ldapserver1.acme.com is indeed resolvable.
Because $#it happens :)
Did you intentionally change this from Collections.singletonList?
even this can be clubbed with above one as there is only one extra property here.
remove the toString()
any reason you use .compareTo() == 0 instead of .equals()?
There is some (mostely) repeated code here between enable and disable debug mode
Shouldn't the interrupt flag be restored here?
will we even get here if we aren't in discovered hosts mode?
This should also use scanner to avoid reading everything into RAM.
You you didn't test NOSONAR
please consider to use setChangeProhibitionReason instead
Is it a good idea to throw an exception in a static block? This exception is thrown to the classloader which is hard to find or to detect and can lead to unexpected behavior. Instead: Just log the exception here? The accessor will be assigned with the exception-implementation which should be ok? What do you think?
eventhough not necessary, please add a break also at the default case.. this prevents errors if these case statements are reordered
Invalid blob key format:  + key
Maybe you spend/add a waitForErrorCalls ?
Should use parameterized logging instead of string concatenation.
This NPEs when openRepository fails gracefully when the repository is suddenly torn out from under Gerrit (this happens!). I would prefer to return "" in this case.
Can return directly.
No braces.
Once this is complete, you should in theory be able to get rid of OPERATION_ flags.
<RowExpression> is redundant for builder()
Since we are refactoring it, we could be a little bit more defensive. Either check the property name with a regex and extract the group we are interested or check if the tokens array has indeed 2+ elements.
any reason we are not doing flatmap similar to the original AsyncReadBenchmark? <LINK_0>
suggestion checkDeploymentOrder(!legacy);  (same elsewhere)
Shouldn't this be give a higher severity? Presumably, if we can't release the lock, it's still there, and processes waiting for it will be stuck.
Please avoid reformatting like this, there's no code change here
nit: import NettyMessage.AddBacklog because it occurs many times in this part.
Given the new behavior, maybe renaming this to "tryDelete" would make sense?
Need to format the code, the space not right, see: +elementType+
nit: can be LinkedList since we are adding and removing entries?
when will this happen ? I like the check but want to know when can this happen ? Or is the intention that this can never happen ?
if you keep the position relative to the 1st datapage above, you just need add this value to every PageHeaderWithOffset here
null check should done for asyncTask.getTaskId() as well
Could we do persistencePath.resolve(key + SER) instead?
object
I would be tempted to put the code for enabling wire frame mode, along with the next two lines into some flavor of prepareForRendering() method. Methods that check and then do something are a bit awkward. Otherwise something like setWireFrameState() or checkAndActivateWireFrameMode() may be clearer. Otherwise 'toggleWireFrameON()' should be 'toggleWireFrameOn()' since ON is not an initialisation/acronym. Likewise for OFF. But both names are bad since they do not reflect what the method does.
While this may work, it is a very strange formulation. I wouldn't expect two mock components here -- either you're mocking the file component or you're mocking the direct component, but not both.
use spring's io utils here
suggestion List<RestEntry> entries = new ArrayList<>();
I had a couple of ideas: 1. Detect that the flow starts with a gateway and automatically add a bridge to nowhere - I rejected this because someone could add a replyChannel header mid-flow. 2. Add a new property to the wireTap and log specs - something like .log().andReply(), which would only be allowed on the last component. But WAD works for me too.
If it hasn't been set to anything it should be interpreted as true. So } else { navigator.mCached = true; }
<= 1
Should be named just macPool. Also no need to extract to variable.
No longer thrown since modifyAttribute() removed.
nit: space after cast
if (!transaction.allowNonRepeatableRead())
please use == when comparing enums
Please remove this empty line
2 typos Milage => Mileage and caluclated => calculated
Is it better to use "false" explicitly than the variable "refresh" to force not to use the cache?
I'm reading this part of the client code <LINK_0> and trying to understand the change in behaviour with RackAwareMode.Enforced. Do you understand the difference between Safe, Disabled and Enforced? It's not clear for me.
delete?
nit: serializables? It is attributeValues or values or something...
It's a redundant check. There already exists a stripe size check under the lock.
Instead of creating two additional objects, it is preferable to use case-insensitive comparison.
The server acts according to the config it has in its quorum verifier, so if this line is executed when the server syncs with the leader, setting quorum verifier overwrites the config file settings with the leader's settings
I'm not sure if this start() method might throw an exception (or if there is a subsequent close() method), but it might be safer to have a start() method on the pusher itself. You can annotate it with @LifecycleStart and then when the object is created, add it to the Lifecycle (lifecycle.addManagedInstance()). You will probably have to add the lifecycle to the method signatures of the initialization code, but a lifecycle object will definitely be available at some layer of the call stack, so it should just be signature adjustments. I'm working on making this a simpler process...
Could this be done within initializeDisksAndReplicasOnNode?
why would that be synchronized? I mean it just executes in site PlatformRun.later ... That make is synchronized because there is only one UI Thread !!!
Since Collation is a required trait, a condition is useless here.
Add a TODO To be implemented in a later patch. I know this is your next task, but other reviewers may not know that ;-)
Can we name this more concisely completions, as in the addMacroExtensionAutoCompletions method? Also, the redundant type arguments can be removed from the constructor call: suggestion ArrayList<Completion> completions = new ArrayList<>();
Could we add another check to make sure that the JSON exported also has 3 decimal points? For example Assert.assertEquals(OBJECT_MAPPER.writeValueAsString(compressedView.getBaselineValues().get(i)), "2.833")
This one can be static
This is consistent with the corresponding code on GoogleComputeInstance, but I would probably use || ipMappingList.isEmpty() for clarity.
Instead of creating the StudentsData > setting the students > getting the students > setting the institute data, could we do all the data manipulation (setting key and institute) on the studentDataList first? Then once we have a finalized studentDataList, pass it to the StudentsData constructor as mentioned above.
message in exception
What if 'data' is null?
how about Integer.toString(pull.number()) instead?
I think checkstyle does not enforce it... Even if I think it should...
Right just keep in mind that the filtering will be pretty simple: just enough to distinguish between system templates and user created templates. The security plugins should be preventing templates that are not shared with the user from returning to the UI.
why not adding a addSection method?
I think that you should check for fFormatterOptions being null and if true, call rewrite.rewriteAST() as the old code did. Otherwise, make the new call. That may explain your catch below.
How about "TestCase name cannot be null"
Same. All these strings are not refactoring friendly. Lets address this.
I think adding back the sender.isMe() check is the right thing to do.
Is it really so that seed member always chosen as a leader?
Not sure what information about the value will assertTrue give you in case it's not greater than 0. If you care about the value, there are assertions for numbers. And in general, using AssertJ simplifies assertions in tests. Have you considered using the library?
Please use the constants defined in CommonJobProperties.java: <LINK_0>
looks like a command line app -- print to STDOUT (or STDERR if it's a warning etc)
This is impossible, blockLength is an int.
this one is probably redundant now as we already checked for constraints on line 158.
++ ?
This assumes/imposes the same sentence structure and order in all languages. Instead we should have 2 templates for the 2 cases, so that each one can be translated appropriately.
This creates an anonymous class that extends HashMap, and is considered a bad practice. I'd go for a much simpler approach: Map<String, String> migrationMap = new HashMap<>(); migrationMap.put("undefined", "true"); migrationMap.put("x86", "true"); migrationMap.put("ppc", "true");
nit: Logger message should say 'bind' instead of 'bond'
You definitely need a null check on mounted before calling mounted.getType(). I'd suggest moving the logic from the if statement on line 280 into the if statement on line 276, then making 280 an "else".
It looks like the code tries to grab the lock for this event ID both here and then, after acquiring it, in the createBooking(...) method which should result in deadlock.
This init shouldn't happen directly here (see the dependency that's created via the import with the ElementSDKManager). Instead of that, I would rely on the ElementController for that purpose. The better would be something like a plugin initialization where all the Controllers that need to be initialized simply subscribe and are initialized here, but if that's too much, at least it's better to have a dependency with our generic controller and not with the element SDK.
Would be better to use Math.toIntExact().
This is not necessarily only IBM JDK, please improve the message.
Don't compare the hash twice, remember the return value and use it within if block. You can do something like this: Java int pos; ... else if ((pos = DeterminismHash.compareHashes(m_responseHashes, hashes)) >= 0) { ... logRelevantMismatchInformation("HASH MISMATCH", hashes, message, pos); }
What will change about the animation?
logger.debug ?
Move this into sendNewGoalConflictMessage.
Should we also check task.isActive here?
Is this a sufficient test to say its empty? What if a project has commits in one or more branches that were pushed directly into the project and bypassed code review? Not every project on a gerrit server has to use the review feature. I wonder if we shouldn't require the project to be truely empty. That is: * no changes * zero refs in the repository * OR * single ref has single commit which has no parents and has empty tree as its tree (so has no files)
You may want to verify in a scratch area that the DataException will still be thrown. I do recall that an exception on the finally block will override the one caught before the finally block, but I don't recall what happens if the finally block catches it.
Do we have a good test to confirm that the chunks in the returned filespan are still sorted after trimming? (applies to removeContentsBefore() as well)
Maybe if we pass the Repository to the NonceGenerator, it can pull out the directory? DFS implementations could then supply a different NonceGenerator that can pull out getRepositoryName.
wrong formula
This should never happen, should it? ReadPermission should now be evaluated instead?
missing space after if
It should be 10001 instead of 10000 here and below since [the upper bound is exclusive](<LINK_0>,int)).
Do we want to log more information about what the error that occurred here was?
SdkConstants.ATTR_TRANSLATABLE, SdkConstants.VALUE_FALSE
This shouldn't be public.
This will cause a NPE. Consider returning an empty list.
this is redundant here
Magic number
Redundant UnsupportedEncodingException
Above two if statements are really confusing. Are you trying to check if these two checking booleans are not the same? Why not use a single if statement like below. if (isIdentifierExactMatch != topicIdentifierExactMatchField.isSelected()) { topicIdentifierExactMatchField.click(); }
Would it be better to use a mock for this? At the very least, we'd have to write less code.
This Exception message is misleading. The value is not invalid... it is simply null. The message should state "Filter value cannot be null" You may also wish to print the allowedFilters as part of the exception message.
Sounds reasonable to me. We're not really interested in testing the functionality of EnvironmentVariablePasswordProvider here, that should be done in EnvironmentVariablePasswordProviderTest (but it doesn't look like it actually tested it..)
Because RefControl sorts the RefRights before use, there isn't a need for List<RefRight>. So why make the API change from List to Collection on these?
Why not create a hash set directly?
Add a FIXME here?
This should use a random database based on the TemporaryMongoRule.
Can we not have any code that specializes to interactive? Ideally, we'd just instantiate the InteractiveMaster class via reflection which takes care of setting everything else up...this way we don't clutter Main.java.
Please save a string (eg name) instead. It is too easy to unknowingly change the order of the enum items.
Should we not also send out an even that triggers an alarm when this happen?
Can't we use just getMyDomainName()?
this could be in the model class
Use Log.e to match the isLoggable tag. Since it's not technically an error Log.DEBUG and Log.D would also probably be ok, I don't have a strong opinion.
really?
split this up into well-named helper methods
I think here we can call setEmitEvaluators() instead.
We could regroup elements whose parent is not a tool section (a group or group extension). You should make two methods/services : . one too filter the selection: only AbstractToolDescription ? . one which take the selected elements and try to retrieve a potential parent toolsection : iterates over each element and get the first parent section (could eventually be eContainer or look into all eContainer hierarchy to find a section). It seems these two services could be moved into an abstract super class (with generics ?)
I think you missed this log statement when converting to parameterized logging.
I suppose this will be configurable later ?
this transparent stuff is mainly for handling drawing of states that end up on the same pixel. I think we can treat all < 0 as non-drawable arrows.
What is the reason of this empty synchronized block?
Initialize with roles.length
We could also just change the QueryLogger interface to accept query params as a separate paramter so we don't have to reconstruct the path.
I think this migration can't work with empty/context/globalMap/... kinds of value. Maybe you can add "-1" after the parameter value. like: If customer fill context.lilimit, it can be migrate to context.lilimit-1
As far as I can tell, this code is run from ConnectivityService#systemReady(), which is a blocking call from SystemServer as part of system startup. That suggests that any time spent here will directly impact system boot time. Have you measured this impact in any way? Additionally, I believe that systemReady call can execute concurrently with the ConnectivityService handler thread, which can also call this method, via, for example, sendProxyBroadcast. Is it safe to call this method concurrently? If not then we might need to post this to the handler thread or add more synchronization. Also: is it guaranteed that any system components that the PAC manager needs are initialized at this point? Finally: when is the PAC proxy needed? Is it when the first NetworkAgent is registered? If so, then I don't think there's any guarantee that the proxy will have loaded by that time, even if this method is called here in systemReady. This is because setCurrentProxyScriptUrl doesn't block, but just calls Context#bindService with a callback, which is an asynchronous operation. If that operation takes a long time - which during boot, it probably can, since ActivityManager is starting up - , then it seems like PAC proxy initialization could still not complete before the proxy is needed.
The error message should really include the segment identifier. Imagine the poor user that gets this error and can't figure out which segment to look at. Perhaps we can keep it along with the QueryableIndex using a Pair or a small static holder class returned from loadSegments.
We missed one :) Please make this one a variable as well.
maybe use Set<String> instead
Is the line break between "logger" and ".info" necessary?
No 'limit' parameter here. Improvement should track the changes we are making to the generic API? Add a method and leave this one for backwards compat?
If this is an error, we should throw something
the only option that we should provide is enable/disable soft commit for the indexer consumer. There is no reason to offer an hardcommit option for the consumer
this seems like a pretty severe issue. Shouldn't this be logged at warn or even error?
why we need try ..catch block here?
Do you want to fail the test in the event of an exception? The runtimeManager.deployDayaSource(...) _could_ be called - and hence pass the assertion, but generate an error that would be silently ignored.
Redundant lines
prefer a new overload on Money which takes a Money object to avoid the doubleValue call.
This function can be simplified to: java private List<Artifact> calculateArtifacts(Iterable<GradleDeployDetails> deployDetails) { return newArrayList(StreamSupport.stream(deployDetails.spliterator(), false).map(from -> { PublishArtifactInfo publishArtifact = from.getPublishArtifact(); DeployDetails deployDetails1 = from.getDeployDetails(); String artifactPath = deployDetails1.getArtifactPath(); int index = artifactPath.lastIndexOf('/'); return new ArtifactBuilder(artifactPath.substring(index + 1)) .type(getTypeString(publishArtifact.getType(), publishArtifact.getClassifier(), publishArtifact.getExtension())) .md5(deployDetails1.getMd5()).sha1(deployDetails1.getSha1()).build(); }).collect(Collectors.toList())); }
This will need to be revisited to throw proper exceptions.
If res is true at this point, can't we return without checking anything else? Or, perhaps the remaining if blocks should first check for !res? (IMO, the former is a tad more efficient and possibly a bit easier to see when just scanning the code, but the latter is not really too bad, either.)
Be aware of conflict with #12710 depending on who lands first. cc: @hellium01
Sorry, I didn't notice that before: will this change break already configured layer in GeoServer? I'm wondering if the new code running against a .idx being configured by previous code will throws exceptions or refers wrong values. OFF TOPIC: Andrea recently changed the sampleImage being stored by ImageMosaic and things stopped working on already configured layers, so he needed to introduce backward-compatibility fix and a different naming for the new file. Wondering if this slices change needs similar checks.
This is nice-if you want to micro optimize even more I'm guessing checking the game mode is cheaper than checking the permission :wink:
System.out vs logger?
consider extracting the filter logic to an helper method (it's the same as in GetClustersWithPermittedAction)
do an equals() instead of ==
nit: Earlier you used == for enum comparison, is there a standard for Phoenix?
Will this consistently pass? The sort order of the questions will not be deterministic now right?
I would change the message to something generic like  Error while trying to get lookup list from coordinator for tier[%s]  exception would already contain specific details. and remove the other catch block covering ISE specially.
Use the constant
you should probably put this check above that big ass switch statement, because: - in the case that notification **isn't** one-time and/or already triggered, you need to do the check - in the case that the notification **is** one-time and already triggered, you still need to do this check, but the results from the switch statement are unused entirely.
@ayush2297 are these changes part of the ticket or formatting changes ?
What if there is a deadlock? How about timed join?
Not sure about purpose of the if here. You are just getting out what you just stored in the last line. Also, you could store the SHOW_SOURCE_NOT_FOUND_EDITOR_ALL_TIME all the time.
// Something like this... if (op.getValue(tvpKey3, tvpValue3)) { // found key }
why this is need? what is the difference with (!flushCount.compareAndSet(flushCountBeforeRead, 0)) interrupt() below?
Should this be just a regular counter?
please add dot at the end of this message, as well as at other similar messages that lack dots at the end
please use a method like createAnchorFile and createYearFile
I'm new to Elide, but would I be right in thinking that it only supports one dialect.. So for users that want to use the legacy dialect, then the RSQL examples should not be displayed.
You can change this condition to student.isRegistered().
Is it really only the route /api/*? Could it be as well /foo/*?
You should use eq(State.LEADER) instead of the direct value
Here we should just throw the exception.
In general, we statically import Math.min.
Did you take a look at this? <LINK_0>
Does archiveName here include the path?
Returning from the method early if a condition is not met makes reading your code a lot easier. java if (modifiersToken == null) { return; } if (!modifiersToken.branchContains(TokenTypes.LITERAL_PUBLIC) && !modifiersToken.branchContains(TokenTypes.LITERAL_PROTECTED)) { return; } checkReturnType(methodDefToken.findFirstToken(TokenTypes.TYPE)); checkParametersType(methodDefToken.findFirstToken(TokenTypes.PARAMETERS));
Mike pointed out to me that this is the wrong thing.
This seems a strange way to check if the state is read-only mode. I wouldn't have guess it from looking at the variable name.
@ivange94 I dont think we should catch that. you need to make sure that this mrrtReportTemplate = mrrtReportTemplateService.getMrrtReportTemplateByUuid(templateId); so add this before the try block  java mrrtReportTemplate = mrrtReportTemplateService.getMrrtReportTemplateByUuid(templateId); if (mrrtReportTemplate == null) { throw new IllegalArgumentException("MrrtReportTemplate not found. templateId '" + templateId + "' unknown."); }  otherwise you mask the actual problem.
also please reverse this one
I would prefer to make the prepare exception the cause and the rollback exception suppressed. I'd also rename innerT to rollbackThrowable and t to prepareThrowable.
That method became quite long. The two cases it handles are good candidates for extracting two methods.
What guarantees (here and in the other equivalent method for straight line) that the current stroke is the right color and thickness?
I think catching the exception here and enriching it is too specific. That way we will leave all other places where this can occur out. I believe that a better approach is to do it where most of the code paths originate from. One idea could be the generation of the JobManagerRunnerImpl in the Dispatcher and its resultFuture. This is the point which will be passed by job submissions as well as job recoveries.
latch
A batch can be large and any command toString is long due to having 2 SHA-1s and a ref name. It might make more sense to format with LFs: r.append(getClass().getSimpleName()).append('['); if (commands.isEmpty()) return r.append(']').toString(); for (ReceiveCommand cmd : commands) { r.append(" "); // $NON-NLS-1$ r.append(cmd); r.append(" (").append(cmd.getResult()).append(")\n"); } return r.append(']').toString();
So the test will pass in case of IOException. Is this desirable?
typo: nto -> not minor: can you re-format the line in intellij?
Use MathUtil.clamp
null doesn't seem to be proper value for maximised window, can you return calculated real dimensions? or at least information that it is maximised window?
Thanks @phillips1021!Ccould the change also be pushed to GitHub?
I think the changes in this file are not needed. probably come from merge?
Yes please add a new error code, like PERMISSION_NOT_GRANTED_MANIFEST_ERROR and maybe differentiate the error text between the audio and video case.
Could be final as well
mentioned earlier, it should be some sort of conc. map
Styling : This can maybe be expressed nicely using streams classSymbol.memberSymbols().stream().filter(...).map( ms-> ms.declaration()).filter(..).forEach( //build CFG LVA etc);
Can we just initialize these to the Config objects default values in the baseclass and avoid these protections?
This pattern of code from lines 25:34 appears in several places. I'm going to open an issue to factor this out as a separate method. (That doesn't need to be done on this branch, we can address it in our next sprint.)
lets populate the swagger def from here . this would prevent unnecessary calls
Too smart :)
else not needed here.
You should not need to go through getSemanticModel but you can use directly the getSymbol from MethodInvocationTreeImpl (and even the upcoming symbol() method from the interface).
Tests should have realistic values: payment amount = -NOTIONAL \* QUANTITY \* 0.99 or something similar.
(minor) could import static org.junit.Assert.* to remove clutter and minimize diff
We do not need to create string resources (that will be automatically translated) to log something, you can include the string itself here.
In order to authenticate requests to amazon when locking down the security on our domain, we will need to be able to add on an authentication header which is a signature based on the request body. <LINK_1> <LINK_0>
Minor - You could use forEach to iterate over the map. This makes it much easier, especially in this case where you can even use a method reference instead of a lambda expression. The whole loop can be replaced by a single line: Java referencePointResourcesMapping.forEach(referencePointMapping::put);
could we please split this into two lines to avoid so long lines in code? java final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate);
regular return is missing
Rename to now.datetime.sessions?
Debug system out should be removed.
Remove type casts
Should we use "last index of" or really the first one? Here I come up with a question: If I have multiple audio sinks, the one supports mp3 streams, the other one wav streams. IIRC at the moment we have to supple a compatible format. If I have a doorbell mp3 and wav in my sounds directory, who should choose the correct one? As the current implementation forces the user to use the correct one, I don't know if we should cut off the file name and drop the information (as a List is used, we have two doorbell entries).
This looks redundant - the suppression file contains: <suppress checks="." files="[\\/]generated-sources[\\/]"/>
what if the nic is null ?
Now that project related code has been checked in, can you check if project can be fetched dynamically?
I know some tools suggest to remove the throws NumberFormatException because it's a runtime exception, but this is wrong, it's part of the contract of the method so should be there.
NullArgumentFinder is redundant with the config property Arguments.getUntypedNullArgument(). This config property exists because Types.OTHER is not supported by all database vendors. Some vendors use Types.NULL (even though NULL constant is a value, not a type), and other vendors might use other values. Let's remove NullArgumentFinder, and replace it with a lambda: java if (parentName.endsWith("?")) { return (name, ctx) -> ctx.getConfig(Arguments.class).getUntypedNullArgument(); }
nit: RestApiManager.java has these the in the opposite order. Should we make these the same order for consistency? "video,discussion"
throw new UnsupportedOperationException("Not supported");
Why would an empty key be present?
If you passed the isSAM() method, then it means that the member is necessarily a MethodTree. From my point of view, you then don't need to check if it is a METHOD.
You can do Collections.emptyMap() instead of creating a new object, unless you're planning to add stuff to the map later. The tiniest of micro-optimizations. :)
A method could be introduced to encapsulate repartitioning condition e.g. shouldRepartition(...).
In theory, this is not the JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout Correlation ID.
This particular bit of loading data can be moved to a separate method, perhaps.
Compare concepts and not conceptIds
Seems like this belongs elsewhere (like maybe in the compiler constructor).
I'd rather use the same package name as the class to keep the resources in, i.e.: org/biojava/nbio/core/sequence/loader
Please use a constant for "_original_"
although currently only virtio is allowed, i think its better to set this from the disk rather than hardcoding it
This doesn't seem right either. Consider a source that emits application/json - if the target module supports ALL, he should get the JSON, not some object that was decoded from JSON. I believe we need to keep separate the conversion done for the purposes of transporting Vs. conversion to some supported type by the next module after we've restored the original payload as received from the source.
Why was this swapped from .equals? That makes no sense for a string comparison. Also a few other weird formatting changes in this file.
Is this if() needed?
nit: i think it would be better to put this and the other methods you added below to after reduce, since merge() and reduce() are very related to each other, so it's helpful to see them grouped together.
Why not make a new AbstractTask constructor that takes a task id and task group, and sets the availability group equal to the task id?
Here, after SUCCESS ',' is not followed by whitespace
I don't think this is a valid email address.
This stuff is all just lifted out of hellbender. I was just kind of assuming it's functioning as expected...
make row(...) a single line
Separator, same for next change
The Joiner can be shared (private static final?).
I'm all for useful logging
Since this is removed, see if you can make the fields createdAt and updatedAt private instead.
what if object will be null ?
We probably need to check that we have authenticated safely. Otherwise if we get a invalid sequence number and need to resync, then a success after, we would transition straight to final.
Perhaps you should send events instead of booleans for these two buttons. This also makes your code simpler - you can just do Igneous.joystick1.getButtonSource(button) and it'll give you an EventInput for that button.
isn't the iconXXX style in a Resource file? If so you should reference that instead.
You could use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmpty(..) (but how was you to know!?!)
Why is this public all of a sudden? I find no code calling this outside of the class, in the platform UI repo? Maybe some previous version of the change needed it to be static? OpenWorkspaceAction no longer calls this, it calls the new method that sets restart arguments.
You don't need to set the initial value, .orElse("") will take care of that. Also, I think you can simplify the logic by filtering lines that match either AE_EXPERIMENT_DISPLAY_NAME or INVESTIGATION_TITLE_ID, no need to go through the stream twice.
Nit: tip: If I were you I would keep the order of the if conditions the same. That way it's easier to review code with less diff. What I mean is, you could have kept if (jobConfig == null) { ...
This method should be called sendReport, since the current name implies that an error report is being sent which is not the case
loggers should be sanitized.
ph > pageHelper?
Shouldn't the TimeoutException be eliminated by the previous commit? If instead this is a real timeout, I don't think we should change the exception - availability exceptions should be immediate, not after a 15s timeout.
Not sure this query is required. Because task definition names are unique in dataflow. In this case we may want to throw a TaskQueryParamException (a new type of exception) stating that you can't request dsltext and search at the same time. Then add the new TaskQueryParamException to the RestControllerAdvice here: <LINK_0>
v1, not v1beta1?
is this related to this JIRA?
This won't work. The Map#addAll method on a Properties object does not pull over defaults that were defined in the Properties object being added.
we should not catch Exception into the Resource, we should let the exception go up to be handling by the Mappers class.
props are always != null
we should use link reference provided by server-side
create a variable for the third parameter to understand what's going on boolean addPublishPermsForRules = true;
You can use the @In'ed entityManager here. (and @In the PrefabManager)
Lets keep this simple, put here "/bin/chmod" or just "chmod" and don't try to check if the file exists. If it doesn't the execution will fail and you will get an error anyway, something like this: java.io.IOException: Cannot run program "chmod": error=2, No such file or directory at java.lang.ProcessBuilder.start(ProcessBuilder.java:1029) at java.lang.Runtime.exec(Runtime.java:615) at java.lang.Runtime.exec(Runtime.java:448) at java.lang.Runtime.exec(Runtime.java:345)
Oops, missed that one! Good catch
Checking module states for  + server.getName() so progress/job name uses same wording
~~How about using stream style like before? Get recentlyUsedAgents as a stream and then, concat these all three streams and limit by agentCount.~~ Now I understand what you expected. It's quite complicate to use recently used agent... How about extract a comparator for AgentInfo rather than using getFreeAgentStream method
Missing indentation in this method.
Throwing unwrapped exceptions from another thread leads to weird stack traces. Can we clone the exception here? It should still contain the original QosException with the original thread's stack trace, so we preserve all the trace the user will need.
not used?
Can we refactor this, and the corresponding code block from the test cases, to a single static function that takes an InputStream and returns a String that is the formatted output?
as we come to unit term, we do not need to parse type name from file, lets just use name of the file.
We should have a better description here "A WebApiSkill that can be used to call a custom web api function.". "Custom skillset" as a concept doesn't really make sense.
What are our options here to factorize this code?
static import
you can just call optimize
I did not follow this change
externalize error message
Similar situation as TOPOLOGY_RAS_CONSTRAINTS. I would give the same recommendation.
missing checkValidPosition(positionCount, position); below?
it's better to instantiate knownParams here, since we know exact size
Please remove either this call or the for call
static import
why?
Nit: I'd personally prefer a private static inner class over an anonymous one.
I think this should go above the addJSFAPI call. If it's going to fail, fail promptly.
OK. Something for a follow-up commit: add preference where the user can switch off being shown that dialog.
Can this be put into a function to avoid repeated code?
Typo in Error :)
why aren't you using the overload with 2 params that you added that does the null thing already?
I would include timeSlice and job in the log statement to provide as much info as possible.
The existing error message does not match this new exception.
If we directly print a runtime exception, we're not giving the user any information about where the program went wrong (only what went wrong). By here, I think this should be a WordsProgramException.
Maybe we could even simplify into one catch block, because IRSErrorException is indirect child of RuntimeException: } catch (RuntimeException ex) { logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex); log.debug("Exception", ex); }
If final can stay, then it's preferable.
_ prefix is not necessary.
wait File.separator should only be used if this is a file path, not if its an attribute tree path...
No need to change this.
It looks like the progress bar is hidden from the onFinally() callback of Task, which is called _after_ onSuccess(), thus causing it to be potentially hidden immediately after it has been shown by the pagination loader initialization. The solution to that would be to have it manually managed here, and ensure that it's hidden _before_ the potential call to populatePostListRunnable.run().
Missing a newline here
it looks strange to me that the UI / client know which should be the sequenceId of the new bitstream
line too long
Should that be guarded with an if(trace_enabeld) ?
You already have a reference to router!
Why do u need to handle set and reset seperatly. Just loop over all all the configs, if the reset flag is set, then add it to reset list and if no reset but there is a change then add it to changed list and perform reset and set . With this approach both of this methods can be merged and u don't need this lock flan on the GlusterVolumeGeoReplicationSessionConfigModel.
This code fills the NullDatum to values array of LazyTuple when user does not insert any data on this index. However, VTuple class does not initialize the values array on itself.
This would break internal LI. Just to keep in mind.
Do you need to set the study's project before saving?
Check is not needed. Why not simply assign it?
Missing assertion(s)?
Yeah, we have an open TODO to replace a number of guava things like propagate/Optional in Singularity. If we replace propagate usage @pschoenfelder can we do it throughout the whole class at least? Would be good to start cleaning these up as we go along
This seems odd to me. Shouldn't Util.toJson throw an exception if it is unable to serialize to JSON?
Same note as in Receive.
I don't think this block of code is really doing anything? It looks like it is re-creating the timeseriesQuery with the same limit that it already has.
So if I understand this correctly, verifyUser is only triggered to load the verifiers? If so, I'd prefer to extract this block as a method and name it dummyLogin or something similiar.
This will still result in a Critical from SonarQube. To resolve this, you can use: LOGGER.error("your custom message", e);
hmmm, we really shouldn't have to profilerate setCatalog calls out everywhere -- better to just to do a setCatalog on the connection once, after we check it out of the pool... unless there's something here I'm missing?
We should probably log a warn or error here if this actually happens, or even just fail.
Will this return a 500 if elastic search is not available? I believe that the strategy for tool refresh was that we would not kill the whole refresh if elastic search was not available.
it is not suggested putting multiple arguments in one line. split line for every argument
It should be separated asserts
This should use a specific Locale.
This print is less relevant, although will do no harm. Change it to: Checking whether user {0} or groups {1} have action group {3} on object type {4}.
Why remove this?
Shouldn't we disable only if engine has scheduled snapshots on volume?
This used to work with jr refs that didn't point to files, we should probably have a fallback for what to do here when this doesn't point to a file
This is probably used a lot, so it'd be better to have a static constant empty array.
I think introducing .class constant and using entry.getName().length() - CLASS.length would be more obvious at first sight.
import ImmutableList.Builder
Any reason not to use tritium for these? I guess we'd need to extract an interface for the Client.. though at this point I'm pretty surprised we haven't decided to do that already :)
Why do we need to trim this? Whatever is between < and > should be taken as-is as the email. Do you have an example of a malformed commit where the email contains leading or trailing whitespace near the <>'s and it needs to be discarded? Even if that exists, I'd almost still be tempted to say that is the proper text of the address, and we should preserve that text in the parsing.
Should we combine that to checks into one using "and"? Java if (configStr.startsWith("{") && configStr.endsWith("}")) { configStr = configStr.substring(1, configStr.length() - 1); }  I assume valid inputs are only start AND end with curly bracket or not using any.
What happens when "m_committedBuffers.peek() == null"?
double check that the group is still here
I don't like we do this explicitly... it should be property of the data container at each relevant change or once when session is created or user is assigned.
we should log a warn if we are disabling a task
![MAJOR](<LINK_0> 'Severity: MAJOR') Extract this nested try block into a separate method. [![rule](<LINK_1>](<LINK_2>
I would save this expensive computation ie elapsedTime / 1000 to perform it just once and I would handle the case of stats == null with a log or something similar: at this point this is not supposed to be null right?
can we make resourceName for all the states be same e.g. "config" instead of being specific as that requires the conditional and hardcoding of URLs? I'm not sure if we need to give each one a different name.
You can use Activator.error to create an error status.
If you want to get a property's value, you can always use proxy.getProperty(name). So you don't need to add another private variable "showInfoWindow" and method getShowInfoWindow() in the AnnotationProxy.java.
What's with the ugly arrow?
This probably wants to be a getSiteVisit(String) call so that it checks permissions. Technically if it's in the public list of sites then returning then it's ok to return the description without having the ability to visit the site but for the purposes of migration we probably don't need to worry about that.
can collapse:  java // Sort according to time Collections.sort(events, (e1, e2) -> e1.getDate().compareTo(e2.getDate())); // Sort according to author Collections.sort(events, (e1, e2) -> e1.getActor().getLogin().compareTo(e2.getActor().getLogin()));
Q: If the record is out-of-order, shouldn't you put the value into the state store regardless of whether it is different from the old value or not? I think this would be more correct because the old value is actually the idempotent update to the new out-of-order value. This is one of the rare cases where we can correct the order. WDYT?
Why is this field needed? Can't clients just use the value of lower? I would expect all methods to do the right thing when passed a null type (that is, a type with kind TypeKind.NULL).
Rename to reducedCountsPseudoInverse
This can be byte[] lastArray = Arrays.copyOf(lastStringArray, lastStringArray.length + 32
Unit test should verify that the constructed account contains the expected phone and the verified flags are set correctly.
We can consolidate this with the logic below. Something like this: scala if (remainingToSearch.isEmpty()) { return result; } else { client.awaitMetadataUpdate(timer); }
Using the internal resource [design_bottom_sheet from the Material Components library](<LINK_0> is very risky and considered an anti-pattern. We have no control over that library, which is actively being developed with regular [releases](<LINK_1> If that resource name is changed or removed, it can cause a NullPointerException crash from the bottomSheetLayout.getLayoutParams() call in the line below. Unfortunately, we are referencing internal resources elsewhere in the codebase too so this wouldn't be setting a precedent. At a minimum, we should add a null-check to ensure the NullPointerException crash doesn't occur.
Is this going to add an authentication to the http client for each request? When do they get cleaned up?
Use the %s feature of checkArgument, to prevent concatenating strings unless it's really necessary. i.e.  checkArgument(getConfig(SOURCE_SENSOR) instanceof AttributeSensor, "expected SOURCE_SENSOR to be AttributeSensor, found %s", getConfig(SOURCE_SENSOR));
You can declare the variable in the try-with-resources block. WatchService watcher = mapsDirectory.getFileSystem().newWatchService(); goes into the try()  customMapsDirectory.register(watcher, ENTRY_DELETE); becomes part of the try-block
Use parameterized logging instead of string concatenation.
this constructor can be package local since class is package local
This is happening because we previously create a dataset with this namespace and name, but in the default Hive database and we now need to move it to the database with the same name as namespace?
Preserves the original exception cause when rethrowing exception. Also, better use throw Throwables.propagate(e); in this case.
Can you add in creating a directory client and putting a file under it? That way we show all the basic client types.
nit: This whole thing is hard to parse. Consider rewriting with extracting some of the variables.  List<ApiClusterTemplateConfig> rangerConfigs = new ArrayList<>(); final String rangerHdfsAuditUrl = ConfigUtils.getStorageLocationForServiceProperty(templatePreparationObject, RANGER_HDFS_AUDIT_URL) .map(location -> location.getValue()) .orElseGet(() -> getDefaultRangerAuditUrl(templateProcessor, templatePreparationObject)); rangerConfigs.add(config(RANGER_HDFS_AUDIT_URL, rangerHdfsAuditUrl)); final String rangerDataUrl = ... final String rangerLogUrl = ... rangerConfigs.add(...); rangerConfigs.add(...); return rangerConfigs;
since there are two of these, an if-else would probably look cleaner.
Shouldn't we log anything bad that happens here?
See Ctor of CreateViewAndOptionallyElementCommand
Seems to fit on a single line?
This change seems me too risky. It means there will be no effective compatibility version set during validate(). Why do you need this?
i, j and s2? Maybe userNameIndex, executeCount and currentArg?
Or isNotEmpty()?
Are there other places where this confirmation will be called? If not, leave the label setting defined in HostRestartConfirmationPopupView.
I might use "travel time values" instead of "times". As written, it could seem like the error message is missing a word "Must supply X expected number of times..."
style nit: missing braces
Perhaps this one line should be outside of the if a.size() == 1 since the Attribute object can hold multiple values just fine.
Please move these two "cleanup" statements before the "notResolving.signal()" within the finally clause.
reservedForArchival here is same as this.reservedForArchival when init?
If we add || Config.generateTreesAmount == 0 here it can efficiently skip decorating trees
no need to specify types on RHS - i would fix this throughout this PR
Do you need to add a space here?
I think this line should be  if (endpoint != null && this.getVersion() >= 2) {  since individual command classes are only supported in version 2. It doesn't matter due to the fact you check the command classes in the node, but it's probably best to use it.
clearly a details but why not ? java if (mode != null && mode.equals(DtlsEndpointContext.HANDSHAKE_MODE_NONE)) { // restore handshake-mode "none" followUpEndpointContext = MapBasedEndpointContext.addEntries(blockContext, DtlsEndpointContext.KEY_HANDSHAKE_MODE, DtlsEndpointContext.HANDSHAKE_MODE_NONE); } else { followUpEndpointContext = blockContext; }
Instead of spinning in loop we should use BinaryMetadataTransport::awaitMetadataUpdate method and wait when metaHolder.pendingVersion is accepted by the cluster.
reduce(mapPartitions) is very often RDD.aggregate(), If we can reformulate this in the following terms, we get perf goodies like treeAggregate nearly for free:  def aggregate[U](zeroValue: U)(seqOp: (U, T)  U, combOp: (U, U)  U): U  Just a thought, dunno if it's worth it at this stage.
null == adapter
I would rather have single expected HttpStatus here. We're testing query cancellation and we do not know what query cancellation REST api is supposed to return?
Can you import static Assert?
Format this file. Also looks like we can still use new ArrayList<>(indexToChunkIds.values()), any specific reason to use indexToChunkIds.values().stream().collect(Collectors.toList()) here?
Nit: Consider now.truncatedTo(ChronoUnit.HOURS) instead.
here it seems that it would make more sense to merge the two  if (pair.length == 2)  into a single if statements:  if (pair.length == 2) { if (pair[1].isEmpty() && i < args.length - 1) { pair[1] = args[++i]; } if (!parseOption(pair[0], pair[1], false)) { messageStream.println(); usage(messageStream, true); return false; } }  if you are already changing the code.
Update the java docs to say this finds unused tasks. Update the java doc to add an @returns as well, indicating that it returns a list of unused DatastreamTasks
Do you need to re-throw the same exception TranslateException?
This test checks whether all diagnostics are expected. But it fails to check if diagnostics are missing
if you think it is a good idea, we could have a similar 'ensure' method for usermetadata and the blob content for better readability here and below.
suggestion return Collections.emptyList();
Are you trying to convert string to boolean here? There is a better way to do that.
should it?
Can't you use settings.sourceBlock.contains(blockPresent)? Then you can just use  if (!settings.sourceBlock.contains(world.getTypeId(x + block.x, y + block.y, z + block.z)) {
I meant the block without the 'if', you already know the action type here :)
You can remove this log line or merge it into previous one, otherwise it will be difficult to comprehend when all these log lines are together.
Rather than hard-code currentPlanProductId > plan.getProductID(), I think we should have a helper routine that checks if one plan is "greater" than another. We had this earlier on, and it was added to avoid sprinkling our code with assumptions that a greater plan ID meant a more expensive plan.
try-with-resources
I think this still does not solve the problem we have. Here is your impl of CFUtils.allOfOrTerminateExceptionally: java CompletableFuture<Void> result = CompletableFuture.allOf(futures); for (CompletableFuture<?> future : futures) { future.handle((res, ex) -> ex == null || result.completeExceptionally(ex)); }  Let's suppose this is the current allFutures structure: a3<a2<a1<f0, f1>, f2>, f3> where a_i means allFuture, f_i means the individual transfer future. If f1 fails at this moment, it will cancel a1, however f2 and f3 are not finished yet, so even though a1 is exceptionally completedly, the curerrnt allFuture, i.e. a3 still waits until f2 and f3 finishes. So if there are more futures, we won't be able to jump out of the loop, right?
If this should happen once, maybe it belongs in the constructor (and bufferedReader can be final).
This might be an opportunity to make the names for these more consistent: this uses handleFoo, other bits use onFoo.
Nitpick: The Java Language Specification [says](<LINK_0> "it is customary, though not required" that the order of these class modifiers would be public static.
OK. I see where is the root of getRequiredTaskScheduler(). But a decision is the same: we always reuse TaskScheduler from the application context.
missing braces
Inline this, please. FQNs are ugly
Running BackgroundLocationManagerTest with coverage it doesn't look like this case gets hit by any of the tests
Agreed, this does look like a bug :)
Formatting
This should be more "assertive"; throw an IllegalArgumentException to break the app. This would be a programming error, not an error condition in runtime.
Please, indent wrapped lines with 8 additional spaces. Don't align arguments, such alignment breaks code style checks.
Use Lib.exceptionToString(ex). ex.toString doesn't work, I think
json can be final
You shouldn't create another variable here named 'scq'. These methods you are calling change the internal state of the SrampClientQuery and then return "this" (aka a fluent API). In other words, after this line of code the following is true: query == scq
Even though logic seems very straightforward and it no doubt works, it would still be nice to test with a non-checker Workflow in the list as well.
How about simplifying this by just using a single if/else that uses the rootTree if non-null and falls back to the working tree config if the rootTree is null? Then the useWorkingTree field can be removed.
What is this actually doing? Why are you checking for the CatalogedBy annotation?
The _PARAM_RECURSE_ should be optional (as well _PARAM_MAX_CHILDREN_, btw)
Consolidate all active-standby lookups as a part of FailoverMetadata?
Logging needs to be conditional on a debug option or removed.
Normally we only use all caps for static values.
iirc, this will be written (~)every second to the log while the vm is locked, this is too much.. maybe move to debug
This looks like a brute force fix to me. Note that the itemsMap is also filled in modelChanged, so you are now doing it several times. Wouldn't the better place the getAll() method as this is the one that gets called (once) before added events are received? And if this would additionally check, whether an entry in the map already exists, it would be even nicer.
Remove this variable and use ctl.getRefName() as the rest of this method is doing.
do not call this method here, Call in method showLoanAccountTemplate() in Fragment
Do we need versions of this test that check the other endpoints in the ChargesApiResource class (for there is a plethora)?
don't split the try block. Most code should be inside the block
you are using "coinmarketcap" prefix for CoinexchangeRateSource?
I believe this is not necessary. It's always the first character.
@sebing spaces around :
use .startsWith?
We should fail in all cases.
suggestion assertThat(ldapUserDetails.getDn()).isEqualTo("uid=base64encoded-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("{MD5}5f4dcc3b5aa765d61d8327deb882cf99"); assertThat(passwordEncoder.matches("password", ldapUserDetails.getPassword())).isEqualTo(true); assertThat(((List<SimpleGrantedAuthority>) ldapUser.getAuthorities())) .contains(new SimpleGrantedAuthority(SystemRole.REPOSITORY_MANAGER.name()), new SimpleGrantedAuthority("USER_ROLE"));
unless I'm misunderstanding, I believe the schema can never be invalid at this point. In order to get here, all unique fields had to have been present when grouping, and the function had to have worked. If there is any validation needed, it should happen in the group method.
can you merge this else if and else parts into else if !
The loop and refresh is common code.
no double blanks
I think I would name it asProjection(). Otherwise, I would kinda expect the return type to be consistent when adding another projection to be returned. The methods have totally different behavior. Especially, I could imagine someone wanting asProjections() with 1, 2, 3 elements to be exactly consistent in the behavior so that their code is generic.
Do we want to reportError here?
This should really be an online type test, e..g, it should be skipped, not fail, if the postgis.properties file is not there
This is only safe when the selector has a 'real' dictionary, i.e. when selector.getValueCardinality() does not return DimensionSelector.CARDINALITY_UNKNOWN. If it is unknown then the ids are not valid outside the context of a specific row. So, in that case you'll need to fall back to the slower code.
missing braces
@idelcano Add curly brackets for this 'if' please. In general at brackets because they make things more clear but special here that we have a loop inside the if (not properly indented btw)
What's the point of catching and then throwing a wrapped exception - again, no additional context of info is provided.
we can add this when we have something to populate it with
Please use the generics-friendly Collections.emptyList()
Aren't we already in GUI thread?
when you are using HttpServerAdapter, handleReceive implicitly parses the client address.
The other place in this class where a DomainException is used could be replaced by this type
Please add UUID.randomUUID().toString() here as well
could you please move this logic to separated method
Has the A: thing been fixed in the meantime?
Use camel-case
Could we keep using Object helperItem = getHelperItem(i); to reduce calls to getHelperItem?
You try to cast a Map.Entry with DiskImage, this will cause an error when try to run a VM. you should simply use: for (Guid sdId : diskIdToDestSdId.values()) { StorageDomainStatic destDomain = storageDomainStaticDao.get(sdId); if (destDomain.isBackup()) { return false; } } or, if you want, you can do it all in one stream and filter command (without the additional for loop), like this: Disk disk = getVm().getDiskMap() .values() .stream() .filter(vmDisk -> vmDisk.getDiskStorageType() == DiskStorageType.IMAGE && storageDomainStaticDao.get(((DiskImage) vmDisk).getStorageIds().get(0)).isBackup()) .findFirst() .orElse(null); if (disk != null) { return false; } return true;
I suggest that you add a constant field to DefaultsConfigContext, so that you reference the default value rather than explicitly set it here.
I guess we might need break statement, since the existing "p2" option doesn't have break;
should we add a metric to count the number of logging errors?
Again, assertNotNull could be more readable.
The hiding event seems to always originate from the UI thread, so the Platform.runLater isn't needed. Can we factor the callback out into its method? It looks kind of similar to triggerTimeoutAction so maybe it could be merged.
Might be cleaner to add a method like hasMoreAttempts() to requestManager
Is this an approximate metric or exact? Looks like exact to me. Same for the others.
Should this be return -1 not sure if this counts as error or page not found?
Check args?
use UTF-8
is this variable still used?
May I suggest to use the following instead? bug_severity=enhancement&bug_status=NEW&email1=rgrunber&emailassigned_to1=1&emailtype1=substring it is much much faster as the query returns a smaller result and bugzilla optimizes such queries better.
this works as long as the trace provides the source code lookup. However, if the there is another trace that provides we need a way to find the right trace (or experiment) to use to get ITmfCallsiteResolver. Not exactly sure what the API should be that client implementation could override. Maybe getCallsiteTrace() or getCallsiteResolver(). Or maybe we could have data provider interface for that, which provides a list of callsite for given row and time range.
really? Why not rely on autoboxing/autounboxing?
if operation is complete, why do we need to proceed further
Hmm, I would rather leave it up to the enhancement processors to decide if anything needs to be done to an object rather than do it here, which we would need to remember to update in the future if more types of derivatives are added for non-files. So I'd suggest removing this and the conditional at 119. The shortcut to jump to the original ds is probably fine to keep.
One more thing @slaskawi, please use a timeout here (e.g. 10 seconds).
@Rimjhim28 , can you investigate why the VisitApi constructor is not called first before calling this getVisitType method? As [this line ](<LINK_0> would've already initialized the restApi.
Username better
We may think about having a dedicated method on CallExpression.
Why not using the "normal" Cancel constant?
Is 0 a magic number?
Why is there a null notice?
I believe you can fix the problem below by replacing replaceTitlesWithCaptions(m.getDisplayTitle(), mediaSize++); with replaceTitlesWithCaptions(m.get(), mediaSize++); and performing this API call instead: <LINK_0> Notice that this query uses ids= instead of titles=. That removes the problem of having to hardcode ".jpg"
Call requiredOptions() instead of new HashSet<>()?
This is actually a really useful log statement when you have multiple ports being bound.
Can this be inserted into the toStringWithStackTrace() itslef?
I would add information about version that was used, since the string from header is not guaranteed to contain it.
shutdown in a finally block ?
why not simply taking a model instead of checking for one?
it's nicer to move the assignment out of the if
no problem, you can do it any way you want, I don't care. Even with (^ *| +) should javascript work. Is there a real argumentation for reluctant quantified ("*?") instead of normal greedy one ("*") or possesive one ("++") instead of greedy one("+")? Since *this* is the unsupported part in javascript, rest should probably work just fine.
what's ed? I don't understand abbreviations!
Delete. Reporting progress at the end of a method is a no-op.
do you think you could refactor the entire if / else part into a separate method (that will return a decryptionResult I suppose)? getGenericPasswordForOptions is becoming a bit too lengthy. Thanks.
